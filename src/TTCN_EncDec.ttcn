/******************************************************************************
* Copyright (c) 2004, 2016  Ericsson AB
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*
* This file is compatible with the Titan compiler R4C
*
******************************************************************************/

module TTCN_EncDec {


//------------------------------------------------------------------------------
import from LibCommon_BasicTypesAndValues all;
import from LibCommon_DataStrings all;
import from LibItsCommon_TypesAndValues all;
import from LibItsBtp_TypesAndValues all;
import from LibItsBtp_TestSystem all;
import from LibItsCam_TypesAndValues all;
import from LibItsCam_TestSystem all;
import from LibItsDenm_TypesAndValues all;
import from LibItsDenm_TestSystem all;
import from LibItsMapSpat_TypesAndValues all;
import from LibItsMapSpat_TestSystem all;
import from LibItsIpv6OverGeoNetworking_TestSystem all;
import from LibItsGeoNetworking_TestSystem all;
import from LibItsIpv6OverGeoNetworking_TypesAndValues all;
import from LibItsGeoNetworking_TypesAndValues all;
import from CAM_Types all;
import from DENM_Types all;
import from MAP_Types all;
import from SPAT_Types all;
import from DENM_PDU_Descriptions language "ASN.1:1997" all;
import from ITS_Container language "ASN.1:1997" all;
import from LibItsExternal_TypesAndValues all;
import from General_Types all;   
import from LibItsSecurity_TypesAndValues all;


//UT-Common------------------------------------------------------------------------------


external function f_enc_UtInitialize(in UtInitialize pdu) return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};


external function f_dec_UtInitialize(in octetstring stream) return UtInitialize
with { extension "prototype(convert)"
  extension "decode(RAW)"
};

external function f_enc_UtChangePosition(in UtChangePosition pdu) return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};


external function f_dec_UtChangePosition(in octetstring stream) return UtChangePosition
with { extension "prototype(convert)"
  extension "decode(RAW)"
};

external function f_enc_UtChangePositionResult(in UtChangePositionResult pdu) return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};


external function f_dec_UtChangePositionResult(in octetstring stream) return UtChangePositionResult
with { extension "prototype(convert)"
  extension "decode(RAW)"
};

external function f_enc_UtChangePseudonym(in UtChangePseudonym pdu) return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};


external function f_dec_UtChangePseudonym(in octetstring stream) return UtChangePseudonym
with { extension "prototype(convert)"
  extension "decode(RAW)"
};

external function f_enc_UtChangePseudonymResult(in UtChangePseudonymResult pdu) return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};


external function f_dec_UtChangePseudonymResult(in octetstring stream) return UtChangePseudonymResult
with { extension "prototype(convert)"
  extension "decode(RAW)"
};






//UT-BTP------------------------------------------------------------------------
/*       

encoding-decoding is done in the test port
*/
//UT-GN------------------------------------------------------------------------

/*MTC@elx1pjld12-hz: 
f_enc_Ut_Gn_GenerateGeoBroadcastMessage(): 
Encoding @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage: 

{ shape := e_geoCircle (0), 
lifetime := 10000, 
trafficClass := { scf := e_scfEnable (1), 
channelOffload := e_choffDisabled (0), 
tcId := 0 },
reserved := 0, 
area := { geoAreaPosLatitude := 10256, 
geoAreaPosLongitude := 0, 
distanceA := 0, 
distanceB := 0, 
angle := 0 }, 
payload := { decodedPayload := omit, 
rawPayload := ''O } }
*/


type bitstring BIT1 length(1) with { variant "FIELDLENGTH(1)" };
type bitstring BIT6 length(6) with { variant "FIELDLENGTH(6)" };

type record ExtTrafficClass {
  BIT1   scf,
  BIT1   channelOffload,
  BIT6   tcId
} with { variant "FIELDORDER(msb)" };


function f_TrafficClass2ExtTrafficClass(TrafficClass tc) return ExtTrafficClass {
  var ExtTrafficClass etc;
  etc.scf := int2bit(enum2int(tc.scf),1);
  etc.channelOffload := int2bit(enum2int(tc.channelOffload),1);
  etc.tcId := int2bit(tc.tcId,6);
  return etc;
}

function f_ExtTrafficClass2TrafficClass(ExtTrafficClass etc) return TrafficClass {
  var TrafficClass tc;

  var SCF v_SCF;
  int2enum(bit2int(etc.scf),v_SCF);
  tc.scf := v_SCF;

  var ChannelOffload v_CO;
  int2enum(bit2int(etc.channelOffload),v_CO);
  tc.channelOffload := v_CO;
  
  tc.tcId := bit2int(etc.tcId);

  return tc;
}

type record ExtGnPayload {
  //DecodedPayload decodedPayload optional, //TODO: Not yet implemented
  octetstring rawPayload
} with { variant "FIELDORDER(msb)" };


/*
 * GeoUnicast
*/

type record ExtGenerateGeoUnicastMessage {
  ExtGN_Address gnAddress,
  UInt16 lifetime,
  ExtTrafficClass trafficClass,
  UInt16 payloadLength,
  ExtGnPayload payload 
} with { variant(payloadLength) "LENGTHTO(payload)";
         variant "FIELDORDER(msb)"};

external function f_enc_Ext_UtGnGenerateGeoUnicastMessage(in ExtGenerateGeoUnicastMessage pdu) return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};

function f_enc_Ut_Gn_GenerateGeoUnicastMessage(in GenerateGeoUnicastMessage pdu) return octetstring {
  var ExtGenerateGeoUnicastMessage ext;

  ext.gnAddress := f_GN_Address2ExtGN_Address(pdu.gnAddress);
  ext.lifetime := pdu.lifetime;

  ext.trafficClass := f_TrafficClass2ExtTrafficClass(pdu.trafficClass);

  ext.payloadLength := lengthof(pdu.payload.rawPayload);
  ext.payload.rawPayload := pdu.payload.rawPayload;

  //TODO: decodedPayload 
  /*if (ispresent(pdu.payload.decodedPayload)) {
  ext.payloadLength := ext.payloadLength + lengthof(pdu.payload.DecodedPayload);
  ext.payload.DecodedPayload := pdu.payload.DecodedPayload
  }
  */

  return f_enc_Ext_UtGnGenerateGeoUnicastMessage(ext);
}

external function f_dec_Ut_Gn_GenerateGeoUnicastMessage(in octetstring stream) return GenerateGeoUnicastMessage
with { extension "prototype(convert)"
  extension "decode(RAW)"
};


/*
 * GeoBroadcast
*/

type record ExtGenerateGeoBroadcastMessage {
  UInt8  shape,
  UInt16 lifetime,
  ExtTrafficClass trafficClass,
  UInt24 reserved,
  Area area,
  UInt16 payloadLength,
  ExtGnPayload payload 
} with { variant(payloadLength) "LENGTHTO(payload)";
         variant "FIELDORDER(msb)"};


external function f_enc_Ext_UtGnGenerateGeoBroadcastMessage(in ExtGenerateGeoBroadcastMessage pdu) return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};


function f_enc_Ut_Gn_GenerateGeoBroadcastMessage(in GenerateGeoBroadcastMessage pdu) return octetstring {
  var ExtGenerateGeoBroadcastMessage ext;

  ext.shape := enum2int(pdu.shape);
  ext.lifetime := pdu.lifetime;

  ext.trafficClass.scf := int2bit(enum2int(pdu.trafficClass.scf),1);
  ext.trafficClass.channelOffload := int2bit(enum2int(pdu.trafficClass.channelOffload),1);
  ext.trafficClass.tcId := int2bit(pdu.trafficClass.tcId,6);

  ext.reserved := 0;

  ext.area := pdu.area;

  ext.payloadLength := lengthof(pdu.payload.rawPayload);
  ext.payload.rawPayload := pdu.payload.rawPayload;

  //TODO: decodedPayload 
  /*if (ispresent(pdu.payload.decodedPayload)) {
  ext.payloadLength := ext.payloadLength + lengthof(pdu.payload.DecodedPayload);
  ext.payload.DecodedPayload := pdu.payload.DecodedPayload
  }
  */

  return f_enc_Ext_UtGnGenerateGeoBroadcastMessage(ext);
}


external function f_dec_Ut_Gn_GenerateGeoBroadcastMessage(in octetstring stream) return GenerateGeoBroadcastMessage
with { extension "prototype(convert)"
  extension "decode(RAW)"
};



/*
 * GeoAnycast
*/

function f_enc_Ut_Gn_GenerateGeoAnycastMessage(in GenerateGeoAnycastMessage pdu) return octetstring {
  return f_enc_Ut_Gn_GenerateGeoBroadcastMessage(pdu);
}

/*
external function f_enc_Ut_Gn_GenerateGeoAnycastMessage(in GenerateGeoAnycastMessage pdu) return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};
*/

external function f_dec_Ut_Gn_GenerateGeoAnycastMessage(in octetstring stream) return GenerateGeoAnycastMessage
with { extension "prototype(convert)"
  extension "decode(RAW)"
};

/*
 * SHBMessage
*/


type record ExtGenerateSHBMessage {
  ExtTrafficClass trafficClass,
  UInt16 payloadLength,
  ExtGnPayload payload 
} with { variant(payloadLength) "LENGTHTO(payload)";
         variant "FIELDORDER(msb)"};

external function f_enc_Ext_Ut_Gn_GenerateSHBMessage(in ExtGenerateSHBMessage pdu) 
  return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};

function f_enc_Ut_Gn_GenerateSHBMessage(in GenerateSHBMessage pdu) return octetstring
{
  var ExtGenerateSHBMessage ext;
  ext.trafficClass := f_TrafficClass2ExtTrafficClass(pdu.trafficClass);
  ext.payloadLength := lengthof(pdu.payload.rawPayload);
  ext.payload.rawPayload := pdu.payload.rawPayload;
  return f_enc_Ext_Ut_Gn_GenerateSHBMessage(ext);
}


external function f_dec_Ut_Gn_GenerateSHBMessage(in octetstring stream) return GenerateSHBMessage
with { extension "prototype(convert)"
  extension "decode(RAW)"
};

/*
 * TSBMessage
*/

type record ExtGenerateTSBMessage {
  UInt8           nbHops,
  UInt16          lifetime,
  ExtTrafficClass trafficClass,
  UInt16          payloadLength,
  ExtGnPayload    payload 
} with { variant(payloadLength) "LENGTHTO(payload)";
         variant "FIELDORDER(msb)"};

external function f_enc_Ext_Ut_Gn_GenerateTSBMessage(in ExtGenerateTSBMessage pdu) 
  return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};

function f_enc_Ut_Gn_GenerateTSBMessage(in GenerateTSBMessage pdu) return octetstring
{
  var ExtGenerateTSBMessage ext;
  ext.nbHops := pdu.nbHops;
  ext.lifetime := pdu.lifetime;
  ext.trafficClass := f_TrafficClass2ExtTrafficClass(pdu.trafficClass);
  ext.payloadLength := lengthof(pdu.payload.rawPayload);
  ext.payload.rawPayload := pdu.payload.rawPayload;
  return f_enc_Ext_Ut_Gn_GenerateTSBMessage(ext);
}

/*
external function f_enc_Ut_Gn_GenerateTSBMessage(in GenerateTSBMessage pdu) return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};
*/

external function f_dec_Ut_Gn_GenerateTSBMessage(in octetstring stream) return GenerateTSBMessage
with { extension "prototype(convert)"
  extension "decode(RAW)"
};


/*
 * UtGnTrigger
*/


function f_enc_UtGnTrigger(in UtGnTrigger pdu) return octetstring
{

  var octetstring ret_os;
  if (ischosen(pdu.geoUnicast)) { ret_os:='50'O&f_enc_Ut_Gn_GenerateGeoUnicastMessage(pdu.geoUnicast); }
  else if (ischosen(pdu.geoBroadcast))  { ret_os:='51'O&f_enc_Ut_Gn_GenerateGeoBroadcastMessage(pdu.geoBroadcast); }
  else if (ischosen(pdu.geoAnycast))  { ret_os:='52'O&f_enc_Ut_Gn_GenerateGeoAnycastMessage(pdu.geoAnycast); }
  else if (ischosen(pdu.shb))  { ret_os:='53'O&f_enc_Ut_Gn_GenerateSHBMessage(pdu.shb); }
  else if (ischosen(pdu.tsb))  { ret_os:='54'O&f_enc_Ut_Gn_GenerateTSBMessage(pdu.tsb); }

  return ret_os;
}





//UT-CAM------------------------------------------------------------------------

type bitstring BIT8 length(8) with { variant "FIELDLENGTH(8)" };

type record ExtPtActivation {
  UInt8 		ptActivationType,
  UInt8 		ptActivationDataLength,
  octetstring   	ptActivationData

}with { variant(ptActivationDataLength) "LENGTHTO(ptActivationData)";
        variant "FIELDORDER(msb)"};


type union ExtUtCamTrigger {
  Int16 changeCurvature,
  Int16 changeSpeed,
  BIT8  setAccelerationControlStatus,
  BIT8  setExteriorLightsStatus,
  UInt16  changeHeading,
  UInt8  setDriveDirection,
  Int16  changeYawRate,
  UInt8 setStationType,
  UInt8 setVehicleRole,
  UInt8 setEmbarkationStatus,
  ExtPtActivation setPtActivation,
  UInt8 setDangerousGoods,
  UInt8 setLightBarSirene
} with { variant "" };



external function f_enc_ExtUt_Cam_Trigger(in ExtUtCamTrigger pdu) return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};


external function f_dec_ExtUt_Cam_Trigger(in octetstring stream) return ExtUtCamTrigger
with { extension "prototype(convert)"
  extension "decode(RAW)"
};


function f_enc_UtCAmTrigger(in UtCamTrigger pdu) return octetstring
{

  var ExtUtCamTrigger v_ExtUtCamTrigger;
  var octetstring ret_os;

  if (ischosen(pdu.changeCurvature)){
    v_ExtUtCamTrigger.changeCurvature:=pdu.changeCurvature;
  } else if (ischosen(pdu.changeSpeed)){
    v_ExtUtCamTrigger.changeSpeed:=pdu.changeSpeed;
  } else if (ischosen(pdu.setAccelerationControlStatus)){
    v_ExtUtCamTrigger.setAccelerationControlStatus:=pdu.setAccelerationControlStatus&'1'B;
  } else if (ischosen(pdu.setExteriorLightsStatus)){
    v_ExtUtCamTrigger.setExteriorLightsStatus:=pdu.setExteriorLightsStatus;
  } else if (ischosen(pdu.changeHeading)){
    v_ExtUtCamTrigger.changeHeading:=pdu.changeHeading;
  } else if (ischosen(pdu.setDriveDirection)){
    v_ExtUtCamTrigger.setDriveDirection:=enum2int(pdu.setDriveDirection);
  } else if (ischosen(pdu.changeYawRate)){
    v_ExtUtCamTrigger.changeYawRate:=pdu.changeYawRate;
  } else if (ischosen(pdu.setStationType)){
    v_ExtUtCamTrigger.setStationType:=pdu.setStationType;
  } else if (ischosen(pdu.setVehicleRole)){
    v_ExtUtCamTrigger.setVehicleRole:=enum2int(pdu.setVehicleRole);
  } else if (ischosen(pdu.setEmbarkationStatus)){
    if(pdu.setEmbarkationStatus) {
      v_ExtUtCamTrigger.setEmbarkationStatus:=255
    } else {
      v_ExtUtCamTrigger.setEmbarkationStatus:=0
    }
  } else if (ischosen(pdu.setPtActivation)){
    v_ExtUtCamTrigger.setPtActivation.ptActivationType:=pdu.setPtActivation.ptActivationType;
    v_ExtUtCamTrigger.setPtActivation.ptActivationDataLength:=0;
    v_ExtUtCamTrigger.setPtActivation.ptActivationData:=pdu.setPtActivation.ptActivationData;
  } else if (ischosen(pdu.setDangerousGoods)){
    v_ExtUtCamTrigger.setDangerousGoods:=enum2int(pdu.setDangerousGoods);
  } else if (ischosen(pdu.setLightBarSirene)){
    v_ExtUtCamTrigger.setLightBarSirene:=bit2int(pdu.setLightBarSirene);
  }

  ret_os:=f_enc_ExtUt_Cam_Trigger(v_ExtUtCamTrigger);

  return ret_os;
}

type record ExtUtCamEventInd {
  UInt16      camPduLength,
  octetstring camMsg
} with { variant(camPduLength) "LENGTHTO(camMsg)";
         variant "FIELDORDER(msb)"};



external function f_dec_ExtUt_Cam_EventInd(in octetstring stream) return ExtUtCamEventInd
with { extension "prototype(convert)"
  extension "decode(RAW)"
};


function f_dec_Ut_Cam_EventInd(in octetstring stream) return UtCamEventInd
{

  var ExtUtCamEventInd v_ExtUtCamEventInd:=f_dec_ExtUt_Cam_EventInd(stream)
  var UtCamEventInd v_UtCamEventInd;

  v_UtCamEventInd.camMsg:= dec_CAM_PDU(v_ExtUtCamEventInd.camMsg);

  return v_UtCamEventInd;
}
/*
UtCamTriggerResult--decoded in the test port
*/


//UT-DENM------------------------------------------------------------------------

type record ExtSituationContainer {
  UInt8 informationQuality,
  UInt8 causeCode,
  UInt8 subCauseCode
} with { variant "FIELDORDER(msb)" };

type record ExtAlacarteContainer {
  UInt8 TODO
} with { variant "FIELDORDER(msb)" };


type record ExtUtDenmTrigger {
  UInt8 bitmask,
  UInt48 detectionTime,
  UInt24 validityDuration optional,
  UInt24 repetitionDuration optional,
  ExtSituationContainer situation,
  UInt8 relevanceDistance,
  UInt8 relevanceTrafficDirection,
  UInt16 transmissionInterval optional,
  UInt16 repetitionInterval optional,
  UInt8 alacarteLength optional,
  ExtAlacarteContainer alacarte optional
} with { variant "FIELDORDER(msb)";
         variant (bitmask) "FIELDLENGTH(8)";
         variant (detectionTime) "FIELDLENGTH(48)";
         variant (validityDuration) "FIELDLENGTH(24)";
         variant (repetitionDuration) "FIELDLENGTH(24)";
         variant (relevanceDistance) "FIELDLENGTH(8)";
         variant (relevanceTrafficDirection) "FIELDLENGTH(8)";
         variant (transmissionInterval) "FIELDLENGTH(16)";
         variant (repetitionInterval) "FIELDLENGTH(16)";
         variant (alacarteLength) "FIELDLENGTH(8)" };



external function f_enc_ExtUt_Denm_Trigger(in ExtUtDenmTrigger pdu) return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};

external function f_dec_ExtUt_Denm_Trigger(in octetstring stream) return ExtUtDenmTrigger
with { extension "prototype(convert)"
  extension "decode(RAW)"
};

function f_enc_UtDenmTrigger(in UtDenmTrigger pdu) return octetstring
{

  var ExtUtDenmTrigger v_ExtUtDenmTrigger;
  var octetstring ret_os;

  v_ExtUtDenmTrigger.bitmask := 0;

  v_ExtUtDenmTrigger.detectionTime := pdu.detectionTime;


  if (ispresent(pdu.validityDuration)) {
    v_ExtUtDenmTrigger.bitmask := 1;
    v_ExtUtDenmTrigger.validityDuration := pdu.validityDuration;
  } else {
    v_ExtUtDenmTrigger.validityDuration := 0;
  }
  if (ispresent(pdu.repetitionDuration)) {
    v_ExtUtDenmTrigger.bitmask := v_ExtUtDenmTrigger.bitmask + 2;
    v_ExtUtDenmTrigger.repetitionDuration := pdu.repetitionDuration;
  } else {
    v_ExtUtDenmTrigger.repetitionDuration := 0; //omit;
  }

  v_ExtUtDenmTrigger.situation.informationQuality := pdu.situation.informationQuality;
  v_ExtUtDenmTrigger.situation.causeCode := pdu.situation.eventType.causeCode;
  v_ExtUtDenmTrigger.situation.subCauseCode := pdu.situation.eventType.subCauseCode;

  v_ExtUtDenmTrigger.relevanceDistance := enum2int(pdu.relevanceDistance);

  v_ExtUtDenmTrigger.relevanceTrafficDirection := enum2int(pdu.relevanceTrafficDirection);
  if (ispresent(pdu.transmissionInterval)) {
    v_ExtUtDenmTrigger.bitmask := v_ExtUtDenmTrigger.bitmask + 32;
    v_ExtUtDenmTrigger.transmissionInterval := pdu.transmissionInterval;
  } else {
    v_ExtUtDenmTrigger.transmissionInterval := 0; //omit;
  }
  if (ispresent(pdu.repetitionInterval)) {
    v_ExtUtDenmTrigger.bitmask := v_ExtUtDenmTrigger.bitmask + 64;
    v_ExtUtDenmTrigger.repetitionInterval := pdu.repetitionInterval;
  } else {
    v_ExtUtDenmTrigger.repetitionInterval := 0; //omit;
  }
  if (ispresent(pdu.alacarte)) {
    v_ExtUtDenmTrigger.alacarteLength := 1;
    var ExtAlacarteContainer v_ExtAlacarteContainer := {0};
    v_ExtUtDenmTrigger.alacarte := v_ExtAlacarteContainer;
  } else {
    v_ExtUtDenmTrigger.alacarteLength := 0; //omit;
    v_ExtUtDenmTrigger.alacarte := omit;
  }

  ret_os:=f_enc_ExtUt_Denm_Trigger(v_ExtUtDenmTrigger);
  return ret_os;
}

//UtDenmUpdate
type record ExtActionID {
  UInt32 originatingStationID,
  UInt16 sequenceNumber
} with { variant "FIELDORDER(msb)" };

type record ExtUtDenmUpdate {
  UInt8                 bitmask,
  ExtActionID           actionID,
  UInt48                detectionTime,
  UInt24                validityDuration          optional,
  ExtSituationContainer situation 		   optional,
  UInt8                 relevanceDistance         optional,
  UInt8 		 relevanceTrafficDirection optional,
  UInt16 		 transmissionInterval 	   optional,
  UInt16 		 repetitionInterval 	   optional,
  UInt8 		 alacarteLength 	   optional,
  ExtAlacarteContainer  alacarte 		   optional
} with {
  variant "FIELDORDER(msb)";
  variant (bitmask) "FIELDLENGTH(8)";
  variant (detectionTime) "FIELDLENGTH(48)";
  variant (validityDuration) "FIELDLENGTH(24)";
  variant (relevanceDistance) "FIELDLENGTH(8)";
  variant (relevanceTrafficDirection) "FIELDLENGTH(8)";
  variant (transmissionInterval) "FIELDLENGTH(16)";
  variant (repetitionInterval) "FIELDLENGTH(16)";
  variant (alacarteLength) "FIELDLENGTH(8)" };



external function f_enc_ExtUt_Denm_Update(in ExtUtDenmUpdate pdu) return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};

external function f_dec_ExtUt_Denm_Update(in octetstring stream) return ExtUtDenmUpdate
with { extension "prototype(convert)"
  extension "decode(RAW)"
};

function f_enc_UtDenmUpdate(in UtDenmUpdate pdu) return octetstring
{

  var ExtUtDenmUpdate v_ExtUtDenmUpdate;
  var octetstring ret_os;

  v_ExtUtDenmUpdate.bitmask := 0;

  v_ExtUtDenmUpdate.actionID.originatingStationID := pdu.actionId.originatingStationID;
  v_ExtUtDenmUpdate.actionID.sequenceNumber := pdu.actionId.sequenceNumber;

  v_ExtUtDenmUpdate.detectionTime := pdu.detectionTime;


  if (ispresent(pdu.validityDuration)) {
    v_ExtUtDenmUpdate.bitmask := 1;
    v_ExtUtDenmUpdate.validityDuration := pdu.validityDuration;
  } else {
    v_ExtUtDenmUpdate.validityDuration := 0;
  }
  if (ispresent(pdu.situation)) {
    v_ExtUtDenmUpdate.bitmask := 2;
    v_ExtUtDenmUpdate.situation.informationQuality := pdu.situation.informationQuality;
    v_ExtUtDenmUpdate.situation.causeCode := pdu.situation.eventType.causeCode;
    v_ExtUtDenmUpdate.situation.subCauseCode := pdu.situation.eventType.subCauseCode;
  } else {
    v_ExtUtDenmUpdate.situation.informationQuality := 0;
    v_ExtUtDenmUpdate.situation.causeCode := 0;
    v_ExtUtDenmUpdate.situation.subCauseCode := 0;
  }

  if (ispresent(pdu.relevanceDistance)) {
    v_ExtUtDenmUpdate.bitmask := v_ExtUtDenmUpdate.bitmask + 4;
    v_ExtUtDenmUpdate.relevanceDistance := enum2int(pdu.relevanceDistance);
  } else {
    v_ExtUtDenmUpdate.relevanceDistance := 0;
  }

  if (ispresent(pdu.relevanceTrafficDirection)) {
    v_ExtUtDenmUpdate.bitmask := v_ExtUtDenmUpdate.bitmask + 8;
    v_ExtUtDenmUpdate.relevanceTrafficDirection := enum2int(pdu.relevanceTrafficDirection);
  } else {
    v_ExtUtDenmUpdate.relevanceTrafficDirection := 0;
  }
  if (ispresent(pdu.transmissionInterval)) {
    v_ExtUtDenmUpdate.bitmask := v_ExtUtDenmUpdate.bitmask + 32;
    v_ExtUtDenmUpdate.transmissionInterval := pdu.transmissionInterval;
  } else {
    v_ExtUtDenmUpdate.transmissionInterval := 0; //omit;
  }
  if (ispresent(pdu.repetitionInterval)) {
    v_ExtUtDenmUpdate.bitmask := v_ExtUtDenmUpdate.bitmask + 64;
    v_ExtUtDenmUpdate.repetitionInterval := pdu.repetitionInterval;
  } else {
    v_ExtUtDenmUpdate.repetitionInterval := 0; //omit;
  }
  if (ispresent(pdu.alacarte)) {
    //TODO: encode alacarte
    v_ExtUtDenmUpdate.alacarteLength := 1;
    var ExtAlacarteContainer v_ExtAlacarteContainer := {0};
    v_ExtUtDenmUpdate.alacarte := v_ExtAlacarteContainer;
  } else {
    v_ExtUtDenmUpdate.alacarteLength := 0; //omit;
    v_ExtUtDenmUpdate.alacarte := omit;
  }

  ret_os:=f_enc_ExtUt_Denm_Update(v_ExtUtDenmUpdate);
  return ret_os;
}



//UtDenmInd
type record ExtDenmInd {

  UInt8   gnNextHeader,
  UInt8   gnHeaderType,
  UInt8   gnHeaderSubtype,
  UInt32  gnLifetime,
  UInt8   gnTrafficClass,
  UInt16  btpDestinationPort,
  UInt16  btpInfo
} with { variant "FIELDORDER(msb)" };


external function f_enc_ExtDenmInd(in ExtDenmInd pdu) return octetstring

with { extension "prototype(convert)"
  extension "encode(RAW)"
};

external function f_dec_ExtDenmInd(in octetstring stream) return ExtDenmInd
with { extension "prototype(convert)"
  extension "decode(RAW)"
};





type record ExtUtDenmEventInd {
  UInt16      denmPduLength,
  octetstring denMsg
} with { variant(denmPduLength) "LENGTHTO(denMsg)";
         variant "FIELDORDER(msb)"};



external function f_dec_ExtUt_Denm_EventInd(in octetstring stream) return ExtUtDenmEventInd
with { extension "prototype(convert)"
  extension "decode(RAW)"
};


function f_dec_Ut_Denm_EventInd(in octetstring stream) return UtDenmEventInd
{

  var ExtUtDenmEventInd v_ExtUtDenmEventInd:=f_dec_ExtUt_Denm_EventInd(stream)
  var UtDenmEventInd v_UtDenmEventInd;

  v_UtDenmEventInd.denMsg:= dec_DENM_PDU(v_ExtUtDenmEventInd.denMsg);

  return v_UtDenmEventInd;


}

/*        
type union PDU_UtDenm_Primitives
{
LibItsDenm_TypesAndValues.UtDenmTrigger       utDenmTrigger,
LibItsDenm_TypesAndValues.UtDenmTriggerResult utDenmTriggerResult,
LibItsDenm_TypesAndValues.UtDenmEventInd      utDenmEventInd,
LibItsDenm_TypesAndValues.UtDenmUpdate		utDenmUpdate,
LibItsDenm_TypesAndValues.UtDenmUpdateResult  utDenmUpdateResult,
LibItsDenm_TypesAndValues.UtDenmTermination   utDenmTermination,
LibItsDenm_TypesAndValues.UtDenmTerminationResult utDenmTerminationResult 
} with { variant ""}  


type record PDU_UtDenmPrimitives
{
OCT1                  messageType,
PDU_UtDenm_Primitives  primitive
} with { variant (primitive) "CROSSTAG( utDenmTrigger,           messageType = '10'O;
utDenmTriggerResult, 	 messageType = '11'O;
utDenmUpdate,	      	 messageType = '12'O;
utDenmUpdateResult,  	 messageType = '13'O;
utDenmTermination,   	 messageType = '14'O;
utDenmTerminationResult, messageType = '15'O;
utDenmEventInd,          messageType = '17'O;
)" }

external function f_enc_PDU_UtDenmPrimitives(in PDU_UtDenmPrimitives pdu) return octetstring
with { extension "prototype(convert)"
extension "encode(RAW)"
};


external function f_dec_PDU_UtDenmPrimitives(in octetstring stream) return PDU_UtDenmPrimitives
with { extension "prototype(convert)"
extension "decode(RAW)"
};

*/
//UT-MAP -----------------------------------------------------------------------------

type record ExtUtMapEventInd {
  UInt16      mapPduLength,
  octetstring mapMsg
} with { variant(mapPduLength) "LENGTHTO(mapMsg)";
         variant "FIELDORDER(msb)"};

external function f_dec_ExtUt_Map_EventInd(in octetstring stream) return ExtUtMapEventInd
with { extension "prototype(convert)"
  extension "decode(RAW)"
};


function f_dec_Ut_Map_EventInd(in octetstring stream) return UtMapEventInd
{

  var ExtUtMapEventInd v_ExtUtMapEventInd:=f_dec_ExtUt_Map_EventInd(stream)
  var UtMapEventInd v_UtMapEventInd;

  v_UtMapEventInd.mapMsg:= dec_MAP_PDU(v_ExtUtMapEventInd.mapMsg);

  return v_UtMapEventInd;
}

//UT-SPAT -----------------------------------------------------------------------------

type record ExtUtSpatEventInd {
  UInt16      spatPduLength,
  octetstring spatMsg
} with { variant(spatPduLength) "LENGTHTO(spatMsg)";
         variant "FIELDORDER(msb)"};

external function f_dec_ExtUt_Spat_EventInd(in octetstring stream) return ExtUtSpatEventInd
with { extension "prototype(convert)"
  extension "decode(RAW)"
};


function f_dec_Ut_Spat_EventInd(in octetstring stream) return UtSpatEventInd
{

  var ExtUtSpatEventInd v_ExtUtSpatEventInd:=f_dec_ExtUt_Spat_EventInd(stream)
  var UtSpatEventInd v_UtSpatEventInd;

  v_UtSpatEventInd.spatMsg:= dec_SPAT_PDU(v_ExtUtSpatEventInd.spatMsg);

  return v_UtSpatEventInd;
}



//BTP-------------------------------------------------------------------------------
//BTPRequest

type record ExtBtpPayload {
  //DecodedBtpPayload decodedPayload optional,
  BtpRawPayload rawPayload
} with { variant "FIELDORDER(msb)" };

type record ExtBtpReq {
  OCT1           nextheader,
  BtpHeader      header,
  ExtBtpPayload  payload optional
} with { variant (header)  "CROSSTAG( btpAHeader, nextheader = '01'O; 
                                      btpBHeader, nextheader = '02'O; )";
         variant "FIELDORDER(msb)"};

external function f_enc_ExtBtpReq(in ExtBtpReq pdu) return octetstring

with { extension "prototype(convert)"
  extension "encode(RAW)"
};

function f_enc_BtpReq(in BtpReq pdu) return octetstring
{

  var ExtBtpReq v_ExtBtpReq

  v_ExtBtpReq.nextheader:='00'O;
  v_ExtBtpReq.header:=pdu.msgOut.header;
  v_ExtBtpReq.payload.rawPayload:=pdu.msgOut.payload.rawPayload;

  //Temporary hack 
  //v_ExtBtpReq.payload.decodedPayload:=omit;


  return f_enc_ExtBtpReq(v_ExtBtpReq);
}



//BtpIndication
type record ExtBtpInd {
  OCT1           nextheader,
  BtpHeader      header,
  octetstring    rawPayload optional
} with { variant (header)  "CROSSTAG( btpAHeader, nextheader = '01'O; 
                                      btpBHeader, nextheader = '02'O; )";
         variant "FIELDORDER(msb)"};

external function f_dec_ExtBtpInd(in octetstring stream) return ExtBtpInd
with { extension "prototype(convert)"
  extension "decode(RAW)"
  extension "errorbehavior(ALL:WARNING)"
};

function f_dec_BtpInd(in octetstring stream) return BtpInd {

  var ExtBtpInd v_ExtBtpInd:=f_dec_ExtBtpInd(stream)

  var BtpInd v_BtpInd

  v_BtpInd.msgIn.header:=v_ExtBtpInd.header;
  if (ispresent(v_ExtBtpInd.rawPayload)) {
    v_BtpInd.msgIn.payload.rawPayload:=v_ExtBtpInd.rawPayload;

    var DecodedBtpPayload v_decodedPayload;
    if (v_ExtBtpInd.nextheader == '01'O) { //BTP A Header
      v_decodedPayload := 
          decodeBTPPayload(v_ExtBtpInd.rawPayload, 
                           v_ExtBtpInd.header.btpAHeader.destinationPort);
    } else if (v_ExtBtpInd.nextheader == '02'O) { //BTP B Header
      v_decodedPayload := 
          decodeBTPPayload(v_ExtBtpInd.rawPayload, 
                           v_ExtBtpInd.header.btpBHeader.destinationPort);
    }

    if (isbound(v_decodedPayload)) {
      v_BtpInd.msgIn.payload.decodedPayload := v_decodedPayload;
    } else {
      v_BtpInd.msgIn.payload.decodedPayload := omit;
    }
  } else
  {
    v_BtpInd.msgIn.payload := omit;
  }

  return v_BtpInd

}

function encodeBTPPayload(DecodedBtpPayload payload) 
  return octetstring {
    var octetstring result;
    if (ischosen(payload.camPacket)) {
      result := enc_CAM_PDU(payload.camPacket);
    } else if (ischosen(payload.denmPacket)) {
      result := enc_DENM_PDU(payload.denmPacket);
    } else if (ischosen(payload.mapPacket)) {
      result := enc_MAP_PDU(payload.mapPacket);
    } else if (ischosen(payload.spatPacket)) {
      result := enc_SPAT_PDU(payload.spatPacket);
    } 
    //TODO: Handle destinationPort == 2005
    
    return result;
}



function decodeBTPPayload(octetstring rawPayload, integer destinationPort) 
  return DecodedBtpPayload {
    var DecodedBtpPayload v_decodedPayload;
    if (destinationPort == 2001) {
      v_decodedPayload := { camPacket := dec_CAM_PDU(rawPayload)}
    } else if (destinationPort == 2002) {
      v_decodedPayload := { denmPacket := dec_DENM_PDU(rawPayload)}
    } else if (destinationPort == 2003) {
      v_decodedPayload := { mapPacket := dec_MAP_PDU(rawPayload)}
    } else if (destinationPort == 2004) {
      v_decodedPayload := { spatPacket := dec_SPAT_PDU(rawPayload)}
    } //TODO: Handle destinationPort == 2005
    return v_decodedPayload;
}

function isWellKnownBTPPort(integer prt) return boolean {
  return ((prt >= 2001) and (prt <= 2005));
}



//CAM------------------------------------------------------------------





type record ExtCamInd {

  UInt8   gnNextHeader,
  UInt8   gnHeaderType,
  UInt8   gnHeaderSubtype,
  UInt32  gnLifetime,
  UInt8   gnTrafficClass,
  UInt16  btpDestinationPort,
  UInt16  btpInfo
} with { variant "FIELDORDER(msb)" };


external function f_enc_ExtCamInd(in ExtCamInd pdu) return octetstring

with { extension "prototype(convert)"
  extension "encode(RAW)"
};

external function f_dec_ExtCamInd(in octetstring stream) return ExtCamInd
with { extension "prototype(convert)"
  extension "decode(RAW)"
};


//MAP-SPAT --------------------------------------------------------

type union MapSpatInd {
  MapInd  mapInd,
  SpatInd spatInd
};// with {variant "" };


type record ExtMapSpatInd {
  //octetstring   msgIn,
  UInt8         gnNextHeader,
  UInt8         gnHeaderType,
  UInt8    	   gnHeaderSubtype,
  UInt32 	   gnLifetime,
  UInt8   	   gnTrafficClass,
  UInt16  	   btpDestinationPort,
  UInt16  	   btpInfo
} with {variant "FIELDORDER(msb)" };

external function f_dec_ExtMapSpatInd(in octetstring stream) return ExtMapSpatInd
with { extension "prototype(convert)"
  extension "decode(RAW)"
};

function f_dec_MapSpatInd(in octetstring stream) return MapSpatInd {
  var octetstring v_os_per,v_os_raw;
  var integer v_lengthof_ExtMapSpatInd := 12;

  var integer v_start_of_raw := lengthof(stream) - v_lengthof_ExtMapSpatInd;

  v_os_per:=substr(stream, 0, v_start_of_raw);
  v_os_raw:=substr(stream, v_start_of_raw, v_lengthof_ExtMapSpatInd);

  var ExtMapSpatInd v_ExtMapSpatInd:=f_dec_ExtMapSpatInd(v_os_raw);

  var MapSpatInd v_MapSpatInd;

  if (v_ExtMapSpatInd.btpDestinationPort == (2003)) {        //MAP
    v_MapSpatInd.mapInd.msgIn.msgMap	     := dec_MAP_PDU(v_os_per);
    v_MapSpatInd.mapInd.gnNextHeader       := v_ExtMapSpatInd.gnNextHeader;
    v_MapSpatInd.mapInd.gnHeaderType	     := v_ExtMapSpatInd.gnHeaderType;
    v_MapSpatInd.mapInd.gnHeaderSubtype    := v_ExtMapSpatInd.gnHeaderSubtype;
    v_MapSpatInd.mapInd.gnLifetime	     := v_ExtMapSpatInd.gnLifetime;
    v_MapSpatInd.mapInd.gnTrafficClass     := v_ExtMapSpatInd.gnTrafficClass;
    v_MapSpatInd.mapInd.btpDestinationPort := v_ExtMapSpatInd.btpDestinationPort;
    v_MapSpatInd.mapInd.btpInfo	     := v_ExtMapSpatInd.btpInfo;

  } else if (v_ExtMapSpatInd.btpDestinationPort == (2004)) { //SPAT
    v_MapSpatInd.spatInd.msgIn.msgSpat      := dec_SPAT_PDU(v_os_per);
    v_MapSpatInd.spatInd.gnNextHeader       := v_ExtMapSpatInd.gnNextHeader;
    v_MapSpatInd.spatInd.gnHeaderType	      := v_ExtMapSpatInd.gnHeaderType;
    v_MapSpatInd.spatInd.gnHeaderSubtype    := v_ExtMapSpatInd.gnHeaderSubtype;
    v_MapSpatInd.spatInd.gnLifetime	      := v_ExtMapSpatInd.gnLifetime;
    v_MapSpatInd.spatInd.gnTrafficClass     := v_ExtMapSpatInd.gnTrafficClass;
    v_MapSpatInd.spatInd.btpDestinationPort := v_ExtMapSpatInd.btpDestinationPort;
    v_MapSpatInd.spatInd.btpInfo	      := v_ExtMapSpatInd.btpInfo;
  }

  return v_MapSpatInd;

}






//GeoNetworking--------------------------------------------------------
external function f_enc_GeoNetworkingPdu(in GeoNetworkingPdu pdu) return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};


external function f_dec_GeoNetworkingPdu(in octetstring stream) return GeoNetworkingPdu
with { extension "prototype(convert)"
  extension "decode(RAW)"
};

external function f_enc_BeaconHeader(in BeaconHeader pdu) return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};


external function f_dec_BeaconHeader(in octetstring stream) return BeaconHeader
with { extension "prototype(convert)"
  extension "decode(RAW)"
};


function f_enc_GN_Address(in GN_Address pdu) return octetstring {
  return f_enc_ExtGN_Address(f_GN_Address2ExtGN_Address(pdu));
};


function f_dec_GN_Address(in octetstring stream) return GN_Address {
  return f_ExtGN_Address2GN_Address(f_dec_ExtGN_Address(stream));
};

type record ExtGeoNetworkingReq {
                ExtGeoNetworkingPdu    msgOut,
                MacAddress             macDestinationAddress
            } with { variant "FIELDORDER(msb)" };

external function f_enc_ExtGeoNetworkingReq(in ExtGeoNetworkingReq pdu) return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};



function f_enc_GeoNetworkingReq(in GeoNetworkingReq pdu) return octetstring {
  var ExtGeoNetworkingReq EGNR;

  EGNR.msgOut.version := pdu.msgOut.basicHeader.version;
  EGNR.msgOut.nextHeader :=  pdu.msgOut.basicHeader.nextHeader;
  EGNR.msgOut.reserved := pdu.msgOut.basicHeader.reserved;
  EGNR.msgOut.lifeTime := f_Lifetime2ExtLifetime(pdu.msgOut.basicHeader.lifeTime);
  EGNR.msgOut.routerHopLimit := pdu.msgOut.basicHeader.routerHopLimit

  if (ispresent(pdu.msgOut.gnPacket.packet)) {
    EGNR.msgOut.packet := f_GnNonSecuredPacket2ExtGnNonSecuredPacket(pdu.msgOut.gnPacket.packet);
  } else {
    EGNR.msgOut.packet := omit;
  }


  //TODO: Encode securedMsg when security comes in
  EGNR.msgOut.securedMsg := pdu.msgOut.gnPacket.securedMsg;


  EGNR.macDestinationAddress := pdu.macDestinationAddress;

  return f_enc_ExtGeoNetworkingReq(EGNR);
}

external function f_dec_ExtGeoNetworkingInd(in octetstring stream) return ExtGeoNetworkingInd
with { extension "prototype(convert)"
  extension "decode(RAW)"
};

type record ExtGN_Address {
    Bit1   typeOfAddress,
    Bit5   stationType,
    UInt10 stationCountryCode,
    Oct6   mid
} with { variant "FIELDORDER(msb)"};

external function f_enc_ExtGN_Address(in ExtGN_Address egna) return octetstring
with { extension "prototype(convert)"
       extension "encode(RAW)"
     };

external function f_dec_ExtGN_Address(in octetstring os) return ExtGN_Address
with { extension "prototype(convert)"
       extension "decode(RAW)"
     };

function f_ExtGN_Address2GN_Address(ExtGN_Address EGNA) return GN_Address {
  var GN_Address GNA;

  var TypeOfAddress toa;
  int2enum(bit2int(EGNA.typeOfAddress),toa);
  GNA.typeOfAddress := toa;

  var LibItsGeoNetworking_TypesAndValues.StationType st;
  int2enum(bit2int(EGNA.stationType),st);
  GNA.stationType := st;

  GNA.stationCountryCode := EGNA.stationCountryCode;
  GNA.mid := EGNA.mid;

  return GNA;
}

function f_GN_Address2ExtGN_Address(GN_Address GNA) return ExtGN_Address {
  var ExtGN_Address EGNA;

  EGNA.typeOfAddress := int2bit(enum2int(GNA.typeOfAddress),1);
  EGNA.stationType := int2bit(enum2int(GNA.stationType),5);
  EGNA.stationCountryCode := GNA.stationCountryCode;
  EGNA.mid := GNA.mid;

  return EGNA;
}


type record ExtLongPosVector {
    ExtGN_Address  gnAddr,
    UInt32         timestamp,
    Int32          latitude,
    Int32          longitude,
    Bit1           pai,
    Int15          speed,
    UInt16         heading
} with { variant "FIELDORDER(msb)" };


function f_ExtLongPosVector2LongPosVector(ExtLongPosVector ELPV) return LongPosVector {
    var LongPosVector LPV;

    LPV.gnAddr := f_ExtGN_Address2GN_Address(ELPV.gnAddr);

    LPV.timestamp := ELPV.timestamp;
    LPV.latitude := ELPV.latitude;
    LPV.longitude := ELPV.longitude;
    LPV.pai := ELPV.pai;
    LPV.speed := ELPV.speed;
    LPV.heading := ELPV.heading;

    return LPV;
}

function f_LongPosVector2ExtLongPosVector(LongPosVector LPV) return ExtLongPosVector {
  var ExtLongPosVector ELPV;

  ELPV.gnAddr := f_GN_Address2ExtGN_Address(LPV.gnAddr);

  ELPV.timestamp := LPV.timestamp;
  ELPV.latitude := LPV.latitude;
  ELPV.longitude := LPV.longitude;
  ELPV.pai := LPV.pai;
  ELPV.speed := LPV.speed;
  ELPV.heading := LPV.heading;

  return ELPV;
}

external function f_dec_ExtLongPosVector(in octetstring os) return ExtLongPosVector
with { extension "prototype(convert)"
  extension "decode(RAW)"
};


external function f_enc_ExtLongPosVector(in ExtLongPosVector ELPV) return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};

function f_dec_LongPosVector(in octetstring stream) return LongPosVector {
  var LongPosVector LPV;
  LPV := f_ExtLongPosVector2LongPosVector(f_dec_ExtLongPosVector(stream));
  return LPV;
}

function f_enc_LongPosVector(in LongPosVector pdu) return octetstring{
  
  return f_enc_ExtLongPosVector(f_LongPosVector2ExtLongPosVector(pdu));
  
}


type record ExtShortPosVector {
   ExtGN_Address  gnAddr,
   UInt32         timestamp,
   Int32          latitude,
   Int32          longitude
} with { variant "FIELDORDER(msb)"};

function f_ExtShortPosVector2ShortPosVector(ExtShortPosVector ESPV)
 return ShortPosVector {
  var ShortPosVector SPV;

  SPV.gnAddr    := f_ExtGN_Address2GN_Address(ESPV.gnAddr);
  SPV.timestamp := ESPV.timestamp;
  SPV.latitude  := ESPV.latitude;
  SPV.longitude := ESPV.longitude;

  return SPV;
}

function f_ShortPosVector2ExtShortPosVector(ShortPosVector SPV)
 return ExtShortPosVector {
  var ExtShortPosVector ESPV;

  ESPV.gnAddr    := f_GN_Address2ExtGN_Address(SPV.gnAddr);
  ESPV.timestamp := SPV.timestamp;
  ESPV.latitude  := SPV.latitude;
  ESPV.longitude := SPV.longitude;

  return ESPV;
}



type union ExtExtendedHeader {
    ExtGeoUnicastHeader    geoUnicastHeader,
    ExtTSBHeader           tsbHeader,
    ExtSHBHeader           shbHeader,
    ExtGeoBroadcastHeader  geoBroadcastHeader,
    ExtGeoAnycastHeader    geoAnycastHeader,
    ExtBeaconHeader        beaconHeader,
    ExtLSRequestHeader     lsRequestHeader,
    ExtLSReplyHeader       lsReplyHeader,
    ExtAnyHeader           anyHeader
} with { variant "FIELDORDER(msb)" };


//GeoUnicastHeader
type record ExtGeoUnicastHeader {
    UInt16          seqNumber,
    UInt16          reserved,
    ExtLongPosVector   srcPosVector,
    ExtShortPosVector  dstPosVector
} with { variant "FIELDORDER(msb)" };

function f_ExtGeoUnicastHeader2GeoUnicastHeader(ExtGeoUnicastHeader EGUH)
 return GeoUnicastHeader {
  var GeoUnicastHeader GUH;

  GUH.seqNumber    := EGUH.seqNumber;
  GUH.reserved     := EGUH.reserved;
  GUH.srcPosVector := f_ExtLongPosVector2LongPosVector(EGUH.srcPosVector);
  GUH.dstPosVector := f_ExtShortPosVector2ShortPosVector(EGUH.dstPosVector);

  return GUH;
}

function f_GeoUnicastHeader2ExtGeoUnicastHeader(GeoUnicastHeader GUH)
 return ExtGeoUnicastHeader {
  var ExtGeoUnicastHeader EGUH;

  EGUH.seqNumber    := GUH.seqNumber;
  EGUH.reserved     := GUH.reserved;
  EGUH.srcPosVector := f_LongPosVector2ExtLongPosVector(GUH.srcPosVector);
  EGUH.dstPosVector := f_ShortPosVector2ExtShortPosVector(GUH.dstPosVector);

  return EGUH;
}

//GeoUnicastHeader End

//TSBHeader
type record ExtTSBHeader {
  UInt16           seqNumber,
  UInt16           reserved,
  ExtLongPosVector srcPosVector
} with { variant "FIELDORDER(msb)" };

function f_ExtTSBHeader2TSBHeader(ExtTSBHeader ETH) return TSBHeader {
  var TSBHeader TH;

  TH.seqNumber    := ETH.seqNumber;
  TH.reserved     := ETH.reserved;
  TH.srcPosVector := f_ExtLongPosVector2LongPosVector(ETH.srcPosVector);

  return TH;
}

function f_TSBHeader2ExtTSBHeader(TSBHeader TH) return ExtTSBHeader {
  var ExtTSBHeader ETH;

  ETH.seqNumber    := TH.seqNumber;
  ETH.reserved     := TH.reserved;
  ETH.srcPosVector := f_LongPosVector2ExtLongPosVector(TH.srcPosVector);

  return ETH;
}
//TSBHeader End

//SHBHeader
type record ExtSHBHeader {
    ExtLongPosVector   srcPosVector,
    UInt32             reserved
} with { variant "FIELDORDER(msb)" };

function f_ExtSHBHeader2SHBHeader(ExtSHBHeader ESH) return SHBHeader {
  var SHBHeader SH;

  SH.srcPosVector := f_ExtLongPosVector2LongPosVector(ESH.srcPosVector);
  SH.reserved     := ESH.reserved;

  return SH;
}

function f_SHBHeader2ExtSHBHeader(SHBHeader SH) return ExtSHBHeader {
  var ExtSHBHeader ESH;

  ESH.srcPosVector := f_LongPosVector2ExtLongPosVector(SH.srcPosVector);
  ESH.reserved     := SH.reserved;

  return ESH;
}
//SHBHeader End

//GeoBroadcastHeader
type ExtGeoAnycastHeader ExtGeoBroadcastHeader with { variant "FIELDORDER(msb)" };

function f_ExtGeoBroadcastHeader2GeoBroadcastHeader(ExtGeoBroadcastHeader EGBH)
 return GeoBroadcastHeader {
  var GeoBroadcastHeader GBH;

  GBH.seqNumber := EGBH.seqNumber;
  GBH.reserved := EGBH.reserved;
  GBH.srcPosVector := f_ExtLongPosVector2LongPosVector(EGBH.srcPosVector);
  GBH.geoAreaPosLatitude := EGBH.geoAreaPosLatitude;
  GBH.geoAreaPosLongitude := EGBH.geoAreaPosLongitude;
  GBH.distanceA := EGBH.distanceA;
  GBH.distanceB := EGBH.distanceB;
  GBH.angle := EGBH.angle;
  GBH.reserved2 := EGBH.reserved2;

  return GBH;
}

function f_GeoBroadcastHeader2ExtGeoBroadcastHeader(GeoBroadcastHeader GBH)
 return ExtGeoBroadcastHeader {
  var ExtGeoBroadcastHeader EGBH;

  EGBH.seqNumber := GBH.seqNumber;
  EGBH.reserved := GBH.reserved;
  EGBH.srcPosVector := f_LongPosVector2ExtLongPosVector(GBH.srcPosVector);
  EGBH.geoAreaPosLatitude := GBH.geoAreaPosLatitude;
  EGBH.geoAreaPosLongitude := GBH.geoAreaPosLongitude;
  EGBH.distanceA := GBH.distanceA;
  EGBH.distanceB := GBH.distanceB;
  EGBH.angle := GBH.angle;
  EGBH.reserved2 := GBH.reserved2;

  return EGBH;
}

//GeoBroadcastHeader End

//GeoAnycastHeader
type record ExtGeoAnycastHeader {
  UInt16           seqNumber,
  UInt16           reserved,
  ExtLongPosVector srcPosVector,
  Int32            geoAreaPosLatitude,
  Int32            geoAreaPosLongitude,
  UInt16           distanceA,
  UInt16           distanceB,
  UInt16           angle,
  UInt16           reserved2
} with { variant "FIELDORDER(msb)"};

function f_ExtGeoAnycastHeader2GeoAnycastHeader(ExtGeoAnycastHeader EGAH)
 return GeoAnycastHeader {
  var GeoAnycastHeader GAH;

  GAH.seqNumber := EGAH.seqNumber;
  GAH.reserved := EGAH.reserved;
  GAH.srcPosVector := f_ExtLongPosVector2LongPosVector(EGAH.srcPosVector);
  GAH.geoAreaPosLatitude := EGAH.geoAreaPosLatitude;
  GAH.geoAreaPosLongitude := EGAH.geoAreaPosLongitude;
  GAH.distanceA := EGAH.distanceA;
  GAH.distanceB := EGAH.distanceB;
  GAH.angle := EGAH.angle;
  GAH.reserved2 := EGAH.reserved2;

  return GAH;
}

function f_GeoAnycastHeader2ExtGeoAnycastHeader(GeoAnycastHeader GAH)
 return ExtGeoAnycastHeader {
  var ExtGeoAnycastHeader EGAH;

  EGAH.seqNumber := GAH.seqNumber;
  EGAH.reserved := GAH.reserved;
  EGAH.srcPosVector := f_LongPosVector2ExtLongPosVector(GAH.srcPosVector);
  EGAH.geoAreaPosLatitude := GAH.geoAreaPosLatitude;
  EGAH.geoAreaPosLongitude := GAH.geoAreaPosLongitude;
  EGAH.distanceA := GAH.distanceA;
  EGAH.distanceB := GAH.distanceB;
  EGAH.angle := GAH.angle;
  EGAH.reserved2 := GAH.reserved2;

  return EGAH;
}
//GeoAnycastHeader End

//BeaconHeader
type record ExtBeaconHeader {
  ExtLongPosVector   srcPosVector
} with { variant "FIELDORDER(msb)"};

function f_ExtBeaconHeader2BeaconHeader(ExtBeaconHeader EBH) return BeaconHeader {
  var BeaconHeader BH;

  BH.srcPosVector := f_ExtLongPosVector2LongPosVector(EBH.srcPosVector);

  return BH;
}

function f_BeaconHeader2ExtBeaconHeader(BeaconHeader BH) return ExtBeaconHeader {
  var ExtBeaconHeader EBH;

  EBH.srcPosVector := f_LongPosVector2ExtLongPosVector(BH.srcPosVector);

  return EBH;
}
//BeaconHeader End

//LSRequestHeader
type record ExtLSRequestHeader {
  UInt16             seqNumber,
  UInt16             reserved,
  ExtLongPosVector   srcPosVector,
  ExtGN_Address      gnAddress
} with { variant "FIELDORDER(msb)"};

function f_ExtLSRequestHeader2LSRequestHeader(ExtLSRequestHeader ELSRH)
 return LSRequestHeader {
  var LSRequestHeader LSRH;

  LSRH.seqNumber    := ELSRH.seqNumber;
  LSRH.reserved     := ELSRH.reserved;
  LSRH.srcPosVector := f_ExtLongPosVector2LongPosVector(ELSRH.srcPosVector);
  LSRH.gnAddress    := f_ExtGN_Address2GN_Address(ELSRH.gnAddress);

  return LSRH;
}

function f_LSRequestHeader2ExtLSRequestHeader(LSRequestHeader LSRH)
 return ExtLSRequestHeader {
  var ExtLSRequestHeader ELSRH;

  ELSRH.seqNumber    := LSRH.seqNumber;
  ELSRH.reserved     := LSRH.reserved;
  ELSRH.srcPosVector := f_LongPosVector2ExtLongPosVector(LSRH.srcPosVector);
  ELSRH.gnAddress    := f_GN_Address2ExtGN_Address(LSRH.gnAddress);

  return ELSRH;
}
//LSRequestHeader End

//LSReplyHeader
type record ExtLSReplyHeader {
  UInt16          seqNumber,
  UInt16          reserved,
  ExtLongPosVector   srcPosVector,
  ExtShortPosVector  dstPosVector
} with { variant "FIELDORDER(msb)" };

function f_ExtLSReplyHeader2LSReplyHeader(ExtLSReplyHeader ELSRH)
 return LSReplyHeader {
  var LSReplyHeader LSRH;

  LSRH.seqNumber    := ELSRH.seqNumber;
  LSRH.reserved     := ELSRH.reserved;
  LSRH.srcPosVector := f_ExtLongPosVector2LongPosVector(ELSRH.srcPosVector);
  LSRH.dstPosVector := f_ExtShortPosVector2ShortPosVector(ELSRH.dstPosVector);

  return LSRH;
}

function f_LSReplyHeader2ExtLSReplyHeader(LSReplyHeader LSRH)
 return ExtLSReplyHeader {
  var ExtLSReplyHeader ELSRH;

  ELSRH.seqNumber    := LSRH.seqNumber;
  ELSRH.reserved     := LSRH.reserved;
  ELSRH.srcPosVector := f_LongPosVector2ExtLongPosVector(LSRH.srcPosVector);
  ELSRH.dstPosVector := f_ShortPosVector2ExtShortPosVector(LSRH.dstPosVector);

  return ELSRH;
}
//LSReplyHeader End

//AnyHeader
type record ExtAnyHeader {
  UInt16          seqNumber,
  UInt16          reserved
} with { variant "FIELDORDER(msb)" };

function f_ExtAnyHeader2AnyHeader(ExtAnyHeader EAH) return AnyHeader {
  var AnyHeader AH;

  AH.seqNumber := EAH.seqNumber;
  AH.reserved  := EAH.reserved;
  
  return AH;
}

function f_AnyHeader2ExtAnyHeader(AnyHeader AH) return ExtAnyHeader {
  var ExtAnyHeader EAH;

  EAH.seqNumber := AH.seqNumber;
  EAH.reserved  := AH.reserved;
  
  return EAH;
}

//AnyHeader End


//GnNonSecuredPacket
type record ExtGnNonSecuredPacket {
  //CommonHeader
  NextHeader         nextHeader,
  UInt4              reserved,
  UInt8              headerTST,
  ExtTrafficClass    trafficClass,
  Bit8               flags,
  UInt16             plLength,
  UInt8              maxHopLimit,
  UInt8              reserved2,
  ExtExtendedHeader  extendedHeader,//  optional,
  Ipv6Packet         ipv6Packet       optional,
  BtpHeader          btpHeader        optional,
  octetstring        btpPayload       optional,
  GnRawPayload       rawPayload//,
  //UInt16	     CohdaBug
} with { variant 	            "FIELDORDER(msb)";
         variant(plLength)     	    "LENGTHTO(ipv6Packet, 
                                              btpHeader, 
                                              btpPayload, 
                                              rawPayload)";

  variant(extendedHeader) "CROSSTAG(anyHeader,           headerTST = 0;
  beaconHeader,        headerTST = 16;
  geoUnicastHeader,    headerTST = 32;
  geoAnycastHeader,   {headerTST = 48,
  headerTST = 49,
  headerTST = 50};
  geoBroadcastHeader, {headerTST = 64,
  headerTST = 65,
  headerTST = 66};
  shbHeader, 	   headerTST = 80;
  tsbHeader, 	   headerTST = 81;
  lsRequestHeader, 	   headerTST = 96;
  lsReplyHeader, 	   headerTST = 97)";

  variant(ipv6Packet)     "PRESENCE(nextHeader = e_ipv6;)";
  variant(btpHeader)      "CROSSTAG(btpAHeader, nextHeader = e_btpA;
                                    btpBHeader, nextHeader = e_btpB;)";

  variant(btpPayload)     "PRESENCE(nextHeader = e_btpA;)";
  variant(btpPayload)     "PRESENCE(nextHeader = e_btpB;)";

};

function f_ExtGnNonSecuredPacket2GnNonSecuredPacket(ExtGnNonSecuredPacket EGNSP)
return GnNonSecuredPacket {
  var GnNonSecuredPacket GNSP;
  
  GNSP.commonHeader.nextHeader := EGNSP.nextHeader;
  GNSP.commonHeader.reserved := EGNSP.reserved;

  select (EGNSP.headerTST) {
    case (0) {
      GNSP.commonHeader.headerTST := {anyHdr := {headerType := e_any, 
                                                 headerSubType := 0}};
      GNSP.extendedHeader.anyHeader :=
        f_ExtAnyHeader2AnyHeader(EGNSP.extendedHeader.anyHeader);
    }
    case (16) {
      GNSP.commonHeader.headerTST := {beaconHdr := {headerType := e_beacon, 
                                                    headerSubType := 0}};
      GNSP.extendedHeader.beaconHeader :=
        f_ExtBeaconHeader2BeaconHeader(EGNSP.extendedHeader.beaconHeader);
    }
    case (32) {
      GNSP.commonHeader.headerTST := {geoUnicastHdr := {headerType := e_geoUnicast, 
                                                        headerSubType := 0}};
      GNSP.extendedHeader.geoUnicastHeader :=
        f_ExtGeoUnicastHeader2GeoUnicastHeader(EGNSP.extendedHeader.geoUnicastHeader);
    }
    case (48) {
      GNSP.commonHeader.headerTST := {geoAnycastHdr :=
                                       {headerType := e_geoAnycast, 
                                        headerSubType := e_geoAnycastCircle}};
      GNSP.extendedHeader.geoAnycastHeader :=
        f_ExtGeoAnycastHeader2GeoAnycastHeader(EGNSP.extendedHeader.geoAnycastHeader);
    }
    case (49) {
      GNSP.commonHeader.headerTST := {geoAnycastHdr :=
                                       {headerType := e_geoAnycast, 
                                        headerSubType := e_geoAnycastRect}};
      GNSP.extendedHeader.geoAnycastHeader :=
        f_ExtGeoAnycastHeader2GeoAnycastHeader(EGNSP.extendedHeader.geoAnycastHeader);
    }
    case (50) {
      GNSP.commonHeader.headerTST := {geoAnycastHdr :=
                                       {headerType := e_geoAnycast, 
                                        headerSubType := e_geoAnycastElip}};
      GNSP.extendedHeader.geoAnycastHeader :=
        f_ExtGeoAnycastHeader2GeoAnycastHeader(EGNSP.extendedHeader.geoAnycastHeader);
    }
    case (64) {
      GNSP.commonHeader.headerTST := {geoBroadcastHdr :=
                                       {headerType := e_geoBroadcast, 
                                        headerSubType := e_geoBroadcastCircle}};
      GNSP.extendedHeader.geoBroadcastHeader :=
        f_ExtGeoBroadcastHeader2GeoBroadcastHeader(EGNSP.extendedHeader.geoBroadcastHeader);
    }
    case (65) {
      GNSP.commonHeader.headerTST := {geoBroadcastHdr :=
                                       {headerType := e_geoBroadcast, 
                                        headerSubType := e_geoBroadcastRect}};
      GNSP.extendedHeader.geoBroadcastHeader :=
        f_ExtGeoBroadcastHeader2GeoBroadcastHeader(EGNSP.extendedHeader.geoBroadcastHeader);
    }
    case (66) {
      GNSP.commonHeader.headerTST := {geoBroadcastHdr :=
                                       {headerType := e_geoBroadcast, 
                                        headerSubType := e_geoBroadcastElip}};
      GNSP.extendedHeader.geoBroadcastHeader :=
        f_ExtGeoBroadcastHeader2GeoBroadcastHeader(EGNSP.extendedHeader.geoBroadcastHeader);
    }
    case (80) {
      GNSP.commonHeader.headerTST :=
        {tsbHdr := {headerType := e_topologicallyScopedBroadcast, 
                    headerSubType := e_singleHop}};
      GNSP.extendedHeader.shbHeader :=
        f_ExtSHBHeader2SHBHeader(EGNSP.extendedHeader.shbHeader);
    }
    case (81) {
      GNSP.commonHeader.headerTST := 
        {tsbHdr := {headerType := e_topologicallyScopedBroadcast, 
                    headerSubType := e_multiHop}};
      GNSP.extendedHeader.tsbHeader :=
      f_ExtTSBHeader2TSBHeader(EGNSP.extendedHeader.tsbHeader);
    }
    case (96) {
      GNSP.commonHeader.headerTST := 
      {lsHdr := {headerType := e_locationService, 
                 headerSubType := e_lsRequest}};
      GNSP.extendedHeader.lsRequestHeader :=
        f_ExtLSRequestHeader2LSRequestHeader(EGNSP.extendedHeader.lsRequestHeader);
    }
    case (97) {
      GNSP.commonHeader.headerTST := 
      {lsHdr := {headerType := e_locationService, 
                 headerSubType := e_lsReply}};
      GNSP.extendedHeader.lsReplyHeader :=
        f_ExtLSReplyHeader2LSReplyHeader(EGNSP.extendedHeader.lsReplyHeader);
    }
  } 
  //TODO saHdr???


  GNSP.commonHeader.trafficClass
    := f_ExtTrafficClass2TrafficClass(EGNSP.trafficClass);
  GNSP.commonHeader.flags        := EGNSP.flags;
  GNSP.commonHeader.plLength     := EGNSP.plLength;
  GNSP.commonHeader.maxHopLimit  := EGNSP.maxHopLimit;
  GNSP.commonHeader.reserved2    := EGNSP.reserved2;

  if (EGNSP.nextHeader == e_btpA) {
  
    var BtpPacket v_btpPacket;
    var DecodedBtpPayload v_decodedPayload;
    if ((EGNSP.plLength > 0) and
         isWellKnownBTPPort(EGNSP.btpHeader.btpAHeader.destinationPort) ) {
      v_decodedPayload := 
        decodeBTPPayload(EGNSP.btpPayload, 
                         EGNSP.btpHeader.btpAHeader.destinationPort);
    }

    if (isbound(v_decodedPayload)) {
        v_btpPacket := {header  := EGNSP.btpHeader,
                        payload := {decodedPayload := v_decodedPayload,
                                    rawPayload     := EGNSP.btpPayload}};
    } else {
      v_btpPacket := {header  := EGNSP.btpHeader,
                      payload := omit};
    } 

    if (isbound(v_btpPacket)) {
        GNSP.payload.decodedPayload := 
            {btpPacket := v_btpPacket};
    } else {
        GNSP.payload.decodedPayload := omit;
    }

    var octetstring btpPayload;
    if (ispresent(EGNSP.btpPayload)) {
      btpPayload := EGNSP.btpPayload;
    } else {
      btpPayload := ''O;
    }

    GNSP.payload.rawPayload :=
      int2oct(EGNSP.btpHeader.btpAHeader.destinationPort,2) &
      int2oct(EGNSP.btpHeader.btpAHeader.sourcePort,2) &
      btpPayload;

  }
  else if (EGNSP.nextHeader == e_btpB)
  {

    var BtpPacket v_btpPacket;
    var DecodedBtpPayload v_decodedPayload;

    if ((EGNSP.plLength > 0) and
         isWellKnownBTPPort(EGNSP.btpHeader.btpBHeader.destinationPort)) {
      v_decodedPayload := 
        decodeBTPPayload(EGNSP.btpPayload, 
                         EGNSP.btpHeader.btpBHeader.destinationPort);
    }

    if (isbound(v_decodedPayload)) {
      v_btpPacket := {header  := EGNSP.btpHeader,
                      payload := {decodedPayload := v_decodedPayload,
                                  rawPayload     := EGNSP.btpPayload}};
    } else {
      v_btpPacket := {header  := EGNSP.btpHeader,
                      payload := omit};
    }

    if (isbound(v_btpPacket)) {
        GNSP.payload.decodedPayload := 
            {btpPacket := v_btpPacket};
    } else {
        GNSP.payload.decodedPayload := omit;
    }

    var octetstring btpPayload;
    if (ispresent(EGNSP.btpPayload)) {
      btpPayload := EGNSP.btpPayload;
    } else {
      btpPayload := ''O;
    }

    GNSP.payload.rawPayload :=
      int2oct(EGNSP.btpHeader.btpBHeader.destinationPort,2) &
      int2oct(EGNSP.btpHeader.btpBHeader.destinationPortInfo,2) &
      btpPayload;

  } else if (EGNSP.nextHeader == e_ipv6) {

    //TODO Handle Ipv6
    GNSP.payload.decodedPayload := omit;
    GNSP.payload.rawPayload := EGNSP.rawPayload;
  } else if (EGNSP.nextHeader == e_any) {
    GNSP.payload.decodedPayload := omit;
    GNSP.payload.rawPayload := EGNSP.rawPayload;
  }
  return GNSP;
}

function f_GnNonSecuredPacket2ExtGnNonSecuredPacket(GnNonSecuredPacket GNSP)
return ExtGnNonSecuredPacket {
  var ExtGnNonSecuredPacket EGNSP;
  
  EGNSP.nextHeader := GNSP.commonHeader.nextHeader;
  EGNSP.reserved := GNSP.commonHeader.reserved;
  
  if (ischosen(GNSP.extendedHeader.anyHeader)) {
    EGNSP.headerTST := 0;
    EGNSP.extendedHeader.anyHeader :=
      f_AnyHeader2ExtAnyHeader(GNSP.extendedHeader.anyHeader);   
  } else if (ischosen(GNSP.extendedHeader.beaconHeader)){
    EGNSP.headerTST := 16;
    EGNSP.extendedHeader.beaconHeader :=
        f_BeaconHeader2ExtBeaconHeader(GNSP.extendedHeader.beaconHeader);
  } else if (ischosen(GNSP.extendedHeader.geoUnicastHeader)){
    EGNSP.headerTST := 32;
    EGNSP.extendedHeader.geoUnicastHeader :=
        f_GeoUnicastHeader2ExtGeoUnicastHeader(GNSP.extendedHeader.geoUnicastHeader);
  } else if (ischosen(GNSP.extendedHeader.geoAnycastHeader)){
    if (GNSP.commonHeader.headerTST.geoAnycastHdr.headerSubType ==
          e_geoAnycastCircle) {
      EGNSP.headerTST := 48;
      EGNSP.extendedHeader.geoAnycastHeader :=
        f_GeoAnycastHeader2ExtGeoAnycastHeader(GNSP.extendedHeader.geoAnycastHeader);
    } else if (GNSP.commonHeader.headerTST.geoAnycastHdr.headerSubType ==
                 e_geoAnycastRect) {
      EGNSP.headerTST := 49;
      EGNSP.extendedHeader.geoAnycastHeader :=
        f_GeoAnycastHeader2ExtGeoAnycastHeader(GNSP.extendedHeader.geoAnycastHeader);
    } else if (GNSP.commonHeader.headerTST.geoAnycastHdr.headerSubType ==
                 e_geoAnycastElip) {
      EGNSP.headerTST := 50;
      EGNSP.extendedHeader.geoAnycastHeader :=
        f_GeoAnycastHeader2ExtGeoAnycastHeader(GNSP.extendedHeader.geoAnycastHeader);
    }
  } else if (ischosen(GNSP.extendedHeader.geoBroadcastHeader)){
    if (GNSP.commonHeader.headerTST.geoBroadcastHdr.headerSubType ==
          e_geoBroadcastCircle) {
      EGNSP.headerTST := 64;
      EGNSP.extendedHeader.geoBroadcastHeader :=
        f_GeoBroadcastHeader2ExtGeoBroadcastHeader(GNSP.extendedHeader.geoBroadcastHeader);
    } else if (GNSP.commonHeader.headerTST.geoBroadcastHdr.headerSubType ==
                 e_geoBroadcastRect) {
      EGNSP.headerTST := 65;
      EGNSP.extendedHeader.geoBroadcastHeader :=
        f_GeoBroadcastHeader2ExtGeoBroadcastHeader(GNSP.extendedHeader.geoBroadcastHeader);
    } else if (GNSP.commonHeader.headerTST.geoBroadcastHdr.headerSubType ==
                 e_geoBroadcastElip) {
      EGNSP.headerTST := 66;
      EGNSP.extendedHeader.geoBroadcastHeader :=
        f_GeoBroadcastHeader2ExtGeoBroadcastHeader(GNSP.extendedHeader.geoBroadcastHeader);
    }
  } else if (ischosen(GNSP.extendedHeader.shbHeader)){
    EGNSP.headerTST := 80;
    EGNSP.extendedHeader.shbHeader :=
      f_SHBHeader2ExtSHBHeader(GNSP.extendedHeader.shbHeader);
  } else if (ischosen(GNSP.extendedHeader.tsbHeader)){
    EGNSP.headerTST := 81;
    EGNSP.extendedHeader.tsbHeader :=
      f_TSBHeader2ExtTSBHeader(GNSP.extendedHeader.tsbHeader);
  } else if (ischosen(GNSP.extendedHeader.lsRequestHeader)){
    EGNSP.headerTST := 96;
    EGNSP.extendedHeader.lsRequestHeader :=
      f_LSRequestHeader2ExtLSRequestHeader(GNSP.extendedHeader.lsRequestHeader);
  } else if (ischosen(GNSP.extendedHeader.lsReplyHeader)){
    EGNSP.headerTST := 96;
    EGNSP.extendedHeader.lsReplyHeader :=
      f_LSReplyHeader2ExtLSReplyHeader(GNSP.extendedHeader.lsReplyHeader);
  } 


  //TODO saHdr???


  EGNSP.trafficClass :=
    f_TrafficClass2ExtTrafficClass(GNSP.commonHeader.trafficClass);
  EGNSP.flags        := GNSP.commonHeader.flags;
  EGNSP.plLength     := GNSP.commonHeader.plLength;
  EGNSP.maxHopLimit  := GNSP.commonHeader.maxHopLimit;
  EGNSP.reserved2    := GNSP.commonHeader.reserved2;
 
  if (GNSP.commonHeader.nextHeader == e_btpA) {
    EGNSP.ipv6Packet := omit;
    EGNSP.btpHeader  := GNSP.payload.decodedPayload.btpPacket.header;
    if (ispresent(GNSP.payload.decodedPayload.btpPacket.payload.decodedPayload)) {
      EGNSP.btpPayload :=
        encodeBTPPayload(GNSP.payload.decodedPayload.btpPacket.payload.decodedPayload);
    } else {
      EGNSP.btpPayload := GNSP.payload.decodedPayload.btpPacket.payload.rawPayload;
    }
  } else if (GNSP.commonHeader.nextHeader == e_btpB) {
    EGNSP.ipv6Packet := omit;
    EGNSP.btpHeader  := GNSP.payload.decodedPayload.btpPacket.header;
    if (ispresent(GNSP.payload.decodedPayload.btpPacket.payload.decodedPayload)) {
      EGNSP.btpPayload :=
        encodeBTPPayload(GNSP.payload.decodedPayload.btpPacket.payload.decodedPayload);
    } else {
      EGNSP.btpPayload := GNSP.payload.decodedPayload.btpPacket.payload.rawPayload;
    }
  } else { //TODO: Handle e_any, e_reserved, e_ipv6
    EGNSP.ipv6Packet := omit;
    EGNSP.btpHeader  := omit;
    EGNSP.btpPayload := omit;
  }

  if (ispresent(GNSP.payload)) {
    EGNSP.rawPayload := GNSP.payload.rawPayload;
  } else {
    EGNSP.rawPayload := ''O;
  }

  return EGNSP;
}
//GnNonSecuredPacket End

//Lifetime
type record ExtLifetime {
  Bit6  multiplier,
  Bit2  ltBase
} with { variant "FIELDORDER(msb)" };

function f_ExtLifetime2Lifetime(ExtLifetime ELT) return Lifetime {
  var Lifetime LT;

  LT.multiplier := bit2int(ELT.multiplier);
  int2enum(bit2int(ELT.ltBase),LT.ltBase);

  return LT;
}

function f_Lifetime2ExtLifetime(Lifetime LT) return ExtLifetime {
  var ExtLifetime ELT;

  ELT.multiplier := int2bit(LT.multiplier,6);
  ELT.ltBase     := int2bit(enum2int(LT.ltBase),2);

  return ELT;
}


//Lifetime END




type record ExtGeoNetworkingPdu {
  UInt4                 version,
  BasicNextHeader       nextHeader,
  UInt8                 reserved,
  ExtLifetime           lifeTime,
  UInt8                 routerHopLimit,
  ExtGnNonSecuredPacket packet     optional,
  SecuredMessage        securedMsg optional
} with { variant 	      "FIELDORDER(msb)";
  variant (packet)     "PRESENCE(nextHeader = e_commonHeader)";
  variant (securedMsg) "PRESENCE(nextHeader = e_securedPacket)";
};

type record ExtGeoNetworkingInd {
  ExtGeoNetworkingPdu msgIn,
  MacAddress          macDestinationAddress
} with { variant (msgIn) "FIELDORDER(msb)" };

function f_dec_GeoNetworkingInd(in octetstring stream) return GeoNetworkingInd {
  var ExtGeoNetworkingInd EGNI := f_dec_ExtGeoNetworkingInd(stream);
  var GeoNetworkingInd    GNI;

  GNI.msgIn.basicHeader.version        := EGNI.msgIn.version;
  GNI.msgIn.basicHeader.nextHeader     := EGNI.msgIn.nextHeader;
  GNI.msgIn.basicHeader.reserved       := EGNI.msgIn.reserved;
  GNI.msgIn.basicHeader.lifeTime       := f_ExtLifetime2Lifetime(EGNI.msgIn.lifeTime);
  GNI.msgIn.basicHeader.routerHopLimit := EGNI.msgIn.routerHopLimit;

  if (ispresent(EGNI.msgIn.packet)) {
    GNI.msgIn.gnPacket.packet := f_ExtGnNonSecuredPacket2GnNonSecuredPacket(EGNI.msgIn.packet);
    }

  GNI.msgIn.gnPacket.securedMsg := EGNI.msgIn.securedMsg;
  GNI.macDestinationAddress := EGNI.macDestinationAddress;

  log(GNI);

  return GNI;	 
}




//IPv6OverGeoNetworking--------------------------------------------------------

external function f_enc_IPv6OverGeoNetworkingReq(in IPv6OverGeoNetworkingReq pdu) return octetstring

with { extension "prototype(convert)"
  extension "encode(RAW)"
};

external function f_dec_IPv6OverGeoNetworkingInd(in octetstring stream) return IPv6OverGeoNetworkingInd
with { extension "prototype(convert)"
  extension "decode(RAW)"
};



//AdapterControlPort--------------------------------------------------------

/*
external function f_enc_LongPosVector(in LongPosVector pdu) return octetstring
with { extension "prototype(convert)"
  extension "encode(RAW)"
};
*/
/*
external function f_dec_LongPosVector(in octetstring stream) return LongPosVector
with { extension "prototype(convert)"
  extension "decode(RAW)"
};
*/





} //endmodule
