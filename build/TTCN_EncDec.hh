// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef TTCN__EncDec_HH
#define TTCN__EncDec_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "LibItsBtp_TestSystem.hh"
#include "LibItsCam_TypesAndValues.hh"
#include "LibItsCam_TestSystem.hh"
#include "LibItsDenm_TypesAndValues.hh"
#include "LibItsDenm_TestSystem.hh"
#include "LibItsIpv6OverGeoNetworking_TestSystem.hh"
#include "LibItsGeoNetworking_TestSystem.hh"
#include "LibItsGeoNetworking_TypesAndValues.hh"
#include "CAM_Types.hh"
#include "DENM_Types.hh"
#include "MAP_Types.hh"
#include "SPAT_Types.hh"
#include "General_Types.hh"

#if TTCN3_VERSION != 50400
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef TTCN__EncDec_HH
#endif

namespace TTCN__EncDec {

/* Forward declarations of classes */

class ExtTrafficClass;
class ExtTrafficClass_template;
class ExtGnPayload;
class ExtGnPayload_template;
class ExtGenerateGeoBroadcastMessage;
class ExtGenerateGeoBroadcastMessage_template;
class ExtPtActivation;
class ExtPtActivation_template;
class ExtUtCamTrigger;
class ExtUtCamTrigger_template;
class ExtUtCamEventInd;
class ExtUtCamEventInd_template;
class ExtSituationContainer;
class ExtSituationContainer_template;
class ExtAlacarteContainer;
class ExtAlacarteContainer_template;
class ExtUtDenmTrigger;
class ExtUtDenmTrigger_template;
class ExtActionID;
class ExtActionID_template;
class ExtUtDenmUpdate;
class ExtUtDenmUpdate_template;
class ExtDenmInd;
class ExtDenmInd_template;
class ExtUtDenmEventInd;
class ExtUtDenmEventInd_template;
class ExtUtMapEventInd;
class ExtUtMapEventInd_template;
class ExtUtSpatEventInd;
class ExtUtSpatEventInd_template;
class ExtBtpPayload;
class ExtBtpPayload_template;
class ExtBtpReq;
class ExtBtpReq_template;
class ExtBtpInd;
class ExtBtpInd_template;
class ExtCamInd;
class ExtCamInd_template;
class MapSpatInd;
class MapSpatInd_template;
class ExtMapSpatInd;
class ExtMapSpatInd_template;
class ExtGnNonSecuredPacket;
class ExtGnNonSecuredPacket_template;
class ExtGeoNetworkingPdu;
class ExtGeoNetworkingPdu_template;
class ExtGeoNetworkingInd;
class ExtGeoNetworkingInd_template;

} /* end of namespace */

#ifndef TTCN__EncDec_HH
#define TTCN__EncDec_HH

namespace TTCN__EncDec {

/* Type definitions */

typedef BITSTRING BIT1;
typedef BITSTRING_template BIT1_template;
typedef BITSTRING BIT6;
typedef BITSTRING_template BIT6_template;
typedef BITSTRING BIT8;
typedef BITSTRING_template BIT8_template;

/* Class definitions */

class ExtTrafficClass : public Base_Type {
  BITSTRING field_scf;
  BITSTRING field_channelOffload;
  BITSTRING field_tcId;
  boolean bound_flag;
public:
  ExtTrafficClass();
  ExtTrafficClass(const BITSTRING& par_scf,
    const BITSTRING& par_channelOffload,
    const BITSTRING& par_tcId);
  ExtTrafficClass(const ExtTrafficClass& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtTrafficClass& operator=(const ExtTrafficClass& other_value);
  boolean operator==(const ExtTrafficClass& other_value) const;
  inline boolean operator!=(const ExtTrafficClass& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BITSTRING& scf()
    {return field_scf;}
  inline const BITSTRING& scf() const
    {return field_scf;}
  inline BITSTRING& channelOffload()
    {return field_channelOffload;}
  inline const BITSTRING& channelOffload() const
    {return field_channelOffload;}
  inline BITSTRING& tcId()
    {return field_tcId;}
  inline const BITSTRING& tcId() const
    {return field_tcId;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtTrafficClass_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtTrafficClass_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtTrafficClass& other_value);
void copy_template(const ExtTrafficClass_template& other_value);

public:
ExtTrafficClass_template();
ExtTrafficClass_template(template_sel other_value);
ExtTrafficClass_template(const ExtTrafficClass& other_value);
ExtTrafficClass_template(const OPTIONAL<ExtTrafficClass>& other_value);
ExtTrafficClass_template(const ExtTrafficClass_template& other_value);
~ExtTrafficClass_template();
ExtTrafficClass_template& operator=(template_sel other_value);
ExtTrafficClass_template& operator=(const ExtTrafficClass& other_value);
ExtTrafficClass_template& operator=(const OPTIONAL<ExtTrafficClass>& other_value);
ExtTrafficClass_template& operator=(const ExtTrafficClass_template& other_value);
boolean match(const ExtTrafficClass& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtTrafficClass valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtTrafficClass_template& list_item(unsigned int list_index) const;
BITSTRING_template& scf();
const BITSTRING_template& scf() const;
BITSTRING_template& channelOffload();
const BITSTRING_template& channelOffload() const;
BITSTRING_template& tcId();
const BITSTRING_template& tcId() const;
int size_of() const;
void log() const;
void log_match(const ExtTrafficClass& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtGnPayload : public Base_Type {
  OCTETSTRING field_rawPayload;
  boolean bound_flag;
public:
  ExtGnPayload();
  ExtGnPayload(const OCTETSTRING& par_rawPayload);
  ExtGnPayload(const ExtGnPayload& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtGnPayload& operator=(const ExtGnPayload& other_value);
  boolean operator==(const ExtGnPayload& other_value) const;
  inline boolean operator!=(const ExtGnPayload& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& rawPayload()
    {return field_rawPayload;}
  inline const OCTETSTRING& rawPayload() const
    {return field_rawPayload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtGnPayload_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtGnPayload_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtGnPayload& other_value);
void copy_template(const ExtGnPayload_template& other_value);

public:
ExtGnPayload_template();
ExtGnPayload_template(template_sel other_value);
ExtGnPayload_template(const ExtGnPayload& other_value);
ExtGnPayload_template(const OPTIONAL<ExtGnPayload>& other_value);
ExtGnPayload_template(const ExtGnPayload_template& other_value);
~ExtGnPayload_template();
ExtGnPayload_template& operator=(template_sel other_value);
ExtGnPayload_template& operator=(const ExtGnPayload& other_value);
ExtGnPayload_template& operator=(const OPTIONAL<ExtGnPayload>& other_value);
ExtGnPayload_template& operator=(const ExtGnPayload_template& other_value);
boolean match(const ExtGnPayload& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtGnPayload valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtGnPayload_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& rawPayload();
const OCTETSTRING_template& rawPayload() const;
int size_of() const;
void log() const;
void log_match(const ExtGnPayload& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtGenerateGeoBroadcastMessage : public Base_Type {
  INTEGER field_shape;
  INTEGER field_lifetime;
  ExtTrafficClass field_trafficClass;
  INTEGER field_reserved;
  LibItsGeoNetworking__TypesAndValues::Area field_area;
  INTEGER field_payloadLength;
  ExtGnPayload field_payload;
  boolean bound_flag;
public:
  ExtGenerateGeoBroadcastMessage();
  ExtGenerateGeoBroadcastMessage(const INTEGER& par_shape,
    const INTEGER& par_lifetime,
    const ExtTrafficClass& par_trafficClass,
    const INTEGER& par_reserved,
    const LibItsGeoNetworking__TypesAndValues::Area& par_area,
    const INTEGER& par_payloadLength,
    const ExtGnPayload& par_payload);
  ExtGenerateGeoBroadcastMessage(const ExtGenerateGeoBroadcastMessage& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtGenerateGeoBroadcastMessage& operator=(const ExtGenerateGeoBroadcastMessage& other_value);
  boolean operator==(const ExtGenerateGeoBroadcastMessage& other_value) const;
  inline boolean operator!=(const ExtGenerateGeoBroadcastMessage& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& shape()
    {return field_shape;}
  inline const INTEGER& shape() const
    {return field_shape;}
  inline INTEGER& lifetime()
    {return field_lifetime;}
  inline const INTEGER& lifetime() const
    {return field_lifetime;}
  inline ExtTrafficClass& trafficClass()
    {return field_trafficClass;}
  inline const ExtTrafficClass& trafficClass() const
    {return field_trafficClass;}
  inline INTEGER& reserved()
    {return field_reserved;}
  inline const INTEGER& reserved() const
    {return field_reserved;}
  inline LibItsGeoNetworking__TypesAndValues::Area& area()
    {return field_area;}
  inline const LibItsGeoNetworking__TypesAndValues::Area& area() const
    {return field_area;}
  inline INTEGER& payloadLength()
    {return field_payloadLength;}
  inline const INTEGER& payloadLength() const
    {return field_payloadLength;}
  inline ExtGnPayload& payload()
    {return field_payload;}
  inline const ExtGnPayload& payload() const
    {return field_payload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtGenerateGeoBroadcastMessage_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtGenerateGeoBroadcastMessage_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtGenerateGeoBroadcastMessage& other_value);
void copy_template(const ExtGenerateGeoBroadcastMessage_template& other_value);

public:
ExtGenerateGeoBroadcastMessage_template();
ExtGenerateGeoBroadcastMessage_template(template_sel other_value);
ExtGenerateGeoBroadcastMessage_template(const ExtGenerateGeoBroadcastMessage& other_value);
ExtGenerateGeoBroadcastMessage_template(const OPTIONAL<ExtGenerateGeoBroadcastMessage>& other_value);
ExtGenerateGeoBroadcastMessage_template(const ExtGenerateGeoBroadcastMessage_template& other_value);
~ExtGenerateGeoBroadcastMessage_template();
ExtGenerateGeoBroadcastMessage_template& operator=(template_sel other_value);
ExtGenerateGeoBroadcastMessage_template& operator=(const ExtGenerateGeoBroadcastMessage& other_value);
ExtGenerateGeoBroadcastMessage_template& operator=(const OPTIONAL<ExtGenerateGeoBroadcastMessage>& other_value);
ExtGenerateGeoBroadcastMessage_template& operator=(const ExtGenerateGeoBroadcastMessage_template& other_value);
boolean match(const ExtGenerateGeoBroadcastMessage& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtGenerateGeoBroadcastMessage valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtGenerateGeoBroadcastMessage_template& list_item(unsigned int list_index) const;
INTEGER_template& shape();
const INTEGER_template& shape() const;
INTEGER_template& lifetime();
const INTEGER_template& lifetime() const;
ExtTrafficClass_template& trafficClass();
const ExtTrafficClass_template& trafficClass() const;
INTEGER_template& reserved();
const INTEGER_template& reserved() const;
LibItsGeoNetworking__TypesAndValues::Area_template& area();
const LibItsGeoNetworking__TypesAndValues::Area_template& area() const;
INTEGER_template& payloadLength();
const INTEGER_template& payloadLength() const;
ExtGnPayload_template& payload();
const ExtGnPayload_template& payload() const;
int size_of() const;
void log() const;
void log_match(const ExtGenerateGeoBroadcastMessage& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtPtActivation : public Base_Type {
  INTEGER field_ptActivationType;
  INTEGER field_ptActivationDataLength;
  OCTETSTRING field_ptActivationData;
  boolean bound_flag;
public:
  ExtPtActivation();
  ExtPtActivation(const INTEGER& par_ptActivationType,
    const INTEGER& par_ptActivationDataLength,
    const OCTETSTRING& par_ptActivationData);
  ExtPtActivation(const ExtPtActivation& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtPtActivation& operator=(const ExtPtActivation& other_value);
  boolean operator==(const ExtPtActivation& other_value) const;
  inline boolean operator!=(const ExtPtActivation& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& ptActivationType()
    {return field_ptActivationType;}
  inline const INTEGER& ptActivationType() const
    {return field_ptActivationType;}
  inline INTEGER& ptActivationDataLength()
    {return field_ptActivationDataLength;}
  inline const INTEGER& ptActivationDataLength() const
    {return field_ptActivationDataLength;}
  inline OCTETSTRING& ptActivationData()
    {return field_ptActivationData;}
  inline const OCTETSTRING& ptActivationData() const
    {return field_ptActivationData;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtPtActivation_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtPtActivation_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtPtActivation& other_value);
void copy_template(const ExtPtActivation_template& other_value);

public:
ExtPtActivation_template();
ExtPtActivation_template(template_sel other_value);
ExtPtActivation_template(const ExtPtActivation& other_value);
ExtPtActivation_template(const OPTIONAL<ExtPtActivation>& other_value);
ExtPtActivation_template(const ExtPtActivation_template& other_value);
~ExtPtActivation_template();
ExtPtActivation_template& operator=(template_sel other_value);
ExtPtActivation_template& operator=(const ExtPtActivation& other_value);
ExtPtActivation_template& operator=(const OPTIONAL<ExtPtActivation>& other_value);
ExtPtActivation_template& operator=(const ExtPtActivation_template& other_value);
boolean match(const ExtPtActivation& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtPtActivation valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtPtActivation_template& list_item(unsigned int list_index) const;
INTEGER_template& ptActivationType();
const INTEGER_template& ptActivationType() const;
INTEGER_template& ptActivationDataLength();
const INTEGER_template& ptActivationDataLength() const;
OCTETSTRING_template& ptActivationData();
const OCTETSTRING_template& ptActivationData() const;
int size_of() const;
void log() const;
void log_match(const ExtPtActivation& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtUtCamTrigger : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_changeCurvature = 1, ALT_changeSpeed = 2, ALT_setAccelerationControlStatus = 3, ALT_setExteriorLightsStatus = 4, ALT_changeHeading = 5, ALT_setDriveDirection = 6, ALT_changeYawRate = 7, ALT_setStationType = 8, ALT_setVehicleRole = 9, ALT_setEmbarkationStatus = 10, ALT_setPtActivation = 11, ALT_setDangerousGoods = 12, ALT_setLightBarSirene = 13 };
private:
union_selection_type union_selection;
union {
INTEGER *field_changeCurvature;
INTEGER *field_changeSpeed;
BITSTRING *field_setAccelerationControlStatus;
BITSTRING *field_setExteriorLightsStatus;
INTEGER *field_changeHeading;
INTEGER *field_setDriveDirection;
INTEGER *field_changeYawRate;
INTEGER *field_setStationType;
INTEGER *field_setVehicleRole;
INTEGER *field_setEmbarkationStatus;
ExtPtActivation *field_setPtActivation;
INTEGER *field_setDangerousGoods;
INTEGER *field_setLightBarSirene;
};
void copy_value(const ExtUtCamTrigger& other_value);

public:
ExtUtCamTrigger();
ExtUtCamTrigger(const ExtUtCamTrigger& other_value);
~ExtUtCamTrigger();
ExtUtCamTrigger& operator=(const ExtUtCamTrigger& other_value);
boolean operator==(const ExtUtCamTrigger& other_value) const;
inline boolean operator!=(const ExtUtCamTrigger& other_value) const { return !(*this == other_value); }
INTEGER& changeCurvature();
const INTEGER& changeCurvature() const;
INTEGER& changeSpeed();
const INTEGER& changeSpeed() const;
BITSTRING& setAccelerationControlStatus();
const BITSTRING& setAccelerationControlStatus() const;
BITSTRING& setExteriorLightsStatus();
const BITSTRING& setExteriorLightsStatus() const;
INTEGER& changeHeading();
const INTEGER& changeHeading() const;
INTEGER& setDriveDirection();
const INTEGER& setDriveDirection() const;
INTEGER& changeYawRate();
const INTEGER& changeYawRate() const;
INTEGER& setStationType();
const INTEGER& setStationType() const;
INTEGER& setVehicleRole();
const INTEGER& setVehicleRole() const;
INTEGER& setEmbarkationStatus();
const INTEGER& setEmbarkationStatus() const;
ExtPtActivation& setPtActivation();
const ExtPtActivation& setPtActivation() const;
INTEGER& setDangerousGoods();
const INTEGER& setDangerousGoods() const;
INTEGER& setLightBarSirene();
const INTEGER& setLightBarSirene() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtUtCamTrigger_template : public Base_Template {
union {
struct {
ExtUtCamTrigger::union_selection_type union_selection;
union {
INTEGER_template *field_changeCurvature;
INTEGER_template *field_changeSpeed;
BITSTRING_template *field_setAccelerationControlStatus;
BITSTRING_template *field_setExteriorLightsStatus;
INTEGER_template *field_changeHeading;
INTEGER_template *field_setDriveDirection;
INTEGER_template *field_changeYawRate;
INTEGER_template *field_setStationType;
INTEGER_template *field_setVehicleRole;
INTEGER_template *field_setEmbarkationStatus;
ExtPtActivation_template *field_setPtActivation;
INTEGER_template *field_setDangerousGoods;
INTEGER_template *field_setLightBarSirene;
};
} single_value;
struct {
unsigned int n_values;
ExtUtCamTrigger_template *list_value;
} value_list;
};
void copy_value(const ExtUtCamTrigger& other_value);

void copy_template(const ExtUtCamTrigger_template& other_value);

public:
ExtUtCamTrigger_template();
ExtUtCamTrigger_template(template_sel other_value);
ExtUtCamTrigger_template(const ExtUtCamTrigger& other_value);
ExtUtCamTrigger_template(const OPTIONAL<ExtUtCamTrigger>& other_value);
ExtUtCamTrigger_template(const ExtUtCamTrigger_template& other_value);
~ExtUtCamTrigger_template();
void clean_up();
ExtUtCamTrigger_template& operator=(template_sel other_value);
ExtUtCamTrigger_template& operator=(const ExtUtCamTrigger& other_value);
ExtUtCamTrigger_template& operator=(const OPTIONAL<ExtUtCamTrigger>& other_value);
ExtUtCamTrigger_template& operator=(const ExtUtCamTrigger_template& other_value);
boolean match(const ExtUtCamTrigger& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ExtUtCamTrigger valueof() const;
ExtUtCamTrigger_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
INTEGER_template& changeCurvature();
const INTEGER_template& changeCurvature() const;
INTEGER_template& changeSpeed();
const INTEGER_template& changeSpeed() const;
BITSTRING_template& setAccelerationControlStatus();
const BITSTRING_template& setAccelerationControlStatus() const;
BITSTRING_template& setExteriorLightsStatus();
const BITSTRING_template& setExteriorLightsStatus() const;
INTEGER_template& changeHeading();
const INTEGER_template& changeHeading() const;
INTEGER_template& setDriveDirection();
const INTEGER_template& setDriveDirection() const;
INTEGER_template& changeYawRate();
const INTEGER_template& changeYawRate() const;
INTEGER_template& setStationType();
const INTEGER_template& setStationType() const;
INTEGER_template& setVehicleRole();
const INTEGER_template& setVehicleRole() const;
INTEGER_template& setEmbarkationStatus();
const INTEGER_template& setEmbarkationStatus() const;
ExtPtActivation_template& setPtActivation();
const ExtPtActivation_template& setPtActivation() const;
INTEGER_template& setDangerousGoods();
const INTEGER_template& setDangerousGoods() const;
INTEGER_template& setLightBarSirene();
const INTEGER_template& setLightBarSirene() const;
boolean ischosen(ExtUtCamTrigger::union_selection_type checked_selection) const;
void log() const;
void log_match(const ExtUtCamTrigger& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ExtUtCamEventInd : public Base_Type {
  INTEGER field_camPduLength;
  OCTETSTRING field_camMsg;
  boolean bound_flag;
public:
  ExtUtCamEventInd();
  ExtUtCamEventInd(const INTEGER& par_camPduLength,
    const OCTETSTRING& par_camMsg);
  ExtUtCamEventInd(const ExtUtCamEventInd& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtUtCamEventInd& operator=(const ExtUtCamEventInd& other_value);
  boolean operator==(const ExtUtCamEventInd& other_value) const;
  inline boolean operator!=(const ExtUtCamEventInd& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& camPduLength()
    {return field_camPduLength;}
  inline const INTEGER& camPduLength() const
    {return field_camPduLength;}
  inline OCTETSTRING& camMsg()
    {return field_camMsg;}
  inline const OCTETSTRING& camMsg() const
    {return field_camMsg;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtUtCamEventInd_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtUtCamEventInd_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtUtCamEventInd& other_value);
void copy_template(const ExtUtCamEventInd_template& other_value);

public:
ExtUtCamEventInd_template();
ExtUtCamEventInd_template(template_sel other_value);
ExtUtCamEventInd_template(const ExtUtCamEventInd& other_value);
ExtUtCamEventInd_template(const OPTIONAL<ExtUtCamEventInd>& other_value);
ExtUtCamEventInd_template(const ExtUtCamEventInd_template& other_value);
~ExtUtCamEventInd_template();
ExtUtCamEventInd_template& operator=(template_sel other_value);
ExtUtCamEventInd_template& operator=(const ExtUtCamEventInd& other_value);
ExtUtCamEventInd_template& operator=(const OPTIONAL<ExtUtCamEventInd>& other_value);
ExtUtCamEventInd_template& operator=(const ExtUtCamEventInd_template& other_value);
boolean match(const ExtUtCamEventInd& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtUtCamEventInd valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtUtCamEventInd_template& list_item(unsigned int list_index) const;
INTEGER_template& camPduLength();
const INTEGER_template& camPduLength() const;
OCTETSTRING_template& camMsg();
const OCTETSTRING_template& camMsg() const;
int size_of() const;
void log() const;
void log_match(const ExtUtCamEventInd& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtSituationContainer : public Base_Type {
  INTEGER field_informationQuality;
  INTEGER field_causeCode;
  INTEGER field_subCauseCode;
  boolean bound_flag;
public:
  ExtSituationContainer();
  ExtSituationContainer(const INTEGER& par_informationQuality,
    const INTEGER& par_causeCode,
    const INTEGER& par_subCauseCode);
  ExtSituationContainer(const ExtSituationContainer& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtSituationContainer& operator=(const ExtSituationContainer& other_value);
  boolean operator==(const ExtSituationContainer& other_value) const;
  inline boolean operator!=(const ExtSituationContainer& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& informationQuality()
    {return field_informationQuality;}
  inline const INTEGER& informationQuality() const
    {return field_informationQuality;}
  inline INTEGER& causeCode()
    {return field_causeCode;}
  inline const INTEGER& causeCode() const
    {return field_causeCode;}
  inline INTEGER& subCauseCode()
    {return field_subCauseCode;}
  inline const INTEGER& subCauseCode() const
    {return field_subCauseCode;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtSituationContainer_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtSituationContainer_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtSituationContainer& other_value);
void copy_template(const ExtSituationContainer_template& other_value);

public:
ExtSituationContainer_template();
ExtSituationContainer_template(template_sel other_value);
ExtSituationContainer_template(const ExtSituationContainer& other_value);
ExtSituationContainer_template(const OPTIONAL<ExtSituationContainer>& other_value);
ExtSituationContainer_template(const ExtSituationContainer_template& other_value);
~ExtSituationContainer_template();
ExtSituationContainer_template& operator=(template_sel other_value);
ExtSituationContainer_template& operator=(const ExtSituationContainer& other_value);
ExtSituationContainer_template& operator=(const OPTIONAL<ExtSituationContainer>& other_value);
ExtSituationContainer_template& operator=(const ExtSituationContainer_template& other_value);
boolean match(const ExtSituationContainer& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtSituationContainer valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtSituationContainer_template& list_item(unsigned int list_index) const;
INTEGER_template& informationQuality();
const INTEGER_template& informationQuality() const;
INTEGER_template& causeCode();
const INTEGER_template& causeCode() const;
INTEGER_template& subCauseCode();
const INTEGER_template& subCauseCode() const;
int size_of() const;
void log() const;
void log_match(const ExtSituationContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtAlacarteContainer : public Base_Type {
  INTEGER field_TODO;
  boolean bound_flag;
public:
  ExtAlacarteContainer();
  ExtAlacarteContainer(const INTEGER& par_TODO);
  ExtAlacarteContainer(const ExtAlacarteContainer& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtAlacarteContainer& operator=(const ExtAlacarteContainer& other_value);
  boolean operator==(const ExtAlacarteContainer& other_value) const;
  inline boolean operator!=(const ExtAlacarteContainer& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& TODO()
    {return field_TODO;}
  inline const INTEGER& TODO() const
    {return field_TODO;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtAlacarteContainer_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtAlacarteContainer_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtAlacarteContainer& other_value);
void copy_template(const ExtAlacarteContainer_template& other_value);

public:
ExtAlacarteContainer_template();
ExtAlacarteContainer_template(template_sel other_value);
ExtAlacarteContainer_template(const ExtAlacarteContainer& other_value);
ExtAlacarteContainer_template(const OPTIONAL<ExtAlacarteContainer>& other_value);
ExtAlacarteContainer_template(const ExtAlacarteContainer_template& other_value);
~ExtAlacarteContainer_template();
ExtAlacarteContainer_template& operator=(template_sel other_value);
ExtAlacarteContainer_template& operator=(const ExtAlacarteContainer& other_value);
ExtAlacarteContainer_template& operator=(const OPTIONAL<ExtAlacarteContainer>& other_value);
ExtAlacarteContainer_template& operator=(const ExtAlacarteContainer_template& other_value);
boolean match(const ExtAlacarteContainer& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtAlacarteContainer valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtAlacarteContainer_template& list_item(unsigned int list_index) const;
INTEGER_template& TODO();
const INTEGER_template& TODO() const;
int size_of() const;
void log() const;
void log_match(const ExtAlacarteContainer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtUtDenmTrigger : public Base_Type {
  INTEGER field_bitmask;
  INTEGER field_detectionTime;
  OPTIONAL<INTEGER> field_validityDuration;
  OPTIONAL<INTEGER> field_repetitionDuration;
  ExtSituationContainer field_situation;
  INTEGER field_relevanceDistance;
  INTEGER field_relevanceTrafficDirection;
  OPTIONAL<INTEGER> field_transmissionInterval;
  OPTIONAL<INTEGER> field_repetitionInterval;
  OPTIONAL<INTEGER> field_alacarteLength;
  OPTIONAL<ExtAlacarteContainer> field_alacarte;
  boolean bound_flag;
public:
  ExtUtDenmTrigger();
  ExtUtDenmTrigger(const INTEGER& par_bitmask,
    const INTEGER& par_detectionTime,
    const OPTIONAL<INTEGER>& par_validityDuration,
    const OPTIONAL<INTEGER>& par_repetitionDuration,
    const ExtSituationContainer& par_situation,
    const INTEGER& par_relevanceDistance,
    const INTEGER& par_relevanceTrafficDirection,
    const OPTIONAL<INTEGER>& par_transmissionInterval,
    const OPTIONAL<INTEGER>& par_repetitionInterval,
    const OPTIONAL<INTEGER>& par_alacarteLength,
    const OPTIONAL<ExtAlacarteContainer>& par_alacarte);
  ExtUtDenmTrigger(const ExtUtDenmTrigger& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtUtDenmTrigger& operator=(const ExtUtDenmTrigger& other_value);
  boolean operator==(const ExtUtDenmTrigger& other_value) const;
  inline boolean operator!=(const ExtUtDenmTrigger& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& bitmask()
    {return field_bitmask;}
  inline const INTEGER& bitmask() const
    {return field_bitmask;}
  inline INTEGER& detectionTime()
    {return field_detectionTime;}
  inline const INTEGER& detectionTime() const
    {return field_detectionTime;}
  inline OPTIONAL<INTEGER>& validityDuration()
    {return field_validityDuration;}
  inline const OPTIONAL<INTEGER>& validityDuration() const
    {return field_validityDuration;}
  inline OPTIONAL<INTEGER>& repetitionDuration()
    {return field_repetitionDuration;}
  inline const OPTIONAL<INTEGER>& repetitionDuration() const
    {return field_repetitionDuration;}
  inline ExtSituationContainer& situation()
    {return field_situation;}
  inline const ExtSituationContainer& situation() const
    {return field_situation;}
  inline INTEGER& relevanceDistance()
    {return field_relevanceDistance;}
  inline const INTEGER& relevanceDistance() const
    {return field_relevanceDistance;}
  inline INTEGER& relevanceTrafficDirection()
    {return field_relevanceTrafficDirection;}
  inline const INTEGER& relevanceTrafficDirection() const
    {return field_relevanceTrafficDirection;}
  inline OPTIONAL<INTEGER>& transmissionInterval()
    {return field_transmissionInterval;}
  inline const OPTIONAL<INTEGER>& transmissionInterval() const
    {return field_transmissionInterval;}
  inline OPTIONAL<INTEGER>& repetitionInterval()
    {return field_repetitionInterval;}
  inline const OPTIONAL<INTEGER>& repetitionInterval() const
    {return field_repetitionInterval;}
  inline OPTIONAL<INTEGER>& alacarteLength()
    {return field_alacarteLength;}
  inline const OPTIONAL<INTEGER>& alacarteLength() const
    {return field_alacarteLength;}
  inline OPTIONAL<ExtAlacarteContainer>& alacarte()
    {return field_alacarte;}
  inline const OPTIONAL<ExtAlacarteContainer>& alacarte() const
    {return field_alacarte;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtUtDenmTrigger_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtUtDenmTrigger_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtUtDenmTrigger& other_value);
void copy_template(const ExtUtDenmTrigger_template& other_value);

public:
ExtUtDenmTrigger_template();
ExtUtDenmTrigger_template(template_sel other_value);
ExtUtDenmTrigger_template(const ExtUtDenmTrigger& other_value);
ExtUtDenmTrigger_template(const OPTIONAL<ExtUtDenmTrigger>& other_value);
ExtUtDenmTrigger_template(const ExtUtDenmTrigger_template& other_value);
~ExtUtDenmTrigger_template();
ExtUtDenmTrigger_template& operator=(template_sel other_value);
ExtUtDenmTrigger_template& operator=(const ExtUtDenmTrigger& other_value);
ExtUtDenmTrigger_template& operator=(const OPTIONAL<ExtUtDenmTrigger>& other_value);
ExtUtDenmTrigger_template& operator=(const ExtUtDenmTrigger_template& other_value);
boolean match(const ExtUtDenmTrigger& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtUtDenmTrigger valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtUtDenmTrigger_template& list_item(unsigned int list_index) const;
INTEGER_template& bitmask();
const INTEGER_template& bitmask() const;
INTEGER_template& detectionTime();
const INTEGER_template& detectionTime() const;
INTEGER_template& validityDuration();
const INTEGER_template& validityDuration() const;
INTEGER_template& repetitionDuration();
const INTEGER_template& repetitionDuration() const;
ExtSituationContainer_template& situation();
const ExtSituationContainer_template& situation() const;
INTEGER_template& relevanceDistance();
const INTEGER_template& relevanceDistance() const;
INTEGER_template& relevanceTrafficDirection();
const INTEGER_template& relevanceTrafficDirection() const;
INTEGER_template& transmissionInterval();
const INTEGER_template& transmissionInterval() const;
INTEGER_template& repetitionInterval();
const INTEGER_template& repetitionInterval() const;
INTEGER_template& alacarteLength();
const INTEGER_template& alacarteLength() const;
ExtAlacarteContainer_template& alacarte();
const ExtAlacarteContainer_template& alacarte() const;
int size_of() const;
void log() const;
void log_match(const ExtUtDenmTrigger& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtActionID : public Base_Type {
  INTEGER field_originatingStationID;
  INTEGER field_sequenceNumber;
  boolean bound_flag;
public:
  ExtActionID();
  ExtActionID(const INTEGER& par_originatingStationID,
    const INTEGER& par_sequenceNumber);
  ExtActionID(const ExtActionID& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtActionID& operator=(const ExtActionID& other_value);
  boolean operator==(const ExtActionID& other_value) const;
  inline boolean operator!=(const ExtActionID& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& originatingStationID()
    {return field_originatingStationID;}
  inline const INTEGER& originatingStationID() const
    {return field_originatingStationID;}
  inline INTEGER& sequenceNumber()
    {return field_sequenceNumber;}
  inline const INTEGER& sequenceNumber() const
    {return field_sequenceNumber;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtActionID_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtActionID_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtActionID& other_value);
void copy_template(const ExtActionID_template& other_value);

public:
ExtActionID_template();
ExtActionID_template(template_sel other_value);
ExtActionID_template(const ExtActionID& other_value);
ExtActionID_template(const OPTIONAL<ExtActionID>& other_value);
ExtActionID_template(const ExtActionID_template& other_value);
~ExtActionID_template();
ExtActionID_template& operator=(template_sel other_value);
ExtActionID_template& operator=(const ExtActionID& other_value);
ExtActionID_template& operator=(const OPTIONAL<ExtActionID>& other_value);
ExtActionID_template& operator=(const ExtActionID_template& other_value);
boolean match(const ExtActionID& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtActionID valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtActionID_template& list_item(unsigned int list_index) const;
INTEGER_template& originatingStationID();
const INTEGER_template& originatingStationID() const;
INTEGER_template& sequenceNumber();
const INTEGER_template& sequenceNumber() const;
int size_of() const;
void log() const;
void log_match(const ExtActionID& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtUtDenmUpdate : public Base_Type {
  INTEGER field_bitmask;
  ExtActionID field_actionID;
  INTEGER field_detectionTime;
  OPTIONAL<INTEGER> field_validityDuration;
  OPTIONAL<ExtSituationContainer> field_situation;
  OPTIONAL<INTEGER> field_relevanceDistance;
  OPTIONAL<INTEGER> field_relevanceTrafficDirection;
  OPTIONAL<INTEGER> field_transmissionInterval;
  OPTIONAL<INTEGER> field_repetitionInterval;
  OPTIONAL<INTEGER> field_alacarteLength;
  OPTIONAL<ExtAlacarteContainer> field_alacarte;
  boolean bound_flag;
public:
  ExtUtDenmUpdate();
  ExtUtDenmUpdate(const INTEGER& par_bitmask,
    const ExtActionID& par_actionID,
    const INTEGER& par_detectionTime,
    const OPTIONAL<INTEGER>& par_validityDuration,
    const OPTIONAL<ExtSituationContainer>& par_situation,
    const OPTIONAL<INTEGER>& par_relevanceDistance,
    const OPTIONAL<INTEGER>& par_relevanceTrafficDirection,
    const OPTIONAL<INTEGER>& par_transmissionInterval,
    const OPTIONAL<INTEGER>& par_repetitionInterval,
    const OPTIONAL<INTEGER>& par_alacarteLength,
    const OPTIONAL<ExtAlacarteContainer>& par_alacarte);
  ExtUtDenmUpdate(const ExtUtDenmUpdate& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtUtDenmUpdate& operator=(const ExtUtDenmUpdate& other_value);
  boolean operator==(const ExtUtDenmUpdate& other_value) const;
  inline boolean operator!=(const ExtUtDenmUpdate& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& bitmask()
    {return field_bitmask;}
  inline const INTEGER& bitmask() const
    {return field_bitmask;}
  inline ExtActionID& actionID()
    {return field_actionID;}
  inline const ExtActionID& actionID() const
    {return field_actionID;}
  inline INTEGER& detectionTime()
    {return field_detectionTime;}
  inline const INTEGER& detectionTime() const
    {return field_detectionTime;}
  inline OPTIONAL<INTEGER>& validityDuration()
    {return field_validityDuration;}
  inline const OPTIONAL<INTEGER>& validityDuration() const
    {return field_validityDuration;}
  inline OPTIONAL<ExtSituationContainer>& situation()
    {return field_situation;}
  inline const OPTIONAL<ExtSituationContainer>& situation() const
    {return field_situation;}
  inline OPTIONAL<INTEGER>& relevanceDistance()
    {return field_relevanceDistance;}
  inline const OPTIONAL<INTEGER>& relevanceDistance() const
    {return field_relevanceDistance;}
  inline OPTIONAL<INTEGER>& relevanceTrafficDirection()
    {return field_relevanceTrafficDirection;}
  inline const OPTIONAL<INTEGER>& relevanceTrafficDirection() const
    {return field_relevanceTrafficDirection;}
  inline OPTIONAL<INTEGER>& transmissionInterval()
    {return field_transmissionInterval;}
  inline const OPTIONAL<INTEGER>& transmissionInterval() const
    {return field_transmissionInterval;}
  inline OPTIONAL<INTEGER>& repetitionInterval()
    {return field_repetitionInterval;}
  inline const OPTIONAL<INTEGER>& repetitionInterval() const
    {return field_repetitionInterval;}
  inline OPTIONAL<INTEGER>& alacarteLength()
    {return field_alacarteLength;}
  inline const OPTIONAL<INTEGER>& alacarteLength() const
    {return field_alacarteLength;}
  inline OPTIONAL<ExtAlacarteContainer>& alacarte()
    {return field_alacarte;}
  inline const OPTIONAL<ExtAlacarteContainer>& alacarte() const
    {return field_alacarte;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtUtDenmUpdate_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtUtDenmUpdate_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtUtDenmUpdate& other_value);
void copy_template(const ExtUtDenmUpdate_template& other_value);

public:
ExtUtDenmUpdate_template();
ExtUtDenmUpdate_template(template_sel other_value);
ExtUtDenmUpdate_template(const ExtUtDenmUpdate& other_value);
ExtUtDenmUpdate_template(const OPTIONAL<ExtUtDenmUpdate>& other_value);
ExtUtDenmUpdate_template(const ExtUtDenmUpdate_template& other_value);
~ExtUtDenmUpdate_template();
ExtUtDenmUpdate_template& operator=(template_sel other_value);
ExtUtDenmUpdate_template& operator=(const ExtUtDenmUpdate& other_value);
ExtUtDenmUpdate_template& operator=(const OPTIONAL<ExtUtDenmUpdate>& other_value);
ExtUtDenmUpdate_template& operator=(const ExtUtDenmUpdate_template& other_value);
boolean match(const ExtUtDenmUpdate& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtUtDenmUpdate valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtUtDenmUpdate_template& list_item(unsigned int list_index) const;
INTEGER_template& bitmask();
const INTEGER_template& bitmask() const;
ExtActionID_template& actionID();
const ExtActionID_template& actionID() const;
INTEGER_template& detectionTime();
const INTEGER_template& detectionTime() const;
INTEGER_template& validityDuration();
const INTEGER_template& validityDuration() const;
ExtSituationContainer_template& situation();
const ExtSituationContainer_template& situation() const;
INTEGER_template& relevanceDistance();
const INTEGER_template& relevanceDistance() const;
INTEGER_template& relevanceTrafficDirection();
const INTEGER_template& relevanceTrafficDirection() const;
INTEGER_template& transmissionInterval();
const INTEGER_template& transmissionInterval() const;
INTEGER_template& repetitionInterval();
const INTEGER_template& repetitionInterval() const;
INTEGER_template& alacarteLength();
const INTEGER_template& alacarteLength() const;
ExtAlacarteContainer_template& alacarte();
const ExtAlacarteContainer_template& alacarte() const;
int size_of() const;
void log() const;
void log_match(const ExtUtDenmUpdate& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtDenmInd : public Base_Type {
  INTEGER field_gnNextHeader;
  INTEGER field_gnHeaderType;
  INTEGER field_gnHeaderSubtype;
  INTEGER field_gnLifetime;
  INTEGER field_gnTrafficClass;
  INTEGER field_btpDestinationPort;
  INTEGER field_btpInfo;
  boolean bound_flag;
public:
  ExtDenmInd();
  ExtDenmInd(const INTEGER& par_gnNextHeader,
    const INTEGER& par_gnHeaderType,
    const INTEGER& par_gnHeaderSubtype,
    const INTEGER& par_gnLifetime,
    const INTEGER& par_gnTrafficClass,
    const INTEGER& par_btpDestinationPort,
    const INTEGER& par_btpInfo);
  ExtDenmInd(const ExtDenmInd& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtDenmInd& operator=(const ExtDenmInd& other_value);
  boolean operator==(const ExtDenmInd& other_value) const;
  inline boolean operator!=(const ExtDenmInd& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& gnNextHeader()
    {return field_gnNextHeader;}
  inline const INTEGER& gnNextHeader() const
    {return field_gnNextHeader;}
  inline INTEGER& gnHeaderType()
    {return field_gnHeaderType;}
  inline const INTEGER& gnHeaderType() const
    {return field_gnHeaderType;}
  inline INTEGER& gnHeaderSubtype()
    {return field_gnHeaderSubtype;}
  inline const INTEGER& gnHeaderSubtype() const
    {return field_gnHeaderSubtype;}
  inline INTEGER& gnLifetime()
    {return field_gnLifetime;}
  inline const INTEGER& gnLifetime() const
    {return field_gnLifetime;}
  inline INTEGER& gnTrafficClass()
    {return field_gnTrafficClass;}
  inline const INTEGER& gnTrafficClass() const
    {return field_gnTrafficClass;}
  inline INTEGER& btpDestinationPort()
    {return field_btpDestinationPort;}
  inline const INTEGER& btpDestinationPort() const
    {return field_btpDestinationPort;}
  inline INTEGER& btpInfo()
    {return field_btpInfo;}
  inline const INTEGER& btpInfo() const
    {return field_btpInfo;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtDenmInd_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtDenmInd_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtDenmInd& other_value);
void copy_template(const ExtDenmInd_template& other_value);

public:
ExtDenmInd_template();
ExtDenmInd_template(template_sel other_value);
ExtDenmInd_template(const ExtDenmInd& other_value);
ExtDenmInd_template(const OPTIONAL<ExtDenmInd>& other_value);
ExtDenmInd_template(const ExtDenmInd_template& other_value);
~ExtDenmInd_template();
ExtDenmInd_template& operator=(template_sel other_value);
ExtDenmInd_template& operator=(const ExtDenmInd& other_value);
ExtDenmInd_template& operator=(const OPTIONAL<ExtDenmInd>& other_value);
ExtDenmInd_template& operator=(const ExtDenmInd_template& other_value);
boolean match(const ExtDenmInd& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtDenmInd valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtDenmInd_template& list_item(unsigned int list_index) const;
INTEGER_template& gnNextHeader();
const INTEGER_template& gnNextHeader() const;
INTEGER_template& gnHeaderType();
const INTEGER_template& gnHeaderType() const;
INTEGER_template& gnHeaderSubtype();
const INTEGER_template& gnHeaderSubtype() const;
INTEGER_template& gnLifetime();
const INTEGER_template& gnLifetime() const;
INTEGER_template& gnTrafficClass();
const INTEGER_template& gnTrafficClass() const;
INTEGER_template& btpDestinationPort();
const INTEGER_template& btpDestinationPort() const;
INTEGER_template& btpInfo();
const INTEGER_template& btpInfo() const;
int size_of() const;
void log() const;
void log_match(const ExtDenmInd& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtUtDenmEventInd : public Base_Type {
  INTEGER field_denmPduLength;
  OCTETSTRING field_denMsg;
  boolean bound_flag;
public:
  ExtUtDenmEventInd();
  ExtUtDenmEventInd(const INTEGER& par_denmPduLength,
    const OCTETSTRING& par_denMsg);
  ExtUtDenmEventInd(const ExtUtDenmEventInd& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtUtDenmEventInd& operator=(const ExtUtDenmEventInd& other_value);
  boolean operator==(const ExtUtDenmEventInd& other_value) const;
  inline boolean operator!=(const ExtUtDenmEventInd& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& denmPduLength()
    {return field_denmPduLength;}
  inline const INTEGER& denmPduLength() const
    {return field_denmPduLength;}
  inline OCTETSTRING& denMsg()
    {return field_denMsg;}
  inline const OCTETSTRING& denMsg() const
    {return field_denMsg;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtUtDenmEventInd_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtUtDenmEventInd_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtUtDenmEventInd& other_value);
void copy_template(const ExtUtDenmEventInd_template& other_value);

public:
ExtUtDenmEventInd_template();
ExtUtDenmEventInd_template(template_sel other_value);
ExtUtDenmEventInd_template(const ExtUtDenmEventInd& other_value);
ExtUtDenmEventInd_template(const OPTIONAL<ExtUtDenmEventInd>& other_value);
ExtUtDenmEventInd_template(const ExtUtDenmEventInd_template& other_value);
~ExtUtDenmEventInd_template();
ExtUtDenmEventInd_template& operator=(template_sel other_value);
ExtUtDenmEventInd_template& operator=(const ExtUtDenmEventInd& other_value);
ExtUtDenmEventInd_template& operator=(const OPTIONAL<ExtUtDenmEventInd>& other_value);
ExtUtDenmEventInd_template& operator=(const ExtUtDenmEventInd_template& other_value);
boolean match(const ExtUtDenmEventInd& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtUtDenmEventInd valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtUtDenmEventInd_template& list_item(unsigned int list_index) const;
INTEGER_template& denmPduLength();
const INTEGER_template& denmPduLength() const;
OCTETSTRING_template& denMsg();
const OCTETSTRING_template& denMsg() const;
int size_of() const;
void log() const;
void log_match(const ExtUtDenmEventInd& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtUtMapEventInd : public Base_Type {
  INTEGER field_mapPduLength;
  OCTETSTRING field_mapMsg;
  boolean bound_flag;
public:
  ExtUtMapEventInd();
  ExtUtMapEventInd(const INTEGER& par_mapPduLength,
    const OCTETSTRING& par_mapMsg);
  ExtUtMapEventInd(const ExtUtMapEventInd& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtUtMapEventInd& operator=(const ExtUtMapEventInd& other_value);
  boolean operator==(const ExtUtMapEventInd& other_value) const;
  inline boolean operator!=(const ExtUtMapEventInd& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& mapPduLength()
    {return field_mapPduLength;}
  inline const INTEGER& mapPduLength() const
    {return field_mapPduLength;}
  inline OCTETSTRING& mapMsg()
    {return field_mapMsg;}
  inline const OCTETSTRING& mapMsg() const
    {return field_mapMsg;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtUtMapEventInd_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtUtMapEventInd_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtUtMapEventInd& other_value);
void copy_template(const ExtUtMapEventInd_template& other_value);

public:
ExtUtMapEventInd_template();
ExtUtMapEventInd_template(template_sel other_value);
ExtUtMapEventInd_template(const ExtUtMapEventInd& other_value);
ExtUtMapEventInd_template(const OPTIONAL<ExtUtMapEventInd>& other_value);
ExtUtMapEventInd_template(const ExtUtMapEventInd_template& other_value);
~ExtUtMapEventInd_template();
ExtUtMapEventInd_template& operator=(template_sel other_value);
ExtUtMapEventInd_template& operator=(const ExtUtMapEventInd& other_value);
ExtUtMapEventInd_template& operator=(const OPTIONAL<ExtUtMapEventInd>& other_value);
ExtUtMapEventInd_template& operator=(const ExtUtMapEventInd_template& other_value);
boolean match(const ExtUtMapEventInd& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtUtMapEventInd valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtUtMapEventInd_template& list_item(unsigned int list_index) const;
INTEGER_template& mapPduLength();
const INTEGER_template& mapPduLength() const;
OCTETSTRING_template& mapMsg();
const OCTETSTRING_template& mapMsg() const;
int size_of() const;
void log() const;
void log_match(const ExtUtMapEventInd& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtUtSpatEventInd : public Base_Type {
  INTEGER field_spatPduLength;
  OCTETSTRING field_spatMsg;
  boolean bound_flag;
public:
  ExtUtSpatEventInd();
  ExtUtSpatEventInd(const INTEGER& par_spatPduLength,
    const OCTETSTRING& par_spatMsg);
  ExtUtSpatEventInd(const ExtUtSpatEventInd& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtUtSpatEventInd& operator=(const ExtUtSpatEventInd& other_value);
  boolean operator==(const ExtUtSpatEventInd& other_value) const;
  inline boolean operator!=(const ExtUtSpatEventInd& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& spatPduLength()
    {return field_spatPduLength;}
  inline const INTEGER& spatPduLength() const
    {return field_spatPduLength;}
  inline OCTETSTRING& spatMsg()
    {return field_spatMsg;}
  inline const OCTETSTRING& spatMsg() const
    {return field_spatMsg;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtUtSpatEventInd_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtUtSpatEventInd_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtUtSpatEventInd& other_value);
void copy_template(const ExtUtSpatEventInd_template& other_value);

public:
ExtUtSpatEventInd_template();
ExtUtSpatEventInd_template(template_sel other_value);
ExtUtSpatEventInd_template(const ExtUtSpatEventInd& other_value);
ExtUtSpatEventInd_template(const OPTIONAL<ExtUtSpatEventInd>& other_value);
ExtUtSpatEventInd_template(const ExtUtSpatEventInd_template& other_value);
~ExtUtSpatEventInd_template();
ExtUtSpatEventInd_template& operator=(template_sel other_value);
ExtUtSpatEventInd_template& operator=(const ExtUtSpatEventInd& other_value);
ExtUtSpatEventInd_template& operator=(const OPTIONAL<ExtUtSpatEventInd>& other_value);
ExtUtSpatEventInd_template& operator=(const ExtUtSpatEventInd_template& other_value);
boolean match(const ExtUtSpatEventInd& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtUtSpatEventInd valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtUtSpatEventInd_template& list_item(unsigned int list_index) const;
INTEGER_template& spatPduLength();
const INTEGER_template& spatPduLength() const;
OCTETSTRING_template& spatMsg();
const OCTETSTRING_template& spatMsg() const;
int size_of() const;
void log() const;
void log_match(const ExtUtSpatEventInd& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtBtpPayload : public Base_Type {
  OCTETSTRING field_rawPayload;
  boolean bound_flag;
public:
  ExtBtpPayload();
  ExtBtpPayload(const OCTETSTRING& par_rawPayload);
  ExtBtpPayload(const ExtBtpPayload& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtBtpPayload& operator=(const ExtBtpPayload& other_value);
  boolean operator==(const ExtBtpPayload& other_value) const;
  inline boolean operator!=(const ExtBtpPayload& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& rawPayload()
    {return field_rawPayload;}
  inline const OCTETSTRING& rawPayload() const
    {return field_rawPayload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtBtpPayload_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtBtpPayload_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtBtpPayload& other_value);
void copy_template(const ExtBtpPayload_template& other_value);

public:
ExtBtpPayload_template();
ExtBtpPayload_template(template_sel other_value);
ExtBtpPayload_template(const ExtBtpPayload& other_value);
ExtBtpPayload_template(const OPTIONAL<ExtBtpPayload>& other_value);
ExtBtpPayload_template(const ExtBtpPayload_template& other_value);
~ExtBtpPayload_template();
ExtBtpPayload_template& operator=(template_sel other_value);
ExtBtpPayload_template& operator=(const ExtBtpPayload& other_value);
ExtBtpPayload_template& operator=(const OPTIONAL<ExtBtpPayload>& other_value);
ExtBtpPayload_template& operator=(const ExtBtpPayload_template& other_value);
boolean match(const ExtBtpPayload& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtBtpPayload valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtBtpPayload_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& rawPayload();
const OCTETSTRING_template& rawPayload() const;
int size_of() const;
void log() const;
void log_match(const ExtBtpPayload& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtBtpReq : public Base_Type {
  OCTETSTRING field_nextheader;
  LibItsBtp__TypesAndValues::BtpHeader field_header;
  OPTIONAL<ExtBtpPayload> field_payload;
  boolean bound_flag;
public:
  ExtBtpReq();
  ExtBtpReq(const OCTETSTRING& par_nextheader,
    const LibItsBtp__TypesAndValues::BtpHeader& par_header,
    const OPTIONAL<ExtBtpPayload>& par_payload);
  ExtBtpReq(const ExtBtpReq& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtBtpReq& operator=(const ExtBtpReq& other_value);
  boolean operator==(const ExtBtpReq& other_value) const;
  inline boolean operator!=(const ExtBtpReq& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& nextheader()
    {return field_nextheader;}
  inline const OCTETSTRING& nextheader() const
    {return field_nextheader;}
  inline LibItsBtp__TypesAndValues::BtpHeader& header()
    {return field_header;}
  inline const LibItsBtp__TypesAndValues::BtpHeader& header() const
    {return field_header;}
  inline OPTIONAL<ExtBtpPayload>& payload()
    {return field_payload;}
  inline const OPTIONAL<ExtBtpPayload>& payload() const
    {return field_payload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtBtpReq_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtBtpReq_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtBtpReq& other_value);
void copy_template(const ExtBtpReq_template& other_value);

public:
ExtBtpReq_template();
ExtBtpReq_template(template_sel other_value);
ExtBtpReq_template(const ExtBtpReq& other_value);
ExtBtpReq_template(const OPTIONAL<ExtBtpReq>& other_value);
ExtBtpReq_template(const ExtBtpReq_template& other_value);
~ExtBtpReq_template();
ExtBtpReq_template& operator=(template_sel other_value);
ExtBtpReq_template& operator=(const ExtBtpReq& other_value);
ExtBtpReq_template& operator=(const OPTIONAL<ExtBtpReq>& other_value);
ExtBtpReq_template& operator=(const ExtBtpReq_template& other_value);
boolean match(const ExtBtpReq& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtBtpReq valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtBtpReq_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& nextheader();
const OCTETSTRING_template& nextheader() const;
LibItsBtp__TypesAndValues::BtpHeader_template& header();
const LibItsBtp__TypesAndValues::BtpHeader_template& header() const;
ExtBtpPayload_template& payload();
const ExtBtpPayload_template& payload() const;
int size_of() const;
void log() const;
void log_match(const ExtBtpReq& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtBtpInd : public Base_Type {
  OCTETSTRING field_nextheader;
  LibItsBtp__TypesAndValues::BtpHeader field_header;
  OPTIONAL<OCTETSTRING> field_rawPayload;
  boolean bound_flag;
public:
  ExtBtpInd();
  ExtBtpInd(const OCTETSTRING& par_nextheader,
    const LibItsBtp__TypesAndValues::BtpHeader& par_header,
    const OPTIONAL<OCTETSTRING>& par_rawPayload);
  ExtBtpInd(const ExtBtpInd& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtBtpInd& operator=(const ExtBtpInd& other_value);
  boolean operator==(const ExtBtpInd& other_value) const;
  inline boolean operator!=(const ExtBtpInd& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& nextheader()
    {return field_nextheader;}
  inline const OCTETSTRING& nextheader() const
    {return field_nextheader;}
  inline LibItsBtp__TypesAndValues::BtpHeader& header()
    {return field_header;}
  inline const LibItsBtp__TypesAndValues::BtpHeader& header() const
    {return field_header;}
  inline OPTIONAL<OCTETSTRING>& rawPayload()
    {return field_rawPayload;}
  inline const OPTIONAL<OCTETSTRING>& rawPayload() const
    {return field_rawPayload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtBtpInd_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtBtpInd_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtBtpInd& other_value);
void copy_template(const ExtBtpInd_template& other_value);

public:
ExtBtpInd_template();
ExtBtpInd_template(template_sel other_value);
ExtBtpInd_template(const ExtBtpInd& other_value);
ExtBtpInd_template(const OPTIONAL<ExtBtpInd>& other_value);
ExtBtpInd_template(const ExtBtpInd_template& other_value);
~ExtBtpInd_template();
ExtBtpInd_template& operator=(template_sel other_value);
ExtBtpInd_template& operator=(const ExtBtpInd& other_value);
ExtBtpInd_template& operator=(const OPTIONAL<ExtBtpInd>& other_value);
ExtBtpInd_template& operator=(const ExtBtpInd_template& other_value);
boolean match(const ExtBtpInd& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtBtpInd valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtBtpInd_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& nextheader();
const OCTETSTRING_template& nextheader() const;
LibItsBtp__TypesAndValues::BtpHeader_template& header();
const LibItsBtp__TypesAndValues::BtpHeader_template& header() const;
OCTETSTRING_template& rawPayload();
const OCTETSTRING_template& rawPayload() const;
int size_of() const;
void log() const;
void log_match(const ExtBtpInd& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtCamInd : public Base_Type {
  INTEGER field_gnNextHeader;
  INTEGER field_gnHeaderType;
  INTEGER field_gnHeaderSubtype;
  INTEGER field_gnLifetime;
  INTEGER field_gnTrafficClass;
  INTEGER field_btpDestinationPort;
  INTEGER field_btpInfo;
  boolean bound_flag;
public:
  ExtCamInd();
  ExtCamInd(const INTEGER& par_gnNextHeader,
    const INTEGER& par_gnHeaderType,
    const INTEGER& par_gnHeaderSubtype,
    const INTEGER& par_gnLifetime,
    const INTEGER& par_gnTrafficClass,
    const INTEGER& par_btpDestinationPort,
    const INTEGER& par_btpInfo);
  ExtCamInd(const ExtCamInd& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtCamInd& operator=(const ExtCamInd& other_value);
  boolean operator==(const ExtCamInd& other_value) const;
  inline boolean operator!=(const ExtCamInd& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& gnNextHeader()
    {return field_gnNextHeader;}
  inline const INTEGER& gnNextHeader() const
    {return field_gnNextHeader;}
  inline INTEGER& gnHeaderType()
    {return field_gnHeaderType;}
  inline const INTEGER& gnHeaderType() const
    {return field_gnHeaderType;}
  inline INTEGER& gnHeaderSubtype()
    {return field_gnHeaderSubtype;}
  inline const INTEGER& gnHeaderSubtype() const
    {return field_gnHeaderSubtype;}
  inline INTEGER& gnLifetime()
    {return field_gnLifetime;}
  inline const INTEGER& gnLifetime() const
    {return field_gnLifetime;}
  inline INTEGER& gnTrafficClass()
    {return field_gnTrafficClass;}
  inline const INTEGER& gnTrafficClass() const
    {return field_gnTrafficClass;}
  inline INTEGER& btpDestinationPort()
    {return field_btpDestinationPort;}
  inline const INTEGER& btpDestinationPort() const
    {return field_btpDestinationPort;}
  inline INTEGER& btpInfo()
    {return field_btpInfo;}
  inline const INTEGER& btpInfo() const
    {return field_btpInfo;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtCamInd_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtCamInd_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtCamInd& other_value);
void copy_template(const ExtCamInd_template& other_value);

public:
ExtCamInd_template();
ExtCamInd_template(template_sel other_value);
ExtCamInd_template(const ExtCamInd& other_value);
ExtCamInd_template(const OPTIONAL<ExtCamInd>& other_value);
ExtCamInd_template(const ExtCamInd_template& other_value);
~ExtCamInd_template();
ExtCamInd_template& operator=(template_sel other_value);
ExtCamInd_template& operator=(const ExtCamInd& other_value);
ExtCamInd_template& operator=(const OPTIONAL<ExtCamInd>& other_value);
ExtCamInd_template& operator=(const ExtCamInd_template& other_value);
boolean match(const ExtCamInd& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtCamInd valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtCamInd_template& list_item(unsigned int list_index) const;
INTEGER_template& gnNextHeader();
const INTEGER_template& gnNextHeader() const;
INTEGER_template& gnHeaderType();
const INTEGER_template& gnHeaderType() const;
INTEGER_template& gnHeaderSubtype();
const INTEGER_template& gnHeaderSubtype() const;
INTEGER_template& gnLifetime();
const INTEGER_template& gnLifetime() const;
INTEGER_template& gnTrafficClass();
const INTEGER_template& gnTrafficClass() const;
INTEGER_template& btpDestinationPort();
const INTEGER_template& btpDestinationPort() const;
INTEGER_template& btpInfo();
const INTEGER_template& btpInfo() const;
int size_of() const;
void log() const;
void log_match(const ExtCamInd& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MapSpatInd : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_mapInd = 1, ALT_spatInd = 2 };
private:
union_selection_type union_selection;
union {
LibItsMapSpat__TestSystem::MapInd *field_mapInd;
LibItsMapSpat__TestSystem::SpatInd *field_spatInd;
};
void copy_value(const MapSpatInd& other_value);

public:
MapSpatInd();
MapSpatInd(const MapSpatInd& other_value);
~MapSpatInd();
MapSpatInd& operator=(const MapSpatInd& other_value);
boolean operator==(const MapSpatInd& other_value) const;
inline boolean operator!=(const MapSpatInd& other_value) const { return !(*this == other_value); }
LibItsMapSpat__TestSystem::MapInd& mapInd();
const LibItsMapSpat__TestSystem::MapInd& mapInd() const;
LibItsMapSpat__TestSystem::SpatInd& spatInd();
const LibItsMapSpat__TestSystem::SpatInd& spatInd() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class MapSpatInd_template : public Base_Template {
union {
struct {
MapSpatInd::union_selection_type union_selection;
union {
LibItsMapSpat__TestSystem::MapInd_template *field_mapInd;
LibItsMapSpat__TestSystem::SpatInd_template *field_spatInd;
};
} single_value;
struct {
unsigned int n_values;
MapSpatInd_template *list_value;
} value_list;
};
void copy_value(const MapSpatInd& other_value);

void copy_template(const MapSpatInd_template& other_value);

public:
MapSpatInd_template();
MapSpatInd_template(template_sel other_value);
MapSpatInd_template(const MapSpatInd& other_value);
MapSpatInd_template(const OPTIONAL<MapSpatInd>& other_value);
MapSpatInd_template(const MapSpatInd_template& other_value);
~MapSpatInd_template();
void clean_up();
MapSpatInd_template& operator=(template_sel other_value);
MapSpatInd_template& operator=(const MapSpatInd& other_value);
MapSpatInd_template& operator=(const OPTIONAL<MapSpatInd>& other_value);
MapSpatInd_template& operator=(const MapSpatInd_template& other_value);
boolean match(const MapSpatInd& other_value, boolean legacy = FALSE) const;
boolean is_value() const;MapSpatInd valueof() const;
MapSpatInd_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
LibItsMapSpat__TestSystem::MapInd_template& mapInd();
const LibItsMapSpat__TestSystem::MapInd_template& mapInd() const;
LibItsMapSpat__TestSystem::SpatInd_template& spatInd();
const LibItsMapSpat__TestSystem::SpatInd_template& spatInd() const;
boolean ischosen(MapSpatInd::union_selection_type checked_selection) const;
void log() const;
void log_match(const MapSpatInd& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ExtMapSpatInd : public Base_Type {
  INTEGER field_gnNextHeader;
  INTEGER field_gnHeaderType;
  INTEGER field_gnHeaderSubtype;
  INTEGER field_gnLifetime;
  INTEGER field_gnTrafficClass;
  INTEGER field_btpDestinationPort;
  INTEGER field_btpInfo;
  boolean bound_flag;
public:
  ExtMapSpatInd();
  ExtMapSpatInd(const INTEGER& par_gnNextHeader,
    const INTEGER& par_gnHeaderType,
    const INTEGER& par_gnHeaderSubtype,
    const INTEGER& par_gnLifetime,
    const INTEGER& par_gnTrafficClass,
    const INTEGER& par_btpDestinationPort,
    const INTEGER& par_btpInfo);
  ExtMapSpatInd(const ExtMapSpatInd& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtMapSpatInd& operator=(const ExtMapSpatInd& other_value);
  boolean operator==(const ExtMapSpatInd& other_value) const;
  inline boolean operator!=(const ExtMapSpatInd& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& gnNextHeader()
    {return field_gnNextHeader;}
  inline const INTEGER& gnNextHeader() const
    {return field_gnNextHeader;}
  inline INTEGER& gnHeaderType()
    {return field_gnHeaderType;}
  inline const INTEGER& gnHeaderType() const
    {return field_gnHeaderType;}
  inline INTEGER& gnHeaderSubtype()
    {return field_gnHeaderSubtype;}
  inline const INTEGER& gnHeaderSubtype() const
    {return field_gnHeaderSubtype;}
  inline INTEGER& gnLifetime()
    {return field_gnLifetime;}
  inline const INTEGER& gnLifetime() const
    {return field_gnLifetime;}
  inline INTEGER& gnTrafficClass()
    {return field_gnTrafficClass;}
  inline const INTEGER& gnTrafficClass() const
    {return field_gnTrafficClass;}
  inline INTEGER& btpDestinationPort()
    {return field_btpDestinationPort;}
  inline const INTEGER& btpDestinationPort() const
    {return field_btpDestinationPort;}
  inline INTEGER& btpInfo()
    {return field_btpInfo;}
  inline const INTEGER& btpInfo() const
    {return field_btpInfo;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtMapSpatInd_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtMapSpatInd_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtMapSpatInd& other_value);
void copy_template(const ExtMapSpatInd_template& other_value);

public:
ExtMapSpatInd_template();
ExtMapSpatInd_template(template_sel other_value);
ExtMapSpatInd_template(const ExtMapSpatInd& other_value);
ExtMapSpatInd_template(const OPTIONAL<ExtMapSpatInd>& other_value);
ExtMapSpatInd_template(const ExtMapSpatInd_template& other_value);
~ExtMapSpatInd_template();
ExtMapSpatInd_template& operator=(template_sel other_value);
ExtMapSpatInd_template& operator=(const ExtMapSpatInd& other_value);
ExtMapSpatInd_template& operator=(const OPTIONAL<ExtMapSpatInd>& other_value);
ExtMapSpatInd_template& operator=(const ExtMapSpatInd_template& other_value);
boolean match(const ExtMapSpatInd& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtMapSpatInd valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtMapSpatInd_template& list_item(unsigned int list_index) const;
INTEGER_template& gnNextHeader();
const INTEGER_template& gnNextHeader() const;
INTEGER_template& gnHeaderType();
const INTEGER_template& gnHeaderType() const;
INTEGER_template& gnHeaderSubtype();
const INTEGER_template& gnHeaderSubtype() const;
INTEGER_template& gnLifetime();
const INTEGER_template& gnLifetime() const;
INTEGER_template& gnTrafficClass();
const INTEGER_template& gnTrafficClass() const;
INTEGER_template& btpDestinationPort();
const INTEGER_template& btpDestinationPort() const;
INTEGER_template& btpInfo();
const INTEGER_template& btpInfo() const;
int size_of() const;
void log() const;
void log_match(const ExtMapSpatInd& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtGnNonSecuredPacket : public Base_Type {
  LibItsGeoNetworking__TypesAndValues::NextHeader field_nextHeader;
  INTEGER field_reserved;
  INTEGER field_headerTST;
  LibItsGeoNetworking__TypesAndValues::TrafficClass field_trafficClass;
  BITSTRING field_flags;
  INTEGER field_plLength;
  INTEGER field_maxHopLimit;
  INTEGER field_reserved2;
  LibItsGeoNetworking__TypesAndValues::ExtendedHeader field_extendedHeader;
  OPTIONAL<LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet> field_ipv6Packet;
  OPTIONAL<LibItsBtp__TypesAndValues::BtpHeader> field_btpHeader;
  OPTIONAL<OCTETSTRING> field_btpPayload;
  OCTETSTRING field_rawPayload;
  boolean bound_flag;
public:
  ExtGnNonSecuredPacket();
  ExtGnNonSecuredPacket(const LibItsGeoNetworking__TypesAndValues::NextHeader& par_nextHeader,
    const INTEGER& par_reserved,
    const INTEGER& par_headerTST,
    const LibItsGeoNetworking__TypesAndValues::TrafficClass& par_trafficClass,
    const BITSTRING& par_flags,
    const INTEGER& par_plLength,
    const INTEGER& par_maxHopLimit,
    const INTEGER& par_reserved2,
    const LibItsGeoNetworking__TypesAndValues::ExtendedHeader& par_extendedHeader,
    const OPTIONAL<LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet>& par_ipv6Packet,
    const OPTIONAL<LibItsBtp__TypesAndValues::BtpHeader>& par_btpHeader,
    const OPTIONAL<OCTETSTRING>& par_btpPayload,
    const OCTETSTRING& par_rawPayload);
  ExtGnNonSecuredPacket(const ExtGnNonSecuredPacket& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtGnNonSecuredPacket& operator=(const ExtGnNonSecuredPacket& other_value);
  boolean operator==(const ExtGnNonSecuredPacket& other_value) const;
  inline boolean operator!=(const ExtGnNonSecuredPacket& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline LibItsGeoNetworking__TypesAndValues::NextHeader& nextHeader()
    {return field_nextHeader;}
  inline const LibItsGeoNetworking__TypesAndValues::NextHeader& nextHeader() const
    {return field_nextHeader;}
  inline INTEGER& reserved()
    {return field_reserved;}
  inline const INTEGER& reserved() const
    {return field_reserved;}
  inline INTEGER& headerTST()
    {return field_headerTST;}
  inline const INTEGER& headerTST() const
    {return field_headerTST;}
  inline LibItsGeoNetworking__TypesAndValues::TrafficClass& trafficClass()
    {return field_trafficClass;}
  inline const LibItsGeoNetworking__TypesAndValues::TrafficClass& trafficClass() const
    {return field_trafficClass;}
  inline BITSTRING& flags()
    {return field_flags;}
  inline const BITSTRING& flags() const
    {return field_flags;}
  inline INTEGER& plLength()
    {return field_plLength;}
  inline const INTEGER& plLength() const
    {return field_plLength;}
  inline INTEGER& maxHopLimit()
    {return field_maxHopLimit;}
  inline const INTEGER& maxHopLimit() const
    {return field_maxHopLimit;}
  inline INTEGER& reserved2()
    {return field_reserved2;}
  inline const INTEGER& reserved2() const
    {return field_reserved2;}
  inline LibItsGeoNetworking__TypesAndValues::ExtendedHeader& extendedHeader()
    {return field_extendedHeader;}
  inline const LibItsGeoNetworking__TypesAndValues::ExtendedHeader& extendedHeader() const
    {return field_extendedHeader;}
  inline OPTIONAL<LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet>& ipv6Packet()
    {return field_ipv6Packet;}
  inline const OPTIONAL<LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet>& ipv6Packet() const
    {return field_ipv6Packet;}
  inline OPTIONAL<LibItsBtp__TypesAndValues::BtpHeader>& btpHeader()
    {return field_btpHeader;}
  inline const OPTIONAL<LibItsBtp__TypesAndValues::BtpHeader>& btpHeader() const
    {return field_btpHeader;}
  inline OPTIONAL<OCTETSTRING>& btpPayload()
    {return field_btpPayload;}
  inline const OPTIONAL<OCTETSTRING>& btpPayload() const
    {return field_btpPayload;}
  inline OCTETSTRING& rawPayload()
    {return field_rawPayload;}
  inline const OCTETSTRING& rawPayload() const
    {return field_rawPayload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtGnNonSecuredPacket_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtGnNonSecuredPacket_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtGnNonSecuredPacket& other_value);
void copy_template(const ExtGnNonSecuredPacket_template& other_value);

public:
ExtGnNonSecuredPacket_template();
ExtGnNonSecuredPacket_template(template_sel other_value);
ExtGnNonSecuredPacket_template(const ExtGnNonSecuredPacket& other_value);
ExtGnNonSecuredPacket_template(const OPTIONAL<ExtGnNonSecuredPacket>& other_value);
ExtGnNonSecuredPacket_template(const ExtGnNonSecuredPacket_template& other_value);
~ExtGnNonSecuredPacket_template();
ExtGnNonSecuredPacket_template& operator=(template_sel other_value);
ExtGnNonSecuredPacket_template& operator=(const ExtGnNonSecuredPacket& other_value);
ExtGnNonSecuredPacket_template& operator=(const OPTIONAL<ExtGnNonSecuredPacket>& other_value);
ExtGnNonSecuredPacket_template& operator=(const ExtGnNonSecuredPacket_template& other_value);
boolean match(const ExtGnNonSecuredPacket& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtGnNonSecuredPacket valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtGnNonSecuredPacket_template& list_item(unsigned int list_index) const;
LibItsGeoNetworking__TypesAndValues::NextHeader_template& nextHeader();
const LibItsGeoNetworking__TypesAndValues::NextHeader_template& nextHeader() const;
INTEGER_template& reserved();
const INTEGER_template& reserved() const;
INTEGER_template& headerTST();
const INTEGER_template& headerTST() const;
LibItsGeoNetworking__TypesAndValues::TrafficClass_template& trafficClass();
const LibItsGeoNetworking__TypesAndValues::TrafficClass_template& trafficClass() const;
BITSTRING_template& flags();
const BITSTRING_template& flags() const;
INTEGER_template& plLength();
const INTEGER_template& plLength() const;
INTEGER_template& maxHopLimit();
const INTEGER_template& maxHopLimit() const;
INTEGER_template& reserved2();
const INTEGER_template& reserved2() const;
LibItsGeoNetworking__TypesAndValues::ExtendedHeader_template& extendedHeader();
const LibItsGeoNetworking__TypesAndValues::ExtendedHeader_template& extendedHeader() const;
LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_template& ipv6Packet();
const LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_template& ipv6Packet() const;
LibItsBtp__TypesAndValues::BtpHeader_template& btpHeader();
const LibItsBtp__TypesAndValues::BtpHeader_template& btpHeader() const;
OCTETSTRING_template& btpPayload();
const OCTETSTRING_template& btpPayload() const;
OCTETSTRING_template& rawPayload();
const OCTETSTRING_template& rawPayload() const;
int size_of() const;
void log() const;
void log_match(const ExtGnNonSecuredPacket& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtGeoNetworkingPdu : public Base_Type {
  INTEGER field_version;
  LibItsGeoNetworking__TypesAndValues::BasicNextHeader field_nextHeader;
  INTEGER field_reserved;
  LibItsGeoNetworking__TypesAndValues::Lifetime field_lifeTime;
  INTEGER field_routerHopLimit;
  OPTIONAL<ExtGnNonSecuredPacket> field_packet;
  OPTIONAL<LibItsSecurity__TypesAndValues::SecuredMessage> field_securedMsg;
  boolean bound_flag;
public:
  ExtGeoNetworkingPdu();
  ExtGeoNetworkingPdu(const INTEGER& par_version,
    const LibItsGeoNetworking__TypesAndValues::BasicNextHeader& par_nextHeader,
    const INTEGER& par_reserved,
    const LibItsGeoNetworking__TypesAndValues::Lifetime& par_lifeTime,
    const INTEGER& par_routerHopLimit,
    const OPTIONAL<ExtGnNonSecuredPacket>& par_packet,
    const OPTIONAL<LibItsSecurity__TypesAndValues::SecuredMessage>& par_securedMsg);
  ExtGeoNetworkingPdu(const ExtGeoNetworkingPdu& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtGeoNetworkingPdu& operator=(const ExtGeoNetworkingPdu& other_value);
  boolean operator==(const ExtGeoNetworkingPdu& other_value) const;
  inline boolean operator!=(const ExtGeoNetworkingPdu& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& version()
    {return field_version;}
  inline const INTEGER& version() const
    {return field_version;}
  inline LibItsGeoNetworking__TypesAndValues::BasicNextHeader& nextHeader()
    {return field_nextHeader;}
  inline const LibItsGeoNetworking__TypesAndValues::BasicNextHeader& nextHeader() const
    {return field_nextHeader;}
  inline INTEGER& reserved()
    {return field_reserved;}
  inline const INTEGER& reserved() const
    {return field_reserved;}
  inline LibItsGeoNetworking__TypesAndValues::Lifetime& lifeTime()
    {return field_lifeTime;}
  inline const LibItsGeoNetworking__TypesAndValues::Lifetime& lifeTime() const
    {return field_lifeTime;}
  inline INTEGER& routerHopLimit()
    {return field_routerHopLimit;}
  inline const INTEGER& routerHopLimit() const
    {return field_routerHopLimit;}
  inline OPTIONAL<ExtGnNonSecuredPacket>& packet()
    {return field_packet;}
  inline const OPTIONAL<ExtGnNonSecuredPacket>& packet() const
    {return field_packet;}
  inline OPTIONAL<LibItsSecurity__TypesAndValues::SecuredMessage>& securedMsg()
    {return field_securedMsg;}
  inline const OPTIONAL<LibItsSecurity__TypesAndValues::SecuredMessage>& securedMsg() const
    {return field_securedMsg;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtGeoNetworkingPdu_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtGeoNetworkingPdu_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtGeoNetworkingPdu& other_value);
void copy_template(const ExtGeoNetworkingPdu_template& other_value);

public:
ExtGeoNetworkingPdu_template();
ExtGeoNetworkingPdu_template(template_sel other_value);
ExtGeoNetworkingPdu_template(const ExtGeoNetworkingPdu& other_value);
ExtGeoNetworkingPdu_template(const OPTIONAL<ExtGeoNetworkingPdu>& other_value);
ExtGeoNetworkingPdu_template(const ExtGeoNetworkingPdu_template& other_value);
~ExtGeoNetworkingPdu_template();
ExtGeoNetworkingPdu_template& operator=(template_sel other_value);
ExtGeoNetworkingPdu_template& operator=(const ExtGeoNetworkingPdu& other_value);
ExtGeoNetworkingPdu_template& operator=(const OPTIONAL<ExtGeoNetworkingPdu>& other_value);
ExtGeoNetworkingPdu_template& operator=(const ExtGeoNetworkingPdu_template& other_value);
boolean match(const ExtGeoNetworkingPdu& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtGeoNetworkingPdu valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtGeoNetworkingPdu_template& list_item(unsigned int list_index) const;
INTEGER_template& version();
const INTEGER_template& version() const;
LibItsGeoNetworking__TypesAndValues::BasicNextHeader_template& nextHeader();
const LibItsGeoNetworking__TypesAndValues::BasicNextHeader_template& nextHeader() const;
INTEGER_template& reserved();
const INTEGER_template& reserved() const;
LibItsGeoNetworking__TypesAndValues::Lifetime_template& lifeTime();
const LibItsGeoNetworking__TypesAndValues::Lifetime_template& lifeTime() const;
INTEGER_template& routerHopLimit();
const INTEGER_template& routerHopLimit() const;
ExtGnNonSecuredPacket_template& packet();
const ExtGnNonSecuredPacket_template& packet() const;
LibItsSecurity__TypesAndValues::SecuredMessage_template& securedMsg();
const LibItsSecurity__TypesAndValues::SecuredMessage_template& securedMsg() const;
int size_of() const;
void log() const;
void log_match(const ExtGeoNetworkingPdu& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtGeoNetworkingInd : public Base_Type {
  ExtGeoNetworkingPdu field_msgIn;
  OCTETSTRING field_macDestinationAddress;
  boolean bound_flag;
public:
  ExtGeoNetworkingInd();
  ExtGeoNetworkingInd(const ExtGeoNetworkingPdu& par_msgIn,
    const OCTETSTRING& par_macDestinationAddress);
  ExtGeoNetworkingInd(const ExtGeoNetworkingInd& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtGeoNetworkingInd& operator=(const ExtGeoNetworkingInd& other_value);
  boolean operator==(const ExtGeoNetworkingInd& other_value) const;
  inline boolean operator!=(const ExtGeoNetworkingInd& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ExtGeoNetworkingPdu& msgIn()
    {return field_msgIn;}
  inline const ExtGeoNetworkingPdu& msgIn() const
    {return field_msgIn;}
  inline OCTETSTRING& macDestinationAddress()
    {return field_macDestinationAddress;}
  inline const OCTETSTRING& macDestinationAddress() const
    {return field_macDestinationAddress;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtGeoNetworkingInd_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtGeoNetworkingInd_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtGeoNetworkingInd& other_value);
void copy_template(const ExtGeoNetworkingInd_template& other_value);

public:
ExtGeoNetworkingInd_template();
ExtGeoNetworkingInd_template(template_sel other_value);
ExtGeoNetworkingInd_template(const ExtGeoNetworkingInd& other_value);
ExtGeoNetworkingInd_template(const OPTIONAL<ExtGeoNetworkingInd>& other_value);
ExtGeoNetworkingInd_template(const ExtGeoNetworkingInd_template& other_value);
~ExtGeoNetworkingInd_template();
ExtGeoNetworkingInd_template& operator=(template_sel other_value);
ExtGeoNetworkingInd_template& operator=(const ExtGeoNetworkingInd& other_value);
ExtGeoNetworkingInd_template& operator=(const OPTIONAL<ExtGeoNetworkingInd>& other_value);
ExtGeoNetworkingInd_template& operator=(const ExtGeoNetworkingInd_template& other_value);
boolean match(const ExtGeoNetworkingInd& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtGeoNetworkingInd valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtGeoNetworkingInd_template& list_item(unsigned int list_index) const;
ExtGeoNetworkingPdu_template& msgIn();
const ExtGeoNetworkingPdu_template& msgIn() const;
OCTETSTRING_template& macDestinationAddress();
const OCTETSTRING_template& macDestinationAddress() const;
int size_of() const;
void log() const;
void log_match(const ExtGeoNetworkingInd& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern OCTETSTRING f__enc__UtInitialize(const LibItsCommon__TypesAndValues::UtInitialize& pdu);
extern LibItsCommon__TypesAndValues::UtInitialize f__dec__UtInitialize(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__UtChangePosition(const LibItsCommon__TypesAndValues::UtChangePosition& pdu);
extern LibItsCommon__TypesAndValues::UtChangePosition f__dec__UtChangePosition(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__UtChangePositionResult(const LibItsCommon__TypesAndValues::UtChangePositionResult& pdu);
extern LibItsCommon__TypesAndValues::UtChangePositionResult f__dec__UtChangePositionResult(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__UtChangePseudonym(const LibItsCommon__TypesAndValues::UtChangePseudonym& pdu);
extern LibItsCommon__TypesAndValues::UtChangePseudonym f__dec__UtChangePseudonym(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__UtChangePseudonymResult(const LibItsCommon__TypesAndValues::UtChangePseudonymResult& pdu);
extern LibItsCommon__TypesAndValues::UtChangePseudonymResult f__dec__UtChangePseudonymResult(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__Ut__Gn__GenerateGeoUnicastMessage(const LibItsGeoNetworking__TypesAndValues::GenerateGeoUnicastMessage& pdu);
extern LibItsGeoNetworking__TypesAndValues::GenerateGeoUnicastMessage f__dec__Ut__Gn__GenerateGeoUnicastMessage(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__Ext__UtGnGenerateGeoBroadcastMessage(const ExtGenerateGeoBroadcastMessage& pdu);
extern OCTETSTRING f__enc__Ut__Gn__GenerateGeoBroadcastMessage(const LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage& pdu);
extern LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage f__dec__Ut__Gn__GenerateGeoBroadcastMessage(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__Ut__Gn__GenerateGeoAnycastMessage(const LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage& pdu);
extern LibItsGeoNetworking__TypesAndValues::GenerateGeoBroadcastMessage f__dec__Ut__Gn__GenerateGeoAnycastMessage(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__Ut__Gn__GenerateSHBMessage(const LibItsGeoNetworking__TypesAndValues::GenerateSHBMessage& pdu);
extern LibItsGeoNetworking__TypesAndValues::GenerateSHBMessage f__dec__Ut__Gn__GenerateSHBMessage(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__Ut__Gn__GenerateTSBMessage(const LibItsGeoNetworking__TypesAndValues::GenerateTSBMessage& pdu);
extern LibItsGeoNetworking__TypesAndValues::GenerateTSBMessage f__dec__Ut__Gn__GenerateTSBMessage(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__UtGnTrigger(const LibItsGeoNetworking__TypesAndValues::UtGnTrigger& pdu);
extern OCTETSTRING f__enc__ExtUt__Cam__Trigger(const ExtUtCamTrigger& pdu);
extern ExtUtCamTrigger f__dec__ExtUt__Cam__Trigger(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__UtCAmTrigger(const LibItsCam__TypesAndValues::UtCamTrigger& pdu);
extern ExtUtCamEventInd f__dec__ExtUt__Cam__EventInd(const OCTETSTRING& stream);
extern LibItsCam__TypesAndValues::UtCamEventInd f__dec__Ut__Cam__EventInd(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__ExtUt__Denm__Trigger(const ExtUtDenmTrigger& pdu);
extern ExtUtDenmTrigger f__dec__ExtUt__Denm__Trigger(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__UtDenmTrigger(const LibItsDenm__TypesAndValues::UtDenmTrigger& pdu);
extern OCTETSTRING f__enc__ExtUt__Denm__Update(const ExtUtDenmUpdate& pdu);
extern ExtUtDenmUpdate f__dec__ExtUt__Denm__Update(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__UtDenmUpdate(const LibItsDenm__TypesAndValues::UtDenmUpdate& pdu);
extern OCTETSTRING f__enc__ExtDenmInd(const ExtDenmInd& pdu);
extern ExtDenmInd f__dec__ExtDenmInd(const OCTETSTRING& stream);
extern ExtUtDenmEventInd f__dec__ExtUt__Denm__EventInd(const OCTETSTRING& stream);
extern LibItsDenm__TypesAndValues::UtDenmEventInd f__dec__Ut__Denm__EventInd(const OCTETSTRING& stream);
extern ExtUtMapEventInd f__dec__ExtUt__Map__EventInd(const OCTETSTRING& stream);
extern LibItsMapSpat__TypesAndValues::UtMapEventInd f__dec__Ut__Map__EventInd(const OCTETSTRING& stream);
extern ExtUtSpatEventInd f__dec__ExtUt__Spat__EventInd(const OCTETSTRING& stream);
extern LibItsMapSpat__TypesAndValues::UtSpatEventInd f__dec__Ut__Spat__EventInd(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__ExtBtpReq(const ExtBtpReq& pdu);
extern OCTETSTRING f__enc__BtpReq(const LibItsBtp__TestSystem::BtpReq& pdu);
extern ExtBtpInd f__dec__ExtBtpInd(const OCTETSTRING& stream);
extern LibItsBtp__TestSystem::BtpInd f__dec__BtpInd(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__ExtCamInd(const ExtCamInd& pdu);
extern ExtCamInd f__dec__ExtCamInd(const OCTETSTRING& stream);
extern ExtMapSpatInd f__dec__ExtMapSpatInd(const OCTETSTRING& stream);
extern MapSpatInd f__dec__MapSpatInd(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__GeoNetworkingPdu(const LibItsGeoNetworking__TypesAndValues::GeoNetworkingPdu& pdu);
extern LibItsGeoNetworking__TypesAndValues::GeoNetworkingPdu f__dec__GeoNetworkingPdu(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__BeaconHeader(const LibItsGeoNetworking__TypesAndValues::BeaconHeader& pdu);
extern LibItsGeoNetworking__TypesAndValues::BeaconHeader f__dec__BeaconHeader(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__GN__Address(const LibItsGeoNetworking__TypesAndValues::GN__Address& pdu);
extern LibItsGeoNetworking__TypesAndValues::GN__Address f__dec__GN__Address(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__GeoNetworkingReq(const LibItsGeoNetworking__TestSystem::GeoNetworkingReq& pdu);
extern ExtGeoNetworkingInd f__dec__ExtGeoNetworkingInd(const OCTETSTRING& stream);
extern LibItsGeoNetworking__TestSystem::GeoNetworkingInd f__dec__GeoNetworkingInd(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__IPv6OverGeoNetworkingReq(const LibItsIpv6OverGeoNetworking__TestSystem::IPv6OverGeoNetworkingReq& pdu);
extern LibItsIpv6OverGeoNetworking__TestSystem::IPv6OverGeoNetworkingInd f__dec__IPv6OverGeoNetworkingInd(const OCTETSTRING& stream);
extern OCTETSTRING f__enc__LongPosVector(const LibItsGeoNetworking__TypesAndValues::LongPosVector& pdu);
extern LibItsGeoNetworking__TypesAndValues::LongPosVector f__dec__LongPosVector(const OCTETSTRING& stream);

/* Global variable declarations */

extern const TTCN_RAWdescriptor_t BIT1_raw_;
extern const XERdescriptor_t BIT1_xer_;
extern const TTCN_Typedescriptor_t BIT1_descr_;
extern const TTCN_RAWdescriptor_t BIT6_raw_;
extern const XERdescriptor_t BIT6_xer_;
extern const TTCN_Typedescriptor_t BIT6_descr_;
extern const XERdescriptor_t ExtTrafficClass_scf_xer_;
extern const TTCN_Typedescriptor_t ExtTrafficClass_scf_descr_;
extern const XERdescriptor_t ExtTrafficClass_channelOffload_xer_;
extern const TTCN_Typedescriptor_t ExtTrafficClass_channelOffload_descr_;
extern const XERdescriptor_t ExtTrafficClass_tcId_xer_;
extern const TTCN_Typedescriptor_t ExtTrafficClass_tcId_descr_;
extern const TTCN_RAWdescriptor_t ExtTrafficClass_raw_;
extern const TTCN_JSONdescriptor_t ExtTrafficClass_json_;
extern const TTCN_Typedescriptor_t ExtTrafficClass_descr_;
extern const XERdescriptor_t ExtGnPayload_rawPayload_xer_;
extern const TTCN_Typedescriptor_t ExtGnPayload_rawPayload_descr_;
extern const TTCN_RAWdescriptor_t ExtGnPayload_raw_;
extern const TTCN_JSONdescriptor_t ExtGnPayload_json_;
extern const TTCN_Typedescriptor_t ExtGnPayload_descr_;
extern const XERdescriptor_t ExtGenerateGeoBroadcastMessage_shape_xer_;
extern const TTCN_Typedescriptor_t ExtGenerateGeoBroadcastMessage_shape_descr_;
extern const XERdescriptor_t ExtGenerateGeoBroadcastMessage_lifetime_xer_;
extern const TTCN_Typedescriptor_t ExtGenerateGeoBroadcastMessage_lifetime_descr_;
extern const XERdescriptor_t ExtGenerateGeoBroadcastMessage_reserved_xer_;
extern const TTCN_Typedescriptor_t ExtGenerateGeoBroadcastMessage_reserved_descr_;
extern const TTCN_RAWdescriptor_t ExtGenerateGeoBroadcastMessage_payloadLength_raw_;
extern const XERdescriptor_t ExtGenerateGeoBroadcastMessage_payloadLength_xer_;
extern const TTCN_Typedescriptor_t ExtGenerateGeoBroadcastMessage_payloadLength_descr_;
extern const TTCN_RAWdescriptor_t ExtGenerateGeoBroadcastMessage_raw_;
extern const TTCN_JSONdescriptor_t ExtGenerateGeoBroadcastMessage_json_;
extern const TTCN_Typedescriptor_t ExtGenerateGeoBroadcastMessage_descr_;
extern const TTCN_RAWdescriptor_t BIT8_raw_;
extern const XERdescriptor_t BIT8_xer_;
extern const TTCN_Typedescriptor_t BIT8_descr_;
extern const XERdescriptor_t ExtPtActivation_ptActivationType_xer_;
extern const TTCN_Typedescriptor_t ExtPtActivation_ptActivationType_descr_;
extern const TTCN_RAWdescriptor_t ExtPtActivation_ptActivationDataLength_raw_;
extern const XERdescriptor_t ExtPtActivation_ptActivationDataLength_xer_;
extern const TTCN_Typedescriptor_t ExtPtActivation_ptActivationDataLength_descr_;
extern const XERdescriptor_t ExtPtActivation_ptActivationData_xer_;
extern const TTCN_Typedescriptor_t ExtPtActivation_ptActivationData_descr_;
extern const TTCN_RAWdescriptor_t ExtPtActivation_raw_;
extern const TTCN_JSONdescriptor_t ExtPtActivation_json_;
extern const TTCN_Typedescriptor_t ExtPtActivation_descr_;
extern const TTCN_RAWdescriptor_t ExtUtCamTrigger_raw_;
extern const TTCN_JSONdescriptor_t ExtUtCamTrigger_json_;
extern const TTCN_Typedescriptor_t ExtUtCamTrigger_descr_;
extern const XERdescriptor_t ExtUtCamTrigger_changeCurvature_xer_;
extern const TTCN_Typedescriptor_t ExtUtCamTrigger_changeCurvature_descr_;
extern const XERdescriptor_t ExtUtCamTrigger_changeSpeed_xer_;
extern const TTCN_Typedescriptor_t ExtUtCamTrigger_changeSpeed_descr_;
extern const XERdescriptor_t ExtUtCamTrigger_setAccelerationControlStatus_xer_;
extern const TTCN_Typedescriptor_t ExtUtCamTrigger_setAccelerationControlStatus_descr_;
extern const XERdescriptor_t ExtUtCamTrigger_setExteriorLightsStatus_xer_;
extern const TTCN_Typedescriptor_t ExtUtCamTrigger_setExteriorLightsStatus_descr_;
extern const XERdescriptor_t ExtUtCamTrigger_changeHeading_xer_;
extern const TTCN_Typedescriptor_t ExtUtCamTrigger_changeHeading_descr_;
extern const XERdescriptor_t ExtUtCamTrigger_setDriveDirection_xer_;
extern const TTCN_Typedescriptor_t ExtUtCamTrigger_setDriveDirection_descr_;
extern const XERdescriptor_t ExtUtCamTrigger_changeYawRate_xer_;
extern const TTCN_Typedescriptor_t ExtUtCamTrigger_changeYawRate_descr_;
extern const XERdescriptor_t ExtUtCamTrigger_setStationType_xer_;
extern const TTCN_Typedescriptor_t ExtUtCamTrigger_setStationType_descr_;
extern const XERdescriptor_t ExtUtCamTrigger_setVehicleRole_xer_;
extern const TTCN_Typedescriptor_t ExtUtCamTrigger_setVehicleRole_descr_;
extern const XERdescriptor_t ExtUtCamTrigger_setEmbarkationStatus_xer_;
extern const TTCN_Typedescriptor_t ExtUtCamTrigger_setEmbarkationStatus_descr_;
extern const XERdescriptor_t ExtUtCamTrigger_setDangerousGoods_xer_;
extern const TTCN_Typedescriptor_t ExtUtCamTrigger_setDangerousGoods_descr_;
extern const XERdescriptor_t ExtUtCamTrigger_setLightBarSirene_xer_;
extern const TTCN_Typedescriptor_t ExtUtCamTrigger_setLightBarSirene_descr_;
extern const TTCN_RAWdescriptor_t ExtUtCamEventInd_camPduLength_raw_;
extern const XERdescriptor_t ExtUtCamEventInd_camPduLength_xer_;
extern const TTCN_Typedescriptor_t ExtUtCamEventInd_camPduLength_descr_;
extern const XERdescriptor_t ExtUtCamEventInd_camMsg_xer_;
extern const TTCN_Typedescriptor_t ExtUtCamEventInd_camMsg_descr_;
extern const TTCN_RAWdescriptor_t ExtUtCamEventInd_raw_;
extern const TTCN_JSONdescriptor_t ExtUtCamEventInd_json_;
extern const TTCN_Typedescriptor_t ExtUtCamEventInd_descr_;
extern const XERdescriptor_t ExtSituationContainer_informationQuality_xer_;
extern const TTCN_Typedescriptor_t ExtSituationContainer_informationQuality_descr_;
extern const XERdescriptor_t ExtSituationContainer_causeCode_xer_;
extern const TTCN_Typedescriptor_t ExtSituationContainer_causeCode_descr_;
extern const XERdescriptor_t ExtSituationContainer_subCauseCode_xer_;
extern const TTCN_Typedescriptor_t ExtSituationContainer_subCauseCode_descr_;
extern const TTCN_RAWdescriptor_t ExtSituationContainer_raw_;
extern const TTCN_JSONdescriptor_t ExtSituationContainer_json_;
extern const TTCN_Typedescriptor_t ExtSituationContainer_descr_;
extern const XERdescriptor_t ExtAlacarteContainer_TODO_xer_;
extern const TTCN_Typedescriptor_t ExtAlacarteContainer_TODO_descr_;
extern const TTCN_RAWdescriptor_t ExtAlacarteContainer_raw_;
extern const TTCN_JSONdescriptor_t ExtAlacarteContainer_json_;
extern const TTCN_Typedescriptor_t ExtAlacarteContainer_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmTrigger_bitmask_raw_;
extern const XERdescriptor_t ExtUtDenmTrigger_bitmask_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmTrigger_bitmask_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmTrigger_detectionTime_raw_;
extern const XERdescriptor_t ExtUtDenmTrigger_detectionTime_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmTrigger_detectionTime_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmTrigger_relevanceDistance_raw_;
extern const XERdescriptor_t ExtUtDenmTrigger_relevanceDistance_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmTrigger_relevanceDistance_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmTrigger_relevanceTrafficDirection_raw_;
extern const XERdescriptor_t ExtUtDenmTrigger_relevanceTrafficDirection_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmTrigger_relevanceTrafficDirection_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmTrigger_raw_;
extern const TTCN_JSONdescriptor_t ExtUtDenmTrigger_json_;
extern const TTCN_Typedescriptor_t ExtUtDenmTrigger_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmTrigger_validityDuration_raw_;
extern const XERdescriptor_t ExtUtDenmTrigger_validityDuration_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmTrigger_validityDuration_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmTrigger_repetitionDuration_raw_;
extern const XERdescriptor_t ExtUtDenmTrigger_repetitionDuration_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmTrigger_repetitionDuration_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmTrigger_transmissionInterval_raw_;
extern const XERdescriptor_t ExtUtDenmTrigger_transmissionInterval_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmTrigger_transmissionInterval_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmTrigger_repetitionInterval_raw_;
extern const XERdescriptor_t ExtUtDenmTrigger_repetitionInterval_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmTrigger_repetitionInterval_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmTrigger_alacarteLength_raw_;
extern const XERdescriptor_t ExtUtDenmTrigger_alacarteLength_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmTrigger_alacarteLength_descr_;
extern const XERdescriptor_t ExtActionID_originatingStationID_xer_;
extern const TTCN_Typedescriptor_t ExtActionID_originatingStationID_descr_;
extern const XERdescriptor_t ExtActionID_sequenceNumber_xer_;
extern const TTCN_Typedescriptor_t ExtActionID_sequenceNumber_descr_;
extern const TTCN_RAWdescriptor_t ExtActionID_raw_;
extern const TTCN_JSONdescriptor_t ExtActionID_json_;
extern const TTCN_Typedescriptor_t ExtActionID_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmUpdate_bitmask_raw_;
extern const XERdescriptor_t ExtUtDenmUpdate_bitmask_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmUpdate_bitmask_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmUpdate_detectionTime_raw_;
extern const XERdescriptor_t ExtUtDenmUpdate_detectionTime_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmUpdate_detectionTime_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmUpdate_raw_;
extern const TTCN_JSONdescriptor_t ExtUtDenmUpdate_json_;
extern const TTCN_Typedescriptor_t ExtUtDenmUpdate_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmUpdate_validityDuration_raw_;
extern const XERdescriptor_t ExtUtDenmUpdate_validityDuration_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmUpdate_validityDuration_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmUpdate_relevanceDistance_raw_;
extern const XERdescriptor_t ExtUtDenmUpdate_relevanceDistance_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmUpdate_relevanceDistance_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmUpdate_relevanceTrafficDirection_raw_;
extern const XERdescriptor_t ExtUtDenmUpdate_relevanceTrafficDirection_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmUpdate_relevanceTrafficDirection_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmUpdate_transmissionInterval_raw_;
extern const XERdescriptor_t ExtUtDenmUpdate_transmissionInterval_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmUpdate_transmissionInterval_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmUpdate_repetitionInterval_raw_;
extern const XERdescriptor_t ExtUtDenmUpdate_repetitionInterval_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmUpdate_repetitionInterval_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmUpdate_alacarteLength_raw_;
extern const XERdescriptor_t ExtUtDenmUpdate_alacarteLength_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmUpdate_alacarteLength_descr_;
extern const XERdescriptor_t ExtDenmInd_gnNextHeader_xer_;
extern const TTCN_Typedescriptor_t ExtDenmInd_gnNextHeader_descr_;
extern const XERdescriptor_t ExtDenmInd_gnHeaderType_xer_;
extern const TTCN_Typedescriptor_t ExtDenmInd_gnHeaderType_descr_;
extern const XERdescriptor_t ExtDenmInd_gnHeaderSubtype_xer_;
extern const TTCN_Typedescriptor_t ExtDenmInd_gnHeaderSubtype_descr_;
extern const XERdescriptor_t ExtDenmInd_gnLifetime_xer_;
extern const TTCN_Typedescriptor_t ExtDenmInd_gnLifetime_descr_;
extern const XERdescriptor_t ExtDenmInd_gnTrafficClass_xer_;
extern const TTCN_Typedescriptor_t ExtDenmInd_gnTrafficClass_descr_;
extern const XERdescriptor_t ExtDenmInd_btpDestinationPort_xer_;
extern const TTCN_Typedescriptor_t ExtDenmInd_btpDestinationPort_descr_;
extern const XERdescriptor_t ExtDenmInd_btpInfo_xer_;
extern const TTCN_Typedescriptor_t ExtDenmInd_btpInfo_descr_;
extern const TTCN_RAWdescriptor_t ExtDenmInd_raw_;
extern const TTCN_JSONdescriptor_t ExtDenmInd_json_;
extern const TTCN_Typedescriptor_t ExtDenmInd_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmEventInd_denmPduLength_raw_;
extern const XERdescriptor_t ExtUtDenmEventInd_denmPduLength_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmEventInd_denmPduLength_descr_;
extern const XERdescriptor_t ExtUtDenmEventInd_denMsg_xer_;
extern const TTCN_Typedescriptor_t ExtUtDenmEventInd_denMsg_descr_;
extern const TTCN_RAWdescriptor_t ExtUtDenmEventInd_raw_;
extern const TTCN_JSONdescriptor_t ExtUtDenmEventInd_json_;
extern const TTCN_Typedescriptor_t ExtUtDenmEventInd_descr_;
extern const TTCN_RAWdescriptor_t ExtUtMapEventInd_mapPduLength_raw_;
extern const XERdescriptor_t ExtUtMapEventInd_mapPduLength_xer_;
extern const TTCN_Typedescriptor_t ExtUtMapEventInd_mapPduLength_descr_;
extern const XERdescriptor_t ExtUtMapEventInd_mapMsg_xer_;
extern const TTCN_Typedescriptor_t ExtUtMapEventInd_mapMsg_descr_;
extern const TTCN_RAWdescriptor_t ExtUtMapEventInd_raw_;
extern const TTCN_JSONdescriptor_t ExtUtMapEventInd_json_;
extern const TTCN_Typedescriptor_t ExtUtMapEventInd_descr_;
extern const TTCN_RAWdescriptor_t ExtUtSpatEventInd_spatPduLength_raw_;
extern const XERdescriptor_t ExtUtSpatEventInd_spatPduLength_xer_;
extern const TTCN_Typedescriptor_t ExtUtSpatEventInd_spatPduLength_descr_;
extern const XERdescriptor_t ExtUtSpatEventInd_spatMsg_xer_;
extern const TTCN_Typedescriptor_t ExtUtSpatEventInd_spatMsg_descr_;
extern const TTCN_RAWdescriptor_t ExtUtSpatEventInd_raw_;
extern const TTCN_JSONdescriptor_t ExtUtSpatEventInd_json_;
extern const TTCN_Typedescriptor_t ExtUtSpatEventInd_descr_;
extern const XERdescriptor_t ExtBtpPayload_rawPayload_xer_;
extern const TTCN_Typedescriptor_t ExtBtpPayload_rawPayload_descr_;
extern const TTCN_RAWdescriptor_t ExtBtpPayload_raw_;
extern const TTCN_JSONdescriptor_t ExtBtpPayload_json_;
extern const TTCN_Typedescriptor_t ExtBtpPayload_descr_;
extern const XERdescriptor_t ExtBtpReq_nextheader_xer_;
extern const TTCN_Typedescriptor_t ExtBtpReq_nextheader_descr_;
extern const TTCN_RAWdescriptor_t ExtBtpReq_header_raw_;
extern const TTCN_Typedescriptor_t ExtBtpReq_header_descr_;
extern const TTCN_RAWdescriptor_t ExtBtpReq_raw_;
extern const TTCN_JSONdescriptor_t ExtBtpReq_json_;
extern const TTCN_Typedescriptor_t ExtBtpReq_descr_;
extern const XERdescriptor_t ExtBtpInd_nextheader_xer_;
extern const TTCN_Typedescriptor_t ExtBtpInd_nextheader_descr_;
extern const TTCN_RAWdescriptor_t ExtBtpInd_header_raw_;
extern const TTCN_Typedescriptor_t ExtBtpInd_header_descr_;
extern const TTCN_RAWdescriptor_t ExtBtpInd_raw_;
extern const TTCN_JSONdescriptor_t ExtBtpInd_json_;
extern const TTCN_Typedescriptor_t ExtBtpInd_descr_;
extern const XERdescriptor_t ExtBtpInd_rawPayload_xer_;
extern const TTCN_Typedescriptor_t ExtBtpInd_rawPayload_descr_;
extern const XERdescriptor_t ExtCamInd_gnNextHeader_xer_;
extern const TTCN_Typedescriptor_t ExtCamInd_gnNextHeader_descr_;
extern const XERdescriptor_t ExtCamInd_gnHeaderType_xer_;
extern const TTCN_Typedescriptor_t ExtCamInd_gnHeaderType_descr_;
extern const XERdescriptor_t ExtCamInd_gnHeaderSubtype_xer_;
extern const TTCN_Typedescriptor_t ExtCamInd_gnHeaderSubtype_descr_;
extern const XERdescriptor_t ExtCamInd_gnLifetime_xer_;
extern const TTCN_Typedescriptor_t ExtCamInd_gnLifetime_descr_;
extern const XERdescriptor_t ExtCamInd_gnTrafficClass_xer_;
extern const TTCN_Typedescriptor_t ExtCamInd_gnTrafficClass_descr_;
extern const XERdescriptor_t ExtCamInd_btpDestinationPort_xer_;
extern const TTCN_Typedescriptor_t ExtCamInd_btpDestinationPort_descr_;
extern const XERdescriptor_t ExtCamInd_btpInfo_xer_;
extern const TTCN_Typedescriptor_t ExtCamInd_btpInfo_descr_;
extern const TTCN_RAWdescriptor_t ExtCamInd_raw_;
extern const TTCN_JSONdescriptor_t ExtCamInd_json_;
extern const TTCN_Typedescriptor_t ExtCamInd_descr_;
extern const TTCN_Typedescriptor_t MapSpatInd_descr_;
extern const XERdescriptor_t ExtMapSpatInd_gnNextHeader_xer_;
extern const TTCN_Typedescriptor_t ExtMapSpatInd_gnNextHeader_descr_;
extern const XERdescriptor_t ExtMapSpatInd_gnHeaderType_xer_;
extern const TTCN_Typedescriptor_t ExtMapSpatInd_gnHeaderType_descr_;
extern const XERdescriptor_t ExtMapSpatInd_gnHeaderSubtype_xer_;
extern const TTCN_Typedescriptor_t ExtMapSpatInd_gnHeaderSubtype_descr_;
extern const XERdescriptor_t ExtMapSpatInd_gnLifetime_xer_;
extern const TTCN_Typedescriptor_t ExtMapSpatInd_gnLifetime_descr_;
extern const XERdescriptor_t ExtMapSpatInd_gnTrafficClass_xer_;
extern const TTCN_Typedescriptor_t ExtMapSpatInd_gnTrafficClass_descr_;
extern const XERdescriptor_t ExtMapSpatInd_btpDestinationPort_xer_;
extern const TTCN_Typedescriptor_t ExtMapSpatInd_btpDestinationPort_descr_;
extern const XERdescriptor_t ExtMapSpatInd_btpInfo_xer_;
extern const TTCN_Typedescriptor_t ExtMapSpatInd_btpInfo_descr_;
extern const TTCN_RAWdescriptor_t ExtMapSpatInd_raw_;
extern const TTCN_JSONdescriptor_t ExtMapSpatInd_json_;
extern const TTCN_Typedescriptor_t ExtMapSpatInd_descr_;
extern const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_nextHeader_raw_;
extern const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_nextHeader_descr_;
extern const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_reserved_raw_;
extern const XERdescriptor_t ExtGnNonSecuredPacket_reserved_xer_;
extern const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_reserved_descr_;
extern const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_headerTST_raw_;
extern const XERdescriptor_t ExtGnNonSecuredPacket_headerTST_xer_;
extern const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_headerTST_descr_;
extern const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_trafficClass_raw_;
extern const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_trafficClass_descr_;
extern const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_flags_raw_;
extern const XERdescriptor_t ExtGnNonSecuredPacket_flags_xer_;
extern const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_flags_descr_;
extern const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_plLength_raw_;
extern const XERdescriptor_t ExtGnNonSecuredPacket_plLength_xer_;
extern const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_plLength_descr_;
extern const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_maxHopLimit_raw_;
extern const XERdescriptor_t ExtGnNonSecuredPacket_maxHopLimit_xer_;
extern const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_maxHopLimit_descr_;
extern const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_reserved2_raw_;
extern const XERdescriptor_t ExtGnNonSecuredPacket_reserved2_xer_;
extern const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_reserved2_descr_;
extern const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_extendedHeader_raw_;
extern const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_extendedHeader_descr_;
extern const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_rawPayload_raw_;
extern const XERdescriptor_t ExtGnNonSecuredPacket_rawPayload_xer_;
extern const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_rawPayload_descr_;
extern const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_raw_;
extern const TTCN_JSONdescriptor_t ExtGnNonSecuredPacket_json_;
extern const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_descr_;
extern const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_ipv6Packet_raw_;
extern const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_ipv6Packet_descr_;
extern const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_btpHeader_raw_;
extern const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_btpHeader_descr_;
extern const TTCN_RAWdescriptor_t ExtGnNonSecuredPacket_btpPayload_raw_;
extern const XERdescriptor_t ExtGnNonSecuredPacket_btpPayload_xer_;
extern const TTCN_Typedescriptor_t ExtGnNonSecuredPacket_btpPayload_descr_;
extern const TTCN_RAWdescriptor_t ExtGeoNetworkingPdu_version_raw_;
extern const XERdescriptor_t ExtGeoNetworkingPdu_version_xer_;
extern const TTCN_Typedescriptor_t ExtGeoNetworkingPdu_version_descr_;
extern const TTCN_RAWdescriptor_t ExtGeoNetworkingPdu_nextHeader_raw_;
extern const TTCN_Typedescriptor_t ExtGeoNetworkingPdu_nextHeader_descr_;
extern const TTCN_RAWdescriptor_t ExtGeoNetworkingPdu_reserved_raw_;
extern const XERdescriptor_t ExtGeoNetworkingPdu_reserved_xer_;
extern const TTCN_Typedescriptor_t ExtGeoNetworkingPdu_reserved_descr_;
extern const TTCN_RAWdescriptor_t ExtGeoNetworkingPdu_lifeTime_raw_;
extern const TTCN_Typedescriptor_t ExtGeoNetworkingPdu_lifeTime_descr_;
extern const TTCN_RAWdescriptor_t ExtGeoNetworkingPdu_routerHopLimit_raw_;
extern const XERdescriptor_t ExtGeoNetworkingPdu_routerHopLimit_xer_;
extern const TTCN_Typedescriptor_t ExtGeoNetworkingPdu_routerHopLimit_descr_;
extern const TTCN_RAWdescriptor_t ExtGeoNetworkingPdu_raw_;
extern const TTCN_JSONdescriptor_t ExtGeoNetworkingPdu_json_;
extern const TTCN_Typedescriptor_t ExtGeoNetworkingPdu_descr_;
extern const TTCN_RAWdescriptor_t ExtGeoNetworkingPdu_packet_raw_;
extern const TTCN_Typedescriptor_t ExtGeoNetworkingPdu_packet_descr_;
extern const TTCN_RAWdescriptor_t ExtGeoNetworkingPdu_securedMsg_raw_;
extern const TTCN_Typedescriptor_t ExtGeoNetworkingPdu_securedMsg_descr_;
extern const TTCN_RAWdescriptor_t ExtGeoNetworkingInd_msgIn_raw_;
extern const TTCN_Typedescriptor_t ExtGeoNetworkingInd_msgIn_descr_;
extern const XERdescriptor_t ExtGeoNetworkingInd_macDestinationAddress_xer_;
extern const TTCN_Typedescriptor_t ExtGeoNetworkingInd_macDestinationAddress_descr_;
extern const TTCN_RAWdescriptor_t ExtGeoNetworkingInd_raw_;
extern const TTCN_JSONdescriptor_t ExtGeoNetworkingInd_json_;
extern const TTCN_Typedescriptor_t ExtGeoNetworkingInd_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
