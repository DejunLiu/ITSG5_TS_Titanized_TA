// This C++ source file was generated by the ASN.1 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "DENM_PDU_Descriptions.hh"

namespace DENM__PDU__Descriptions {

/* Prototypes of static functions */

static void pre_init_module();

/* Global variable definitions */

static const ASN_Tag_t DENM_header_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t DENM_header_ber_ = { 1u, DENM_header_tag_ };
// No XER for DENM_header
const TTCN_Typedescriptor_t DENM_header_descr_ = { "@DENM-PDU-Descriptions.DENM.header", &DENM_header_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ManagementContainer_actionID_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t ManagementContainer_actionID_ber_ = { 1u, ManagementContainer_actionID_tag_ };
// No XER for ManagementContainer_actionID
const TTCN_Typedescriptor_t ManagementContainer_actionID_descr_ = { "@DENM-PDU-Descriptions.ManagementContainer.actionID", &ManagementContainer_actionID_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ManagementContainer_detectionTime_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t ManagementContainer_detectionTime_ber_ = { 1u, ManagementContainer_detectionTime_tag_ };
// No XER for ManagementContainer_detectionTime
const TTCN_Typedescriptor_t ManagementContainer_detectionTime_descr_ = { "@DENM-PDU-Descriptions.ManagementContainer.detectionTime", &ManagementContainer_detectionTime_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ManagementContainer_referenceTime_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t ManagementContainer_referenceTime_ber_ = { 1u, ManagementContainer_referenceTime_tag_ };
// No XER for ManagementContainer_referenceTime
const TTCN_Typedescriptor_t ManagementContainer_referenceTime_descr_ = { "@DENM-PDU-Descriptions.ManagementContainer.referenceTime", &ManagementContainer_referenceTime_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ManagementContainer_eventPosition_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t ManagementContainer_eventPosition_ber_ = { 1u, ManagementContainer_eventPosition_tag_ };
// No XER for ManagementContainer_eventPosition
const TTCN_Typedescriptor_t ManagementContainer_eventPosition_descr_ = { "@DENM-PDU-Descriptions.ManagementContainer.eventPosition", &ManagementContainer_eventPosition_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ManagementContainer_validityDuration_tag_[] = { { ASN_TAG_CONT, 7u }};
const ASN_BERdescriptor_t ManagementContainer_validityDuration_ber_ = { 1u, ManagementContainer_validityDuration_tag_ };
// No XER for ManagementContainer_validityDuration
const TTCN_Typedescriptor_t ManagementContainer_validityDuration_descr_ = { "@DENM-PDU-Descriptions.ManagementContainer.validityDuration", &ManagementContainer_validityDuration_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ManagementContainer_stationType_tag_[] = { { ASN_TAG_CONT, 9u }};
const ASN_BERdescriptor_t ManagementContainer_stationType_ber_ = { 1u, ManagementContainer_stationType_tag_ };
// No XER for ManagementContainer_stationType
const TTCN_Typedescriptor_t ManagementContainer_stationType_descr_ = { "@DENM-PDU-Descriptions.ManagementContainer.stationType", &ManagementContainer_stationType_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ManagementContainer
const TTCN_JSONdescriptor_t ManagementContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ManagementContainer_descr_ = { "@DENM-PDU-Descriptions.ManagementContainer", &SEQUENCE_ber_, NULL, NULL, NULL, &ManagementContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static INTEGER const_ManagementContainer_validityDuration_defval_;
const INTEGER& ManagementContainer_validityDuration_defval_ = const_ManagementContainer_validityDuration_defval_;
// No XER for Termination
const TTCN_JSONdescriptor_t Termination_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Termination_descr_ = { "@DENM-PDU-Descriptions.Termination", &ENUMERATED_ber_, NULL, NULL, NULL, &Termination_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ManagementContainer_termination_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t ManagementContainer_termination_ber_ = { 1u, ManagementContainer_termination_tag_ };
// No XER for ManagementContainer_termination
const TTCN_Typedescriptor_t ManagementContainer_termination_descr_ = { "@DENM-PDU-Descriptions.ManagementContainer.termination", &ManagementContainer_termination_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ManagementContainer_relevanceDistance_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t ManagementContainer_relevanceDistance_ber_ = { 1u, ManagementContainer_relevanceDistance_tag_ };
// No XER for ManagementContainer_relevanceDistance
const TTCN_Typedescriptor_t ManagementContainer_relevanceDistance_descr_ = { "@DENM-PDU-Descriptions.ManagementContainer.relevanceDistance", &ManagementContainer_relevanceDistance_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ManagementContainer_relevanceTrafficDirection_tag_[] = { { ASN_TAG_CONT, 6u }};
const ASN_BERdescriptor_t ManagementContainer_relevanceTrafficDirection_ber_ = { 1u, ManagementContainer_relevanceTrafficDirection_tag_ };
// No XER for ManagementContainer_relevanceTrafficDirection
const TTCN_Typedescriptor_t ManagementContainer_relevanceTrafficDirection_descr_ = { "@DENM-PDU-Descriptions.ManagementContainer.relevanceTrafficDirection", &ManagementContainer_relevanceTrafficDirection_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ManagementContainer_transmissionInterval_tag_[] = { { ASN_TAG_CONT, 8u }};
const ASN_BERdescriptor_t ManagementContainer_transmissionInterval_ber_ = { 1u, ManagementContainer_transmissionInterval_tag_ };
// No XER for ManagementContainer_transmissionInterval
const TTCN_Typedescriptor_t ManagementContainer_transmissionInterval_descr_ = { "@DENM-PDU-Descriptions.ManagementContainer.transmissionInterval", &ManagementContainer_transmissionInterval_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DecentralizedEnvironmentalNotificationMessage_management_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t DecentralizedEnvironmentalNotificationMessage_management_ber_ = { 1u, DecentralizedEnvironmentalNotificationMessage_management_tag_ };
// No XER for DecentralizedEnvironmentalNotificationMessage_management
const TTCN_Typedescriptor_t DecentralizedEnvironmentalNotificationMessage_management_descr_ = { "@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.management", &DecentralizedEnvironmentalNotificationMessage_management_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for DecentralizedEnvironmentalNotificationMessage
const TTCN_JSONdescriptor_t DecentralizedEnvironmentalNotificationMessage_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t DecentralizedEnvironmentalNotificationMessage_descr_ = { "@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage", &SEQUENCE_ber_, NULL, NULL, NULL, &DecentralizedEnvironmentalNotificationMessage_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SituationContainer_informationQuality_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t SituationContainer_informationQuality_ber_ = { 1u, SituationContainer_informationQuality_tag_ };
// No XER for SituationContainer_informationQuality
const TTCN_Typedescriptor_t SituationContainer_informationQuality_descr_ = { "@DENM-PDU-Descriptions.SituationContainer.informationQuality", &SituationContainer_informationQuality_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SituationContainer_eventType_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t SituationContainer_eventType_ber_ = { 1u, SituationContainer_eventType_tag_ };
// No XER for SituationContainer_eventType
const TTCN_Typedescriptor_t SituationContainer_eventType_descr_ = { "@DENM-PDU-Descriptions.SituationContainer.eventType", &SituationContainer_eventType_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SituationContainer
const TTCN_JSONdescriptor_t SituationContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SituationContainer_descr_ = { "@DENM-PDU-Descriptions.SituationContainer", &SEQUENCE_ber_, NULL, NULL, NULL, &SituationContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SituationContainer_linkedCause_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t SituationContainer_linkedCause_ber_ = { 1u, SituationContainer_linkedCause_tag_ };
// No XER for SituationContainer_linkedCause
const TTCN_Typedescriptor_t SituationContainer_linkedCause_descr_ = { "@DENM-PDU-Descriptions.SituationContainer.linkedCause", &SituationContainer_linkedCause_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t SituationContainer_eventHistory_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t SituationContainer_eventHistory_ber_ = { 1u, SituationContainer_eventHistory_tag_ };
// No XER for SituationContainer_eventHistory
const TTCN_Typedescriptor_t SituationContainer_eventHistory_descr_ = { "@DENM-PDU-Descriptions.SituationContainer.eventHistory", &SituationContainer_eventHistory_ber_, NULL, NULL, NULL, NULL, &ITS__Container::EventPoint_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DecentralizedEnvironmentalNotificationMessage_situation_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t DecentralizedEnvironmentalNotificationMessage_situation_ber_ = { 1u, DecentralizedEnvironmentalNotificationMessage_situation_tag_ };
// No XER for DecentralizedEnvironmentalNotificationMessage_situation
const TTCN_Typedescriptor_t DecentralizedEnvironmentalNotificationMessage_situation_descr_ = { "@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.situation", &DecentralizedEnvironmentalNotificationMessage_situation_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t LocationContainer_traces_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t LocationContainer_traces_ber_ = { 1u, LocationContainer_traces_tag_ };
// No XER for LocationContainer_traces
const TTCN_Typedescriptor_t LocationContainer_traces_descr_ = { "@DENM-PDU-Descriptions.LocationContainer.traces", &LocationContainer_traces_ber_, NULL, NULL, NULL, NULL, &ITS__Container::PathHistory_descr_, TTCN_Typedescriptor_t::DONTCARE };
// No XER for LocationContainer
const TTCN_JSONdescriptor_t LocationContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t LocationContainer_descr_ = { "@DENM-PDU-Descriptions.LocationContainer", &SEQUENCE_ber_, NULL, NULL, NULL, &LocationContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t LocationContainer_eventSpeed_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t LocationContainer_eventSpeed_ber_ = { 1u, LocationContainer_eventSpeed_tag_ };
// No XER for LocationContainer_eventSpeed
const TTCN_Typedescriptor_t LocationContainer_eventSpeed_descr_ = { "@DENM-PDU-Descriptions.LocationContainer.eventSpeed", &LocationContainer_eventSpeed_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t LocationContainer_eventPositionHeading_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t LocationContainer_eventPositionHeading_ber_ = { 1u, LocationContainer_eventPositionHeading_tag_ };
// No XER for LocationContainer_eventPositionHeading
const TTCN_Typedescriptor_t LocationContainer_eventPositionHeading_descr_ = { "@DENM-PDU-Descriptions.LocationContainer.eventPositionHeading", &LocationContainer_eventPositionHeading_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t LocationContainer_roadType_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t LocationContainer_roadType_ber_ = { 1u, LocationContainer_roadType_tag_ };
// No XER for LocationContainer_roadType
const TTCN_Typedescriptor_t LocationContainer_roadType_descr_ = { "@DENM-PDU-Descriptions.LocationContainer.roadType", &LocationContainer_roadType_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DecentralizedEnvironmentalNotificationMessage_location_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t DecentralizedEnvironmentalNotificationMessage_location_ber_ = { 1u, DecentralizedEnvironmentalNotificationMessage_location_tag_ };
// No XER for DecentralizedEnvironmentalNotificationMessage_location
const TTCN_Typedescriptor_t DecentralizedEnvironmentalNotificationMessage_location_descr_ = { "@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.location", &DecentralizedEnvironmentalNotificationMessage_location_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for AlacarteContainer
const TTCN_JSONdescriptor_t AlacarteContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AlacarteContainer_descr_ = { "@DENM-PDU-Descriptions.AlacarteContainer", &SEQUENCE_ber_, NULL, NULL, NULL, &AlacarteContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t AlacarteContainer_lanePosition_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t AlacarteContainer_lanePosition_ber_ = { 1u, AlacarteContainer_lanePosition_tag_ };
// No XER for AlacarteContainer_lanePosition
const TTCN_Typedescriptor_t AlacarteContainer_lanePosition_descr_ = { "@DENM-PDU-Descriptions.AlacarteContainer.lanePosition", &AlacarteContainer_lanePosition_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ImpactReductionContainer_heightLonCarrLeft_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t ImpactReductionContainer_heightLonCarrLeft_ber_ = { 1u, ImpactReductionContainer_heightLonCarrLeft_tag_ };
// No XER for ImpactReductionContainer_heightLonCarrLeft
const TTCN_Typedescriptor_t ImpactReductionContainer_heightLonCarrLeft_descr_ = { "@DENM-PDU-Descriptions.ImpactReductionContainer.heightLonCarrLeft", &ImpactReductionContainer_heightLonCarrLeft_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ImpactReductionContainer_heightLonCarrRight_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t ImpactReductionContainer_heightLonCarrRight_ber_ = { 1u, ImpactReductionContainer_heightLonCarrRight_tag_ };
// No XER for ImpactReductionContainer_heightLonCarrRight
const TTCN_Typedescriptor_t ImpactReductionContainer_heightLonCarrRight_descr_ = { "@DENM-PDU-Descriptions.ImpactReductionContainer.heightLonCarrRight", &ImpactReductionContainer_heightLonCarrRight_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ImpactReductionContainer_posLonCarrLeft_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t ImpactReductionContainer_posLonCarrLeft_ber_ = { 1u, ImpactReductionContainer_posLonCarrLeft_tag_ };
// No XER for ImpactReductionContainer_posLonCarrLeft
const TTCN_Typedescriptor_t ImpactReductionContainer_posLonCarrLeft_descr_ = { "@DENM-PDU-Descriptions.ImpactReductionContainer.posLonCarrLeft", &ImpactReductionContainer_posLonCarrLeft_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ImpactReductionContainer_posLonCarrRight_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t ImpactReductionContainer_posLonCarrRight_ber_ = { 1u, ImpactReductionContainer_posLonCarrRight_tag_ };
// No XER for ImpactReductionContainer_posLonCarrRight
const TTCN_Typedescriptor_t ImpactReductionContainer_posLonCarrRight_descr_ = { "@DENM-PDU-Descriptions.ImpactReductionContainer.posLonCarrRight", &ImpactReductionContainer_posLonCarrRight_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ImpactReductionContainer_positionOfPillars_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t ImpactReductionContainer_positionOfPillars_ber_ = { 1u, ImpactReductionContainer_positionOfPillars_tag_ };
// No XER for ImpactReductionContainer_positionOfPillars
const TTCN_Typedescriptor_t ImpactReductionContainer_positionOfPillars_descr_ = { "@DENM-PDU-Descriptions.ImpactReductionContainer.positionOfPillars", &ImpactReductionContainer_positionOfPillars_ber_, NULL, NULL, NULL, NULL, &INTEGER_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ImpactReductionContainer_posCentMass_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t ImpactReductionContainer_posCentMass_ber_ = { 1u, ImpactReductionContainer_posCentMass_tag_ };
// No XER for ImpactReductionContainer_posCentMass
const TTCN_Typedescriptor_t ImpactReductionContainer_posCentMass_descr_ = { "@DENM-PDU-Descriptions.ImpactReductionContainer.posCentMass", &ImpactReductionContainer_posCentMass_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ImpactReductionContainer_wheelBaseVehicle_tag_[] = { { ASN_TAG_CONT, 6u }};
const ASN_BERdescriptor_t ImpactReductionContainer_wheelBaseVehicle_ber_ = { 1u, ImpactReductionContainer_wheelBaseVehicle_tag_ };
// No XER for ImpactReductionContainer_wheelBaseVehicle
const TTCN_Typedescriptor_t ImpactReductionContainer_wheelBaseVehicle_descr_ = { "@DENM-PDU-Descriptions.ImpactReductionContainer.wheelBaseVehicle", &ImpactReductionContainer_wheelBaseVehicle_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ImpactReductionContainer_turningRadius_tag_[] = { { ASN_TAG_CONT, 7u }};
const ASN_BERdescriptor_t ImpactReductionContainer_turningRadius_ber_ = { 1u, ImpactReductionContainer_turningRadius_tag_ };
// No XER for ImpactReductionContainer_turningRadius
const TTCN_Typedescriptor_t ImpactReductionContainer_turningRadius_descr_ = { "@DENM-PDU-Descriptions.ImpactReductionContainer.turningRadius", &ImpactReductionContainer_turningRadius_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ImpactReductionContainer_posFrontAx_tag_[] = { { ASN_TAG_CONT, 8u }};
const ASN_BERdescriptor_t ImpactReductionContainer_posFrontAx_ber_ = { 1u, ImpactReductionContainer_posFrontAx_tag_ };
// No XER for ImpactReductionContainer_posFrontAx
const TTCN_Typedescriptor_t ImpactReductionContainer_posFrontAx_descr_ = { "@DENM-PDU-Descriptions.ImpactReductionContainer.posFrontAx", &ImpactReductionContainer_posFrontAx_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ImpactReductionContainer_positionOfOccupants_tag_[] = { { ASN_TAG_CONT, 9u }};
const ASN_BERdescriptor_t ImpactReductionContainer_positionOfOccupants_ber_ = { 1u, ImpactReductionContainer_positionOfOccupants_tag_ };
// No XER for ImpactReductionContainer_positionOfOccupants
const TTCN_Typedescriptor_t ImpactReductionContainer_positionOfOccupants_descr_ = { "@DENM-PDU-Descriptions.ImpactReductionContainer.positionOfOccupants", &ImpactReductionContainer_positionOfOccupants_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ImpactReductionContainer_vehicleMass_tag_[] = { { ASN_TAG_CONT, 10u }};
const ASN_BERdescriptor_t ImpactReductionContainer_vehicleMass_ber_ = { 1u, ImpactReductionContainer_vehicleMass_tag_ };
// No XER for ImpactReductionContainer_vehicleMass
const TTCN_Typedescriptor_t ImpactReductionContainer_vehicleMass_descr_ = { "@DENM-PDU-Descriptions.ImpactReductionContainer.vehicleMass", &ImpactReductionContainer_vehicleMass_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t ImpactReductionContainer_requestResponseIndication_tag_[] = { { ASN_TAG_CONT, 11u }};
const ASN_BERdescriptor_t ImpactReductionContainer_requestResponseIndication_ber_ = { 1u, ImpactReductionContainer_requestResponseIndication_tag_ };
// No XER for ImpactReductionContainer_requestResponseIndication
const TTCN_Typedescriptor_t ImpactReductionContainer_requestResponseIndication_descr_ = { "@DENM-PDU-Descriptions.ImpactReductionContainer.requestResponseIndication", &ImpactReductionContainer_requestResponseIndication_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ImpactReductionContainer
const TTCN_JSONdescriptor_t ImpactReductionContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ImpactReductionContainer_descr_ = { "@DENM-PDU-Descriptions.ImpactReductionContainer", &SEQUENCE_ber_, NULL, NULL, NULL, &ImpactReductionContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t AlacarteContainer_impactReduction_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t AlacarteContainer_impactReduction_ber_ = { 1u, AlacarteContainer_impactReduction_tag_ };
// No XER for AlacarteContainer_impactReduction
const TTCN_Typedescriptor_t AlacarteContainer_impactReduction_descr_ = { "@DENM-PDU-Descriptions.AlacarteContainer.impactReduction", &AlacarteContainer_impactReduction_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t AlacarteContainer_externalTemperature_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t AlacarteContainer_externalTemperature_ber_ = { 1u, AlacarteContainer_externalTemperature_tag_ };
// No XER for AlacarteContainer_externalTemperature
const TTCN_Typedescriptor_t AlacarteContainer_externalTemperature_descr_ = { "@DENM-PDU-Descriptions.AlacarteContainer.externalTemperature", &AlacarteContainer_externalTemperature_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for RoadWorksContainerExtended
const TTCN_JSONdescriptor_t RoadWorksContainerExtended_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RoadWorksContainerExtended_descr_ = { "@DENM-PDU-Descriptions.RoadWorksContainerExtended", &SEQUENCE_ber_, NULL, NULL, NULL, &RoadWorksContainerExtended_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadWorksContainerExtended_lightBarSirenInUse_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t RoadWorksContainerExtended_lightBarSirenInUse_ber_ = { 1u, RoadWorksContainerExtended_lightBarSirenInUse_tag_ };
// No XER for RoadWorksContainerExtended_lightBarSirenInUse
const TTCN_Typedescriptor_t RoadWorksContainerExtended_lightBarSirenInUse_descr_ = { "@DENM-PDU-Descriptions.RoadWorksContainerExtended.lightBarSirenInUse", &RoadWorksContainerExtended_lightBarSirenInUse_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadWorksContainerExtended_closedLanes_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t RoadWorksContainerExtended_closedLanes_ber_ = { 1u, RoadWorksContainerExtended_closedLanes_tag_ };
// No XER for RoadWorksContainerExtended_closedLanes
const TTCN_Typedescriptor_t RoadWorksContainerExtended_closedLanes_descr_ = { "@DENM-PDU-Descriptions.RoadWorksContainerExtended.closedLanes", &RoadWorksContainerExtended_closedLanes_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadWorksContainerExtended_restriction_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t RoadWorksContainerExtended_restriction_ber_ = { 1u, RoadWorksContainerExtended_restriction_tag_ };
// No XER for RoadWorksContainerExtended_restriction
const TTCN_Typedescriptor_t RoadWorksContainerExtended_restriction_descr_ = { "@DENM-PDU-Descriptions.RoadWorksContainerExtended.restriction", &RoadWorksContainerExtended_restriction_ber_, NULL, NULL, NULL, NULL, &INTEGER_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadWorksContainerExtended_speedLimit_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t RoadWorksContainerExtended_speedLimit_ber_ = { 1u, RoadWorksContainerExtended_speedLimit_tag_ };
// No XER for RoadWorksContainerExtended_speedLimit
const TTCN_Typedescriptor_t RoadWorksContainerExtended_speedLimit_descr_ = { "@DENM-PDU-Descriptions.RoadWorksContainerExtended.speedLimit", &RoadWorksContainerExtended_speedLimit_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadWorksContainerExtended_incidentIndication_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t RoadWorksContainerExtended_incidentIndication_ber_ = { 1u, RoadWorksContainerExtended_incidentIndication_tag_ };
// No XER for RoadWorksContainerExtended_incidentIndication
const TTCN_Typedescriptor_t RoadWorksContainerExtended_incidentIndication_descr_ = { "@DENM-PDU-Descriptions.RoadWorksContainerExtended.incidentIndication", &RoadWorksContainerExtended_incidentIndication_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadWorksContainerExtended_recommendedPath_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t RoadWorksContainerExtended_recommendedPath_ber_ = { 1u, RoadWorksContainerExtended_recommendedPath_tag_ };
// No XER for RoadWorksContainerExtended_recommendedPath
const TTCN_Typedescriptor_t RoadWorksContainerExtended_recommendedPath_descr_ = { "@DENM-PDU-Descriptions.RoadWorksContainerExtended.recommendedPath", &RoadWorksContainerExtended_recommendedPath_ber_, NULL, NULL, NULL, NULL, &ITS__Container::ReferencePosition_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadWorksContainerExtended_startingPointSpeedLimit_tag_[] = { { ASN_TAG_CONT, 6u }};
const ASN_BERdescriptor_t RoadWorksContainerExtended_startingPointSpeedLimit_ber_ = { 1u, RoadWorksContainerExtended_startingPointSpeedLimit_tag_ };
// No XER for RoadWorksContainerExtended_startingPointSpeedLimit
const TTCN_Typedescriptor_t RoadWorksContainerExtended_startingPointSpeedLimit_descr_ = { "@DENM-PDU-Descriptions.RoadWorksContainerExtended.startingPointSpeedLimit", &RoadWorksContainerExtended_startingPointSpeedLimit_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadWorksContainerExtended_trafficFlowRule_tag_[] = { { ASN_TAG_CONT, 7u }};
const ASN_BERdescriptor_t RoadWorksContainerExtended_trafficFlowRule_ber_ = { 1u, RoadWorksContainerExtended_trafficFlowRule_tag_ };
// No XER for RoadWorksContainerExtended_trafficFlowRule
const TTCN_Typedescriptor_t RoadWorksContainerExtended_trafficFlowRule_descr_ = { "@DENM-PDU-Descriptions.RoadWorksContainerExtended.trafficFlowRule", &RoadWorksContainerExtended_trafficFlowRule_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for ReferenceDenms
const TTCN_JSONdescriptor_t ReferenceDenms_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ReferenceDenms_descr_ = { "@DENM-PDU-Descriptions.ReferenceDenms", &SEQUENCE_ber_, NULL, NULL, NULL, &ReferenceDenms_json_, &ITS__Container::ActionID_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t RoadWorksContainerExtended_referenceDenms_tag_[] = { { ASN_TAG_CONT, 8u }};
const ASN_BERdescriptor_t RoadWorksContainerExtended_referenceDenms_ber_ = { 1u, RoadWorksContainerExtended_referenceDenms_tag_ };
// No XER for RoadWorksContainerExtended_referenceDenms
const TTCN_Typedescriptor_t RoadWorksContainerExtended_referenceDenms_descr_ = { "@DENM-PDU-Descriptions.RoadWorksContainerExtended.referenceDenms", &RoadWorksContainerExtended_referenceDenms_ber_, NULL, NULL, NULL, NULL, &ITS__Container::ActionID_descr_, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t AlacarteContainer_roadWorks_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t AlacarteContainer_roadWorks_ber_ = { 1u, AlacarteContainer_roadWorks_tag_ };
// No XER for AlacarteContainer_roadWorks
const TTCN_Typedescriptor_t AlacarteContainer_roadWorks_descr_ = { "@DENM-PDU-Descriptions.AlacarteContainer.roadWorks", &AlacarteContainer_roadWorks_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t AlacarteContainer_positioningSolution_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t AlacarteContainer_positioningSolution_ber_ = { 1u, AlacarteContainer_positioningSolution_tag_ };
// No XER for AlacarteContainer_positioningSolution
const TTCN_Typedescriptor_t AlacarteContainer_positioningSolution_descr_ = { "@DENM-PDU-Descriptions.AlacarteContainer.positioningSolution", &AlacarteContainer_positioningSolution_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for StationaryVehicleContainer
const TTCN_JSONdescriptor_t StationaryVehicleContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t StationaryVehicleContainer_descr_ = { "@DENM-PDU-Descriptions.StationaryVehicleContainer", &SEQUENCE_ber_, NULL, NULL, NULL, &StationaryVehicleContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t StationaryVehicleContainer_stationarySince_tag_[] = { { ASN_TAG_CONT, 0u }};
const ASN_BERdescriptor_t StationaryVehicleContainer_stationarySince_ber_ = { 1u, StationaryVehicleContainer_stationarySince_tag_ };
// No XER for StationaryVehicleContainer_stationarySince
const TTCN_Typedescriptor_t StationaryVehicleContainer_stationarySince_descr_ = { "@DENM-PDU-Descriptions.StationaryVehicleContainer.stationarySince", &StationaryVehicleContainer_stationarySince_ber_, NULL, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t StationaryVehicleContainer_stationaryCause_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t StationaryVehicleContainer_stationaryCause_ber_ = { 1u, StationaryVehicleContainer_stationaryCause_tag_ };
// No XER for StationaryVehicleContainer_stationaryCause
const TTCN_Typedescriptor_t StationaryVehicleContainer_stationaryCause_descr_ = { "@DENM-PDU-Descriptions.StationaryVehicleContainer.stationaryCause", &StationaryVehicleContainer_stationaryCause_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t StationaryVehicleContainer_carryingDangerousGoods_tag_[] = { { ASN_TAG_CONT, 2u }};
const ASN_BERdescriptor_t StationaryVehicleContainer_carryingDangerousGoods_ber_ = { 1u, StationaryVehicleContainer_carryingDangerousGoods_tag_ };
// No XER for StationaryVehicleContainer_carryingDangerousGoods
const TTCN_Typedescriptor_t StationaryVehicleContainer_carryingDangerousGoods_descr_ = { "@DENM-PDU-Descriptions.StationaryVehicleContainer.carryingDangerousGoods", &StationaryVehicleContainer_carryingDangerousGoods_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t StationaryVehicleContainer_numberOfOccupants_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t StationaryVehicleContainer_numberOfOccupants_ber_ = { 1u, StationaryVehicleContainer_numberOfOccupants_tag_ };
// No XER for StationaryVehicleContainer_numberOfOccupants
const TTCN_Typedescriptor_t StationaryVehicleContainer_numberOfOccupants_descr_ = { "@DENM-PDU-Descriptions.StationaryVehicleContainer.numberOfOccupants", &StationaryVehicleContainer_numberOfOccupants_ber_, NULL, NULL, NULL, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t StationaryVehicleContainer_vehicleIdentification_tag_[] = { { ASN_TAG_CONT, 4u }};
const ASN_BERdescriptor_t StationaryVehicleContainer_vehicleIdentification_ber_ = { 1u, StationaryVehicleContainer_vehicleIdentification_tag_ };
// No XER for StationaryVehicleContainer_vehicleIdentification
const TTCN_Typedescriptor_t StationaryVehicleContainer_vehicleIdentification_descr_ = { "@DENM-PDU-Descriptions.StationaryVehicleContainer.vehicleIdentification", &StationaryVehicleContainer_vehicleIdentification_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t StationaryVehicleContainer_energyStorageType_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t StationaryVehicleContainer_energyStorageType_ber_ = { 1u, StationaryVehicleContainer_energyStorageType_tag_ };
// No XER for StationaryVehicleContainer_energyStorageType
const TTCN_Typedescriptor_t StationaryVehicleContainer_energyStorageType_descr_ = { "@DENM-PDU-Descriptions.StationaryVehicleContainer.energyStorageType", &StationaryVehicleContainer_energyStorageType_ber_, NULL, NULL, NULL, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t AlacarteContainer_stationaryVehicle_tag_[] = { { ASN_TAG_CONT, 5u }};
const ASN_BERdescriptor_t AlacarteContainer_stationaryVehicle_ber_ = { 1u, AlacarteContainer_stationaryVehicle_tag_ };
// No XER for AlacarteContainer_stationaryVehicle
const TTCN_Typedescriptor_t AlacarteContainer_stationaryVehicle_descr_ = { "@DENM-PDU-Descriptions.AlacarteContainer.stationaryVehicle", &AlacarteContainer_stationaryVehicle_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DecentralizedEnvironmentalNotificationMessage_alacarte_tag_[] = { { ASN_TAG_CONT, 3u }};
const ASN_BERdescriptor_t DecentralizedEnvironmentalNotificationMessage_alacarte_ber_ = { 1u, DecentralizedEnvironmentalNotificationMessage_alacarte_tag_ };
// No XER for DecentralizedEnvironmentalNotificationMessage_alacarte
const TTCN_Typedescriptor_t DecentralizedEnvironmentalNotificationMessage_alacarte_descr_ = { "@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.alacarte", &DecentralizedEnvironmentalNotificationMessage_alacarte_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const ASN_Tag_t DENM_denm_tag_[] = { { ASN_TAG_CONT, 1u }};
const ASN_BERdescriptor_t DENM_denm_ber_ = { 1u, DENM_denm_tag_ };
// No XER for DENM_denm
const TTCN_Typedescriptor_t DENM_denm_descr_ = { "@DENM-PDU-Descriptions.DENM.denm", &DENM_denm_ber_, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for DENM
const TTCN_JSONdescriptor_t DENM_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t DENM_descr_ = { "@DENM-PDU-Descriptions.DENM", &SEQUENCE_ber_, NULL, NULL, NULL, &DENM_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static INTEGER const_defaultValidity;
const INTEGER& defaultValidity = const_defaultValidity;
TTCN_Module module_object("DENM-PDU-Descriptions", __DATE__, __TIME__, NULL, pre_init_module);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_5,
  current_runtime_version.requires_minor_version_4,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

ManagementContainer::ManagementContainer()
{
  bound_flag = FALSE;
}

ManagementContainer::ManagementContainer(const ITS__Container::ActionID& par_actionID,
    const INTEGER& par_detectionTime,
    const INTEGER& par_referenceTime,
    const OPTIONAL<Termination>& par_termination,
    const ITS__Container::ReferencePosition& par_eventPosition,
    const OPTIONAL<ITS__Container::RelevanceDistance>& par_relevanceDistance,
    const OPTIONAL<ITS__Container::RelevanceTrafficDirection>& par_relevanceTrafficDirection,
    const INTEGER& par_validityDuration,
    const OPTIONAL<INTEGER>& par_transmissionInterval,
    const INTEGER& par_stationType)
  :   field_actionID(par_actionID),
  field_detectionTime(par_detectionTime),
  field_referenceTime(par_referenceTime),
  field_termination(par_termination),
  field_eventPosition(par_eventPosition),
  field_relevanceDistance(par_relevanceDistance),
  field_relevanceTrafficDirection(par_relevanceTrafficDirection),
  field_validityDuration(par_validityDuration),
  field_transmissionInterval(par_transmissionInterval),
  field_stationType(par_stationType)
{
  bound_flag = TRUE;
}

ManagementContainer::ManagementContainer(const ManagementContainer& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DENM-PDU-Descriptions.ManagementContainer.");
bound_flag = TRUE;
if (other_value.actionID().is_bound()) field_actionID = other_value.actionID();
else field_actionID.clean_up();
if (other_value.detectionTime().is_bound()) field_detectionTime = other_value.detectionTime();
else field_detectionTime.clean_up();
if (other_value.referenceTime().is_bound()) field_referenceTime = other_value.referenceTime();
else field_referenceTime.clean_up();
if (other_value.termination().is_bound()) field_termination = other_value.termination();
else field_termination.clean_up();
if (other_value.eventPosition().is_bound()) field_eventPosition = other_value.eventPosition();
else field_eventPosition.clean_up();
if (other_value.relevanceDistance().is_bound()) field_relevanceDistance = other_value.relevanceDistance();
else field_relevanceDistance.clean_up();
if (other_value.relevanceTrafficDirection().is_bound()) field_relevanceTrafficDirection = other_value.relevanceTrafficDirection();
else field_relevanceTrafficDirection.clean_up();
if (other_value.validityDuration().is_bound()) field_validityDuration = other_value.validityDuration();
else field_validityDuration.clean_up();
if (other_value.transmissionInterval().is_bound()) field_transmissionInterval = other_value.transmissionInterval();
else field_transmissionInterval.clean_up();
if (other_value.stationType().is_bound()) field_stationType = other_value.stationType();
else field_stationType.clean_up();
}

void ManagementContainer::clean_up()
{
field_actionID.clean_up();
field_detectionTime.clean_up();
field_referenceTime.clean_up();
field_termination.clean_up();
field_eventPosition.clean_up();
field_relevanceDistance.clean_up();
field_relevanceTrafficDirection.clean_up();
field_validityDuration.clean_up();
field_transmissionInterval.clean_up();
field_stationType.clean_up();
bound_flag = FALSE;
}

ManagementContainer& ManagementContainer::operator=(const ManagementContainer& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DENM-PDU-Descriptions.ManagementContainer.");
  bound_flag = TRUE;
  if (other_value.actionID().is_bound()) field_actionID = other_value.actionID();
  else field_actionID.clean_up();
  if (other_value.detectionTime().is_bound()) field_detectionTime = other_value.detectionTime();
  else field_detectionTime.clean_up();
  if (other_value.referenceTime().is_bound()) field_referenceTime = other_value.referenceTime();
  else field_referenceTime.clean_up();
  if (other_value.termination().is_bound()) field_termination = other_value.termination();
  else field_termination.clean_up();
  if (other_value.eventPosition().is_bound()) field_eventPosition = other_value.eventPosition();
  else field_eventPosition.clean_up();
  if (other_value.relevanceDistance().is_bound()) field_relevanceDistance = other_value.relevanceDistance();
  else field_relevanceDistance.clean_up();
  if (other_value.relevanceTrafficDirection().is_bound()) field_relevanceTrafficDirection = other_value.relevanceTrafficDirection();
  else field_relevanceTrafficDirection.clean_up();
  if (other_value.validityDuration().is_bound()) field_validityDuration = other_value.validityDuration();
  else field_validityDuration.clean_up();
  if (other_value.transmissionInterval().is_bound()) field_transmissionInterval = other_value.transmissionInterval();
  else field_transmissionInterval.clean_up();
  if (other_value.stationType().is_bound()) field_stationType = other_value.stationType();
  else field_stationType.clean_up();
}
return *this;
}

boolean ManagementContainer::operator==(const ManagementContainer& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_actionID==other_value.field_actionID
  && field_detectionTime==other_value.field_detectionTime
  && field_referenceTime==other_value.field_referenceTime
  && field_termination==other_value.field_termination
  && field_eventPosition==other_value.field_eventPosition
  && field_relevanceDistance==other_value.field_relevanceDistance
  && field_relevanceTrafficDirection==other_value.field_relevanceTrafficDirection
  && field_validityDuration==other_value.field_validityDuration
  && field_transmissionInterval==other_value.field_transmissionInterval
  && field_stationType==other_value.field_stationType;
}

boolean ManagementContainer::is_bound() const
{
if (bound_flag) return TRUE;
if(field_actionID.is_bound()) return TRUE;
if(field_detectionTime.is_bound()) return TRUE;
if(field_referenceTime.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_termination.get_selection() || field_termination.is_bound()) return TRUE;
if(field_eventPosition.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_relevanceDistance.get_selection() || field_relevanceDistance.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_relevanceTrafficDirection.get_selection() || field_relevanceTrafficDirection.is_bound()) return TRUE;
if(field_validityDuration.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_transmissionInterval.get_selection() || field_transmissionInterval.is_bound()) return TRUE;
if(field_stationType.is_bound()) return TRUE;
return FALSE;
}
boolean ManagementContainer::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_actionID.is_value()) return FALSE;
if(!field_detectionTime.is_value()) return FALSE;
if(!field_referenceTime.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_termination.get_selection() && !field_termination.is_value()) return FALSE;
if(!field_eventPosition.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_relevanceDistance.get_selection() && !field_relevanceDistance.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_relevanceTrafficDirection.get_selection() && !field_relevanceTrafficDirection.is_value()) return FALSE;
if(!field_validityDuration.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_transmissionInterval.get_selection() && !field_transmissionInterval.is_value()) return FALSE;
if(!field_stationType.is_value()) return FALSE;
return TRUE;
}
int ManagementContainer::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DENM-PDU-Descriptions.ManagementContainer");
  int ret_val = 6;
  if (field_termination.ispresent()) ret_val++;
  if (field_relevanceDistance.ispresent()) ret_val++;
  if (field_relevanceTrafficDirection.ispresent()) ret_val++;
  if (field_transmissionInterval.ispresent()) ret_val++;
  return ret_val;
}

void ManagementContainer::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ actionID := ");
field_actionID.log();
TTCN_Logger::log_event_str(", detectionTime := ");
field_detectionTime.log();
TTCN_Logger::log_event_str(", referenceTime := ");
field_referenceTime.log();
TTCN_Logger::log_event_str(", termination := ");
field_termination.log();
TTCN_Logger::log_event_str(", eventPosition := ");
field_eventPosition.log();
TTCN_Logger::log_event_str(", relevanceDistance := ");
field_relevanceDistance.log();
TTCN_Logger::log_event_str(", relevanceTrafficDirection := ");
field_relevanceTrafficDirection.log();
TTCN_Logger::log_event_str(", validityDuration := ");
field_validityDuration.log();
TTCN_Logger::log_event_str(", transmissionInterval := ");
field_transmissionInterval.log();
TTCN_Logger::log_event_str(", stationType := ");
field_stationType.log();
TTCN_Logger::log_event_str(" }");
}

void ManagementContainer::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DENM-PDU-Descriptions.ManagementContainer'");
    }
    if (strcmp("actionID", param_field) == 0) {
      actionID().set_param(param);
      return;
    } else if (strcmp("detectionTime", param_field) == 0) {
      detectionTime().set_param(param);
      return;
    } else if (strcmp("referenceTime", param_field) == 0) {
      referenceTime().set_param(param);
      return;
    } else if (strcmp("termination", param_field) == 0) {
      termination().set_param(param);
      return;
    } else if (strcmp("eventPosition", param_field) == 0) {
      eventPosition().set_param(param);
      return;
    } else if (strcmp("relevanceDistance", param_field) == 0) {
      relevanceDistance().set_param(param);
      return;
    } else if (strcmp("relevanceTrafficDirection", param_field) == 0) {
      relevanceTrafficDirection().set_param(param);
      return;
    } else if (strcmp("validityDuration", param_field) == 0) {
      validityDuration().set_param(param);
      return;
    } else if (strcmp("transmissionInterval", param_field) == 0) {
      transmissionInterval().set_param(param);
      return;
    } else if (strcmp("stationType", param_field) == 0) {
      stationType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DENM-PDU-Descriptions.ManagementContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (10<mp->get_size()) {
      param.error("record value of type @DENM-PDU-Descriptions.ManagementContainer has 10 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) actionID().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) detectionTime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) referenceTime().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) termination().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) eventPosition().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) relevanceDistance().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) relevanceTrafficDirection().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) validityDuration().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) transmissionInterval().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) stationType().set_param(*mp->get_elem(9));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "actionID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          actionID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "detectionTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          detectionTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "referenceTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          referenceTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "termination")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          termination().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eventPosition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eventPosition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "relevanceDistance")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          relevanceDistance().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "relevanceTrafficDirection")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          relevanceTrafficDirection().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "validityDuration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          validityDuration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "transmissionInterval")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          transmissionInterval().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.ManagementContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DENM-PDU-Descriptions.ManagementContainer");
  }
}

Module_Param* ManagementContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DENM-PDU-Descriptions.ManagementContainer'");
    }
    if (strcmp("actionID", param_field) == 0) {
      return actionID().get_param(param_name);
    } else if (strcmp("detectionTime", param_field) == 0) {
      return detectionTime().get_param(param_name);
    } else if (strcmp("referenceTime", param_field) == 0) {
      return referenceTime().get_param(param_name);
    } else if (strcmp("termination", param_field) == 0) {
      return termination().get_param(param_name);
    } else if (strcmp("eventPosition", param_field) == 0) {
      return eventPosition().get_param(param_name);
    } else if (strcmp("relevanceDistance", param_field) == 0) {
      return relevanceDistance().get_param(param_name);
    } else if (strcmp("relevanceTrafficDirection", param_field) == 0) {
      return relevanceTrafficDirection().get_param(param_name);
    } else if (strcmp("validityDuration", param_field) == 0) {
      return validityDuration().get_param(param_name);
    } else if (strcmp("transmissionInterval", param_field) == 0) {
      return transmissionInterval().get_param(param_name);
    } else if (strcmp("stationType", param_field) == 0) {
      return stationType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.ManagementContainer'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_actionID = field_actionID.get_param(param_name);
  mp_field_actionID->set_id(new Module_Param_FieldName(mcopystr("actionID")));
  mp->add_elem(mp_field_actionID);
  Module_Param* mp_field_detectionTime = field_detectionTime.get_param(param_name);
  mp_field_detectionTime->set_id(new Module_Param_FieldName(mcopystr("detectionTime")));
  mp->add_elem(mp_field_detectionTime);
  Module_Param* mp_field_referenceTime = field_referenceTime.get_param(param_name);
  mp_field_referenceTime->set_id(new Module_Param_FieldName(mcopystr("referenceTime")));
  mp->add_elem(mp_field_referenceTime);
  Module_Param* mp_field_termination = field_termination.get_param(param_name);
  mp_field_termination->set_id(new Module_Param_FieldName(mcopystr("termination")));
  mp->add_elem(mp_field_termination);
  Module_Param* mp_field_eventPosition = field_eventPosition.get_param(param_name);
  mp_field_eventPosition->set_id(new Module_Param_FieldName(mcopystr("eventPosition")));
  mp->add_elem(mp_field_eventPosition);
  Module_Param* mp_field_relevanceDistance = field_relevanceDistance.get_param(param_name);
  mp_field_relevanceDistance->set_id(new Module_Param_FieldName(mcopystr("relevanceDistance")));
  mp->add_elem(mp_field_relevanceDistance);
  Module_Param* mp_field_relevanceTrafficDirection = field_relevanceTrafficDirection.get_param(param_name);
  mp_field_relevanceTrafficDirection->set_id(new Module_Param_FieldName(mcopystr("relevanceTrafficDirection")));
  mp->add_elem(mp_field_relevanceTrafficDirection);
  Module_Param* mp_field_validityDuration = field_validityDuration.get_param(param_name);
  mp_field_validityDuration->set_id(new Module_Param_FieldName(mcopystr("validityDuration")));
  mp->add_elem(mp_field_validityDuration);
  Module_Param* mp_field_transmissionInterval = field_transmissionInterval.get_param(param_name);
  mp_field_transmissionInterval->set_id(new Module_Param_FieldName(mcopystr("transmissionInterval")));
  mp->add_elem(mp_field_transmissionInterval);
  Module_Param* mp_field_stationType = field_stationType.get_param(param_name);
  mp_field_stationType->set_id(new Module_Param_FieldName(mcopystr("stationType")));
  mp->add_elem(mp_field_stationType);
  return mp;
  }

void ManagementContainer::set_implicit_omit()
{
if (actionID().is_bound()) actionID().set_implicit_omit();
if (detectionTime().is_bound()) detectionTime().set_implicit_omit();
if (referenceTime().is_bound()) referenceTime().set_implicit_omit();
if (!termination().is_bound()) termination() = OMIT_VALUE;
else termination().set_implicit_omit();
if (eventPosition().is_bound()) eventPosition().set_implicit_omit();
if (!relevanceDistance().is_bound()) relevanceDistance() = OMIT_VALUE;
else relevanceDistance().set_implicit_omit();
if (!relevanceTrafficDirection().is_bound()) relevanceTrafficDirection() = OMIT_VALUE;
else relevanceTrafficDirection().set_implicit_omit();
if (validityDuration().is_bound()) validityDuration().set_implicit_omit();
if (!transmissionInterval().is_bound()) transmissionInterval() = OMIT_VALUE;
else transmissionInterval().set_implicit_omit();
if (stationType().is_bound()) stationType().set_implicit_omit();
}

void ManagementContainer::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DENM-PDU-Descriptions.ManagementContainer.");
field_actionID.encode_text(text_buf);
field_detectionTime.encode_text(text_buf);
field_referenceTime.encode_text(text_buf);
field_termination.encode_text(text_buf);
field_eventPosition.encode_text(text_buf);
field_relevanceDistance.encode_text(text_buf);
field_relevanceTrafficDirection.encode_text(text_buf);
field_validityDuration.encode_text(text_buf);
field_transmissionInterval.encode_text(text_buf);
field_stationType.encode_text(text_buf);
}

void ManagementContainer::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_actionID.decode_text(text_buf);
field_detectionTime.decode_text(text_buf);
field_referenceTime.decode_text(text_buf);
field_termination.decode_text(text_buf);
field_eventPosition.decode_text(text_buf);
field_relevanceDistance.decode_text(text_buf);
field_relevanceTrafficDirection.decode_text(text_buf);
field_validityDuration.decode_text(text_buf);
field_transmissionInterval.decode_text(text_buf);
field_stationType.decode_text(text_buf);
}

void ManagementContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ManagementContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* ManagementContainer::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("actionID': ");
  new_tlv->add_TLV(field_actionID.BER_encode_TLV(ManagementContainer_actionID_descr_, p_coding));
  ec_1.set_msg("detectionTime': ");
  new_tlv->add_TLV(field_detectionTime.BER_encode_TLV(ManagementContainer_detectionTime_descr_, p_coding));
  ec_1.set_msg("referenceTime': ");
  new_tlv->add_TLV(field_referenceTime.BER_encode_TLV(ManagementContainer_referenceTime_descr_, p_coding));
  ec_1.set_msg("termination': ");
  new_tlv->add_TLV(field_termination.BER_encode_TLV(ManagementContainer_termination_descr_, p_coding));
  ec_1.set_msg("eventPosition': ");
  new_tlv->add_TLV(field_eventPosition.BER_encode_TLV(ManagementContainer_eventPosition_descr_, p_coding));
  ec_1.set_msg("relevanceDistance': ");
  new_tlv->add_TLV(field_relevanceDistance.BER_encode_TLV(ManagementContainer_relevanceDistance_descr_, p_coding));
  ec_1.set_msg("relevanceTrafficDirection': ");
  new_tlv->add_TLV(field_relevanceTrafficDirection.BER_encode_TLV(ManagementContainer_relevanceTrafficDirection_descr_, p_coding));
  if(field_validityDuration!=ManagementContainer_validityDuration_defval_) {
    ec_1.set_msg("validityDuration': ");
    new_tlv->add_TLV(field_validityDuration.BER_encode_TLV(ManagementContainer_validityDuration_descr_, p_coding));
  }
  ec_1.set_msg("transmissionInterval': ");
  new_tlv->add_TLV(field_transmissionInterval.BER_encode_TLV(ManagementContainer_transmissionInterval_descr_, p_coding));
  ec_1.set_msg("stationType': ");
  new_tlv->add_TLV(field_stationType.BER_encode_TLV(ManagementContainer_stationType_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean ManagementContainer::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DENM-PDU-Descriptions.ManagementContainer' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("actionID': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_actionID.BER_decode_TLV(ManagementContainer_actionID_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("detectionTime': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_detectionTime.BER_decode_TLV(ManagementContainer_detectionTime_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("referenceTime': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_referenceTime.BER_decode_TLV(ManagementContainer_referenceTime_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("termination': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_termination=OMIT_VALUE;
    else {
      field_termination.BER_decode_TLV(ManagementContainer_termination_descr_, tmp_tlv, L_form);
      if(field_termination.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("eventPosition': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_eventPosition.BER_decode_TLV(ManagementContainer_eventPosition_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("relevanceDistance': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_relevanceDistance=OMIT_VALUE;
    else {
      field_relevanceDistance.BER_decode_TLV(ManagementContainer_relevanceDistance_descr_, tmp_tlv, L_form);
      if(field_relevanceDistance.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("relevanceTrafficDirection': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_relevanceTrafficDirection=OMIT_VALUE;
    else {
      field_relevanceTrafficDirection.BER_decode_TLV(ManagementContainer_relevanceTrafficDirection_descr_, tmp_tlv, L_form);
      if(field_relevanceTrafficDirection.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("validityDuration': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present || !field_validityDuration.BER_decode_isMyMsg(ManagementContainer_validityDuration_descr_, tmp_tlv))
      field_validityDuration=ManagementContainer_validityDuration_defval_;
    else {
      field_validityDuration.BER_decode_TLV(ManagementContainer_validityDuration_descr_, tmp_tlv, L_form);
      tlv_present=FALSE;
    }
    ec_2.set_msg("transmissionInterval': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_transmissionInterval=OMIT_VALUE;
    else {
      field_transmissionInterval.BER_decode_TLV(ManagementContainer_transmissionInterval_descr_, tmp_tlv, L_form);
      if(field_transmissionInterval.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("stationType': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_stationType.BER_decode_TLV(ManagementContainer_stationType_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int ManagementContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DENM-PDU-Descriptions.ManagementContainer.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "actionID");
    enc_len += field_actionID.JSON_encode(ManagementContainer_actionID_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "detectionTime");
    enc_len += field_detectionTime.JSON_encode(ManagementContainer_detectionTime_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "referenceTime");
    enc_len += field_referenceTime.JSON_encode(ManagementContainer_referenceTime_descr_, p_tok);
  }

  if (field_termination.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "termination");
    enc_len += field_termination.JSON_encode(ManagementContainer_termination_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "eventPosition");
    enc_len += field_eventPosition.JSON_encode(ManagementContainer_eventPosition_descr_, p_tok);
  }

  if (field_relevanceDistance.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "relevanceDistance");
    enc_len += field_relevanceDistance.JSON_encode(ManagementContainer_relevanceDistance_descr_, p_tok);
  }

  if (field_relevanceTrafficDirection.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "relevanceTrafficDirection");
    enc_len += field_relevanceTrafficDirection.JSON_encode(ManagementContainer_relevanceTrafficDirection_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "validityDuration");
    enc_len += field_validityDuration.JSON_encode(ManagementContainer_validityDuration_descr_, p_tok);
  }

  if (field_transmissionInterval.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "transmissionInterval");
    enc_len += field_transmissionInterval.JSON_encode(ManagementContainer_transmissionInterval_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "stationType");
    enc_len += field_stationType.JSON_encode(ManagementContainer_stationType_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ManagementContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (8 == name_len && 0 == strncmp(fld_name, "actionID", name_len)) {
         int ret_val = field_actionID.JSON_decode(ManagementContainer_actionID_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "actionID");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "detectionTime", name_len)) {
         int ret_val = field_detectionTime.JSON_decode(ManagementContainer_detectionTime_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "detectionTime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "referenceTime", name_len)) {
         int ret_val = field_referenceTime.JSON_decode(ManagementContainer_referenceTime_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "referenceTime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "termination", name_len)) {
         int ret_val = field_termination.JSON_decode(ManagementContainer_termination_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "termination");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "eventPosition", name_len)) {
         int ret_val = field_eventPosition.JSON_decode(ManagementContainer_eventPosition_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "eventPosition");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "relevanceDistance", name_len)) {
         int ret_val = field_relevanceDistance.JSON_decode(ManagementContainer_relevanceDistance_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "relevanceDistance");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (25 == name_len && 0 == strncmp(fld_name, "relevanceTrafficDirection", name_len)) {
         int ret_val = field_relevanceTrafficDirection.JSON_decode(ManagementContainer_relevanceTrafficDirection_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "relevanceTrafficDirection");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (16 == name_len && 0 == strncmp(fld_name, "validityDuration", name_len)) {
         int ret_val = field_validityDuration.JSON_decode(ManagementContainer_validityDuration_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "validityDuration");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (20 == name_len && 0 == strncmp(fld_name, "transmissionInterval", name_len)) {
         int ret_val = field_transmissionInterval.JSON_decode(ManagementContainer_transmissionInterval_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "transmissionInterval");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "stationType", name_len)) {
         int ret_val = field_stationType.JSON_decode(ManagementContainer_stationType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "stationType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_actionID.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "actionID");
    return JSON_ERROR_FATAL;
  }
if (!field_detectionTime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "detectionTime");
    return JSON_ERROR_FATAL;
  }
if (!field_referenceTime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "referenceTime");
    return JSON_ERROR_FATAL;
  }
if (!field_termination.is_bound()) {
    field_termination = OMIT_VALUE;
  }
if (!field_eventPosition.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "eventPosition");
    return JSON_ERROR_FATAL;
  }
if (!field_relevanceDistance.is_bound()) {
    field_relevanceDistance = OMIT_VALUE;
  }
if (!field_relevanceTrafficDirection.is_bound()) {
    field_relevanceTrafficDirection = OMIT_VALUE;
  }
if (!field_validityDuration.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "validityDuration");
    return JSON_ERROR_FATAL;
  }
if (!field_transmissionInterval.is_bound()) {
    field_transmissionInterval = OMIT_VALUE;
  }
if (!field_stationType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "stationType");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ManagementContainer_template::single_value_struct {
ITS__Container::ActionID_template field_actionID;
INTEGER_template field_detectionTime;
INTEGER_template field_referenceTime;
Termination_template field_termination;
ITS__Container::ReferencePosition_template field_eventPosition;
ITS__Container::RelevanceDistance_template field_relevanceDistance;
ITS__Container::RelevanceTrafficDirection_template field_relevanceTrafficDirection;
INTEGER_template field_validityDuration;
INTEGER_template field_transmissionInterval;
INTEGER_template field_stationType;
};

void ManagementContainer_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_actionID = ANY_VALUE;
single_value->field_detectionTime = ANY_VALUE;
single_value->field_referenceTime = ANY_VALUE;
single_value->field_termination = ANY_OR_OMIT;
single_value->field_eventPosition = ANY_VALUE;
single_value->field_relevanceDistance = ANY_OR_OMIT;
single_value->field_relevanceTrafficDirection = ANY_OR_OMIT;
single_value->field_validityDuration = ANY_VALUE;
single_value->field_transmissionInterval = ANY_OR_OMIT;
single_value->field_stationType = ANY_VALUE;
}
}
}

void ManagementContainer_template::copy_value(const ManagementContainer& other_value)
{
single_value = new single_value_struct;
if (other_value.actionID().is_bound()) {
  single_value->field_actionID = other_value.actionID();
} else {
  single_value->field_actionID.clean_up();
}
if (other_value.detectionTime().is_bound()) {
  single_value->field_detectionTime = other_value.detectionTime();
} else {
  single_value->field_detectionTime.clean_up();
}
if (other_value.referenceTime().is_bound()) {
  single_value->field_referenceTime = other_value.referenceTime();
} else {
  single_value->field_referenceTime.clean_up();
}
if (other_value.termination().is_bound()) {
  if (other_value.termination().ispresent()) single_value->field_termination = other_value.termination()();
  else single_value->field_termination = OMIT_VALUE;
} else {
  single_value->field_termination.clean_up();
}
if (other_value.eventPosition().is_bound()) {
  single_value->field_eventPosition = other_value.eventPosition();
} else {
  single_value->field_eventPosition.clean_up();
}
if (other_value.relevanceDistance().is_bound()) {
  if (other_value.relevanceDistance().ispresent()) single_value->field_relevanceDistance = other_value.relevanceDistance()();
  else single_value->field_relevanceDistance = OMIT_VALUE;
} else {
  single_value->field_relevanceDistance.clean_up();
}
if (other_value.relevanceTrafficDirection().is_bound()) {
  if (other_value.relevanceTrafficDirection().ispresent()) single_value->field_relevanceTrafficDirection = other_value.relevanceTrafficDirection()();
  else single_value->field_relevanceTrafficDirection = OMIT_VALUE;
} else {
  single_value->field_relevanceTrafficDirection.clean_up();
}
if (other_value.validityDuration().is_bound()) {
  single_value->field_validityDuration = other_value.validityDuration();
} else {
  single_value->field_validityDuration.clean_up();
}
if (other_value.transmissionInterval().is_bound()) {
  if (other_value.transmissionInterval().ispresent()) single_value->field_transmissionInterval = other_value.transmissionInterval()();
  else single_value->field_transmissionInterval = OMIT_VALUE;
} else {
  single_value->field_transmissionInterval.clean_up();
}
if (other_value.stationType().is_bound()) {
  single_value->field_stationType = other_value.stationType();
} else {
  single_value->field_stationType.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ManagementContainer_template::copy_template(const ManagementContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.actionID().get_selection()) {
single_value->field_actionID = other_value.actionID();
} else {
single_value->field_actionID.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.detectionTime().get_selection()) {
single_value->field_detectionTime = other_value.detectionTime();
} else {
single_value->field_detectionTime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.referenceTime().get_selection()) {
single_value->field_referenceTime = other_value.referenceTime();
} else {
single_value->field_referenceTime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.termination().get_selection()) {
single_value->field_termination = other_value.termination();
} else {
single_value->field_termination.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.eventPosition().get_selection()) {
single_value->field_eventPosition = other_value.eventPosition();
} else {
single_value->field_eventPosition.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.relevanceDistance().get_selection()) {
single_value->field_relevanceDistance = other_value.relevanceDistance();
} else {
single_value->field_relevanceDistance.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.relevanceTrafficDirection().get_selection()) {
single_value->field_relevanceTrafficDirection = other_value.relevanceTrafficDirection();
} else {
single_value->field_relevanceTrafficDirection.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.validityDuration().get_selection()) {
single_value->field_validityDuration = other_value.validityDuration();
} else {
single_value->field_validityDuration.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.transmissionInterval().get_selection()) {
single_value->field_transmissionInterval = other_value.transmissionInterval();
} else {
single_value->field_transmissionInterval.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.stationType().get_selection()) {
single_value->field_stationType = other_value.stationType();
} else {
single_value->field_stationType.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ManagementContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DENM-PDU-Descriptions.ManagementContainer.");
break;
}
set_selection(other_value);
}

ManagementContainer_template::ManagementContainer_template()
{
}

ManagementContainer_template::ManagementContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ManagementContainer_template::ManagementContainer_template(const ManagementContainer& other_value)
{
copy_value(other_value);
}

ManagementContainer_template::ManagementContainer_template(const OPTIONAL<ManagementContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ManagementContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DENM-PDU-Descriptions.ManagementContainer from an unbound optional field.");
}
}

ManagementContainer_template::ManagementContainer_template(const ManagementContainer_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ManagementContainer_template::~ManagementContainer_template()
{
clean_up();
}

ManagementContainer_template& ManagementContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ManagementContainer_template& ManagementContainer_template::operator=(const ManagementContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ManagementContainer_template& ManagementContainer_template::operator=(const OPTIONAL<ManagementContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ManagementContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DENM-PDU-Descriptions.ManagementContainer.");
}
return *this;
}

ManagementContainer_template& ManagementContainer_template::operator=(const ManagementContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ManagementContainer_template::match(const ManagementContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.actionID().is_bound()) return FALSE;
if(!single_value->field_actionID.match(other_value.actionID(), legacy))return FALSE;
if(!other_value.detectionTime().is_bound()) return FALSE;
if(!single_value->field_detectionTime.match(other_value.detectionTime(), legacy))return FALSE;
if(!other_value.referenceTime().is_bound()) return FALSE;
if(!single_value->field_referenceTime.match(other_value.referenceTime(), legacy))return FALSE;
if(!other_value.termination().is_bound()) return FALSE;
if((other_value.termination().ispresent() ? !single_value->field_termination.match((const Termination&)other_value.termination(), legacy) : !single_value->field_termination.match_omit(legacy)))return FALSE;
if(!other_value.eventPosition().is_bound()) return FALSE;
if(!single_value->field_eventPosition.match(other_value.eventPosition(), legacy))return FALSE;
if(!other_value.relevanceDistance().is_bound()) return FALSE;
if((other_value.relevanceDistance().ispresent() ? !single_value->field_relevanceDistance.match((const ITS__Container::RelevanceDistance&)other_value.relevanceDistance(), legacy) : !single_value->field_relevanceDistance.match_omit(legacy)))return FALSE;
if(!other_value.relevanceTrafficDirection().is_bound()) return FALSE;
if((other_value.relevanceTrafficDirection().ispresent() ? !single_value->field_relevanceTrafficDirection.match((const ITS__Container::RelevanceTrafficDirection&)other_value.relevanceTrafficDirection(), legacy) : !single_value->field_relevanceTrafficDirection.match_omit(legacy)))return FALSE;
if(!other_value.validityDuration().is_bound()) return FALSE;
if(!single_value->field_validityDuration.match(other_value.validityDuration(), legacy))return FALSE;
if(!other_value.transmissionInterval().is_bound()) return FALSE;
if((other_value.transmissionInterval().ispresent() ? !single_value->field_transmissionInterval.match((const INTEGER&)other_value.transmissionInterval(), legacy) : !single_value->field_transmissionInterval.match_omit(legacy)))return FALSE;
if(!other_value.stationType().is_bound()) return FALSE;
if(!single_value->field_stationType.match(other_value.stationType(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DENM-PDU-Descriptions.ManagementContainer.");
}
return FALSE;
}

boolean ManagementContainer_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_actionID.is_bound()) return TRUE;
if (single_value->field_detectionTime.is_bound()) return TRUE;
if (single_value->field_referenceTime.is_bound()) return TRUE;
if (single_value->field_termination.is_omit() || single_value->field_termination.is_bound()) return TRUE;
if (single_value->field_eventPosition.is_bound()) return TRUE;
if (single_value->field_relevanceDistance.is_omit() || single_value->field_relevanceDistance.is_bound()) return TRUE;
if (single_value->field_relevanceTrafficDirection.is_omit() || single_value->field_relevanceTrafficDirection.is_bound()) return TRUE;
if (single_value->field_validityDuration.is_bound()) return TRUE;
if (single_value->field_transmissionInterval.is_omit() || single_value->field_transmissionInterval.is_bound()) return TRUE;
if (single_value->field_stationType.is_bound()) return TRUE;
return FALSE;
}

boolean ManagementContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_actionID.is_value()) return FALSE;
if (!single_value->field_detectionTime.is_value()) return FALSE;
if (!single_value->field_referenceTime.is_value()) return FALSE;
if (!single_value->field_termination.is_omit() && !single_value->field_termination.is_value()) return FALSE;
if (!single_value->field_eventPosition.is_value()) return FALSE;
if (!single_value->field_relevanceDistance.is_omit() && !single_value->field_relevanceDistance.is_value()) return FALSE;
if (!single_value->field_relevanceTrafficDirection.is_omit() && !single_value->field_relevanceTrafficDirection.is_value()) return FALSE;
if (!single_value->field_validityDuration.is_value()) return FALSE;
if (!single_value->field_transmissionInterval.is_omit() && !single_value->field_transmissionInterval.is_value()) return FALSE;
if (!single_value->field_stationType.is_value()) return FALSE;
return TRUE;
}

void ManagementContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ManagementContainer ManagementContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DENM-PDU-Descriptions.ManagementContainer.");
ManagementContainer ret_val;
if (single_value->field_actionID.is_bound()) {
ret_val.actionID() = single_value->field_actionID.valueof();
}
if (single_value->field_detectionTime.is_bound()) {
ret_val.detectionTime() = single_value->field_detectionTime.valueof();
}
if (single_value->field_referenceTime.is_bound()) {
ret_val.referenceTime() = single_value->field_referenceTime.valueof();
}
if (single_value->field_termination.is_omit()) ret_val.termination() = OMIT_VALUE;
else if (single_value->field_termination.is_bound()) {
ret_val.termination() = single_value->field_termination.valueof();
}
if (single_value->field_eventPosition.is_bound()) {
ret_val.eventPosition() = single_value->field_eventPosition.valueof();
}
if (single_value->field_relevanceDistance.is_omit()) ret_val.relevanceDistance() = OMIT_VALUE;
else if (single_value->field_relevanceDistance.is_bound()) {
ret_val.relevanceDistance() = single_value->field_relevanceDistance.valueof();
}
if (single_value->field_relevanceTrafficDirection.is_omit()) ret_val.relevanceTrafficDirection() = OMIT_VALUE;
else if (single_value->field_relevanceTrafficDirection.is_bound()) {
ret_val.relevanceTrafficDirection() = single_value->field_relevanceTrafficDirection.valueof();
}
if (single_value->field_validityDuration.is_bound()) {
ret_val.validityDuration() = single_value->field_validityDuration.valueof();
}
if (single_value->field_transmissionInterval.is_omit()) ret_val.transmissionInterval() = OMIT_VALUE;
else if (single_value->field_transmissionInterval.is_bound()) {
ret_val.transmissionInterval() = single_value->field_transmissionInterval.valueof();
}
if (single_value->field_stationType.is_bound()) {
ret_val.stationType() = single_value->field_stationType.valueof();
}
return ret_val;
}

void ManagementContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DENM-PDU-Descriptions.ManagementContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ManagementContainer_template[list_length];
}

ManagementContainer_template& ManagementContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DENM-PDU-Descriptions.ManagementContainer.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DENM-PDU-Descriptions.ManagementContainer.");
return value_list.list_value[list_index];
}

ITS__Container::ActionID_template& ManagementContainer_template::actionID()
{
set_specific();
return single_value->field_actionID;
}

const ITS__Container::ActionID_template& ManagementContainer_template::actionID() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field actionID of a non-specific template of type @DENM-PDU-Descriptions.ManagementContainer.");
return single_value->field_actionID;
}

INTEGER_template& ManagementContainer_template::detectionTime()
{
set_specific();
return single_value->field_detectionTime;
}

const INTEGER_template& ManagementContainer_template::detectionTime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field detectionTime of a non-specific template of type @DENM-PDU-Descriptions.ManagementContainer.");
return single_value->field_detectionTime;
}

INTEGER_template& ManagementContainer_template::referenceTime()
{
set_specific();
return single_value->field_referenceTime;
}

const INTEGER_template& ManagementContainer_template::referenceTime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field referenceTime of a non-specific template of type @DENM-PDU-Descriptions.ManagementContainer.");
return single_value->field_referenceTime;
}

Termination_template& ManagementContainer_template::termination()
{
set_specific();
return single_value->field_termination;
}

const Termination_template& ManagementContainer_template::termination() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field termination of a non-specific template of type @DENM-PDU-Descriptions.ManagementContainer.");
return single_value->field_termination;
}

ITS__Container::ReferencePosition_template& ManagementContainer_template::eventPosition()
{
set_specific();
return single_value->field_eventPosition;
}

const ITS__Container::ReferencePosition_template& ManagementContainer_template::eventPosition() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field eventPosition of a non-specific template of type @DENM-PDU-Descriptions.ManagementContainer.");
return single_value->field_eventPosition;
}

ITS__Container::RelevanceDistance_template& ManagementContainer_template::relevanceDistance()
{
set_specific();
return single_value->field_relevanceDistance;
}

const ITS__Container::RelevanceDistance_template& ManagementContainer_template::relevanceDistance() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field relevanceDistance of a non-specific template of type @DENM-PDU-Descriptions.ManagementContainer.");
return single_value->field_relevanceDistance;
}

ITS__Container::RelevanceTrafficDirection_template& ManagementContainer_template::relevanceTrafficDirection()
{
set_specific();
return single_value->field_relevanceTrafficDirection;
}

const ITS__Container::RelevanceTrafficDirection_template& ManagementContainer_template::relevanceTrafficDirection() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field relevanceTrafficDirection of a non-specific template of type @DENM-PDU-Descriptions.ManagementContainer.");
return single_value->field_relevanceTrafficDirection;
}

INTEGER_template& ManagementContainer_template::validityDuration()
{
set_specific();
return single_value->field_validityDuration;
}

const INTEGER_template& ManagementContainer_template::validityDuration() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field validityDuration of a non-specific template of type @DENM-PDU-Descriptions.ManagementContainer.");
return single_value->field_validityDuration;
}

INTEGER_template& ManagementContainer_template::transmissionInterval()
{
set_specific();
return single_value->field_transmissionInterval;
}

const INTEGER_template& ManagementContainer_template::transmissionInterval() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field transmissionInterval of a non-specific template of type @DENM-PDU-Descriptions.ManagementContainer.");
return single_value->field_transmissionInterval;
}

INTEGER_template& ManagementContainer_template::stationType()
{
set_specific();
return single_value->field_stationType;
}

const INTEGER_template& ManagementContainer_template::stationType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stationType of a non-specific template of type @DENM-PDU-Descriptions.ManagementContainer.");
return single_value->field_stationType;
}

int ManagementContainer_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.ManagementContainer which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 6;
      if (single_value->field_termination.is_present()) ret_val++;
      if (single_value->field_relevanceDistance.is_present()) ret_val++;
      if (single_value->field_relevanceTrafficDirection.is_present()) ret_val++;
      if (single_value->field_transmissionInterval.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.ManagementContainer containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.ManagementContainer containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.ManagementContainer containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.ManagementContainer containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.ManagementContainer containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DENM-PDU-Descriptions.ManagementContainer.");
  }
  return 0;
}

void ManagementContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ actionID := ");
single_value->field_actionID.log();
TTCN_Logger::log_event_str(", detectionTime := ");
single_value->field_detectionTime.log();
TTCN_Logger::log_event_str(", referenceTime := ");
single_value->field_referenceTime.log();
TTCN_Logger::log_event_str(", termination := ");
single_value->field_termination.log();
TTCN_Logger::log_event_str(", eventPosition := ");
single_value->field_eventPosition.log();
TTCN_Logger::log_event_str(", relevanceDistance := ");
single_value->field_relevanceDistance.log();
TTCN_Logger::log_event_str(", relevanceTrafficDirection := ");
single_value->field_relevanceTrafficDirection.log();
TTCN_Logger::log_event_str(", validityDuration := ");
single_value->field_validityDuration.log();
TTCN_Logger::log_event_str(", transmissionInterval := ");
single_value->field_transmissionInterval.log();
TTCN_Logger::log_event_str(", stationType := ");
single_value->field_stationType.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ManagementContainer_template::log_match(const ManagementContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_actionID.match(match_value.actionID(), legacy)){
TTCN_Logger::log_logmatch_info(".actionID");
single_value->field_actionID.log_match(match_value.actionID(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_detectionTime.match(match_value.detectionTime(), legacy)){
TTCN_Logger::log_logmatch_info(".detectionTime");
single_value->field_detectionTime.log_match(match_value.detectionTime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_referenceTime.match(match_value.referenceTime(), legacy)){
TTCN_Logger::log_logmatch_info(".referenceTime");
single_value->field_referenceTime.log_match(match_value.referenceTime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.termination().ispresent()){
if(!single_value->field_termination.match(match_value.termination(), legacy)){
TTCN_Logger::log_logmatch_info(".termination");
single_value->field_termination.log_match(match_value.termination(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_termination.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".termination := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_termination.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_eventPosition.match(match_value.eventPosition(), legacy)){
TTCN_Logger::log_logmatch_info(".eventPosition");
single_value->field_eventPosition.log_match(match_value.eventPosition(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.relevanceDistance().ispresent()){
if(!single_value->field_relevanceDistance.match(match_value.relevanceDistance(), legacy)){
TTCN_Logger::log_logmatch_info(".relevanceDistance");
single_value->field_relevanceDistance.log_match(match_value.relevanceDistance(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_relevanceDistance.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".relevanceDistance := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_relevanceDistance.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.relevanceTrafficDirection().ispresent()){
if(!single_value->field_relevanceTrafficDirection.match(match_value.relevanceTrafficDirection(), legacy)){
TTCN_Logger::log_logmatch_info(".relevanceTrafficDirection");
single_value->field_relevanceTrafficDirection.log_match(match_value.relevanceTrafficDirection(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_relevanceTrafficDirection.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".relevanceTrafficDirection := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_relevanceTrafficDirection.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_validityDuration.match(match_value.validityDuration(), legacy)){
TTCN_Logger::log_logmatch_info(".validityDuration");
single_value->field_validityDuration.log_match(match_value.validityDuration(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.transmissionInterval().ispresent()){
if(!single_value->field_transmissionInterval.match(match_value.transmissionInterval(), legacy)){
TTCN_Logger::log_logmatch_info(".transmissionInterval");
single_value->field_transmissionInterval.log_match(match_value.transmissionInterval(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_transmissionInterval.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".transmissionInterval := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_transmissionInterval.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_stationType.match(match_value.stationType(), legacy)){
TTCN_Logger::log_logmatch_info(".stationType");
single_value->field_stationType.log_match(match_value.stationType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ actionID := ");
single_value->field_actionID.log_match(match_value.actionID(), legacy);
TTCN_Logger::log_event_str(", detectionTime := ");
single_value->field_detectionTime.log_match(match_value.detectionTime(), legacy);
TTCN_Logger::log_event_str(", referenceTime := ");
single_value->field_referenceTime.log_match(match_value.referenceTime(), legacy);
TTCN_Logger::log_event_str(", termination := ");
if (match_value.termination().ispresent()) single_value->field_termination.log_match(match_value.termination(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_termination.log();
if (single_value->field_termination.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", eventPosition := ");
single_value->field_eventPosition.log_match(match_value.eventPosition(), legacy);
TTCN_Logger::log_event_str(", relevanceDistance := ");
if (match_value.relevanceDistance().ispresent()) single_value->field_relevanceDistance.log_match(match_value.relevanceDistance(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_relevanceDistance.log();
if (single_value->field_relevanceDistance.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", relevanceTrafficDirection := ");
if (match_value.relevanceTrafficDirection().ispresent()) single_value->field_relevanceTrafficDirection.log_match(match_value.relevanceTrafficDirection(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_relevanceTrafficDirection.log();
if (single_value->field_relevanceTrafficDirection.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", validityDuration := ");
single_value->field_validityDuration.log_match(match_value.validityDuration(), legacy);
TTCN_Logger::log_event_str(", transmissionInterval := ");
if (match_value.transmissionInterval().ispresent()) single_value->field_transmissionInterval.log_match(match_value.transmissionInterval(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_transmissionInterval.log();
if (single_value->field_transmissionInterval.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", stationType := ");
single_value->field_stationType.log_match(match_value.stationType(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ManagementContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_actionID.encode_text(text_buf);
single_value->field_detectionTime.encode_text(text_buf);
single_value->field_referenceTime.encode_text(text_buf);
single_value->field_termination.encode_text(text_buf);
single_value->field_eventPosition.encode_text(text_buf);
single_value->field_relevanceDistance.encode_text(text_buf);
single_value->field_relevanceTrafficDirection.encode_text(text_buf);
single_value->field_validityDuration.encode_text(text_buf);
single_value->field_transmissionInterval.encode_text(text_buf);
single_value->field_stationType.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DENM-PDU-Descriptions.ManagementContainer.");
}
}

void ManagementContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_actionID.decode_text(text_buf);
single_value->field_detectionTime.decode_text(text_buf);
single_value->field_referenceTime.decode_text(text_buf);
single_value->field_termination.decode_text(text_buf);
single_value->field_eventPosition.decode_text(text_buf);
single_value->field_relevanceDistance.decode_text(text_buf);
single_value->field_relevanceTrafficDirection.decode_text(text_buf);
single_value->field_validityDuration.decode_text(text_buf);
single_value->field_transmissionInterval.decode_text(text_buf);
single_value->field_stationType.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ManagementContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DENM-PDU-Descriptions.ManagementContainer.");
}
}

void ManagementContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DENM-PDU-Descriptions.ManagementContainer'");
    }
    if (strcmp("actionID", param_field) == 0) {
      actionID().set_param(param);
      return;
    } else if (strcmp("detectionTime", param_field) == 0) {
      detectionTime().set_param(param);
      return;
    } else if (strcmp("referenceTime", param_field) == 0) {
      referenceTime().set_param(param);
      return;
    } else if (strcmp("termination", param_field) == 0) {
      termination().set_param(param);
      return;
    } else if (strcmp("eventPosition", param_field) == 0) {
      eventPosition().set_param(param);
      return;
    } else if (strcmp("relevanceDistance", param_field) == 0) {
      relevanceDistance().set_param(param);
      return;
    } else if (strcmp("relevanceTrafficDirection", param_field) == 0) {
      relevanceTrafficDirection().set_param(param);
      return;
    } else if (strcmp("validityDuration", param_field) == 0) {
      validityDuration().set_param(param);
      return;
    } else if (strcmp("transmissionInterval", param_field) == 0) {
      transmissionInterval().set_param(param);
      return;
    } else if (strcmp("stationType", param_field) == 0) {
      stationType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DENM-PDU-Descriptions.ManagementContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ManagementContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (10<mp->get_size()) {
      param.error("record template of type @DENM-PDU-Descriptions.ManagementContainer has 10 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) actionID().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) detectionTime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) referenceTime().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) termination().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) eventPosition().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) relevanceDistance().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) relevanceTrafficDirection().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) validityDuration().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) transmissionInterval().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) stationType().set_param(*mp->get_elem(9));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "actionID")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          actionID().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "detectionTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          detectionTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "referenceTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          referenceTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "termination")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          termination().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eventPosition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eventPosition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "relevanceDistance")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          relevanceDistance().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "relevanceTrafficDirection")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          relevanceTrafficDirection().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "validityDuration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          validityDuration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "transmissionInterval")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          transmissionInterval().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.ManagementContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DENM-PDU-Descriptions.ManagementContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ManagementContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DENM-PDU-Descriptions.ManagementContainer'");
    }
    if (strcmp("actionID", param_field) == 0) {
      return actionID().get_param(param_name);
    } else if (strcmp("detectionTime", param_field) == 0) {
      return detectionTime().get_param(param_name);
    } else if (strcmp("referenceTime", param_field) == 0) {
      return referenceTime().get_param(param_name);
    } else if (strcmp("termination", param_field) == 0) {
      return termination().get_param(param_name);
    } else if (strcmp("eventPosition", param_field) == 0) {
      return eventPosition().get_param(param_name);
    } else if (strcmp("relevanceDistance", param_field) == 0) {
      return relevanceDistance().get_param(param_name);
    } else if (strcmp("relevanceTrafficDirection", param_field) == 0) {
      return relevanceTrafficDirection().get_param(param_name);
    } else if (strcmp("validityDuration", param_field) == 0) {
      return validityDuration().get_param(param_name);
    } else if (strcmp("transmissionInterval", param_field) == 0) {
      return transmissionInterval().get_param(param_name);
    } else if (strcmp("stationType", param_field) == 0) {
      return stationType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.ManagementContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_actionID = single_value->field_actionID.get_param(param_name);
    mp_field_actionID->set_id(new Module_Param_FieldName(mcopystr("actionID")));
    mp->add_elem(mp_field_actionID);
    Module_Param* mp_field_detectionTime = single_value->field_detectionTime.get_param(param_name);
    mp_field_detectionTime->set_id(new Module_Param_FieldName(mcopystr("detectionTime")));
    mp->add_elem(mp_field_detectionTime);
    Module_Param* mp_field_referenceTime = single_value->field_referenceTime.get_param(param_name);
    mp_field_referenceTime->set_id(new Module_Param_FieldName(mcopystr("referenceTime")));
    mp->add_elem(mp_field_referenceTime);
    Module_Param* mp_field_termination = single_value->field_termination.get_param(param_name);
    mp_field_termination->set_id(new Module_Param_FieldName(mcopystr("termination")));
    mp->add_elem(mp_field_termination);
    Module_Param* mp_field_eventPosition = single_value->field_eventPosition.get_param(param_name);
    mp_field_eventPosition->set_id(new Module_Param_FieldName(mcopystr("eventPosition")));
    mp->add_elem(mp_field_eventPosition);
    Module_Param* mp_field_relevanceDistance = single_value->field_relevanceDistance.get_param(param_name);
    mp_field_relevanceDistance->set_id(new Module_Param_FieldName(mcopystr("relevanceDistance")));
    mp->add_elem(mp_field_relevanceDistance);
    Module_Param* mp_field_relevanceTrafficDirection = single_value->field_relevanceTrafficDirection.get_param(param_name);
    mp_field_relevanceTrafficDirection->set_id(new Module_Param_FieldName(mcopystr("relevanceTrafficDirection")));
    mp->add_elem(mp_field_relevanceTrafficDirection);
    Module_Param* mp_field_validityDuration = single_value->field_validityDuration.get_param(param_name);
    mp_field_validityDuration->set_id(new Module_Param_FieldName(mcopystr("validityDuration")));
    mp->add_elem(mp_field_validityDuration);
    Module_Param* mp_field_transmissionInterval = single_value->field_transmissionInterval.get_param(param_name);
    mp_field_transmissionInterval->set_id(new Module_Param_FieldName(mcopystr("transmissionInterval")));
    mp->add_elem(mp_field_transmissionInterval);
    Module_Param* mp_field_stationType = single_value->field_stationType.get_param(param_name);
    mp_field_stationType->set_id(new Module_Param_FieldName(mcopystr("stationType")));
    mp->add_elem(mp_field_stationType);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ManagementContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_actionID.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ManagementContainer");
single_value->field_detectionTime.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ManagementContainer");
single_value->field_referenceTime.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ManagementContainer");
single_value->field_termination.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ManagementContainer");
single_value->field_eventPosition.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ManagementContainer");
single_value->field_relevanceDistance.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ManagementContainer");
single_value->field_relevanceTrafficDirection.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ManagementContainer");
single_value->field_validityDuration.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ManagementContainer");
single_value->field_transmissionInterval.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ManagementContainer");
single_value->field_stationType.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ManagementContainer");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DENM-PDU-Descriptions.ManagementContainer");
}

boolean ManagementContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ManagementContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

Termination::Termination()
{
enum_value = UNBOUND_VALUE;
}

Termination::Termination(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @DENM-PDU-Descriptions.Termination with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

Termination::Termination(enum_type other_value)
{
enum_value = other_value;
}

Termination::Termination(const Termination& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @DENM-PDU-Descriptions.Termination.");
enum_value = other_value.enum_value;
}

Termination& Termination::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @DENM-PDU-Descriptions.Termination.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

Termination& Termination::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

Termination& Termination::operator=(const Termination& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @DENM-PDU-Descriptions.Termination.");
enum_value = other_value.enum_value;
return *this;
}

boolean Termination::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DENM-PDU-Descriptions.Termination.");
return enum_value == other_value;
}

boolean Termination::operator==(const Termination& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DENM-PDU-Descriptions.Termination.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DENM-PDU-Descriptions.Termination.");
return enum_value == other_value.enum_value;
}

boolean Termination::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DENM-PDU-Descriptions.Termination.");
return enum_value < other_value;
}

boolean Termination::operator<(const Termination& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DENM-PDU-Descriptions.Termination.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DENM-PDU-Descriptions.Termination.");
return enum_value < other_value.enum_value;
}

boolean Termination::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DENM-PDU-Descriptions.Termination.");
return enum_value > other_value;
}

boolean Termination::operator>(const Termination& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @DENM-PDU-Descriptions.Termination.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @DENM-PDU-Descriptions.Termination.");
return enum_value > other_value.enum_value;
}

const char *Termination::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case isCancellation: return "isCancellation";
case isNegation: return "isNegation";
default: return "<unknown>";
}
}

Termination::enum_type Termination::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "isCancellation")) return isCancellation;
else if (!strcmp(str_par, "isNegation")) return isNegation;
else return UNKNOWN_VALUE;
}

boolean Termination::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
return TRUE;
default:
return FALSE;
}
}

int Termination::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @DENM-PDU-Descriptions.Termination.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int Termination::enum2int(const Termination& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @DENM-PDU-Descriptions.Termination.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void Termination::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @DENM-PDU-Descriptions.Termination.", int_val);
enum_value = (enum_type)int_val;
}

Termination::operator Termination::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @DENM-PDU-Descriptions.Termination.");
return enum_value;
}

void Termination::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void Termination::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@DENM-PDU-Descriptions.Termination");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @DENM-PDU-Descriptions.Termination.");
  }
}

Module_Param* Termination::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void Termination::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @DENM-PDU-Descriptions.Termination.");
text_buf.push_int(enum_value);
}

void Termination::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @DENM-PDU-Descriptions.Termination.", enum_value);
}

void Termination::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Termination::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* Termination::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    BER_encode_chk_enum_valid(p_td, is_valid_enum(enum_value), enum_value);
    new_tlv=BER_encode_TLV_INTEGER(p_coding, enum_value);
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean Termination::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  enum_value = UNBOUND_VALUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec("While decoding ENUMERATED type @DENM-PDU-Descriptions.Termination: ");
  int tmp_mfr;
  if (BER_decode_TLV_INTEGER(stripped_tlv, L_form, tmp_mfr)) {
    BER_decode_chk_enum_valid(p_td, is_valid_enum(tmp_mfr), tmp_mfr);
    enum_value = (enum_type)tmp_mfr;
    return TRUE;
  } else return FALSE;
}

int Termination::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @DENM-PDU-Descriptions.Termination.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int Termination::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void Termination_template::copy_template(const Termination_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Termination_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @DENM-PDU-Descriptions.Termination.");
}
}

Termination_template::Termination_template()
{
}

Termination_template::Termination_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Termination_template::Termination_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!Termination::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @DENM-PDU-Descriptions.Termination with unknown numeric value %d.", other_value);
single_value = (Termination::enum_type)other_value;
}

Termination_template::Termination_template(Termination::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

Termination_template::Termination_template(const Termination& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == Termination::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @DENM-PDU-Descriptions.Termination.");
single_value = other_value.enum_value;
}

Termination_template::Termination_template(const OPTIONAL<Termination>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (Termination::enum_type)(const Termination&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @DENM-PDU-Descriptions.Termination from an unbound optional field.");
}
}

Termination_template::Termination_template(const Termination_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

Termination_template::~Termination_template()
{
clean_up();
}

boolean Termination_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean Termination_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != Termination::UNBOUND_VALUE;
}

void Termination_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

Termination_template& Termination_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Termination_template& Termination_template::operator=(int other_value)
{
if (!Termination::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @DENM-PDU-Descriptions.Termination.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (Termination::enum_type)other_value;
return *this;
}

Termination_template& Termination_template::operator=(Termination::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

Termination_template& Termination_template::operator=(const Termination& other_value)
{
if (other_value.enum_value == Termination::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @DENM-PDU-Descriptions.Termination to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

Termination_template& Termination_template::operator=(const OPTIONAL<Termination>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (Termination::enum_type)(const Termination&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @DENM-PDU-Descriptions.Termination.");
}
return *this;
}

Termination_template& Termination_template::operator=(const Termination_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Termination_template::match(Termination::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @DENM-PDU-Descriptions.Termination.");
}
return FALSE;
}

boolean Termination_template::match(const Termination& other_value, boolean) const
{
if (other_value.enum_value == Termination::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @DENM-PDU-Descriptions.Termination with an unbound value.");
return match(other_value.enum_value);
}

Termination::enum_type Termination_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @DENM-PDU-Descriptions.Termination.");
return single_value;
}

void Termination_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @DENM-PDU-Descriptions.Termination.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Termination_template[list_length];
}

Termination_template& Termination_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @DENM-PDU-Descriptions.Termination.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @DENM-PDU-Descriptions.Termination.");
return value_list.list_value[list_index];
}

void Termination_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(Termination::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Termination_template::log_match(const Termination& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void Termination_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @DENM-PDU-Descriptions.Termination.");
}
}

void Termination_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (Termination::enum_type)text_buf.pull_int().get_val();
if (!Termination::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @DENM-PDU-Descriptions.Termination.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Termination_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @DENM-PDU-Descriptions.Termination.");
}
}

boolean Termination_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Termination_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void Termination_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    Termination::enum_type enum_val = (enum_name != NULL) ? Termination::str_to_enum(enum_name) : Termination::UNKNOWN_VALUE;
    if (Termination::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Termination_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    Termination::enum_type enum_val = Termination::str_to_enum(mp->get_enumerated());
    if (!Termination::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @DENM-PDU-Descriptions.Termination.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@DENM-PDU-Descriptions.Termination");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Termination_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(Termination::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Termination_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DENM-PDU-Descriptions.Termination");
}

DecentralizedEnvironmentalNotificationMessage::DecentralizedEnvironmentalNotificationMessage()
{
  bound_flag = FALSE;
}

DecentralizedEnvironmentalNotificationMessage::DecentralizedEnvironmentalNotificationMessage(const ManagementContainer& par_management,
    const OPTIONAL<SituationContainer>& par_situation,
    const OPTIONAL<LocationContainer>& par_location,
    const OPTIONAL<AlacarteContainer>& par_alacarte)
  :   field_management(par_management),
  field_situation(par_situation),
  field_location(par_location),
  field_alacarte(par_alacarte)
{
  bound_flag = TRUE;
}

DecentralizedEnvironmentalNotificationMessage::DecentralizedEnvironmentalNotificationMessage(const DecentralizedEnvironmentalNotificationMessage& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
bound_flag = TRUE;
if (other_value.management().is_bound()) field_management = other_value.management();
else field_management.clean_up();
if (other_value.situation().is_bound()) field_situation = other_value.situation();
else field_situation.clean_up();
if (other_value.location().is_bound()) field_location = other_value.location();
else field_location.clean_up();
if (other_value.alacarte().is_bound()) field_alacarte = other_value.alacarte();
else field_alacarte.clean_up();
}

void DecentralizedEnvironmentalNotificationMessage::clean_up()
{
field_management.clean_up();
field_situation.clean_up();
field_location.clean_up();
field_alacarte.clean_up();
bound_flag = FALSE;
}

DecentralizedEnvironmentalNotificationMessage& DecentralizedEnvironmentalNotificationMessage::operator=(const DecentralizedEnvironmentalNotificationMessage& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
  bound_flag = TRUE;
  if (other_value.management().is_bound()) field_management = other_value.management();
  else field_management.clean_up();
  if (other_value.situation().is_bound()) field_situation = other_value.situation();
  else field_situation.clean_up();
  if (other_value.location().is_bound()) field_location = other_value.location();
  else field_location.clean_up();
  if (other_value.alacarte().is_bound()) field_alacarte = other_value.alacarte();
  else field_alacarte.clean_up();
}
return *this;
}

boolean DecentralizedEnvironmentalNotificationMessage::operator==(const DecentralizedEnvironmentalNotificationMessage& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_management==other_value.field_management
  && field_situation==other_value.field_situation
  && field_location==other_value.field_location
  && field_alacarte==other_value.field_alacarte;
}

boolean DecentralizedEnvironmentalNotificationMessage::is_bound() const
{
if (bound_flag) return TRUE;
if(field_management.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_situation.get_selection() || field_situation.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_location.get_selection() || field_location.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_alacarte.get_selection() || field_alacarte.is_bound()) return TRUE;
return FALSE;
}
boolean DecentralizedEnvironmentalNotificationMessage::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_management.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_situation.get_selection() && !field_situation.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_location.get_selection() && !field_location.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_alacarte.get_selection() && !field_alacarte.is_value()) return FALSE;
return TRUE;
}
int DecentralizedEnvironmentalNotificationMessage::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage");
  int ret_val = 1;
  if (field_situation.ispresent()) ret_val++;
  if (field_location.ispresent()) ret_val++;
  if (field_alacarte.ispresent()) ret_val++;
  return ret_val;
}

void DecentralizedEnvironmentalNotificationMessage::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ management := ");
field_management.log();
TTCN_Logger::log_event_str(", situation := ");
field_situation.log();
TTCN_Logger::log_event_str(", location := ");
field_location.log();
TTCN_Logger::log_event_str(", alacarte := ");
field_alacarte.log();
TTCN_Logger::log_event_str(" }");
}

void DecentralizedEnvironmentalNotificationMessage::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage'");
    }
    if (strcmp("management", param_field) == 0) {
      management().set_param(param);
      return;
    } else if (strcmp("situation", param_field) == 0) {
      situation().set_param(param);
      return;
    } else if (strcmp("location", param_field) == 0) {
      location().set_param(param);
      return;
    } else if (strcmp("alacarte", param_field) == 0) {
      alacarte().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) management().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) situation().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) location().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) alacarte().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "management")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          management().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "situation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          situation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "location")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          location().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "alacarte")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          alacarte().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage");
  }
}

Module_Param* DecentralizedEnvironmentalNotificationMessage::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage'");
    }
    if (strcmp("management", param_field) == 0) {
      return management().get_param(param_name);
    } else if (strcmp("situation", param_field) == 0) {
      return situation().get_param(param_name);
    } else if (strcmp("location", param_field) == 0) {
      return location().get_param(param_name);
    } else if (strcmp("alacarte", param_field) == 0) {
      return alacarte().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_management = field_management.get_param(param_name);
  mp_field_management->set_id(new Module_Param_FieldName(mcopystr("management")));
  mp->add_elem(mp_field_management);
  Module_Param* mp_field_situation = field_situation.get_param(param_name);
  mp_field_situation->set_id(new Module_Param_FieldName(mcopystr("situation")));
  mp->add_elem(mp_field_situation);
  Module_Param* mp_field_location = field_location.get_param(param_name);
  mp_field_location->set_id(new Module_Param_FieldName(mcopystr("location")));
  mp->add_elem(mp_field_location);
  Module_Param* mp_field_alacarte = field_alacarte.get_param(param_name);
  mp_field_alacarte->set_id(new Module_Param_FieldName(mcopystr("alacarte")));
  mp->add_elem(mp_field_alacarte);
  return mp;
  }

void DecentralizedEnvironmentalNotificationMessage::set_implicit_omit()
{
if (management().is_bound()) management().set_implicit_omit();
if (!situation().is_bound()) situation() = OMIT_VALUE;
else situation().set_implicit_omit();
if (!location().is_bound()) location() = OMIT_VALUE;
else location().set_implicit_omit();
if (!alacarte().is_bound()) alacarte() = OMIT_VALUE;
else alacarte().set_implicit_omit();
}

void DecentralizedEnvironmentalNotificationMessage::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
field_management.encode_text(text_buf);
field_situation.encode_text(text_buf);
field_location.encode_text(text_buf);
field_alacarte.encode_text(text_buf);
}

void DecentralizedEnvironmentalNotificationMessage::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_management.decode_text(text_buf);
field_situation.decode_text(text_buf);
field_location.decode_text(text_buf);
field_alacarte.decode_text(text_buf);
}

void DecentralizedEnvironmentalNotificationMessage::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void DecentralizedEnvironmentalNotificationMessage::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* DecentralizedEnvironmentalNotificationMessage::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("management': ");
  new_tlv->add_TLV(field_management.BER_encode_TLV(DecentralizedEnvironmentalNotificationMessage_management_descr_, p_coding));
  ec_1.set_msg("situation': ");
  new_tlv->add_TLV(field_situation.BER_encode_TLV(DecentralizedEnvironmentalNotificationMessage_situation_descr_, p_coding));
  ec_1.set_msg("location': ");
  new_tlv->add_TLV(field_location.BER_encode_TLV(DecentralizedEnvironmentalNotificationMessage_location_descr_, p_coding));
  ec_1.set_msg("alacarte': ");
  new_tlv->add_TLV(field_alacarte.BER_encode_TLV(DecentralizedEnvironmentalNotificationMessage_alacarte_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean DecentralizedEnvironmentalNotificationMessage::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("management': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_management.BER_decode_TLV(DecentralizedEnvironmentalNotificationMessage_management_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("situation': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_situation=OMIT_VALUE;
    else {
      field_situation.BER_decode_TLV(DecentralizedEnvironmentalNotificationMessage_situation_descr_, tmp_tlv, L_form);
      if(field_situation.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("location': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_location=OMIT_VALUE;
    else {
      field_location.BER_decode_TLV(DecentralizedEnvironmentalNotificationMessage_location_descr_, tmp_tlv, L_form);
      if(field_location.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("alacarte': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_alacarte=OMIT_VALUE;
    else {
      field_alacarte.BER_decode_TLV(DecentralizedEnvironmentalNotificationMessage_alacarte_descr_, tmp_tlv, L_form);
      if(field_alacarte.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int DecentralizedEnvironmentalNotificationMessage::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "management");
    enc_len += field_management.JSON_encode(DecentralizedEnvironmentalNotificationMessage_management_descr_, p_tok);
  }

  if (field_situation.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "situation");
    enc_len += field_situation.JSON_encode(DecentralizedEnvironmentalNotificationMessage_situation_descr_, p_tok);
  }

  if (field_location.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "location");
    enc_len += field_location.JSON_encode(DecentralizedEnvironmentalNotificationMessage_location_descr_, p_tok);
  }

  if (field_alacarte.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "alacarte");
    enc_len += field_alacarte.JSON_encode(DecentralizedEnvironmentalNotificationMessage_alacarte_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int DecentralizedEnvironmentalNotificationMessage::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "management", name_len)) {
         int ret_val = field_management.JSON_decode(DecentralizedEnvironmentalNotificationMessage_management_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "management");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "situation", name_len)) {
         int ret_val = field_situation.JSON_decode(DecentralizedEnvironmentalNotificationMessage_situation_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "situation");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "location", name_len)) {
         int ret_val = field_location.JSON_decode(DecentralizedEnvironmentalNotificationMessage_location_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "location");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "alacarte", name_len)) {
         int ret_val = field_alacarte.JSON_decode(DecentralizedEnvironmentalNotificationMessage_alacarte_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "alacarte");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_management.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "management");
    return JSON_ERROR_FATAL;
  }
if (!field_situation.is_bound()) {
    field_situation = OMIT_VALUE;
  }
if (!field_location.is_bound()) {
    field_location = OMIT_VALUE;
  }
if (!field_alacarte.is_bound()) {
    field_alacarte = OMIT_VALUE;
  }

  return dec_len;
}

struct DecentralizedEnvironmentalNotificationMessage_template::single_value_struct {
ManagementContainer_template field_management;
SituationContainer_template field_situation;
LocationContainer_template field_location;
AlacarteContainer_template field_alacarte;
};

void DecentralizedEnvironmentalNotificationMessage_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_management = ANY_VALUE;
single_value->field_situation = ANY_OR_OMIT;
single_value->field_location = ANY_OR_OMIT;
single_value->field_alacarte = ANY_OR_OMIT;
}
}
}

void DecentralizedEnvironmentalNotificationMessage_template::copy_value(const DecentralizedEnvironmentalNotificationMessage& other_value)
{
single_value = new single_value_struct;
if (other_value.management().is_bound()) {
  single_value->field_management = other_value.management();
} else {
  single_value->field_management.clean_up();
}
if (other_value.situation().is_bound()) {
  if (other_value.situation().ispresent()) single_value->field_situation = other_value.situation()();
  else single_value->field_situation = OMIT_VALUE;
} else {
  single_value->field_situation.clean_up();
}
if (other_value.location().is_bound()) {
  if (other_value.location().ispresent()) single_value->field_location = other_value.location()();
  else single_value->field_location = OMIT_VALUE;
} else {
  single_value->field_location.clean_up();
}
if (other_value.alacarte().is_bound()) {
  if (other_value.alacarte().ispresent()) single_value->field_alacarte = other_value.alacarte()();
  else single_value->field_alacarte = OMIT_VALUE;
} else {
  single_value->field_alacarte.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void DecentralizedEnvironmentalNotificationMessage_template::copy_template(const DecentralizedEnvironmentalNotificationMessage_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.management().get_selection()) {
single_value->field_management = other_value.management();
} else {
single_value->field_management.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.situation().get_selection()) {
single_value->field_situation = other_value.situation();
} else {
single_value->field_situation.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.location().get_selection()) {
single_value->field_location = other_value.location();
} else {
single_value->field_location.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.alacarte().get_selection()) {
single_value->field_alacarte = other_value.alacarte();
} else {
single_value->field_alacarte.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new DecentralizedEnvironmentalNotificationMessage_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
break;
}
set_selection(other_value);
}

DecentralizedEnvironmentalNotificationMessage_template::DecentralizedEnvironmentalNotificationMessage_template()
{
}

DecentralizedEnvironmentalNotificationMessage_template::DecentralizedEnvironmentalNotificationMessage_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

DecentralizedEnvironmentalNotificationMessage_template::DecentralizedEnvironmentalNotificationMessage_template(const DecentralizedEnvironmentalNotificationMessage& other_value)
{
copy_value(other_value);
}

DecentralizedEnvironmentalNotificationMessage_template::DecentralizedEnvironmentalNotificationMessage_template(const OPTIONAL<DecentralizedEnvironmentalNotificationMessage>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DecentralizedEnvironmentalNotificationMessage&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage from an unbound optional field.");
}
}

DecentralizedEnvironmentalNotificationMessage_template::DecentralizedEnvironmentalNotificationMessage_template(const DecentralizedEnvironmentalNotificationMessage_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

DecentralizedEnvironmentalNotificationMessage_template::~DecentralizedEnvironmentalNotificationMessage_template()
{
clean_up();
}

DecentralizedEnvironmentalNotificationMessage_template& DecentralizedEnvironmentalNotificationMessage_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

DecentralizedEnvironmentalNotificationMessage_template& DecentralizedEnvironmentalNotificationMessage_template::operator=(const DecentralizedEnvironmentalNotificationMessage& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

DecentralizedEnvironmentalNotificationMessage_template& DecentralizedEnvironmentalNotificationMessage_template::operator=(const OPTIONAL<DecentralizedEnvironmentalNotificationMessage>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DecentralizedEnvironmentalNotificationMessage&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
}
return *this;
}

DecentralizedEnvironmentalNotificationMessage_template& DecentralizedEnvironmentalNotificationMessage_template::operator=(const DecentralizedEnvironmentalNotificationMessage_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean DecentralizedEnvironmentalNotificationMessage_template::match(const DecentralizedEnvironmentalNotificationMessage& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.management().is_bound()) return FALSE;
if(!single_value->field_management.match(other_value.management(), legacy))return FALSE;
if(!other_value.situation().is_bound()) return FALSE;
if((other_value.situation().ispresent() ? !single_value->field_situation.match((const SituationContainer&)other_value.situation(), legacy) : !single_value->field_situation.match_omit(legacy)))return FALSE;
if(!other_value.location().is_bound()) return FALSE;
if((other_value.location().ispresent() ? !single_value->field_location.match((const LocationContainer&)other_value.location(), legacy) : !single_value->field_location.match_omit(legacy)))return FALSE;
if(!other_value.alacarte().is_bound()) return FALSE;
if((other_value.alacarte().ispresent() ? !single_value->field_alacarte.match((const AlacarteContainer&)other_value.alacarte(), legacy) : !single_value->field_alacarte.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
}
return FALSE;
}

boolean DecentralizedEnvironmentalNotificationMessage_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_management.is_bound()) return TRUE;
if (single_value->field_situation.is_omit() || single_value->field_situation.is_bound()) return TRUE;
if (single_value->field_location.is_omit() || single_value->field_location.is_bound()) return TRUE;
if (single_value->field_alacarte.is_omit() || single_value->field_alacarte.is_bound()) return TRUE;
return FALSE;
}

boolean DecentralizedEnvironmentalNotificationMessage_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_management.is_value()) return FALSE;
if (!single_value->field_situation.is_omit() && !single_value->field_situation.is_value()) return FALSE;
if (!single_value->field_location.is_omit() && !single_value->field_location.is_value()) return FALSE;
if (!single_value->field_alacarte.is_omit() && !single_value->field_alacarte.is_value()) return FALSE;
return TRUE;
}

void DecentralizedEnvironmentalNotificationMessage_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

DecentralizedEnvironmentalNotificationMessage DecentralizedEnvironmentalNotificationMessage_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
DecentralizedEnvironmentalNotificationMessage ret_val;
if (single_value->field_management.is_bound()) {
ret_val.management() = single_value->field_management.valueof();
}
if (single_value->field_situation.is_omit()) ret_val.situation() = OMIT_VALUE;
else if (single_value->field_situation.is_bound()) {
ret_val.situation() = single_value->field_situation.valueof();
}
if (single_value->field_location.is_omit()) ret_val.location() = OMIT_VALUE;
else if (single_value->field_location.is_bound()) {
ret_val.location() = single_value->field_location.valueof();
}
if (single_value->field_alacarte.is_omit()) ret_val.alacarte() = OMIT_VALUE;
else if (single_value->field_alacarte.is_bound()) {
ret_val.alacarte() = single_value->field_alacarte.valueof();
}
return ret_val;
}

void DecentralizedEnvironmentalNotificationMessage_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new DecentralizedEnvironmentalNotificationMessage_template[list_length];
}

DecentralizedEnvironmentalNotificationMessage_template& DecentralizedEnvironmentalNotificationMessage_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
return value_list.list_value[list_index];
}

ManagementContainer_template& DecentralizedEnvironmentalNotificationMessage_template::management()
{
set_specific();
return single_value->field_management;
}

const ManagementContainer_template& DecentralizedEnvironmentalNotificationMessage_template::management() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field management of a non-specific template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
return single_value->field_management;
}

SituationContainer_template& DecentralizedEnvironmentalNotificationMessage_template::situation()
{
set_specific();
return single_value->field_situation;
}

const SituationContainer_template& DecentralizedEnvironmentalNotificationMessage_template::situation() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field situation of a non-specific template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
return single_value->field_situation;
}

LocationContainer_template& DecentralizedEnvironmentalNotificationMessage_template::location()
{
set_specific();
return single_value->field_location;
}

const LocationContainer_template& DecentralizedEnvironmentalNotificationMessage_template::location() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field location of a non-specific template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
return single_value->field_location;
}

AlacarteContainer_template& DecentralizedEnvironmentalNotificationMessage_template::alacarte()
{
set_specific();
return single_value->field_alacarte;
}

const AlacarteContainer_template& DecentralizedEnvironmentalNotificationMessage_template::alacarte() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field alacarte of a non-specific template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
return single_value->field_alacarte;
}

int DecentralizedEnvironmentalNotificationMessage_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_situation.is_present()) ret_val++;
      if (single_value->field_location.is_present()) ret_val++;
      if (single_value->field_alacarte.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
  }
  return 0;
}

void DecentralizedEnvironmentalNotificationMessage_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ management := ");
single_value->field_management.log();
TTCN_Logger::log_event_str(", situation := ");
single_value->field_situation.log();
TTCN_Logger::log_event_str(", location := ");
single_value->field_location.log();
TTCN_Logger::log_event_str(", alacarte := ");
single_value->field_alacarte.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void DecentralizedEnvironmentalNotificationMessage_template::log_match(const DecentralizedEnvironmentalNotificationMessage& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_management.match(match_value.management(), legacy)){
TTCN_Logger::log_logmatch_info(".management");
single_value->field_management.log_match(match_value.management(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.situation().ispresent()){
if(!single_value->field_situation.match(match_value.situation(), legacy)){
TTCN_Logger::log_logmatch_info(".situation");
single_value->field_situation.log_match(match_value.situation(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_situation.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".situation := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_situation.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.location().ispresent()){
if(!single_value->field_location.match(match_value.location(), legacy)){
TTCN_Logger::log_logmatch_info(".location");
single_value->field_location.log_match(match_value.location(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_location.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".location := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_location.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.alacarte().ispresent()){
if(!single_value->field_alacarte.match(match_value.alacarte(), legacy)){
TTCN_Logger::log_logmatch_info(".alacarte");
single_value->field_alacarte.log_match(match_value.alacarte(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_alacarte.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".alacarte := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_alacarte.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ management := ");
single_value->field_management.log_match(match_value.management(), legacy);
TTCN_Logger::log_event_str(", situation := ");
if (match_value.situation().ispresent()) single_value->field_situation.log_match(match_value.situation(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_situation.log();
if (single_value->field_situation.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", location := ");
if (match_value.location().ispresent()) single_value->field_location.log_match(match_value.location(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_location.log();
if (single_value->field_location.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", alacarte := ");
if (match_value.alacarte().ispresent()) single_value->field_alacarte.log_match(match_value.alacarte(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_alacarte.log();
if (single_value->field_alacarte.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void DecentralizedEnvironmentalNotificationMessage_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_management.encode_text(text_buf);
single_value->field_situation.encode_text(text_buf);
single_value->field_location.encode_text(text_buf);
single_value->field_alacarte.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
}
}

void DecentralizedEnvironmentalNotificationMessage_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_management.decode_text(text_buf);
single_value->field_situation.decode_text(text_buf);
single_value->field_location.decode_text(text_buf);
single_value->field_alacarte.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new DecentralizedEnvironmentalNotificationMessage_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage.");
}
}

void DecentralizedEnvironmentalNotificationMessage_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage'");
    }
    if (strcmp("management", param_field) == 0) {
      management().set_param(param);
      return;
    } else if (strcmp("situation", param_field) == 0) {
      situation().set_param(param);
      return;
    } else if (strcmp("location", param_field) == 0) {
      location().set_param(param);
      return;
    } else if (strcmp("alacarte", param_field) == 0) {
      alacarte().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    DecentralizedEnvironmentalNotificationMessage_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) management().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) situation().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) location().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) alacarte().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "management")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          management().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "situation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          situation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "location")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          location().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "alacarte")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          alacarte().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* DecentralizedEnvironmentalNotificationMessage_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage'");
    }
    if (strcmp("management", param_field) == 0) {
      return management().get_param(param_name);
    } else if (strcmp("situation", param_field) == 0) {
      return situation().get_param(param_name);
    } else if (strcmp("location", param_field) == 0) {
      return location().get_param(param_name);
    } else if (strcmp("alacarte", param_field) == 0) {
      return alacarte().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_management = single_value->field_management.get_param(param_name);
    mp_field_management->set_id(new Module_Param_FieldName(mcopystr("management")));
    mp->add_elem(mp_field_management);
    Module_Param* mp_field_situation = single_value->field_situation.get_param(param_name);
    mp_field_situation->set_id(new Module_Param_FieldName(mcopystr("situation")));
    mp->add_elem(mp_field_situation);
    Module_Param* mp_field_location = single_value->field_location.get_param(param_name);
    mp_field_location->set_id(new Module_Param_FieldName(mcopystr("location")));
    mp->add_elem(mp_field_location);
    Module_Param* mp_field_alacarte = single_value->field_alacarte.get_param(param_name);
    mp_field_alacarte->set_id(new Module_Param_FieldName(mcopystr("alacarte")));
    mp->add_elem(mp_field_alacarte);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void DecentralizedEnvironmentalNotificationMessage_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_management.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage");
single_value->field_situation.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage");
single_value->field_location.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage");
single_value->field_alacarte.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DENM-PDU-Descriptions.DecentralizedEnvironmentalNotificationMessage");
}

boolean DecentralizedEnvironmentalNotificationMessage_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean DecentralizedEnvironmentalNotificationMessage_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SituationContainer::SituationContainer()
{
  bound_flag = FALSE;
}

SituationContainer::SituationContainer(const INTEGER& par_informationQuality,
    const ITS__Container::CauseCode& par_eventType,
    const OPTIONAL<ITS__Container::CauseCode>& par_linkedCause,
    const OPTIONAL<ITS__Container::EventHistory>& par_eventHistory)
  :   field_informationQuality(par_informationQuality),
  field_eventType(par_eventType),
  field_linkedCause(par_linkedCause),
  field_eventHistory(par_eventHistory)
{
  bound_flag = TRUE;
}

SituationContainer::SituationContainer(const SituationContainer& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DENM-PDU-Descriptions.SituationContainer.");
bound_flag = TRUE;
if (other_value.informationQuality().is_bound()) field_informationQuality = other_value.informationQuality();
else field_informationQuality.clean_up();
if (other_value.eventType().is_bound()) field_eventType = other_value.eventType();
else field_eventType.clean_up();
if (other_value.linkedCause().is_bound()) field_linkedCause = other_value.linkedCause();
else field_linkedCause.clean_up();
if (other_value.eventHistory().is_bound()) field_eventHistory = other_value.eventHistory();
else field_eventHistory.clean_up();
}

void SituationContainer::clean_up()
{
field_informationQuality.clean_up();
field_eventType.clean_up();
field_linkedCause.clean_up();
field_eventHistory.clean_up();
bound_flag = FALSE;
}

SituationContainer& SituationContainer::operator=(const SituationContainer& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DENM-PDU-Descriptions.SituationContainer.");
  bound_flag = TRUE;
  if (other_value.informationQuality().is_bound()) field_informationQuality = other_value.informationQuality();
  else field_informationQuality.clean_up();
  if (other_value.eventType().is_bound()) field_eventType = other_value.eventType();
  else field_eventType.clean_up();
  if (other_value.linkedCause().is_bound()) field_linkedCause = other_value.linkedCause();
  else field_linkedCause.clean_up();
  if (other_value.eventHistory().is_bound()) field_eventHistory = other_value.eventHistory();
  else field_eventHistory.clean_up();
}
return *this;
}

boolean SituationContainer::operator==(const SituationContainer& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_informationQuality==other_value.field_informationQuality
  && field_eventType==other_value.field_eventType
  && field_linkedCause==other_value.field_linkedCause
  && field_eventHistory==other_value.field_eventHistory;
}

boolean SituationContainer::is_bound() const
{
if (bound_flag) return TRUE;
if(field_informationQuality.is_bound()) return TRUE;
if(field_eventType.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_linkedCause.get_selection() || field_linkedCause.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_eventHistory.get_selection() || field_eventHistory.is_bound()) return TRUE;
return FALSE;
}
boolean SituationContainer::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_informationQuality.is_value()) return FALSE;
if(!field_eventType.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_linkedCause.get_selection() && !field_linkedCause.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_eventHistory.get_selection() && !field_eventHistory.is_value()) return FALSE;
return TRUE;
}
int SituationContainer::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DENM-PDU-Descriptions.SituationContainer");
  int ret_val = 2;
  if (field_linkedCause.ispresent()) ret_val++;
  if (field_eventHistory.ispresent()) ret_val++;
  return ret_val;
}

void SituationContainer::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ informationQuality := ");
field_informationQuality.log();
TTCN_Logger::log_event_str(", eventType := ");
field_eventType.log();
TTCN_Logger::log_event_str(", linkedCause := ");
field_linkedCause.log();
TTCN_Logger::log_event_str(", eventHistory := ");
field_eventHistory.log();
TTCN_Logger::log_event_str(" }");
}

void SituationContainer::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DENM-PDU-Descriptions.SituationContainer'");
    }
    if (strcmp("informationQuality", param_field) == 0) {
      informationQuality().set_param(param);
      return;
    } else if (strcmp("eventType", param_field) == 0) {
      eventType().set_param(param);
      return;
    } else if (strcmp("linkedCause", param_field) == 0) {
      linkedCause().set_param(param);
      return;
    } else if (strcmp("eventHistory", param_field) == 0) {
      eventHistory().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DENM-PDU-Descriptions.SituationContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @DENM-PDU-Descriptions.SituationContainer has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) informationQuality().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) eventType().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) linkedCause().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) eventHistory().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "informationQuality")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          informationQuality().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eventType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eventType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "linkedCause")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          linkedCause().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eventHistory")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eventHistory().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.SituationContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DENM-PDU-Descriptions.SituationContainer");
  }
}

Module_Param* SituationContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DENM-PDU-Descriptions.SituationContainer'");
    }
    if (strcmp("informationQuality", param_field) == 0) {
      return informationQuality().get_param(param_name);
    } else if (strcmp("eventType", param_field) == 0) {
      return eventType().get_param(param_name);
    } else if (strcmp("linkedCause", param_field) == 0) {
      return linkedCause().get_param(param_name);
    } else if (strcmp("eventHistory", param_field) == 0) {
      return eventHistory().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.SituationContainer'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_informationQuality = field_informationQuality.get_param(param_name);
  mp_field_informationQuality->set_id(new Module_Param_FieldName(mcopystr("informationQuality")));
  mp->add_elem(mp_field_informationQuality);
  Module_Param* mp_field_eventType = field_eventType.get_param(param_name);
  mp_field_eventType->set_id(new Module_Param_FieldName(mcopystr("eventType")));
  mp->add_elem(mp_field_eventType);
  Module_Param* mp_field_linkedCause = field_linkedCause.get_param(param_name);
  mp_field_linkedCause->set_id(new Module_Param_FieldName(mcopystr("linkedCause")));
  mp->add_elem(mp_field_linkedCause);
  Module_Param* mp_field_eventHistory = field_eventHistory.get_param(param_name);
  mp_field_eventHistory->set_id(new Module_Param_FieldName(mcopystr("eventHistory")));
  mp->add_elem(mp_field_eventHistory);
  return mp;
  }

void SituationContainer::set_implicit_omit()
{
if (informationQuality().is_bound()) informationQuality().set_implicit_omit();
if (eventType().is_bound()) eventType().set_implicit_omit();
if (!linkedCause().is_bound()) linkedCause() = OMIT_VALUE;
else linkedCause().set_implicit_omit();
if (!eventHistory().is_bound()) eventHistory() = OMIT_VALUE;
else eventHistory().set_implicit_omit();
}

void SituationContainer::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DENM-PDU-Descriptions.SituationContainer.");
field_informationQuality.encode_text(text_buf);
field_eventType.encode_text(text_buf);
field_linkedCause.encode_text(text_buf);
field_eventHistory.encode_text(text_buf);
}

void SituationContainer::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_informationQuality.decode_text(text_buf);
field_eventType.decode_text(text_buf);
field_linkedCause.decode_text(text_buf);
field_eventHistory.decode_text(text_buf);
}

void SituationContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SituationContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* SituationContainer::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("informationQuality': ");
  new_tlv->add_TLV(field_informationQuality.BER_encode_TLV(SituationContainer_informationQuality_descr_, p_coding));
  ec_1.set_msg("eventType': ");
  new_tlv->add_TLV(field_eventType.BER_encode_TLV(SituationContainer_eventType_descr_, p_coding));
  ec_1.set_msg("linkedCause': ");
  new_tlv->add_TLV(field_linkedCause.BER_encode_TLV(SituationContainer_linkedCause_descr_, p_coding));
  ec_1.set_msg("eventHistory': ");
  new_tlv->add_TLV(field_eventHistory.BER_encode_TLV(SituationContainer_eventHistory_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean SituationContainer::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DENM-PDU-Descriptions.SituationContainer' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("informationQuality': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_informationQuality.BER_decode_TLV(SituationContainer_informationQuality_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("eventType': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_eventType.BER_decode_TLV(SituationContainer_eventType_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("linkedCause': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_linkedCause=OMIT_VALUE;
    else {
      field_linkedCause.BER_decode_TLV(SituationContainer_linkedCause_descr_, tmp_tlv, L_form);
      if(field_linkedCause.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("eventHistory': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_eventHistory=OMIT_VALUE;
    else {
      field_eventHistory.BER_decode_TLV(SituationContainer_eventHistory_descr_, tmp_tlv, L_form);
      if(field_eventHistory.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int SituationContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DENM-PDU-Descriptions.SituationContainer.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "informationQuality");
    enc_len += field_informationQuality.JSON_encode(SituationContainer_informationQuality_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "eventType");
    enc_len += field_eventType.JSON_encode(SituationContainer_eventType_descr_, p_tok);
  }

  if (field_linkedCause.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "linkedCause");
    enc_len += field_linkedCause.JSON_encode(SituationContainer_linkedCause_descr_, p_tok);
  }

  if (field_eventHistory.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "eventHistory");
    enc_len += field_eventHistory.JSON_encode(SituationContainer_eventHistory_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SituationContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (18 == name_len && 0 == strncmp(fld_name, "informationQuality", name_len)) {
         int ret_val = field_informationQuality.JSON_decode(SituationContainer_informationQuality_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "informationQuality");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "eventType", name_len)) {
         int ret_val = field_eventType.JSON_decode(SituationContainer_eventType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "eventType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "linkedCause", name_len)) {
         int ret_val = field_linkedCause.JSON_decode(SituationContainer_linkedCause_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "linkedCause");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "eventHistory", name_len)) {
         int ret_val = field_eventHistory.JSON_decode(SituationContainer_eventHistory_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "eventHistory");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_informationQuality.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "informationQuality");
    return JSON_ERROR_FATAL;
  }
if (!field_eventType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "eventType");
    return JSON_ERROR_FATAL;
  }
if (!field_linkedCause.is_bound()) {
    field_linkedCause = OMIT_VALUE;
  }
if (!field_eventHistory.is_bound()) {
    field_eventHistory = OMIT_VALUE;
  }

  return dec_len;
}

struct SituationContainer_template::single_value_struct {
INTEGER_template field_informationQuality;
ITS__Container::CauseCode_template field_eventType;
ITS__Container::CauseCode_template field_linkedCause;
ITS__Container::EventHistory_template field_eventHistory;
};

void SituationContainer_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_informationQuality = ANY_VALUE;
single_value->field_eventType = ANY_VALUE;
single_value->field_linkedCause = ANY_OR_OMIT;
single_value->field_eventHistory = ANY_OR_OMIT;
}
}
}

void SituationContainer_template::copy_value(const SituationContainer& other_value)
{
single_value = new single_value_struct;
if (other_value.informationQuality().is_bound()) {
  single_value->field_informationQuality = other_value.informationQuality();
} else {
  single_value->field_informationQuality.clean_up();
}
if (other_value.eventType().is_bound()) {
  single_value->field_eventType = other_value.eventType();
} else {
  single_value->field_eventType.clean_up();
}
if (other_value.linkedCause().is_bound()) {
  if (other_value.linkedCause().ispresent()) single_value->field_linkedCause = other_value.linkedCause()();
  else single_value->field_linkedCause = OMIT_VALUE;
} else {
  single_value->field_linkedCause.clean_up();
}
if (other_value.eventHistory().is_bound()) {
  if (other_value.eventHistory().ispresent()) single_value->field_eventHistory = other_value.eventHistory()();
  else single_value->field_eventHistory = OMIT_VALUE;
} else {
  single_value->field_eventHistory.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SituationContainer_template::copy_template(const SituationContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.informationQuality().get_selection()) {
single_value->field_informationQuality = other_value.informationQuality();
} else {
single_value->field_informationQuality.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.eventType().get_selection()) {
single_value->field_eventType = other_value.eventType();
} else {
single_value->field_eventType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.linkedCause().get_selection()) {
single_value->field_linkedCause = other_value.linkedCause();
} else {
single_value->field_linkedCause.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.eventHistory().get_selection()) {
single_value->field_eventHistory = other_value.eventHistory();
} else {
single_value->field_eventHistory.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SituationContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DENM-PDU-Descriptions.SituationContainer.");
break;
}
set_selection(other_value);
}

SituationContainer_template::SituationContainer_template()
{
}

SituationContainer_template::SituationContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SituationContainer_template::SituationContainer_template(const SituationContainer& other_value)
{
copy_value(other_value);
}

SituationContainer_template::SituationContainer_template(const OPTIONAL<SituationContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SituationContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DENM-PDU-Descriptions.SituationContainer from an unbound optional field.");
}
}

SituationContainer_template::SituationContainer_template(const SituationContainer_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SituationContainer_template::~SituationContainer_template()
{
clean_up();
}

SituationContainer_template& SituationContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SituationContainer_template& SituationContainer_template::operator=(const SituationContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SituationContainer_template& SituationContainer_template::operator=(const OPTIONAL<SituationContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SituationContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DENM-PDU-Descriptions.SituationContainer.");
}
return *this;
}

SituationContainer_template& SituationContainer_template::operator=(const SituationContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SituationContainer_template::match(const SituationContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.informationQuality().is_bound()) return FALSE;
if(!single_value->field_informationQuality.match(other_value.informationQuality(), legacy))return FALSE;
if(!other_value.eventType().is_bound()) return FALSE;
if(!single_value->field_eventType.match(other_value.eventType(), legacy))return FALSE;
if(!other_value.linkedCause().is_bound()) return FALSE;
if((other_value.linkedCause().ispresent() ? !single_value->field_linkedCause.match((const ITS__Container::CauseCode&)other_value.linkedCause(), legacy) : !single_value->field_linkedCause.match_omit(legacy)))return FALSE;
if(!other_value.eventHistory().is_bound()) return FALSE;
if((other_value.eventHistory().ispresent() ? !single_value->field_eventHistory.match((const ITS__Container::EventHistory&)other_value.eventHistory(), legacy) : !single_value->field_eventHistory.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DENM-PDU-Descriptions.SituationContainer.");
}
return FALSE;
}

boolean SituationContainer_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_informationQuality.is_bound()) return TRUE;
if (single_value->field_eventType.is_bound()) return TRUE;
if (single_value->field_linkedCause.is_omit() || single_value->field_linkedCause.is_bound()) return TRUE;
if (single_value->field_eventHistory.is_omit() || single_value->field_eventHistory.is_bound()) return TRUE;
return FALSE;
}

boolean SituationContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_informationQuality.is_value()) return FALSE;
if (!single_value->field_eventType.is_value()) return FALSE;
if (!single_value->field_linkedCause.is_omit() && !single_value->field_linkedCause.is_value()) return FALSE;
if (!single_value->field_eventHistory.is_omit() && !single_value->field_eventHistory.is_value()) return FALSE;
return TRUE;
}

void SituationContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SituationContainer SituationContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DENM-PDU-Descriptions.SituationContainer.");
SituationContainer ret_val;
if (single_value->field_informationQuality.is_bound()) {
ret_val.informationQuality() = single_value->field_informationQuality.valueof();
}
if (single_value->field_eventType.is_bound()) {
ret_val.eventType() = single_value->field_eventType.valueof();
}
if (single_value->field_linkedCause.is_omit()) ret_val.linkedCause() = OMIT_VALUE;
else if (single_value->field_linkedCause.is_bound()) {
ret_val.linkedCause() = single_value->field_linkedCause.valueof();
}
if (single_value->field_eventHistory.is_omit()) ret_val.eventHistory() = OMIT_VALUE;
else if (single_value->field_eventHistory.is_bound()) {
ret_val.eventHistory() = single_value->field_eventHistory.valueof();
}
return ret_val;
}

void SituationContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DENM-PDU-Descriptions.SituationContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SituationContainer_template[list_length];
}

SituationContainer_template& SituationContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DENM-PDU-Descriptions.SituationContainer.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DENM-PDU-Descriptions.SituationContainer.");
return value_list.list_value[list_index];
}

INTEGER_template& SituationContainer_template::informationQuality()
{
set_specific();
return single_value->field_informationQuality;
}

const INTEGER_template& SituationContainer_template::informationQuality() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field informationQuality of a non-specific template of type @DENM-PDU-Descriptions.SituationContainer.");
return single_value->field_informationQuality;
}

ITS__Container::CauseCode_template& SituationContainer_template::eventType()
{
set_specific();
return single_value->field_eventType;
}

const ITS__Container::CauseCode_template& SituationContainer_template::eventType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field eventType of a non-specific template of type @DENM-PDU-Descriptions.SituationContainer.");
return single_value->field_eventType;
}

ITS__Container::CauseCode_template& SituationContainer_template::linkedCause()
{
set_specific();
return single_value->field_linkedCause;
}

const ITS__Container::CauseCode_template& SituationContainer_template::linkedCause() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field linkedCause of a non-specific template of type @DENM-PDU-Descriptions.SituationContainer.");
return single_value->field_linkedCause;
}

ITS__Container::EventHistory_template& SituationContainer_template::eventHistory()
{
set_specific();
return single_value->field_eventHistory;
}

const ITS__Container::EventHistory_template& SituationContainer_template::eventHistory() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field eventHistory of a non-specific template of type @DENM-PDU-Descriptions.SituationContainer.");
return single_value->field_eventHistory;
}

int SituationContainer_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.SituationContainer which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 2;
      if (single_value->field_linkedCause.is_present()) ret_val++;
      if (single_value->field_eventHistory.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.SituationContainer containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.SituationContainer containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.SituationContainer containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.SituationContainer containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.SituationContainer containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DENM-PDU-Descriptions.SituationContainer.");
  }
  return 0;
}

void SituationContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ informationQuality := ");
single_value->field_informationQuality.log();
TTCN_Logger::log_event_str(", eventType := ");
single_value->field_eventType.log();
TTCN_Logger::log_event_str(", linkedCause := ");
single_value->field_linkedCause.log();
TTCN_Logger::log_event_str(", eventHistory := ");
single_value->field_eventHistory.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SituationContainer_template::log_match(const SituationContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_informationQuality.match(match_value.informationQuality(), legacy)){
TTCN_Logger::log_logmatch_info(".informationQuality");
single_value->field_informationQuality.log_match(match_value.informationQuality(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_eventType.match(match_value.eventType(), legacy)){
TTCN_Logger::log_logmatch_info(".eventType");
single_value->field_eventType.log_match(match_value.eventType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.linkedCause().ispresent()){
if(!single_value->field_linkedCause.match(match_value.linkedCause(), legacy)){
TTCN_Logger::log_logmatch_info(".linkedCause");
single_value->field_linkedCause.log_match(match_value.linkedCause(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_linkedCause.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".linkedCause := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_linkedCause.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.eventHistory().ispresent()){
if(!single_value->field_eventHistory.match(match_value.eventHistory(), legacy)){
TTCN_Logger::log_logmatch_info(".eventHistory");
single_value->field_eventHistory.log_match(match_value.eventHistory(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_eventHistory.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".eventHistory := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_eventHistory.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ informationQuality := ");
single_value->field_informationQuality.log_match(match_value.informationQuality(), legacy);
TTCN_Logger::log_event_str(", eventType := ");
single_value->field_eventType.log_match(match_value.eventType(), legacy);
TTCN_Logger::log_event_str(", linkedCause := ");
if (match_value.linkedCause().ispresent()) single_value->field_linkedCause.log_match(match_value.linkedCause(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_linkedCause.log();
if (single_value->field_linkedCause.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", eventHistory := ");
if (match_value.eventHistory().ispresent()) single_value->field_eventHistory.log_match(match_value.eventHistory(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_eventHistory.log();
if (single_value->field_eventHistory.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SituationContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_informationQuality.encode_text(text_buf);
single_value->field_eventType.encode_text(text_buf);
single_value->field_linkedCause.encode_text(text_buf);
single_value->field_eventHistory.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DENM-PDU-Descriptions.SituationContainer.");
}
}

void SituationContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_informationQuality.decode_text(text_buf);
single_value->field_eventType.decode_text(text_buf);
single_value->field_linkedCause.decode_text(text_buf);
single_value->field_eventHistory.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SituationContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DENM-PDU-Descriptions.SituationContainer.");
}
}

void SituationContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DENM-PDU-Descriptions.SituationContainer'");
    }
    if (strcmp("informationQuality", param_field) == 0) {
      informationQuality().set_param(param);
      return;
    } else if (strcmp("eventType", param_field) == 0) {
      eventType().set_param(param);
      return;
    } else if (strcmp("linkedCause", param_field) == 0) {
      linkedCause().set_param(param);
      return;
    } else if (strcmp("eventHistory", param_field) == 0) {
      eventHistory().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DENM-PDU-Descriptions.SituationContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SituationContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @DENM-PDU-Descriptions.SituationContainer has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) informationQuality().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) eventType().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) linkedCause().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) eventHistory().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "informationQuality")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          informationQuality().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eventType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eventType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "linkedCause")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          linkedCause().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eventHistory")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eventHistory().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.SituationContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DENM-PDU-Descriptions.SituationContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SituationContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DENM-PDU-Descriptions.SituationContainer'");
    }
    if (strcmp("informationQuality", param_field) == 0) {
      return informationQuality().get_param(param_name);
    } else if (strcmp("eventType", param_field) == 0) {
      return eventType().get_param(param_name);
    } else if (strcmp("linkedCause", param_field) == 0) {
      return linkedCause().get_param(param_name);
    } else if (strcmp("eventHistory", param_field) == 0) {
      return eventHistory().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.SituationContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_informationQuality = single_value->field_informationQuality.get_param(param_name);
    mp_field_informationQuality->set_id(new Module_Param_FieldName(mcopystr("informationQuality")));
    mp->add_elem(mp_field_informationQuality);
    Module_Param* mp_field_eventType = single_value->field_eventType.get_param(param_name);
    mp_field_eventType->set_id(new Module_Param_FieldName(mcopystr("eventType")));
    mp->add_elem(mp_field_eventType);
    Module_Param* mp_field_linkedCause = single_value->field_linkedCause.get_param(param_name);
    mp_field_linkedCause->set_id(new Module_Param_FieldName(mcopystr("linkedCause")));
    mp->add_elem(mp_field_linkedCause);
    Module_Param* mp_field_eventHistory = single_value->field_eventHistory.get_param(param_name);
    mp_field_eventHistory->set_id(new Module_Param_FieldName(mcopystr("eventHistory")));
    mp->add_elem(mp_field_eventHistory);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SituationContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_informationQuality.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.SituationContainer");
single_value->field_eventType.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.SituationContainer");
single_value->field_linkedCause.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.SituationContainer");
single_value->field_eventHistory.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.SituationContainer");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DENM-PDU-Descriptions.SituationContainer");
}

boolean SituationContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SituationContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

LocationContainer::LocationContainer()
{
  bound_flag = FALSE;
}

LocationContainer::LocationContainer(const OPTIONAL<ITS__Container::Speed>& par_eventSpeed,
    const OPTIONAL<ITS__Container::Heading>& par_eventPositionHeading,
    const ITS__Container::Traces& par_traces,
    const OPTIONAL<ITS__Container::RoadType>& par_roadType)
  :   field_eventSpeed(par_eventSpeed),
  field_eventPositionHeading(par_eventPositionHeading),
  field_traces(par_traces),
  field_roadType(par_roadType)
{
  bound_flag = TRUE;
}

LocationContainer::LocationContainer(const LocationContainer& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DENM-PDU-Descriptions.LocationContainer.");
bound_flag = TRUE;
if (other_value.eventSpeed().is_bound()) field_eventSpeed = other_value.eventSpeed();
else field_eventSpeed.clean_up();
if (other_value.eventPositionHeading().is_bound()) field_eventPositionHeading = other_value.eventPositionHeading();
else field_eventPositionHeading.clean_up();
if (other_value.traces().is_bound()) field_traces = other_value.traces();
else field_traces.clean_up();
if (other_value.roadType().is_bound()) field_roadType = other_value.roadType();
else field_roadType.clean_up();
}

void LocationContainer::clean_up()
{
field_eventSpeed.clean_up();
field_eventPositionHeading.clean_up();
field_traces.clean_up();
field_roadType.clean_up();
bound_flag = FALSE;
}

LocationContainer& LocationContainer::operator=(const LocationContainer& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DENM-PDU-Descriptions.LocationContainer.");
  bound_flag = TRUE;
  if (other_value.eventSpeed().is_bound()) field_eventSpeed = other_value.eventSpeed();
  else field_eventSpeed.clean_up();
  if (other_value.eventPositionHeading().is_bound()) field_eventPositionHeading = other_value.eventPositionHeading();
  else field_eventPositionHeading.clean_up();
  if (other_value.traces().is_bound()) field_traces = other_value.traces();
  else field_traces.clean_up();
  if (other_value.roadType().is_bound()) field_roadType = other_value.roadType();
  else field_roadType.clean_up();
}
return *this;
}

boolean LocationContainer::operator==(const LocationContainer& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_eventSpeed==other_value.field_eventSpeed
  && field_eventPositionHeading==other_value.field_eventPositionHeading
  && field_traces==other_value.field_traces
  && field_roadType==other_value.field_roadType;
}

boolean LocationContainer::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_eventSpeed.get_selection() || field_eventSpeed.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_eventPositionHeading.get_selection() || field_eventPositionHeading.is_bound()) return TRUE;
if(field_traces.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_roadType.get_selection() || field_roadType.is_bound()) return TRUE;
return FALSE;
}
boolean LocationContainer::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_eventSpeed.get_selection() && !field_eventSpeed.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_eventPositionHeading.get_selection() && !field_eventPositionHeading.is_value()) return FALSE;
if(!field_traces.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_roadType.get_selection() && !field_roadType.is_value()) return FALSE;
return TRUE;
}
int LocationContainer::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DENM-PDU-Descriptions.LocationContainer");
  int ret_val = 1;
  if (field_eventSpeed.ispresent()) ret_val++;
  if (field_eventPositionHeading.ispresent()) ret_val++;
  if (field_roadType.ispresent()) ret_val++;
  return ret_val;
}

void LocationContainer::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ eventSpeed := ");
field_eventSpeed.log();
TTCN_Logger::log_event_str(", eventPositionHeading := ");
field_eventPositionHeading.log();
TTCN_Logger::log_event_str(", traces := ");
field_traces.log();
TTCN_Logger::log_event_str(", roadType := ");
field_roadType.log();
TTCN_Logger::log_event_str(" }");
}

void LocationContainer::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DENM-PDU-Descriptions.LocationContainer'");
    }
    if (strcmp("eventSpeed", param_field) == 0) {
      eventSpeed().set_param(param);
      return;
    } else if (strcmp("eventPositionHeading", param_field) == 0) {
      eventPositionHeading().set_param(param);
      return;
    } else if (strcmp("traces", param_field) == 0) {
      traces().set_param(param);
      return;
    } else if (strcmp("roadType", param_field) == 0) {
      roadType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DENM-PDU-Descriptions.LocationContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @DENM-PDU-Descriptions.LocationContainer has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) eventSpeed().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) eventPositionHeading().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) traces().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) roadType().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eventSpeed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eventSpeed().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eventPositionHeading")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eventPositionHeading().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "traces")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          traces().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "roadType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          roadType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.LocationContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DENM-PDU-Descriptions.LocationContainer");
  }
}

Module_Param* LocationContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DENM-PDU-Descriptions.LocationContainer'");
    }
    if (strcmp("eventSpeed", param_field) == 0) {
      return eventSpeed().get_param(param_name);
    } else if (strcmp("eventPositionHeading", param_field) == 0) {
      return eventPositionHeading().get_param(param_name);
    } else if (strcmp("traces", param_field) == 0) {
      return traces().get_param(param_name);
    } else if (strcmp("roadType", param_field) == 0) {
      return roadType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.LocationContainer'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_eventSpeed = field_eventSpeed.get_param(param_name);
  mp_field_eventSpeed->set_id(new Module_Param_FieldName(mcopystr("eventSpeed")));
  mp->add_elem(mp_field_eventSpeed);
  Module_Param* mp_field_eventPositionHeading = field_eventPositionHeading.get_param(param_name);
  mp_field_eventPositionHeading->set_id(new Module_Param_FieldName(mcopystr("eventPositionHeading")));
  mp->add_elem(mp_field_eventPositionHeading);
  Module_Param* mp_field_traces = field_traces.get_param(param_name);
  mp_field_traces->set_id(new Module_Param_FieldName(mcopystr("traces")));
  mp->add_elem(mp_field_traces);
  Module_Param* mp_field_roadType = field_roadType.get_param(param_name);
  mp_field_roadType->set_id(new Module_Param_FieldName(mcopystr("roadType")));
  mp->add_elem(mp_field_roadType);
  return mp;
  }

void LocationContainer::set_implicit_omit()
{
if (!eventSpeed().is_bound()) eventSpeed() = OMIT_VALUE;
else eventSpeed().set_implicit_omit();
if (!eventPositionHeading().is_bound()) eventPositionHeading() = OMIT_VALUE;
else eventPositionHeading().set_implicit_omit();
if (traces().is_bound()) traces().set_implicit_omit();
if (!roadType().is_bound()) roadType() = OMIT_VALUE;
else roadType().set_implicit_omit();
}

void LocationContainer::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DENM-PDU-Descriptions.LocationContainer.");
field_eventSpeed.encode_text(text_buf);
field_eventPositionHeading.encode_text(text_buf);
field_traces.encode_text(text_buf);
field_roadType.encode_text(text_buf);
}

void LocationContainer::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_eventSpeed.decode_text(text_buf);
field_eventPositionHeading.decode_text(text_buf);
field_traces.decode_text(text_buf);
field_roadType.decode_text(text_buf);
}

void LocationContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void LocationContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* LocationContainer::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("eventSpeed': ");
  new_tlv->add_TLV(field_eventSpeed.BER_encode_TLV(LocationContainer_eventSpeed_descr_, p_coding));
  ec_1.set_msg("eventPositionHeading': ");
  new_tlv->add_TLV(field_eventPositionHeading.BER_encode_TLV(LocationContainer_eventPositionHeading_descr_, p_coding));
  ec_1.set_msg("traces': ");
  new_tlv->add_TLV(field_traces.BER_encode_TLV(LocationContainer_traces_descr_, p_coding));
  ec_1.set_msg("roadType': ");
  new_tlv->add_TLV(field_roadType.BER_encode_TLV(LocationContainer_roadType_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean LocationContainer::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DENM-PDU-Descriptions.LocationContainer' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("eventSpeed': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_eventSpeed=OMIT_VALUE;
    else {
      field_eventSpeed.BER_decode_TLV(LocationContainer_eventSpeed_descr_, tmp_tlv, L_form);
      if(field_eventSpeed.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("eventPositionHeading': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_eventPositionHeading=OMIT_VALUE;
    else {
      field_eventPositionHeading.BER_decode_TLV(LocationContainer_eventPositionHeading_descr_, tmp_tlv, L_form);
      if(field_eventPositionHeading.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("traces': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_traces.BER_decode_TLV(LocationContainer_traces_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("roadType': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_roadType=OMIT_VALUE;
    else {
      field_roadType.BER_decode_TLV(LocationContainer_roadType_descr_, tmp_tlv, L_form);
      if(field_roadType.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int LocationContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DENM-PDU-Descriptions.LocationContainer.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_eventSpeed.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "eventSpeed");
    enc_len += field_eventSpeed.JSON_encode(LocationContainer_eventSpeed_descr_, p_tok);
  }

  if (field_eventPositionHeading.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "eventPositionHeading");
    enc_len += field_eventPositionHeading.JSON_encode(LocationContainer_eventPositionHeading_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "traces");
    enc_len += field_traces.JSON_encode(LocationContainer_traces_descr_, p_tok);
  }

  if (field_roadType.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "roadType");
    enc_len += field_roadType.JSON_encode(LocationContainer_roadType_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int LocationContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "eventSpeed", name_len)) {
         int ret_val = field_eventSpeed.JSON_decode(LocationContainer_eventSpeed_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "eventSpeed");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (20 == name_len && 0 == strncmp(fld_name, "eventPositionHeading", name_len)) {
         int ret_val = field_eventPositionHeading.JSON_decode(LocationContainer_eventPositionHeading_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "eventPositionHeading");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "traces", name_len)) {
         int ret_val = field_traces.JSON_decode(LocationContainer_traces_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "traces");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "roadType", name_len)) {
         int ret_val = field_roadType.JSON_decode(LocationContainer_roadType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "roadType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_eventSpeed.is_bound()) {
    field_eventSpeed = OMIT_VALUE;
  }
if (!field_eventPositionHeading.is_bound()) {
    field_eventPositionHeading = OMIT_VALUE;
  }
if (!field_traces.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "traces");
    return JSON_ERROR_FATAL;
  }
if (!field_roadType.is_bound()) {
    field_roadType = OMIT_VALUE;
  }

  return dec_len;
}

struct LocationContainer_template::single_value_struct {
ITS__Container::Speed_template field_eventSpeed;
ITS__Container::Heading_template field_eventPositionHeading;
ITS__Container::Traces_template field_traces;
ITS__Container::RoadType_template field_roadType;
};

void LocationContainer_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_eventSpeed = ANY_OR_OMIT;
single_value->field_eventPositionHeading = ANY_OR_OMIT;
single_value->field_traces = ANY_VALUE;
single_value->field_roadType = ANY_OR_OMIT;
}
}
}

void LocationContainer_template::copy_value(const LocationContainer& other_value)
{
single_value = new single_value_struct;
if (other_value.eventSpeed().is_bound()) {
  if (other_value.eventSpeed().ispresent()) single_value->field_eventSpeed = other_value.eventSpeed()();
  else single_value->field_eventSpeed = OMIT_VALUE;
} else {
  single_value->field_eventSpeed.clean_up();
}
if (other_value.eventPositionHeading().is_bound()) {
  if (other_value.eventPositionHeading().ispresent()) single_value->field_eventPositionHeading = other_value.eventPositionHeading()();
  else single_value->field_eventPositionHeading = OMIT_VALUE;
} else {
  single_value->field_eventPositionHeading.clean_up();
}
if (other_value.traces().is_bound()) {
  single_value->field_traces = other_value.traces();
} else {
  single_value->field_traces.clean_up();
}
if (other_value.roadType().is_bound()) {
  if (other_value.roadType().ispresent()) single_value->field_roadType = other_value.roadType()();
  else single_value->field_roadType = OMIT_VALUE;
} else {
  single_value->field_roadType.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void LocationContainer_template::copy_template(const LocationContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.eventSpeed().get_selection()) {
single_value->field_eventSpeed = other_value.eventSpeed();
} else {
single_value->field_eventSpeed.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.eventPositionHeading().get_selection()) {
single_value->field_eventPositionHeading = other_value.eventPositionHeading();
} else {
single_value->field_eventPositionHeading.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.traces().get_selection()) {
single_value->field_traces = other_value.traces();
} else {
single_value->field_traces.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.roadType().get_selection()) {
single_value->field_roadType = other_value.roadType();
} else {
single_value->field_roadType.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new LocationContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DENM-PDU-Descriptions.LocationContainer.");
break;
}
set_selection(other_value);
}

LocationContainer_template::LocationContainer_template()
{
}

LocationContainer_template::LocationContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

LocationContainer_template::LocationContainer_template(const LocationContainer& other_value)
{
copy_value(other_value);
}

LocationContainer_template::LocationContainer_template(const OPTIONAL<LocationContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LocationContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DENM-PDU-Descriptions.LocationContainer from an unbound optional field.");
}
}

LocationContainer_template::LocationContainer_template(const LocationContainer_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

LocationContainer_template::~LocationContainer_template()
{
clean_up();
}

LocationContainer_template& LocationContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

LocationContainer_template& LocationContainer_template::operator=(const LocationContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

LocationContainer_template& LocationContainer_template::operator=(const OPTIONAL<LocationContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LocationContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DENM-PDU-Descriptions.LocationContainer.");
}
return *this;
}

LocationContainer_template& LocationContainer_template::operator=(const LocationContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean LocationContainer_template::match(const LocationContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.eventSpeed().is_bound()) return FALSE;
if((other_value.eventSpeed().ispresent() ? !single_value->field_eventSpeed.match((const ITS__Container::Speed&)other_value.eventSpeed(), legacy) : !single_value->field_eventSpeed.match_omit(legacy)))return FALSE;
if(!other_value.eventPositionHeading().is_bound()) return FALSE;
if((other_value.eventPositionHeading().ispresent() ? !single_value->field_eventPositionHeading.match((const ITS__Container::Heading&)other_value.eventPositionHeading(), legacy) : !single_value->field_eventPositionHeading.match_omit(legacy)))return FALSE;
if(!other_value.traces().is_bound()) return FALSE;
if(!single_value->field_traces.match(other_value.traces(), legacy))return FALSE;
if(!other_value.roadType().is_bound()) return FALSE;
if((other_value.roadType().ispresent() ? !single_value->field_roadType.match((const ITS__Container::RoadType&)other_value.roadType(), legacy) : !single_value->field_roadType.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DENM-PDU-Descriptions.LocationContainer.");
}
return FALSE;
}

boolean LocationContainer_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_eventSpeed.is_omit() || single_value->field_eventSpeed.is_bound()) return TRUE;
if (single_value->field_eventPositionHeading.is_omit() || single_value->field_eventPositionHeading.is_bound()) return TRUE;
if (single_value->field_traces.is_bound()) return TRUE;
if (single_value->field_roadType.is_omit() || single_value->field_roadType.is_bound()) return TRUE;
return FALSE;
}

boolean LocationContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_eventSpeed.is_omit() && !single_value->field_eventSpeed.is_value()) return FALSE;
if (!single_value->field_eventPositionHeading.is_omit() && !single_value->field_eventPositionHeading.is_value()) return FALSE;
if (!single_value->field_traces.is_value()) return FALSE;
if (!single_value->field_roadType.is_omit() && !single_value->field_roadType.is_value()) return FALSE;
return TRUE;
}

void LocationContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

LocationContainer LocationContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DENM-PDU-Descriptions.LocationContainer.");
LocationContainer ret_val;
if (single_value->field_eventSpeed.is_omit()) ret_val.eventSpeed() = OMIT_VALUE;
else if (single_value->field_eventSpeed.is_bound()) {
ret_val.eventSpeed() = single_value->field_eventSpeed.valueof();
}
if (single_value->field_eventPositionHeading.is_omit()) ret_val.eventPositionHeading() = OMIT_VALUE;
else if (single_value->field_eventPositionHeading.is_bound()) {
ret_val.eventPositionHeading() = single_value->field_eventPositionHeading.valueof();
}
if (single_value->field_traces.is_bound()) {
ret_val.traces() = single_value->field_traces.valueof();
}
if (single_value->field_roadType.is_omit()) ret_val.roadType() = OMIT_VALUE;
else if (single_value->field_roadType.is_bound()) {
ret_val.roadType() = single_value->field_roadType.valueof();
}
return ret_val;
}

void LocationContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DENM-PDU-Descriptions.LocationContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new LocationContainer_template[list_length];
}

LocationContainer_template& LocationContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DENM-PDU-Descriptions.LocationContainer.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DENM-PDU-Descriptions.LocationContainer.");
return value_list.list_value[list_index];
}

ITS__Container::Speed_template& LocationContainer_template::eventSpeed()
{
set_specific();
return single_value->field_eventSpeed;
}

const ITS__Container::Speed_template& LocationContainer_template::eventSpeed() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field eventSpeed of a non-specific template of type @DENM-PDU-Descriptions.LocationContainer.");
return single_value->field_eventSpeed;
}

ITS__Container::Heading_template& LocationContainer_template::eventPositionHeading()
{
set_specific();
return single_value->field_eventPositionHeading;
}

const ITS__Container::Heading_template& LocationContainer_template::eventPositionHeading() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field eventPositionHeading of a non-specific template of type @DENM-PDU-Descriptions.LocationContainer.");
return single_value->field_eventPositionHeading;
}

ITS__Container::Traces_template& LocationContainer_template::traces()
{
set_specific();
return single_value->field_traces;
}

const ITS__Container::Traces_template& LocationContainer_template::traces() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field traces of a non-specific template of type @DENM-PDU-Descriptions.LocationContainer.");
return single_value->field_traces;
}

ITS__Container::RoadType_template& LocationContainer_template::roadType()
{
set_specific();
return single_value->field_roadType;
}

const ITS__Container::RoadType_template& LocationContainer_template::roadType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field roadType of a non-specific template of type @DENM-PDU-Descriptions.LocationContainer.");
return single_value->field_roadType;
}

int LocationContainer_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.LocationContainer which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_eventSpeed.is_present()) ret_val++;
      if (single_value->field_eventPositionHeading.is_present()) ret_val++;
      if (single_value->field_roadType.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.LocationContainer containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.LocationContainer containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.LocationContainer containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.LocationContainer containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.LocationContainer containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DENM-PDU-Descriptions.LocationContainer.");
  }
  return 0;
}

void LocationContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ eventSpeed := ");
single_value->field_eventSpeed.log();
TTCN_Logger::log_event_str(", eventPositionHeading := ");
single_value->field_eventPositionHeading.log();
TTCN_Logger::log_event_str(", traces := ");
single_value->field_traces.log();
TTCN_Logger::log_event_str(", roadType := ");
single_value->field_roadType.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void LocationContainer_template::log_match(const LocationContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.eventSpeed().ispresent()){
if(!single_value->field_eventSpeed.match(match_value.eventSpeed(), legacy)){
TTCN_Logger::log_logmatch_info(".eventSpeed");
single_value->field_eventSpeed.log_match(match_value.eventSpeed(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_eventSpeed.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".eventSpeed := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_eventSpeed.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.eventPositionHeading().ispresent()){
if(!single_value->field_eventPositionHeading.match(match_value.eventPositionHeading(), legacy)){
TTCN_Logger::log_logmatch_info(".eventPositionHeading");
single_value->field_eventPositionHeading.log_match(match_value.eventPositionHeading(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_eventPositionHeading.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".eventPositionHeading := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_eventPositionHeading.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_traces.match(match_value.traces(), legacy)){
TTCN_Logger::log_logmatch_info(".traces");
single_value->field_traces.log_match(match_value.traces(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.roadType().ispresent()){
if(!single_value->field_roadType.match(match_value.roadType(), legacy)){
TTCN_Logger::log_logmatch_info(".roadType");
single_value->field_roadType.log_match(match_value.roadType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_roadType.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".roadType := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_roadType.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ eventSpeed := ");
if (match_value.eventSpeed().ispresent()) single_value->field_eventSpeed.log_match(match_value.eventSpeed(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_eventSpeed.log();
if (single_value->field_eventSpeed.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", eventPositionHeading := ");
if (match_value.eventPositionHeading().ispresent()) single_value->field_eventPositionHeading.log_match(match_value.eventPositionHeading(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_eventPositionHeading.log();
if (single_value->field_eventPositionHeading.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", traces := ");
single_value->field_traces.log_match(match_value.traces(), legacy);
TTCN_Logger::log_event_str(", roadType := ");
if (match_value.roadType().ispresent()) single_value->field_roadType.log_match(match_value.roadType(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_roadType.log();
if (single_value->field_roadType.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void LocationContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_eventSpeed.encode_text(text_buf);
single_value->field_eventPositionHeading.encode_text(text_buf);
single_value->field_traces.encode_text(text_buf);
single_value->field_roadType.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DENM-PDU-Descriptions.LocationContainer.");
}
}

void LocationContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_eventSpeed.decode_text(text_buf);
single_value->field_eventPositionHeading.decode_text(text_buf);
single_value->field_traces.decode_text(text_buf);
single_value->field_roadType.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new LocationContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DENM-PDU-Descriptions.LocationContainer.");
}
}

void LocationContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DENM-PDU-Descriptions.LocationContainer'");
    }
    if (strcmp("eventSpeed", param_field) == 0) {
      eventSpeed().set_param(param);
      return;
    } else if (strcmp("eventPositionHeading", param_field) == 0) {
      eventPositionHeading().set_param(param);
      return;
    } else if (strcmp("traces", param_field) == 0) {
      traces().set_param(param);
      return;
    } else if (strcmp("roadType", param_field) == 0) {
      roadType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DENM-PDU-Descriptions.LocationContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    LocationContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @DENM-PDU-Descriptions.LocationContainer has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) eventSpeed().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) eventPositionHeading().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) traces().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) roadType().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eventSpeed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eventSpeed().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eventPositionHeading")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eventPositionHeading().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "traces")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          traces().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "roadType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          roadType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.LocationContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DENM-PDU-Descriptions.LocationContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* LocationContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DENM-PDU-Descriptions.LocationContainer'");
    }
    if (strcmp("eventSpeed", param_field) == 0) {
      return eventSpeed().get_param(param_name);
    } else if (strcmp("eventPositionHeading", param_field) == 0) {
      return eventPositionHeading().get_param(param_name);
    } else if (strcmp("traces", param_field) == 0) {
      return traces().get_param(param_name);
    } else if (strcmp("roadType", param_field) == 0) {
      return roadType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.LocationContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_eventSpeed = single_value->field_eventSpeed.get_param(param_name);
    mp_field_eventSpeed->set_id(new Module_Param_FieldName(mcopystr("eventSpeed")));
    mp->add_elem(mp_field_eventSpeed);
    Module_Param* mp_field_eventPositionHeading = single_value->field_eventPositionHeading.get_param(param_name);
    mp_field_eventPositionHeading->set_id(new Module_Param_FieldName(mcopystr("eventPositionHeading")));
    mp->add_elem(mp_field_eventPositionHeading);
    Module_Param* mp_field_traces = single_value->field_traces.get_param(param_name);
    mp_field_traces->set_id(new Module_Param_FieldName(mcopystr("traces")));
    mp->add_elem(mp_field_traces);
    Module_Param* mp_field_roadType = single_value->field_roadType.get_param(param_name);
    mp_field_roadType->set_id(new Module_Param_FieldName(mcopystr("roadType")));
    mp->add_elem(mp_field_roadType);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void LocationContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_eventSpeed.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.LocationContainer");
single_value->field_eventPositionHeading.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.LocationContainer");
single_value->field_traces.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.LocationContainer");
single_value->field_roadType.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.LocationContainer");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DENM-PDU-Descriptions.LocationContainer");
}

boolean LocationContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean LocationContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

AlacarteContainer::AlacarteContainer()
{
  bound_flag = FALSE;
}

AlacarteContainer::AlacarteContainer(const OPTIONAL<INTEGER>& par_lanePosition,
    const OPTIONAL<ImpactReductionContainer>& par_impactReduction,
    const OPTIONAL<INTEGER>& par_externalTemperature,
    const OPTIONAL<RoadWorksContainerExtended>& par_roadWorks,
    const OPTIONAL<ITS__Container::PositioningSolutionType>& par_positioningSolution,
    const OPTIONAL<StationaryVehicleContainer>& par_stationaryVehicle)
  :   field_lanePosition(par_lanePosition),
  field_impactReduction(par_impactReduction),
  field_externalTemperature(par_externalTemperature),
  field_roadWorks(par_roadWorks),
  field_positioningSolution(par_positioningSolution),
  field_stationaryVehicle(par_stationaryVehicle)
{
  bound_flag = TRUE;
}

AlacarteContainer::AlacarteContainer(const AlacarteContainer& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DENM-PDU-Descriptions.AlacarteContainer.");
bound_flag = TRUE;
if (other_value.lanePosition().is_bound()) field_lanePosition = other_value.lanePosition();
else field_lanePosition.clean_up();
if (other_value.impactReduction().is_bound()) field_impactReduction = other_value.impactReduction();
else field_impactReduction.clean_up();
if (other_value.externalTemperature().is_bound()) field_externalTemperature = other_value.externalTemperature();
else field_externalTemperature.clean_up();
if (other_value.roadWorks().is_bound()) field_roadWorks = other_value.roadWorks();
else field_roadWorks.clean_up();
if (other_value.positioningSolution().is_bound()) field_positioningSolution = other_value.positioningSolution();
else field_positioningSolution.clean_up();
if (other_value.stationaryVehicle().is_bound()) field_stationaryVehicle = other_value.stationaryVehicle();
else field_stationaryVehicle.clean_up();
}

void AlacarteContainer::clean_up()
{
field_lanePosition.clean_up();
field_impactReduction.clean_up();
field_externalTemperature.clean_up();
field_roadWorks.clean_up();
field_positioningSolution.clean_up();
field_stationaryVehicle.clean_up();
bound_flag = FALSE;
}

AlacarteContainer& AlacarteContainer::operator=(const AlacarteContainer& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DENM-PDU-Descriptions.AlacarteContainer.");
  bound_flag = TRUE;
  if (other_value.lanePosition().is_bound()) field_lanePosition = other_value.lanePosition();
  else field_lanePosition.clean_up();
  if (other_value.impactReduction().is_bound()) field_impactReduction = other_value.impactReduction();
  else field_impactReduction.clean_up();
  if (other_value.externalTemperature().is_bound()) field_externalTemperature = other_value.externalTemperature();
  else field_externalTemperature.clean_up();
  if (other_value.roadWorks().is_bound()) field_roadWorks = other_value.roadWorks();
  else field_roadWorks.clean_up();
  if (other_value.positioningSolution().is_bound()) field_positioningSolution = other_value.positioningSolution();
  else field_positioningSolution.clean_up();
  if (other_value.stationaryVehicle().is_bound()) field_stationaryVehicle = other_value.stationaryVehicle();
  else field_stationaryVehicle.clean_up();
}
return *this;
}

boolean AlacarteContainer::operator==(const AlacarteContainer& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_lanePosition==other_value.field_lanePosition
  && field_impactReduction==other_value.field_impactReduction
  && field_externalTemperature==other_value.field_externalTemperature
  && field_roadWorks==other_value.field_roadWorks
  && field_positioningSolution==other_value.field_positioningSolution
  && field_stationaryVehicle==other_value.field_stationaryVehicle;
}

boolean AlacarteContainer::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_lanePosition.get_selection() || field_lanePosition.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_impactReduction.get_selection() || field_impactReduction.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_externalTemperature.get_selection() || field_externalTemperature.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_roadWorks.get_selection() || field_roadWorks.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_positioningSolution.get_selection() || field_positioningSolution.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_stationaryVehicle.get_selection() || field_stationaryVehicle.is_bound()) return TRUE;
return FALSE;
}
boolean AlacarteContainer::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_lanePosition.get_selection() && !field_lanePosition.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_impactReduction.get_selection() && !field_impactReduction.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_externalTemperature.get_selection() && !field_externalTemperature.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_roadWorks.get_selection() && !field_roadWorks.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_positioningSolution.get_selection() && !field_positioningSolution.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_stationaryVehicle.get_selection() && !field_stationaryVehicle.is_value()) return FALSE;
return TRUE;
}
int AlacarteContainer::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DENM-PDU-Descriptions.AlacarteContainer");
  int ret_val = 0;
  if (field_lanePosition.ispresent()) ret_val++;
  if (field_impactReduction.ispresent()) ret_val++;
  if (field_externalTemperature.ispresent()) ret_val++;
  if (field_roadWorks.ispresent()) ret_val++;
  if (field_positioningSolution.ispresent()) ret_val++;
  if (field_stationaryVehicle.ispresent()) ret_val++;
  return ret_val;
}

void AlacarteContainer::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ lanePosition := ");
field_lanePosition.log();
TTCN_Logger::log_event_str(", impactReduction := ");
field_impactReduction.log();
TTCN_Logger::log_event_str(", externalTemperature := ");
field_externalTemperature.log();
TTCN_Logger::log_event_str(", roadWorks := ");
field_roadWorks.log();
TTCN_Logger::log_event_str(", positioningSolution := ");
field_positioningSolution.log();
TTCN_Logger::log_event_str(", stationaryVehicle := ");
field_stationaryVehicle.log();
TTCN_Logger::log_event_str(" }");
}

void AlacarteContainer::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DENM-PDU-Descriptions.AlacarteContainer'");
    }
    if (strcmp("lanePosition", param_field) == 0) {
      lanePosition().set_param(param);
      return;
    } else if (strcmp("impactReduction", param_field) == 0) {
      impactReduction().set_param(param);
      return;
    } else if (strcmp("externalTemperature", param_field) == 0) {
      externalTemperature().set_param(param);
      return;
    } else if (strcmp("roadWorks", param_field) == 0) {
      roadWorks().set_param(param);
      return;
    } else if (strcmp("positioningSolution", param_field) == 0) {
      positioningSolution().set_param(param);
      return;
    } else if (strcmp("stationaryVehicle", param_field) == 0) {
      stationaryVehicle().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DENM-PDU-Descriptions.AlacarteContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record value of type @DENM-PDU-Descriptions.AlacarteContainer has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lanePosition().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) impactReduction().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) externalTemperature().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) roadWorks().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) positioningSolution().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) stationaryVehicle().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lanePosition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lanePosition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "impactReduction")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          impactReduction().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "externalTemperature")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          externalTemperature().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "roadWorks")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          roadWorks().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "positioningSolution")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          positioningSolution().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationaryVehicle")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationaryVehicle().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.AlacarteContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DENM-PDU-Descriptions.AlacarteContainer");
  }
}

Module_Param* AlacarteContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DENM-PDU-Descriptions.AlacarteContainer'");
    }
    if (strcmp("lanePosition", param_field) == 0) {
      return lanePosition().get_param(param_name);
    } else if (strcmp("impactReduction", param_field) == 0) {
      return impactReduction().get_param(param_name);
    } else if (strcmp("externalTemperature", param_field) == 0) {
      return externalTemperature().get_param(param_name);
    } else if (strcmp("roadWorks", param_field) == 0) {
      return roadWorks().get_param(param_name);
    } else if (strcmp("positioningSolution", param_field) == 0) {
      return positioningSolution().get_param(param_name);
    } else if (strcmp("stationaryVehicle", param_field) == 0) {
      return stationaryVehicle().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.AlacarteContainer'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_lanePosition = field_lanePosition.get_param(param_name);
  mp_field_lanePosition->set_id(new Module_Param_FieldName(mcopystr("lanePosition")));
  mp->add_elem(mp_field_lanePosition);
  Module_Param* mp_field_impactReduction = field_impactReduction.get_param(param_name);
  mp_field_impactReduction->set_id(new Module_Param_FieldName(mcopystr("impactReduction")));
  mp->add_elem(mp_field_impactReduction);
  Module_Param* mp_field_externalTemperature = field_externalTemperature.get_param(param_name);
  mp_field_externalTemperature->set_id(new Module_Param_FieldName(mcopystr("externalTemperature")));
  mp->add_elem(mp_field_externalTemperature);
  Module_Param* mp_field_roadWorks = field_roadWorks.get_param(param_name);
  mp_field_roadWorks->set_id(new Module_Param_FieldName(mcopystr("roadWorks")));
  mp->add_elem(mp_field_roadWorks);
  Module_Param* mp_field_positioningSolution = field_positioningSolution.get_param(param_name);
  mp_field_positioningSolution->set_id(new Module_Param_FieldName(mcopystr("positioningSolution")));
  mp->add_elem(mp_field_positioningSolution);
  Module_Param* mp_field_stationaryVehicle = field_stationaryVehicle.get_param(param_name);
  mp_field_stationaryVehicle->set_id(new Module_Param_FieldName(mcopystr("stationaryVehicle")));
  mp->add_elem(mp_field_stationaryVehicle);
  return mp;
  }

void AlacarteContainer::set_implicit_omit()
{
if (!lanePosition().is_bound()) lanePosition() = OMIT_VALUE;
else lanePosition().set_implicit_omit();
if (!impactReduction().is_bound()) impactReduction() = OMIT_VALUE;
else impactReduction().set_implicit_omit();
if (!externalTemperature().is_bound()) externalTemperature() = OMIT_VALUE;
else externalTemperature().set_implicit_omit();
if (!roadWorks().is_bound()) roadWorks() = OMIT_VALUE;
else roadWorks().set_implicit_omit();
if (!positioningSolution().is_bound()) positioningSolution() = OMIT_VALUE;
else positioningSolution().set_implicit_omit();
if (!stationaryVehicle().is_bound()) stationaryVehicle() = OMIT_VALUE;
else stationaryVehicle().set_implicit_omit();
}

void AlacarteContainer::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DENM-PDU-Descriptions.AlacarteContainer.");
field_lanePosition.encode_text(text_buf);
field_impactReduction.encode_text(text_buf);
field_externalTemperature.encode_text(text_buf);
field_roadWorks.encode_text(text_buf);
field_positioningSolution.encode_text(text_buf);
field_stationaryVehicle.encode_text(text_buf);
}

void AlacarteContainer::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_lanePosition.decode_text(text_buf);
field_impactReduction.decode_text(text_buf);
field_externalTemperature.decode_text(text_buf);
field_roadWorks.decode_text(text_buf);
field_positioningSolution.decode_text(text_buf);
field_stationaryVehicle.decode_text(text_buf);
}

void AlacarteContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AlacarteContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* AlacarteContainer::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("lanePosition': ");
  new_tlv->add_TLV(field_lanePosition.BER_encode_TLV(AlacarteContainer_lanePosition_descr_, p_coding));
  ec_1.set_msg("impactReduction': ");
  new_tlv->add_TLV(field_impactReduction.BER_encode_TLV(AlacarteContainer_impactReduction_descr_, p_coding));
  ec_1.set_msg("externalTemperature': ");
  new_tlv->add_TLV(field_externalTemperature.BER_encode_TLV(AlacarteContainer_externalTemperature_descr_, p_coding));
  ec_1.set_msg("roadWorks': ");
  new_tlv->add_TLV(field_roadWorks.BER_encode_TLV(AlacarteContainer_roadWorks_descr_, p_coding));
  ec_1.set_msg("positioningSolution': ");
  new_tlv->add_TLV(field_positioningSolution.BER_encode_TLV(AlacarteContainer_positioningSolution_descr_, p_coding));
  ec_1.set_msg("stationaryVehicle': ");
  new_tlv->add_TLV(field_stationaryVehicle.BER_encode_TLV(AlacarteContainer_stationaryVehicle_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean AlacarteContainer::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DENM-PDU-Descriptions.AlacarteContainer' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("lanePosition': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_lanePosition=OMIT_VALUE;
    else {
      field_lanePosition.BER_decode_TLV(AlacarteContainer_lanePosition_descr_, tmp_tlv, L_form);
      if(field_lanePosition.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("impactReduction': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_impactReduction=OMIT_VALUE;
    else {
      field_impactReduction.BER_decode_TLV(AlacarteContainer_impactReduction_descr_, tmp_tlv, L_form);
      if(field_impactReduction.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("externalTemperature': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_externalTemperature=OMIT_VALUE;
    else {
      field_externalTemperature.BER_decode_TLV(AlacarteContainer_externalTemperature_descr_, tmp_tlv, L_form);
      if(field_externalTemperature.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("roadWorks': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_roadWorks=OMIT_VALUE;
    else {
      field_roadWorks.BER_decode_TLV(AlacarteContainer_roadWorks_descr_, tmp_tlv, L_form);
      if(field_roadWorks.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("positioningSolution': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_positioningSolution=OMIT_VALUE;
    else {
      field_positioningSolution.BER_decode_TLV(AlacarteContainer_positioningSolution_descr_, tmp_tlv, L_form);
      if(field_positioningSolution.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("stationaryVehicle': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_stationaryVehicle=OMIT_VALUE;
    else {
      field_stationaryVehicle.BER_decode_TLV(AlacarteContainer_stationaryVehicle_descr_, tmp_tlv, L_form);
      if(field_stationaryVehicle.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int AlacarteContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DENM-PDU-Descriptions.AlacarteContainer.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_lanePosition.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lanePosition");
    enc_len += field_lanePosition.JSON_encode(AlacarteContainer_lanePosition_descr_, p_tok);
  }

  if (field_impactReduction.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "impactReduction");
    enc_len += field_impactReduction.JSON_encode(AlacarteContainer_impactReduction_descr_, p_tok);
  }

  if (field_externalTemperature.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "externalTemperature");
    enc_len += field_externalTemperature.JSON_encode(AlacarteContainer_externalTemperature_descr_, p_tok);
  }

  if (field_roadWorks.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "roadWorks");
    enc_len += field_roadWorks.JSON_encode(AlacarteContainer_roadWorks_descr_, p_tok);
  }

  if (field_positioningSolution.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "positioningSolution");
    enc_len += field_positioningSolution.JSON_encode(AlacarteContainer_positioningSolution_descr_, p_tok);
  }

  if (field_stationaryVehicle.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "stationaryVehicle");
    enc_len += field_stationaryVehicle.JSON_encode(AlacarteContainer_stationaryVehicle_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AlacarteContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "lanePosition", name_len)) {
         int ret_val = field_lanePosition.JSON_decode(AlacarteContainer_lanePosition_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lanePosition");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "impactReduction", name_len)) {
         int ret_val = field_impactReduction.JSON_decode(AlacarteContainer_impactReduction_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "impactReduction");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (19 == name_len && 0 == strncmp(fld_name, "externalTemperature", name_len)) {
         int ret_val = field_externalTemperature.JSON_decode(AlacarteContainer_externalTemperature_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "externalTemperature");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "roadWorks", name_len)) {
         int ret_val = field_roadWorks.JSON_decode(AlacarteContainer_roadWorks_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "roadWorks");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (19 == name_len && 0 == strncmp(fld_name, "positioningSolution", name_len)) {
         int ret_val = field_positioningSolution.JSON_decode(AlacarteContainer_positioningSolution_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "positioningSolution");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "stationaryVehicle", name_len)) {
         int ret_val = field_stationaryVehicle.JSON_decode(AlacarteContainer_stationaryVehicle_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "stationaryVehicle");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_lanePosition.is_bound()) {
    field_lanePosition = OMIT_VALUE;
  }
if (!field_impactReduction.is_bound()) {
    field_impactReduction = OMIT_VALUE;
  }
if (!field_externalTemperature.is_bound()) {
    field_externalTemperature = OMIT_VALUE;
  }
if (!field_roadWorks.is_bound()) {
    field_roadWorks = OMIT_VALUE;
  }
if (!field_positioningSolution.is_bound()) {
    field_positioningSolution = OMIT_VALUE;
  }
if (!field_stationaryVehicle.is_bound()) {
    field_stationaryVehicle = OMIT_VALUE;
  }

  return dec_len;
}

struct AlacarteContainer_template::single_value_struct {
INTEGER_template field_lanePosition;
ImpactReductionContainer_template field_impactReduction;
INTEGER_template field_externalTemperature;
RoadWorksContainerExtended_template field_roadWorks;
ITS__Container::PositioningSolutionType_template field_positioningSolution;
StationaryVehicleContainer_template field_stationaryVehicle;
};

void AlacarteContainer_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_lanePosition = ANY_OR_OMIT;
single_value->field_impactReduction = ANY_OR_OMIT;
single_value->field_externalTemperature = ANY_OR_OMIT;
single_value->field_roadWorks = ANY_OR_OMIT;
single_value->field_positioningSolution = ANY_OR_OMIT;
single_value->field_stationaryVehicle = ANY_OR_OMIT;
}
}
}

void AlacarteContainer_template::copy_value(const AlacarteContainer& other_value)
{
single_value = new single_value_struct;
if (other_value.lanePosition().is_bound()) {
  if (other_value.lanePosition().ispresent()) single_value->field_lanePosition = other_value.lanePosition()();
  else single_value->field_lanePosition = OMIT_VALUE;
} else {
  single_value->field_lanePosition.clean_up();
}
if (other_value.impactReduction().is_bound()) {
  if (other_value.impactReduction().ispresent()) single_value->field_impactReduction = other_value.impactReduction()();
  else single_value->field_impactReduction = OMIT_VALUE;
} else {
  single_value->field_impactReduction.clean_up();
}
if (other_value.externalTemperature().is_bound()) {
  if (other_value.externalTemperature().ispresent()) single_value->field_externalTemperature = other_value.externalTemperature()();
  else single_value->field_externalTemperature = OMIT_VALUE;
} else {
  single_value->field_externalTemperature.clean_up();
}
if (other_value.roadWorks().is_bound()) {
  if (other_value.roadWorks().ispresent()) single_value->field_roadWorks = other_value.roadWorks()();
  else single_value->field_roadWorks = OMIT_VALUE;
} else {
  single_value->field_roadWorks.clean_up();
}
if (other_value.positioningSolution().is_bound()) {
  if (other_value.positioningSolution().ispresent()) single_value->field_positioningSolution = other_value.positioningSolution()();
  else single_value->field_positioningSolution = OMIT_VALUE;
} else {
  single_value->field_positioningSolution.clean_up();
}
if (other_value.stationaryVehicle().is_bound()) {
  if (other_value.stationaryVehicle().ispresent()) single_value->field_stationaryVehicle = other_value.stationaryVehicle()();
  else single_value->field_stationaryVehicle = OMIT_VALUE;
} else {
  single_value->field_stationaryVehicle.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void AlacarteContainer_template::copy_template(const AlacarteContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.lanePosition().get_selection()) {
single_value->field_lanePosition = other_value.lanePosition();
} else {
single_value->field_lanePosition.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.impactReduction().get_selection()) {
single_value->field_impactReduction = other_value.impactReduction();
} else {
single_value->field_impactReduction.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.externalTemperature().get_selection()) {
single_value->field_externalTemperature = other_value.externalTemperature();
} else {
single_value->field_externalTemperature.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.roadWorks().get_selection()) {
single_value->field_roadWorks = other_value.roadWorks();
} else {
single_value->field_roadWorks.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.positioningSolution().get_selection()) {
single_value->field_positioningSolution = other_value.positioningSolution();
} else {
single_value->field_positioningSolution.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.stationaryVehicle().get_selection()) {
single_value->field_stationaryVehicle = other_value.stationaryVehicle();
} else {
single_value->field_stationaryVehicle.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AlacarteContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DENM-PDU-Descriptions.AlacarteContainer.");
break;
}
set_selection(other_value);
}

AlacarteContainer_template::AlacarteContainer_template()
{
}

AlacarteContainer_template::AlacarteContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AlacarteContainer_template::AlacarteContainer_template(const AlacarteContainer& other_value)
{
copy_value(other_value);
}

AlacarteContainer_template::AlacarteContainer_template(const OPTIONAL<AlacarteContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AlacarteContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DENM-PDU-Descriptions.AlacarteContainer from an unbound optional field.");
}
}

AlacarteContainer_template::AlacarteContainer_template(const AlacarteContainer_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

AlacarteContainer_template::~AlacarteContainer_template()
{
clean_up();
}

AlacarteContainer_template& AlacarteContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AlacarteContainer_template& AlacarteContainer_template::operator=(const AlacarteContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AlacarteContainer_template& AlacarteContainer_template::operator=(const OPTIONAL<AlacarteContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AlacarteContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DENM-PDU-Descriptions.AlacarteContainer.");
}
return *this;
}

AlacarteContainer_template& AlacarteContainer_template::operator=(const AlacarteContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AlacarteContainer_template::match(const AlacarteContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.lanePosition().is_bound()) return FALSE;
if((other_value.lanePosition().ispresent() ? !single_value->field_lanePosition.match((const INTEGER&)other_value.lanePosition(), legacy) : !single_value->field_lanePosition.match_omit(legacy)))return FALSE;
if(!other_value.impactReduction().is_bound()) return FALSE;
if((other_value.impactReduction().ispresent() ? !single_value->field_impactReduction.match((const ImpactReductionContainer&)other_value.impactReduction(), legacy) : !single_value->field_impactReduction.match_omit(legacy)))return FALSE;
if(!other_value.externalTemperature().is_bound()) return FALSE;
if((other_value.externalTemperature().ispresent() ? !single_value->field_externalTemperature.match((const INTEGER&)other_value.externalTemperature(), legacy) : !single_value->field_externalTemperature.match_omit(legacy)))return FALSE;
if(!other_value.roadWorks().is_bound()) return FALSE;
if((other_value.roadWorks().ispresent() ? !single_value->field_roadWorks.match((const RoadWorksContainerExtended&)other_value.roadWorks(), legacy) : !single_value->field_roadWorks.match_omit(legacy)))return FALSE;
if(!other_value.positioningSolution().is_bound()) return FALSE;
if((other_value.positioningSolution().ispresent() ? !single_value->field_positioningSolution.match((const ITS__Container::PositioningSolutionType&)other_value.positioningSolution(), legacy) : !single_value->field_positioningSolution.match_omit(legacy)))return FALSE;
if(!other_value.stationaryVehicle().is_bound()) return FALSE;
if((other_value.stationaryVehicle().ispresent() ? !single_value->field_stationaryVehicle.match((const StationaryVehicleContainer&)other_value.stationaryVehicle(), legacy) : !single_value->field_stationaryVehicle.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DENM-PDU-Descriptions.AlacarteContainer.");
}
return FALSE;
}

boolean AlacarteContainer_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_lanePosition.is_omit() || single_value->field_lanePosition.is_bound()) return TRUE;
if (single_value->field_impactReduction.is_omit() || single_value->field_impactReduction.is_bound()) return TRUE;
if (single_value->field_externalTemperature.is_omit() || single_value->field_externalTemperature.is_bound()) return TRUE;
if (single_value->field_roadWorks.is_omit() || single_value->field_roadWorks.is_bound()) return TRUE;
if (single_value->field_positioningSolution.is_omit() || single_value->field_positioningSolution.is_bound()) return TRUE;
if (single_value->field_stationaryVehicle.is_omit() || single_value->field_stationaryVehicle.is_bound()) return TRUE;
return FALSE;
}

boolean AlacarteContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_lanePosition.is_omit() && !single_value->field_lanePosition.is_value()) return FALSE;
if (!single_value->field_impactReduction.is_omit() && !single_value->field_impactReduction.is_value()) return FALSE;
if (!single_value->field_externalTemperature.is_omit() && !single_value->field_externalTemperature.is_value()) return FALSE;
if (!single_value->field_roadWorks.is_omit() && !single_value->field_roadWorks.is_value()) return FALSE;
if (!single_value->field_positioningSolution.is_omit() && !single_value->field_positioningSolution.is_value()) return FALSE;
if (!single_value->field_stationaryVehicle.is_omit() && !single_value->field_stationaryVehicle.is_value()) return FALSE;
return TRUE;
}

void AlacarteContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AlacarteContainer AlacarteContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DENM-PDU-Descriptions.AlacarteContainer.");
AlacarteContainer ret_val;
if (single_value->field_lanePosition.is_omit()) ret_val.lanePosition() = OMIT_VALUE;
else if (single_value->field_lanePosition.is_bound()) {
ret_val.lanePosition() = single_value->field_lanePosition.valueof();
}
if (single_value->field_impactReduction.is_omit()) ret_val.impactReduction() = OMIT_VALUE;
else if (single_value->field_impactReduction.is_bound()) {
ret_val.impactReduction() = single_value->field_impactReduction.valueof();
}
if (single_value->field_externalTemperature.is_omit()) ret_val.externalTemperature() = OMIT_VALUE;
else if (single_value->field_externalTemperature.is_bound()) {
ret_val.externalTemperature() = single_value->field_externalTemperature.valueof();
}
if (single_value->field_roadWorks.is_omit()) ret_val.roadWorks() = OMIT_VALUE;
else if (single_value->field_roadWorks.is_bound()) {
ret_val.roadWorks() = single_value->field_roadWorks.valueof();
}
if (single_value->field_positioningSolution.is_omit()) ret_val.positioningSolution() = OMIT_VALUE;
else if (single_value->field_positioningSolution.is_bound()) {
ret_val.positioningSolution() = single_value->field_positioningSolution.valueof();
}
if (single_value->field_stationaryVehicle.is_omit()) ret_val.stationaryVehicle() = OMIT_VALUE;
else if (single_value->field_stationaryVehicle.is_bound()) {
ret_val.stationaryVehicle() = single_value->field_stationaryVehicle.valueof();
}
return ret_val;
}

void AlacarteContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DENM-PDU-Descriptions.AlacarteContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AlacarteContainer_template[list_length];
}

AlacarteContainer_template& AlacarteContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DENM-PDU-Descriptions.AlacarteContainer.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DENM-PDU-Descriptions.AlacarteContainer.");
return value_list.list_value[list_index];
}

INTEGER_template& AlacarteContainer_template::lanePosition()
{
set_specific();
return single_value->field_lanePosition;
}

const INTEGER_template& AlacarteContainer_template::lanePosition() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lanePosition of a non-specific template of type @DENM-PDU-Descriptions.AlacarteContainer.");
return single_value->field_lanePosition;
}

ImpactReductionContainer_template& AlacarteContainer_template::impactReduction()
{
set_specific();
return single_value->field_impactReduction;
}

const ImpactReductionContainer_template& AlacarteContainer_template::impactReduction() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field impactReduction of a non-specific template of type @DENM-PDU-Descriptions.AlacarteContainer.");
return single_value->field_impactReduction;
}

INTEGER_template& AlacarteContainer_template::externalTemperature()
{
set_specific();
return single_value->field_externalTemperature;
}

const INTEGER_template& AlacarteContainer_template::externalTemperature() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field externalTemperature of a non-specific template of type @DENM-PDU-Descriptions.AlacarteContainer.");
return single_value->field_externalTemperature;
}

RoadWorksContainerExtended_template& AlacarteContainer_template::roadWorks()
{
set_specific();
return single_value->field_roadWorks;
}

const RoadWorksContainerExtended_template& AlacarteContainer_template::roadWorks() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field roadWorks of a non-specific template of type @DENM-PDU-Descriptions.AlacarteContainer.");
return single_value->field_roadWorks;
}

ITS__Container::PositioningSolutionType_template& AlacarteContainer_template::positioningSolution()
{
set_specific();
return single_value->field_positioningSolution;
}

const ITS__Container::PositioningSolutionType_template& AlacarteContainer_template::positioningSolution() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field positioningSolution of a non-specific template of type @DENM-PDU-Descriptions.AlacarteContainer.");
return single_value->field_positioningSolution;
}

StationaryVehicleContainer_template& AlacarteContainer_template::stationaryVehicle()
{
set_specific();
return single_value->field_stationaryVehicle;
}

const StationaryVehicleContainer_template& AlacarteContainer_template::stationaryVehicle() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stationaryVehicle of a non-specific template of type @DENM-PDU-Descriptions.AlacarteContainer.");
return single_value->field_stationaryVehicle;
}

int AlacarteContainer_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.AlacarteContainer which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 0;
      if (single_value->field_lanePosition.is_present()) ret_val++;
      if (single_value->field_impactReduction.is_present()) ret_val++;
      if (single_value->field_externalTemperature.is_present()) ret_val++;
      if (single_value->field_roadWorks.is_present()) ret_val++;
      if (single_value->field_positioningSolution.is_present()) ret_val++;
      if (single_value->field_stationaryVehicle.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.AlacarteContainer containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.AlacarteContainer containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.AlacarteContainer containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.AlacarteContainer containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.AlacarteContainer containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DENM-PDU-Descriptions.AlacarteContainer.");
  }
  return 0;
}

void AlacarteContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ lanePosition := ");
single_value->field_lanePosition.log();
TTCN_Logger::log_event_str(", impactReduction := ");
single_value->field_impactReduction.log();
TTCN_Logger::log_event_str(", externalTemperature := ");
single_value->field_externalTemperature.log();
TTCN_Logger::log_event_str(", roadWorks := ");
single_value->field_roadWorks.log();
TTCN_Logger::log_event_str(", positioningSolution := ");
single_value->field_positioningSolution.log();
TTCN_Logger::log_event_str(", stationaryVehicle := ");
single_value->field_stationaryVehicle.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AlacarteContainer_template::log_match(const AlacarteContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.lanePosition().ispresent()){
if(!single_value->field_lanePosition.match(match_value.lanePosition(), legacy)){
TTCN_Logger::log_logmatch_info(".lanePosition");
single_value->field_lanePosition.log_match(match_value.lanePosition(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_lanePosition.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".lanePosition := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_lanePosition.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.impactReduction().ispresent()){
if(!single_value->field_impactReduction.match(match_value.impactReduction(), legacy)){
TTCN_Logger::log_logmatch_info(".impactReduction");
single_value->field_impactReduction.log_match(match_value.impactReduction(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_impactReduction.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".impactReduction := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_impactReduction.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.externalTemperature().ispresent()){
if(!single_value->field_externalTemperature.match(match_value.externalTemperature(), legacy)){
TTCN_Logger::log_logmatch_info(".externalTemperature");
single_value->field_externalTemperature.log_match(match_value.externalTemperature(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_externalTemperature.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".externalTemperature := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_externalTemperature.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.roadWorks().ispresent()){
if(!single_value->field_roadWorks.match(match_value.roadWorks(), legacy)){
TTCN_Logger::log_logmatch_info(".roadWorks");
single_value->field_roadWorks.log_match(match_value.roadWorks(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_roadWorks.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".roadWorks := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_roadWorks.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.positioningSolution().ispresent()){
if(!single_value->field_positioningSolution.match(match_value.positioningSolution(), legacy)){
TTCN_Logger::log_logmatch_info(".positioningSolution");
single_value->field_positioningSolution.log_match(match_value.positioningSolution(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_positioningSolution.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".positioningSolution := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_positioningSolution.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.stationaryVehicle().ispresent()){
if(!single_value->field_stationaryVehicle.match(match_value.stationaryVehicle(), legacy)){
TTCN_Logger::log_logmatch_info(".stationaryVehicle");
single_value->field_stationaryVehicle.log_match(match_value.stationaryVehicle(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_stationaryVehicle.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".stationaryVehicle := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_stationaryVehicle.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ lanePosition := ");
if (match_value.lanePosition().ispresent()) single_value->field_lanePosition.log_match(match_value.lanePosition(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_lanePosition.log();
if (single_value->field_lanePosition.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", impactReduction := ");
if (match_value.impactReduction().ispresent()) single_value->field_impactReduction.log_match(match_value.impactReduction(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_impactReduction.log();
if (single_value->field_impactReduction.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", externalTemperature := ");
if (match_value.externalTemperature().ispresent()) single_value->field_externalTemperature.log_match(match_value.externalTemperature(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_externalTemperature.log();
if (single_value->field_externalTemperature.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", roadWorks := ");
if (match_value.roadWorks().ispresent()) single_value->field_roadWorks.log_match(match_value.roadWorks(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_roadWorks.log();
if (single_value->field_roadWorks.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", positioningSolution := ");
if (match_value.positioningSolution().ispresent()) single_value->field_positioningSolution.log_match(match_value.positioningSolution(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_positioningSolution.log();
if (single_value->field_positioningSolution.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", stationaryVehicle := ");
if (match_value.stationaryVehicle().ispresent()) single_value->field_stationaryVehicle.log_match(match_value.stationaryVehicle(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_stationaryVehicle.log();
if (single_value->field_stationaryVehicle.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AlacarteContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_lanePosition.encode_text(text_buf);
single_value->field_impactReduction.encode_text(text_buf);
single_value->field_externalTemperature.encode_text(text_buf);
single_value->field_roadWorks.encode_text(text_buf);
single_value->field_positioningSolution.encode_text(text_buf);
single_value->field_stationaryVehicle.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DENM-PDU-Descriptions.AlacarteContainer.");
}
}

void AlacarteContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_lanePosition.decode_text(text_buf);
single_value->field_impactReduction.decode_text(text_buf);
single_value->field_externalTemperature.decode_text(text_buf);
single_value->field_roadWorks.decode_text(text_buf);
single_value->field_positioningSolution.decode_text(text_buf);
single_value->field_stationaryVehicle.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AlacarteContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DENM-PDU-Descriptions.AlacarteContainer.");
}
}

void AlacarteContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DENM-PDU-Descriptions.AlacarteContainer'");
    }
    if (strcmp("lanePosition", param_field) == 0) {
      lanePosition().set_param(param);
      return;
    } else if (strcmp("impactReduction", param_field) == 0) {
      impactReduction().set_param(param);
      return;
    } else if (strcmp("externalTemperature", param_field) == 0) {
      externalTemperature().set_param(param);
      return;
    } else if (strcmp("roadWorks", param_field) == 0) {
      roadWorks().set_param(param);
      return;
    } else if (strcmp("positioningSolution", param_field) == 0) {
      positioningSolution().set_param(param);
      return;
    } else if (strcmp("stationaryVehicle", param_field) == 0) {
      stationaryVehicle().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DENM-PDU-Descriptions.AlacarteContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AlacarteContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record template of type @DENM-PDU-Descriptions.AlacarteContainer has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lanePosition().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) impactReduction().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) externalTemperature().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) roadWorks().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) positioningSolution().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) stationaryVehicle().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lanePosition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lanePosition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "impactReduction")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          impactReduction().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "externalTemperature")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          externalTemperature().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "roadWorks")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          roadWorks().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "positioningSolution")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          positioningSolution().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationaryVehicle")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationaryVehicle().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.AlacarteContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DENM-PDU-Descriptions.AlacarteContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AlacarteContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DENM-PDU-Descriptions.AlacarteContainer'");
    }
    if (strcmp("lanePosition", param_field) == 0) {
      return lanePosition().get_param(param_name);
    } else if (strcmp("impactReduction", param_field) == 0) {
      return impactReduction().get_param(param_name);
    } else if (strcmp("externalTemperature", param_field) == 0) {
      return externalTemperature().get_param(param_name);
    } else if (strcmp("roadWorks", param_field) == 0) {
      return roadWorks().get_param(param_name);
    } else if (strcmp("positioningSolution", param_field) == 0) {
      return positioningSolution().get_param(param_name);
    } else if (strcmp("stationaryVehicle", param_field) == 0) {
      return stationaryVehicle().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.AlacarteContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_lanePosition = single_value->field_lanePosition.get_param(param_name);
    mp_field_lanePosition->set_id(new Module_Param_FieldName(mcopystr("lanePosition")));
    mp->add_elem(mp_field_lanePosition);
    Module_Param* mp_field_impactReduction = single_value->field_impactReduction.get_param(param_name);
    mp_field_impactReduction->set_id(new Module_Param_FieldName(mcopystr("impactReduction")));
    mp->add_elem(mp_field_impactReduction);
    Module_Param* mp_field_externalTemperature = single_value->field_externalTemperature.get_param(param_name);
    mp_field_externalTemperature->set_id(new Module_Param_FieldName(mcopystr("externalTemperature")));
    mp->add_elem(mp_field_externalTemperature);
    Module_Param* mp_field_roadWorks = single_value->field_roadWorks.get_param(param_name);
    mp_field_roadWorks->set_id(new Module_Param_FieldName(mcopystr("roadWorks")));
    mp->add_elem(mp_field_roadWorks);
    Module_Param* mp_field_positioningSolution = single_value->field_positioningSolution.get_param(param_name);
    mp_field_positioningSolution->set_id(new Module_Param_FieldName(mcopystr("positioningSolution")));
    mp->add_elem(mp_field_positioningSolution);
    Module_Param* mp_field_stationaryVehicle = single_value->field_stationaryVehicle.get_param(param_name);
    mp_field_stationaryVehicle->set_id(new Module_Param_FieldName(mcopystr("stationaryVehicle")));
    mp->add_elem(mp_field_stationaryVehicle);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AlacarteContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_lanePosition.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.AlacarteContainer");
single_value->field_impactReduction.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.AlacarteContainer");
single_value->field_externalTemperature.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.AlacarteContainer");
single_value->field_roadWorks.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.AlacarteContainer");
single_value->field_positioningSolution.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.AlacarteContainer");
single_value->field_stationaryVehicle.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.AlacarteContainer");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DENM-PDU-Descriptions.AlacarteContainer");
}

boolean AlacarteContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AlacarteContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ImpactReductionContainer::ImpactReductionContainer()
{
  bound_flag = FALSE;
}

ImpactReductionContainer::ImpactReductionContainer(const INTEGER& par_heightLonCarrLeft,
    const INTEGER& par_heightLonCarrRight,
    const INTEGER& par_posLonCarrLeft,
    const INTEGER& par_posLonCarrRight,
    const ITS__Container::PositionOfPillars& par_positionOfPillars,
    const INTEGER& par_posCentMass,
    const INTEGER& par_wheelBaseVehicle,
    const INTEGER& par_turningRadius,
    const INTEGER& par_posFrontAx,
    const BITSTRING& par_positionOfOccupants,
    const INTEGER& par_vehicleMass,
    const ITS__Container::RequestResponseIndication& par_requestResponseIndication)
  :   field_heightLonCarrLeft(par_heightLonCarrLeft),
  field_heightLonCarrRight(par_heightLonCarrRight),
  field_posLonCarrLeft(par_posLonCarrLeft),
  field_posLonCarrRight(par_posLonCarrRight),
  field_positionOfPillars(par_positionOfPillars),
  field_posCentMass(par_posCentMass),
  field_wheelBaseVehicle(par_wheelBaseVehicle),
  field_turningRadius(par_turningRadius),
  field_posFrontAx(par_posFrontAx),
  field_positionOfOccupants(par_positionOfOccupants),
  field_vehicleMass(par_vehicleMass),
  field_requestResponseIndication(par_requestResponseIndication)
{
  bound_flag = TRUE;
}

ImpactReductionContainer::ImpactReductionContainer(const ImpactReductionContainer& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
bound_flag = TRUE;
if (other_value.heightLonCarrLeft().is_bound()) field_heightLonCarrLeft = other_value.heightLonCarrLeft();
else field_heightLonCarrLeft.clean_up();
if (other_value.heightLonCarrRight().is_bound()) field_heightLonCarrRight = other_value.heightLonCarrRight();
else field_heightLonCarrRight.clean_up();
if (other_value.posLonCarrLeft().is_bound()) field_posLonCarrLeft = other_value.posLonCarrLeft();
else field_posLonCarrLeft.clean_up();
if (other_value.posLonCarrRight().is_bound()) field_posLonCarrRight = other_value.posLonCarrRight();
else field_posLonCarrRight.clean_up();
if (other_value.positionOfPillars().is_bound()) field_positionOfPillars = other_value.positionOfPillars();
else field_positionOfPillars.clean_up();
if (other_value.posCentMass().is_bound()) field_posCentMass = other_value.posCentMass();
else field_posCentMass.clean_up();
if (other_value.wheelBaseVehicle().is_bound()) field_wheelBaseVehicle = other_value.wheelBaseVehicle();
else field_wheelBaseVehicle.clean_up();
if (other_value.turningRadius().is_bound()) field_turningRadius = other_value.turningRadius();
else field_turningRadius.clean_up();
if (other_value.posFrontAx().is_bound()) field_posFrontAx = other_value.posFrontAx();
else field_posFrontAx.clean_up();
if (other_value.positionOfOccupants().is_bound()) field_positionOfOccupants = other_value.positionOfOccupants();
else field_positionOfOccupants.clean_up();
if (other_value.vehicleMass().is_bound()) field_vehicleMass = other_value.vehicleMass();
else field_vehicleMass.clean_up();
if (other_value.requestResponseIndication().is_bound()) field_requestResponseIndication = other_value.requestResponseIndication();
else field_requestResponseIndication.clean_up();
}

void ImpactReductionContainer::clean_up()
{
field_heightLonCarrLeft.clean_up();
field_heightLonCarrRight.clean_up();
field_posLonCarrLeft.clean_up();
field_posLonCarrRight.clean_up();
field_positionOfPillars.clean_up();
field_posCentMass.clean_up();
field_wheelBaseVehicle.clean_up();
field_turningRadius.clean_up();
field_posFrontAx.clean_up();
field_positionOfOccupants.clean_up();
field_vehicleMass.clean_up();
field_requestResponseIndication.clean_up();
bound_flag = FALSE;
}

ImpactReductionContainer& ImpactReductionContainer::operator=(const ImpactReductionContainer& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
  bound_flag = TRUE;
  if (other_value.heightLonCarrLeft().is_bound()) field_heightLonCarrLeft = other_value.heightLonCarrLeft();
  else field_heightLonCarrLeft.clean_up();
  if (other_value.heightLonCarrRight().is_bound()) field_heightLonCarrRight = other_value.heightLonCarrRight();
  else field_heightLonCarrRight.clean_up();
  if (other_value.posLonCarrLeft().is_bound()) field_posLonCarrLeft = other_value.posLonCarrLeft();
  else field_posLonCarrLeft.clean_up();
  if (other_value.posLonCarrRight().is_bound()) field_posLonCarrRight = other_value.posLonCarrRight();
  else field_posLonCarrRight.clean_up();
  if (other_value.positionOfPillars().is_bound()) field_positionOfPillars = other_value.positionOfPillars();
  else field_positionOfPillars.clean_up();
  if (other_value.posCentMass().is_bound()) field_posCentMass = other_value.posCentMass();
  else field_posCentMass.clean_up();
  if (other_value.wheelBaseVehicle().is_bound()) field_wheelBaseVehicle = other_value.wheelBaseVehicle();
  else field_wheelBaseVehicle.clean_up();
  if (other_value.turningRadius().is_bound()) field_turningRadius = other_value.turningRadius();
  else field_turningRadius.clean_up();
  if (other_value.posFrontAx().is_bound()) field_posFrontAx = other_value.posFrontAx();
  else field_posFrontAx.clean_up();
  if (other_value.positionOfOccupants().is_bound()) field_positionOfOccupants = other_value.positionOfOccupants();
  else field_positionOfOccupants.clean_up();
  if (other_value.vehicleMass().is_bound()) field_vehicleMass = other_value.vehicleMass();
  else field_vehicleMass.clean_up();
  if (other_value.requestResponseIndication().is_bound()) field_requestResponseIndication = other_value.requestResponseIndication();
  else field_requestResponseIndication.clean_up();
}
return *this;
}

boolean ImpactReductionContainer::operator==(const ImpactReductionContainer& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_heightLonCarrLeft==other_value.field_heightLonCarrLeft
  && field_heightLonCarrRight==other_value.field_heightLonCarrRight
  && field_posLonCarrLeft==other_value.field_posLonCarrLeft
  && field_posLonCarrRight==other_value.field_posLonCarrRight
  && field_positionOfPillars==other_value.field_positionOfPillars
  && field_posCentMass==other_value.field_posCentMass
  && field_wheelBaseVehicle==other_value.field_wheelBaseVehicle
  && field_turningRadius==other_value.field_turningRadius
  && field_posFrontAx==other_value.field_posFrontAx
  && field_positionOfOccupants==other_value.field_positionOfOccupants
  && field_vehicleMass==other_value.field_vehicleMass
  && field_requestResponseIndication==other_value.field_requestResponseIndication;
}

boolean ImpactReductionContainer::is_bound() const
{
if (bound_flag) return TRUE;
if(field_heightLonCarrLeft.is_bound()) return TRUE;
if(field_heightLonCarrRight.is_bound()) return TRUE;
if(field_posLonCarrLeft.is_bound()) return TRUE;
if(field_posLonCarrRight.is_bound()) return TRUE;
if(field_positionOfPillars.is_bound()) return TRUE;
if(field_posCentMass.is_bound()) return TRUE;
if(field_wheelBaseVehicle.is_bound()) return TRUE;
if(field_turningRadius.is_bound()) return TRUE;
if(field_posFrontAx.is_bound()) return TRUE;
if(field_positionOfOccupants.is_bound()) return TRUE;
if(field_vehicleMass.is_bound()) return TRUE;
if(field_requestResponseIndication.is_bound()) return TRUE;
return FALSE;
}
boolean ImpactReductionContainer::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_heightLonCarrLeft.is_value()) return FALSE;
if(!field_heightLonCarrRight.is_value()) return FALSE;
if(!field_posLonCarrLeft.is_value()) return FALSE;
if(!field_posLonCarrRight.is_value()) return FALSE;
if(!field_positionOfPillars.is_value()) return FALSE;
if(!field_posCentMass.is_value()) return FALSE;
if(!field_wheelBaseVehicle.is_value()) return FALSE;
if(!field_turningRadius.is_value()) return FALSE;
if(!field_posFrontAx.is_value()) return FALSE;
if(!field_positionOfOccupants.is_value()) return FALSE;
if(!field_vehicleMass.is_value()) return FALSE;
if(!field_requestResponseIndication.is_value()) return FALSE;
return TRUE;
}
int ImpactReductionContainer::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DENM-PDU-Descriptions.ImpactReductionContainer");
  return 12;
}

void ImpactReductionContainer::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ heightLonCarrLeft := ");
field_heightLonCarrLeft.log();
TTCN_Logger::log_event_str(", heightLonCarrRight := ");
field_heightLonCarrRight.log();
TTCN_Logger::log_event_str(", posLonCarrLeft := ");
field_posLonCarrLeft.log();
TTCN_Logger::log_event_str(", posLonCarrRight := ");
field_posLonCarrRight.log();
TTCN_Logger::log_event_str(", positionOfPillars := ");
field_positionOfPillars.log();
TTCN_Logger::log_event_str(", posCentMass := ");
field_posCentMass.log();
TTCN_Logger::log_event_str(", wheelBaseVehicle := ");
field_wheelBaseVehicle.log();
TTCN_Logger::log_event_str(", turningRadius := ");
field_turningRadius.log();
TTCN_Logger::log_event_str(", posFrontAx := ");
field_posFrontAx.log();
TTCN_Logger::log_event_str(", positionOfOccupants := ");
field_positionOfOccupants.log();
TTCN_Logger::log_event_str(", vehicleMass := ");
field_vehicleMass.log();
TTCN_Logger::log_event_str(", requestResponseIndication := ");
field_requestResponseIndication.log();
TTCN_Logger::log_event_str(" }");
}

void ImpactReductionContainer::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DENM-PDU-Descriptions.ImpactReductionContainer'");
    }
    if (strcmp("heightLonCarrLeft", param_field) == 0) {
      heightLonCarrLeft().set_param(param);
      return;
    } else if (strcmp("heightLonCarrRight", param_field) == 0) {
      heightLonCarrRight().set_param(param);
      return;
    } else if (strcmp("posLonCarrLeft", param_field) == 0) {
      posLonCarrLeft().set_param(param);
      return;
    } else if (strcmp("posLonCarrRight", param_field) == 0) {
      posLonCarrRight().set_param(param);
      return;
    } else if (strcmp("positionOfPillars", param_field) == 0) {
      positionOfPillars().set_param(param);
      return;
    } else if (strcmp("posCentMass", param_field) == 0) {
      posCentMass().set_param(param);
      return;
    } else if (strcmp("wheelBaseVehicle", param_field) == 0) {
      wheelBaseVehicle().set_param(param);
      return;
    } else if (strcmp("turningRadius", param_field) == 0) {
      turningRadius().set_param(param);
      return;
    } else if (strcmp("posFrontAx", param_field) == 0) {
      posFrontAx().set_param(param);
      return;
    } else if (strcmp("positionOfOccupants", param_field) == 0) {
      positionOfOccupants().set_param(param);
      return;
    } else if (strcmp("vehicleMass", param_field) == 0) {
      vehicleMass().set_param(param);
      return;
    } else if (strcmp("requestResponseIndication", param_field) == 0) {
      requestResponseIndication().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DENM-PDU-Descriptions.ImpactReductionContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (12<mp->get_size()) {
      param.error("record value of type @DENM-PDU-Descriptions.ImpactReductionContainer has 12 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) heightLonCarrLeft().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) heightLonCarrRight().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) posLonCarrLeft().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) posLonCarrRight().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) positionOfPillars().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) posCentMass().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) wheelBaseVehicle().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) turningRadius().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) posFrontAx().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) positionOfOccupants().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) vehicleMass().set_param(*mp->get_elem(10));
    if (mp->get_size()>11 && mp->get_elem(11)->get_type()!=Module_Param::MP_NotUsed) requestResponseIndication().set_param(*mp->get_elem(11));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "heightLonCarrLeft")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          heightLonCarrLeft().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "heightLonCarrRight")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          heightLonCarrRight().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "posLonCarrLeft")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          posLonCarrLeft().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "posLonCarrRight")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          posLonCarrRight().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "positionOfPillars")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          positionOfPillars().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "posCentMass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          posCentMass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "wheelBaseVehicle")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          wheelBaseVehicle().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "turningRadius")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          turningRadius().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "posFrontAx")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          posFrontAx().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "positionOfOccupants")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          positionOfOccupants().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vehicleMass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vehicleMass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "requestResponseIndication")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          requestResponseIndication().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.ImpactReductionContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DENM-PDU-Descriptions.ImpactReductionContainer");
  }
}

Module_Param* ImpactReductionContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DENM-PDU-Descriptions.ImpactReductionContainer'");
    }
    if (strcmp("heightLonCarrLeft", param_field) == 0) {
      return heightLonCarrLeft().get_param(param_name);
    } else if (strcmp("heightLonCarrRight", param_field) == 0) {
      return heightLonCarrRight().get_param(param_name);
    } else if (strcmp("posLonCarrLeft", param_field) == 0) {
      return posLonCarrLeft().get_param(param_name);
    } else if (strcmp("posLonCarrRight", param_field) == 0) {
      return posLonCarrRight().get_param(param_name);
    } else if (strcmp("positionOfPillars", param_field) == 0) {
      return positionOfPillars().get_param(param_name);
    } else if (strcmp("posCentMass", param_field) == 0) {
      return posCentMass().get_param(param_name);
    } else if (strcmp("wheelBaseVehicle", param_field) == 0) {
      return wheelBaseVehicle().get_param(param_name);
    } else if (strcmp("turningRadius", param_field) == 0) {
      return turningRadius().get_param(param_name);
    } else if (strcmp("posFrontAx", param_field) == 0) {
      return posFrontAx().get_param(param_name);
    } else if (strcmp("positionOfOccupants", param_field) == 0) {
      return positionOfOccupants().get_param(param_name);
    } else if (strcmp("vehicleMass", param_field) == 0) {
      return vehicleMass().get_param(param_name);
    } else if (strcmp("requestResponseIndication", param_field) == 0) {
      return requestResponseIndication().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.ImpactReductionContainer'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_heightLonCarrLeft = field_heightLonCarrLeft.get_param(param_name);
  mp_field_heightLonCarrLeft->set_id(new Module_Param_FieldName(mcopystr("heightLonCarrLeft")));
  mp->add_elem(mp_field_heightLonCarrLeft);
  Module_Param* mp_field_heightLonCarrRight = field_heightLonCarrRight.get_param(param_name);
  mp_field_heightLonCarrRight->set_id(new Module_Param_FieldName(mcopystr("heightLonCarrRight")));
  mp->add_elem(mp_field_heightLonCarrRight);
  Module_Param* mp_field_posLonCarrLeft = field_posLonCarrLeft.get_param(param_name);
  mp_field_posLonCarrLeft->set_id(new Module_Param_FieldName(mcopystr("posLonCarrLeft")));
  mp->add_elem(mp_field_posLonCarrLeft);
  Module_Param* mp_field_posLonCarrRight = field_posLonCarrRight.get_param(param_name);
  mp_field_posLonCarrRight->set_id(new Module_Param_FieldName(mcopystr("posLonCarrRight")));
  mp->add_elem(mp_field_posLonCarrRight);
  Module_Param* mp_field_positionOfPillars = field_positionOfPillars.get_param(param_name);
  mp_field_positionOfPillars->set_id(new Module_Param_FieldName(mcopystr("positionOfPillars")));
  mp->add_elem(mp_field_positionOfPillars);
  Module_Param* mp_field_posCentMass = field_posCentMass.get_param(param_name);
  mp_field_posCentMass->set_id(new Module_Param_FieldName(mcopystr("posCentMass")));
  mp->add_elem(mp_field_posCentMass);
  Module_Param* mp_field_wheelBaseVehicle = field_wheelBaseVehicle.get_param(param_name);
  mp_field_wheelBaseVehicle->set_id(new Module_Param_FieldName(mcopystr("wheelBaseVehicle")));
  mp->add_elem(mp_field_wheelBaseVehicle);
  Module_Param* mp_field_turningRadius = field_turningRadius.get_param(param_name);
  mp_field_turningRadius->set_id(new Module_Param_FieldName(mcopystr("turningRadius")));
  mp->add_elem(mp_field_turningRadius);
  Module_Param* mp_field_posFrontAx = field_posFrontAx.get_param(param_name);
  mp_field_posFrontAx->set_id(new Module_Param_FieldName(mcopystr("posFrontAx")));
  mp->add_elem(mp_field_posFrontAx);
  Module_Param* mp_field_positionOfOccupants = field_positionOfOccupants.get_param(param_name);
  mp_field_positionOfOccupants->set_id(new Module_Param_FieldName(mcopystr("positionOfOccupants")));
  mp->add_elem(mp_field_positionOfOccupants);
  Module_Param* mp_field_vehicleMass = field_vehicleMass.get_param(param_name);
  mp_field_vehicleMass->set_id(new Module_Param_FieldName(mcopystr("vehicleMass")));
  mp->add_elem(mp_field_vehicleMass);
  Module_Param* mp_field_requestResponseIndication = field_requestResponseIndication.get_param(param_name);
  mp_field_requestResponseIndication->set_id(new Module_Param_FieldName(mcopystr("requestResponseIndication")));
  mp->add_elem(mp_field_requestResponseIndication);
  return mp;
  }

void ImpactReductionContainer::set_implicit_omit()
{
if (heightLonCarrLeft().is_bound()) heightLonCarrLeft().set_implicit_omit();
if (heightLonCarrRight().is_bound()) heightLonCarrRight().set_implicit_omit();
if (posLonCarrLeft().is_bound()) posLonCarrLeft().set_implicit_omit();
if (posLonCarrRight().is_bound()) posLonCarrRight().set_implicit_omit();
if (positionOfPillars().is_bound()) positionOfPillars().set_implicit_omit();
if (posCentMass().is_bound()) posCentMass().set_implicit_omit();
if (wheelBaseVehicle().is_bound()) wheelBaseVehicle().set_implicit_omit();
if (turningRadius().is_bound()) turningRadius().set_implicit_omit();
if (posFrontAx().is_bound()) posFrontAx().set_implicit_omit();
if (positionOfOccupants().is_bound()) positionOfOccupants().set_implicit_omit();
if (vehicleMass().is_bound()) vehicleMass().set_implicit_omit();
if (requestResponseIndication().is_bound()) requestResponseIndication().set_implicit_omit();
}

void ImpactReductionContainer::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
field_heightLonCarrLeft.encode_text(text_buf);
field_heightLonCarrRight.encode_text(text_buf);
field_posLonCarrLeft.encode_text(text_buf);
field_posLonCarrRight.encode_text(text_buf);
field_positionOfPillars.encode_text(text_buf);
field_posCentMass.encode_text(text_buf);
field_wheelBaseVehicle.encode_text(text_buf);
field_turningRadius.encode_text(text_buf);
field_posFrontAx.encode_text(text_buf);
field_positionOfOccupants.encode_text(text_buf);
field_vehicleMass.encode_text(text_buf);
field_requestResponseIndication.encode_text(text_buf);
}

void ImpactReductionContainer::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_heightLonCarrLeft.decode_text(text_buf);
field_heightLonCarrRight.decode_text(text_buf);
field_posLonCarrLeft.decode_text(text_buf);
field_posLonCarrRight.decode_text(text_buf);
field_positionOfPillars.decode_text(text_buf);
field_posCentMass.decode_text(text_buf);
field_wheelBaseVehicle.decode_text(text_buf);
field_turningRadius.decode_text(text_buf);
field_posFrontAx.decode_text(text_buf);
field_positionOfOccupants.decode_text(text_buf);
field_vehicleMass.decode_text(text_buf);
field_requestResponseIndication.decode_text(text_buf);
}

void ImpactReductionContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ImpactReductionContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* ImpactReductionContainer::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("heightLonCarrLeft': ");
  new_tlv->add_TLV(field_heightLonCarrLeft.BER_encode_TLV(ImpactReductionContainer_heightLonCarrLeft_descr_, p_coding));
  ec_1.set_msg("heightLonCarrRight': ");
  new_tlv->add_TLV(field_heightLonCarrRight.BER_encode_TLV(ImpactReductionContainer_heightLonCarrRight_descr_, p_coding));
  ec_1.set_msg("posLonCarrLeft': ");
  new_tlv->add_TLV(field_posLonCarrLeft.BER_encode_TLV(ImpactReductionContainer_posLonCarrLeft_descr_, p_coding));
  ec_1.set_msg("posLonCarrRight': ");
  new_tlv->add_TLV(field_posLonCarrRight.BER_encode_TLV(ImpactReductionContainer_posLonCarrRight_descr_, p_coding));
  ec_1.set_msg("positionOfPillars': ");
  new_tlv->add_TLV(field_positionOfPillars.BER_encode_TLV(ImpactReductionContainer_positionOfPillars_descr_, p_coding));
  ec_1.set_msg("posCentMass': ");
  new_tlv->add_TLV(field_posCentMass.BER_encode_TLV(ImpactReductionContainer_posCentMass_descr_, p_coding));
  ec_1.set_msg("wheelBaseVehicle': ");
  new_tlv->add_TLV(field_wheelBaseVehicle.BER_encode_TLV(ImpactReductionContainer_wheelBaseVehicle_descr_, p_coding));
  ec_1.set_msg("turningRadius': ");
  new_tlv->add_TLV(field_turningRadius.BER_encode_TLV(ImpactReductionContainer_turningRadius_descr_, p_coding));
  ec_1.set_msg("posFrontAx': ");
  new_tlv->add_TLV(field_posFrontAx.BER_encode_TLV(ImpactReductionContainer_posFrontAx_descr_, p_coding));
  ec_1.set_msg("positionOfOccupants': ");
  new_tlv->add_TLV(field_positionOfOccupants.BER_encode_TLV(ImpactReductionContainer_positionOfOccupants_descr_, p_coding));
  ec_1.set_msg("vehicleMass': ");
  new_tlv->add_TLV(field_vehicleMass.BER_encode_TLV(ImpactReductionContainer_vehicleMass_descr_, p_coding));
  ec_1.set_msg("requestResponseIndication': ");
  new_tlv->add_TLV(field_requestResponseIndication.BER_encode_TLV(ImpactReductionContainer_requestResponseIndication_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean ImpactReductionContainer::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DENM-PDU-Descriptions.ImpactReductionContainer' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("heightLonCarrLeft': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_heightLonCarrLeft.BER_decode_TLV(ImpactReductionContainer_heightLonCarrLeft_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("heightLonCarrRight': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_heightLonCarrRight.BER_decode_TLV(ImpactReductionContainer_heightLonCarrRight_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("posLonCarrLeft': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_posLonCarrLeft.BER_decode_TLV(ImpactReductionContainer_posLonCarrLeft_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("posLonCarrRight': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_posLonCarrRight.BER_decode_TLV(ImpactReductionContainer_posLonCarrRight_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("positionOfPillars': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_positionOfPillars.BER_decode_TLV(ImpactReductionContainer_positionOfPillars_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("posCentMass': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_posCentMass.BER_decode_TLV(ImpactReductionContainer_posCentMass_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("wheelBaseVehicle': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_wheelBaseVehicle.BER_decode_TLV(ImpactReductionContainer_wheelBaseVehicle_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("turningRadius': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_turningRadius.BER_decode_TLV(ImpactReductionContainer_turningRadius_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("posFrontAx': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_posFrontAx.BER_decode_TLV(ImpactReductionContainer_posFrontAx_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("positionOfOccupants': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_positionOfOccupants.BER_decode_TLV(ImpactReductionContainer_positionOfOccupants_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("vehicleMass': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_vehicleMass.BER_decode_TLV(ImpactReductionContainer_vehicleMass_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("requestResponseIndication': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_requestResponseIndication.BER_decode_TLV(ImpactReductionContainer_requestResponseIndication_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int ImpactReductionContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "heightLonCarrLeft");
    enc_len += field_heightLonCarrLeft.JSON_encode(ImpactReductionContainer_heightLonCarrLeft_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "heightLonCarrRight");
    enc_len += field_heightLonCarrRight.JSON_encode(ImpactReductionContainer_heightLonCarrRight_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "posLonCarrLeft");
    enc_len += field_posLonCarrLeft.JSON_encode(ImpactReductionContainer_posLonCarrLeft_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "posLonCarrRight");
    enc_len += field_posLonCarrRight.JSON_encode(ImpactReductionContainer_posLonCarrRight_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "positionOfPillars");
    enc_len += field_positionOfPillars.JSON_encode(ImpactReductionContainer_positionOfPillars_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "posCentMass");
    enc_len += field_posCentMass.JSON_encode(ImpactReductionContainer_posCentMass_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "wheelBaseVehicle");
    enc_len += field_wheelBaseVehicle.JSON_encode(ImpactReductionContainer_wheelBaseVehicle_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "turningRadius");
    enc_len += field_turningRadius.JSON_encode(ImpactReductionContainer_turningRadius_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "posFrontAx");
    enc_len += field_posFrontAx.JSON_encode(ImpactReductionContainer_posFrontAx_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "positionOfOccupants");
    enc_len += field_positionOfOccupants.JSON_encode(ImpactReductionContainer_positionOfOccupants_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "vehicleMass");
    enc_len += field_vehicleMass.JSON_encode(ImpactReductionContainer_vehicleMass_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "requestResponseIndication");
    enc_len += field_requestResponseIndication.JSON_encode(ImpactReductionContainer_requestResponseIndication_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ImpactReductionContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (17 == name_len && 0 == strncmp(fld_name, "heightLonCarrLeft", name_len)) {
         int ret_val = field_heightLonCarrLeft.JSON_decode(ImpactReductionContainer_heightLonCarrLeft_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "heightLonCarrLeft");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "heightLonCarrRight", name_len)) {
         int ret_val = field_heightLonCarrRight.JSON_decode(ImpactReductionContainer_heightLonCarrRight_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "heightLonCarrRight");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "posLonCarrLeft", name_len)) {
         int ret_val = field_posLonCarrLeft.JSON_decode(ImpactReductionContainer_posLonCarrLeft_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "posLonCarrLeft");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "posLonCarrRight", name_len)) {
         int ret_val = field_posLonCarrRight.JSON_decode(ImpactReductionContainer_posLonCarrRight_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "posLonCarrRight");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "positionOfPillars", name_len)) {
         int ret_val = field_positionOfPillars.JSON_decode(ImpactReductionContainer_positionOfPillars_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "positionOfPillars");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "posCentMass", name_len)) {
         int ret_val = field_posCentMass.JSON_decode(ImpactReductionContainer_posCentMass_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "posCentMass");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (16 == name_len && 0 == strncmp(fld_name, "wheelBaseVehicle", name_len)) {
         int ret_val = field_wheelBaseVehicle.JSON_decode(ImpactReductionContainer_wheelBaseVehicle_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "wheelBaseVehicle");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "turningRadius", name_len)) {
         int ret_val = field_turningRadius.JSON_decode(ImpactReductionContainer_turningRadius_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "turningRadius");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "posFrontAx", name_len)) {
         int ret_val = field_posFrontAx.JSON_decode(ImpactReductionContainer_posFrontAx_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "posFrontAx");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (19 == name_len && 0 == strncmp(fld_name, "positionOfOccupants", name_len)) {
         int ret_val = field_positionOfOccupants.JSON_decode(ImpactReductionContainer_positionOfOccupants_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "positionOfOccupants");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "vehicleMass", name_len)) {
         int ret_val = field_vehicleMass.JSON_decode(ImpactReductionContainer_vehicleMass_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "vehicleMass");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (25 == name_len && 0 == strncmp(fld_name, "requestResponseIndication", name_len)) {
         int ret_val = field_requestResponseIndication.JSON_decode(ImpactReductionContainer_requestResponseIndication_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "requestResponseIndication");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_heightLonCarrLeft.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "heightLonCarrLeft");
    return JSON_ERROR_FATAL;
  }
if (!field_heightLonCarrRight.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "heightLonCarrRight");
    return JSON_ERROR_FATAL;
  }
if (!field_posLonCarrLeft.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "posLonCarrLeft");
    return JSON_ERROR_FATAL;
  }
if (!field_posLonCarrRight.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "posLonCarrRight");
    return JSON_ERROR_FATAL;
  }
if (!field_positionOfPillars.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "positionOfPillars");
    return JSON_ERROR_FATAL;
  }
if (!field_posCentMass.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "posCentMass");
    return JSON_ERROR_FATAL;
  }
if (!field_wheelBaseVehicle.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "wheelBaseVehicle");
    return JSON_ERROR_FATAL;
  }
if (!field_turningRadius.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "turningRadius");
    return JSON_ERROR_FATAL;
  }
if (!field_posFrontAx.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "posFrontAx");
    return JSON_ERROR_FATAL;
  }
if (!field_positionOfOccupants.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "positionOfOccupants");
    return JSON_ERROR_FATAL;
  }
if (!field_vehicleMass.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "vehicleMass");
    return JSON_ERROR_FATAL;
  }
if (!field_requestResponseIndication.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "requestResponseIndication");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ImpactReductionContainer_template::single_value_struct {
INTEGER_template field_heightLonCarrLeft;
INTEGER_template field_heightLonCarrRight;
INTEGER_template field_posLonCarrLeft;
INTEGER_template field_posLonCarrRight;
ITS__Container::PositionOfPillars_template field_positionOfPillars;
INTEGER_template field_posCentMass;
INTEGER_template field_wheelBaseVehicle;
INTEGER_template field_turningRadius;
INTEGER_template field_posFrontAx;
BITSTRING_template field_positionOfOccupants;
INTEGER_template field_vehicleMass;
ITS__Container::RequestResponseIndication_template field_requestResponseIndication;
};

void ImpactReductionContainer_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_heightLonCarrLeft = ANY_VALUE;
single_value->field_heightLonCarrRight = ANY_VALUE;
single_value->field_posLonCarrLeft = ANY_VALUE;
single_value->field_posLonCarrRight = ANY_VALUE;
single_value->field_positionOfPillars = ANY_VALUE;
single_value->field_posCentMass = ANY_VALUE;
single_value->field_wheelBaseVehicle = ANY_VALUE;
single_value->field_turningRadius = ANY_VALUE;
single_value->field_posFrontAx = ANY_VALUE;
single_value->field_positionOfOccupants = ANY_VALUE;
single_value->field_vehicleMass = ANY_VALUE;
single_value->field_requestResponseIndication = ANY_VALUE;
}
}
}

void ImpactReductionContainer_template::copy_value(const ImpactReductionContainer& other_value)
{
single_value = new single_value_struct;
if (other_value.heightLonCarrLeft().is_bound()) {
  single_value->field_heightLonCarrLeft = other_value.heightLonCarrLeft();
} else {
  single_value->field_heightLonCarrLeft.clean_up();
}
if (other_value.heightLonCarrRight().is_bound()) {
  single_value->field_heightLonCarrRight = other_value.heightLonCarrRight();
} else {
  single_value->field_heightLonCarrRight.clean_up();
}
if (other_value.posLonCarrLeft().is_bound()) {
  single_value->field_posLonCarrLeft = other_value.posLonCarrLeft();
} else {
  single_value->field_posLonCarrLeft.clean_up();
}
if (other_value.posLonCarrRight().is_bound()) {
  single_value->field_posLonCarrRight = other_value.posLonCarrRight();
} else {
  single_value->field_posLonCarrRight.clean_up();
}
if (other_value.positionOfPillars().is_bound()) {
  single_value->field_positionOfPillars = other_value.positionOfPillars();
} else {
  single_value->field_positionOfPillars.clean_up();
}
if (other_value.posCentMass().is_bound()) {
  single_value->field_posCentMass = other_value.posCentMass();
} else {
  single_value->field_posCentMass.clean_up();
}
if (other_value.wheelBaseVehicle().is_bound()) {
  single_value->field_wheelBaseVehicle = other_value.wheelBaseVehicle();
} else {
  single_value->field_wheelBaseVehicle.clean_up();
}
if (other_value.turningRadius().is_bound()) {
  single_value->field_turningRadius = other_value.turningRadius();
} else {
  single_value->field_turningRadius.clean_up();
}
if (other_value.posFrontAx().is_bound()) {
  single_value->field_posFrontAx = other_value.posFrontAx();
} else {
  single_value->field_posFrontAx.clean_up();
}
if (other_value.positionOfOccupants().is_bound()) {
  single_value->field_positionOfOccupants = other_value.positionOfOccupants();
} else {
  single_value->field_positionOfOccupants.clean_up();
}
if (other_value.vehicleMass().is_bound()) {
  single_value->field_vehicleMass = other_value.vehicleMass();
} else {
  single_value->field_vehicleMass.clean_up();
}
if (other_value.requestResponseIndication().is_bound()) {
  single_value->field_requestResponseIndication = other_value.requestResponseIndication();
} else {
  single_value->field_requestResponseIndication.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ImpactReductionContainer_template::copy_template(const ImpactReductionContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.heightLonCarrLeft().get_selection()) {
single_value->field_heightLonCarrLeft = other_value.heightLonCarrLeft();
} else {
single_value->field_heightLonCarrLeft.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.heightLonCarrRight().get_selection()) {
single_value->field_heightLonCarrRight = other_value.heightLonCarrRight();
} else {
single_value->field_heightLonCarrRight.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.posLonCarrLeft().get_selection()) {
single_value->field_posLonCarrLeft = other_value.posLonCarrLeft();
} else {
single_value->field_posLonCarrLeft.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.posLonCarrRight().get_selection()) {
single_value->field_posLonCarrRight = other_value.posLonCarrRight();
} else {
single_value->field_posLonCarrRight.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.positionOfPillars().get_selection()) {
single_value->field_positionOfPillars = other_value.positionOfPillars();
} else {
single_value->field_positionOfPillars.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.posCentMass().get_selection()) {
single_value->field_posCentMass = other_value.posCentMass();
} else {
single_value->field_posCentMass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.wheelBaseVehicle().get_selection()) {
single_value->field_wheelBaseVehicle = other_value.wheelBaseVehicle();
} else {
single_value->field_wheelBaseVehicle.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.turningRadius().get_selection()) {
single_value->field_turningRadius = other_value.turningRadius();
} else {
single_value->field_turningRadius.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.posFrontAx().get_selection()) {
single_value->field_posFrontAx = other_value.posFrontAx();
} else {
single_value->field_posFrontAx.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.positionOfOccupants().get_selection()) {
single_value->field_positionOfOccupants = other_value.positionOfOccupants();
} else {
single_value->field_positionOfOccupants.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.vehicleMass().get_selection()) {
single_value->field_vehicleMass = other_value.vehicleMass();
} else {
single_value->field_vehicleMass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.requestResponseIndication().get_selection()) {
single_value->field_requestResponseIndication = other_value.requestResponseIndication();
} else {
single_value->field_requestResponseIndication.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ImpactReductionContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
break;
}
set_selection(other_value);
}

ImpactReductionContainer_template::ImpactReductionContainer_template()
{
}

ImpactReductionContainer_template::ImpactReductionContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ImpactReductionContainer_template::ImpactReductionContainer_template(const ImpactReductionContainer& other_value)
{
copy_value(other_value);
}

ImpactReductionContainer_template::ImpactReductionContainer_template(const OPTIONAL<ImpactReductionContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ImpactReductionContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DENM-PDU-Descriptions.ImpactReductionContainer from an unbound optional field.");
}
}

ImpactReductionContainer_template::ImpactReductionContainer_template(const ImpactReductionContainer_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ImpactReductionContainer_template::~ImpactReductionContainer_template()
{
clean_up();
}

ImpactReductionContainer_template& ImpactReductionContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ImpactReductionContainer_template& ImpactReductionContainer_template::operator=(const ImpactReductionContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ImpactReductionContainer_template& ImpactReductionContainer_template::operator=(const OPTIONAL<ImpactReductionContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ImpactReductionContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
}
return *this;
}

ImpactReductionContainer_template& ImpactReductionContainer_template::operator=(const ImpactReductionContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ImpactReductionContainer_template::match(const ImpactReductionContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.heightLonCarrLeft().is_bound()) return FALSE;
if(!single_value->field_heightLonCarrLeft.match(other_value.heightLonCarrLeft(), legacy))return FALSE;
if(!other_value.heightLonCarrRight().is_bound()) return FALSE;
if(!single_value->field_heightLonCarrRight.match(other_value.heightLonCarrRight(), legacy))return FALSE;
if(!other_value.posLonCarrLeft().is_bound()) return FALSE;
if(!single_value->field_posLonCarrLeft.match(other_value.posLonCarrLeft(), legacy))return FALSE;
if(!other_value.posLonCarrRight().is_bound()) return FALSE;
if(!single_value->field_posLonCarrRight.match(other_value.posLonCarrRight(), legacy))return FALSE;
if(!other_value.positionOfPillars().is_bound()) return FALSE;
if(!single_value->field_positionOfPillars.match(other_value.positionOfPillars(), legacy))return FALSE;
if(!other_value.posCentMass().is_bound()) return FALSE;
if(!single_value->field_posCentMass.match(other_value.posCentMass(), legacy))return FALSE;
if(!other_value.wheelBaseVehicle().is_bound()) return FALSE;
if(!single_value->field_wheelBaseVehicle.match(other_value.wheelBaseVehicle(), legacy))return FALSE;
if(!other_value.turningRadius().is_bound()) return FALSE;
if(!single_value->field_turningRadius.match(other_value.turningRadius(), legacy))return FALSE;
if(!other_value.posFrontAx().is_bound()) return FALSE;
if(!single_value->field_posFrontAx.match(other_value.posFrontAx(), legacy))return FALSE;
if(!other_value.positionOfOccupants().is_bound()) return FALSE;
if(!single_value->field_positionOfOccupants.match(other_value.positionOfOccupants(), legacy))return FALSE;
if(!other_value.vehicleMass().is_bound()) return FALSE;
if(!single_value->field_vehicleMass.match(other_value.vehicleMass(), legacy))return FALSE;
if(!other_value.requestResponseIndication().is_bound()) return FALSE;
if(!single_value->field_requestResponseIndication.match(other_value.requestResponseIndication(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
}
return FALSE;
}

boolean ImpactReductionContainer_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_heightLonCarrLeft.is_bound()) return TRUE;
if (single_value->field_heightLonCarrRight.is_bound()) return TRUE;
if (single_value->field_posLonCarrLeft.is_bound()) return TRUE;
if (single_value->field_posLonCarrRight.is_bound()) return TRUE;
if (single_value->field_positionOfPillars.is_bound()) return TRUE;
if (single_value->field_posCentMass.is_bound()) return TRUE;
if (single_value->field_wheelBaseVehicle.is_bound()) return TRUE;
if (single_value->field_turningRadius.is_bound()) return TRUE;
if (single_value->field_posFrontAx.is_bound()) return TRUE;
if (single_value->field_positionOfOccupants.is_bound()) return TRUE;
if (single_value->field_vehicleMass.is_bound()) return TRUE;
if (single_value->field_requestResponseIndication.is_bound()) return TRUE;
return FALSE;
}

boolean ImpactReductionContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_heightLonCarrLeft.is_value()) return FALSE;
if (!single_value->field_heightLonCarrRight.is_value()) return FALSE;
if (!single_value->field_posLonCarrLeft.is_value()) return FALSE;
if (!single_value->field_posLonCarrRight.is_value()) return FALSE;
if (!single_value->field_positionOfPillars.is_value()) return FALSE;
if (!single_value->field_posCentMass.is_value()) return FALSE;
if (!single_value->field_wheelBaseVehicle.is_value()) return FALSE;
if (!single_value->field_turningRadius.is_value()) return FALSE;
if (!single_value->field_posFrontAx.is_value()) return FALSE;
if (!single_value->field_positionOfOccupants.is_value()) return FALSE;
if (!single_value->field_vehicleMass.is_value()) return FALSE;
if (!single_value->field_requestResponseIndication.is_value()) return FALSE;
return TRUE;
}

void ImpactReductionContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ImpactReductionContainer ImpactReductionContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
ImpactReductionContainer ret_val;
if (single_value->field_heightLonCarrLeft.is_bound()) {
ret_val.heightLonCarrLeft() = single_value->field_heightLonCarrLeft.valueof();
}
if (single_value->field_heightLonCarrRight.is_bound()) {
ret_val.heightLonCarrRight() = single_value->field_heightLonCarrRight.valueof();
}
if (single_value->field_posLonCarrLeft.is_bound()) {
ret_val.posLonCarrLeft() = single_value->field_posLonCarrLeft.valueof();
}
if (single_value->field_posLonCarrRight.is_bound()) {
ret_val.posLonCarrRight() = single_value->field_posLonCarrRight.valueof();
}
if (single_value->field_positionOfPillars.is_bound()) {
ret_val.positionOfPillars() = single_value->field_positionOfPillars.valueof();
}
if (single_value->field_posCentMass.is_bound()) {
ret_val.posCentMass() = single_value->field_posCentMass.valueof();
}
if (single_value->field_wheelBaseVehicle.is_bound()) {
ret_val.wheelBaseVehicle() = single_value->field_wheelBaseVehicle.valueof();
}
if (single_value->field_turningRadius.is_bound()) {
ret_val.turningRadius() = single_value->field_turningRadius.valueof();
}
if (single_value->field_posFrontAx.is_bound()) {
ret_val.posFrontAx() = single_value->field_posFrontAx.valueof();
}
if (single_value->field_positionOfOccupants.is_bound()) {
ret_val.positionOfOccupants() = single_value->field_positionOfOccupants.valueof();
}
if (single_value->field_vehicleMass.is_bound()) {
ret_val.vehicleMass() = single_value->field_vehicleMass.valueof();
}
if (single_value->field_requestResponseIndication.is_bound()) {
ret_val.requestResponseIndication() = single_value->field_requestResponseIndication.valueof();
}
return ret_val;
}

void ImpactReductionContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ImpactReductionContainer_template[list_length];
}

ImpactReductionContainer_template& ImpactReductionContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
return value_list.list_value[list_index];
}

INTEGER_template& ImpactReductionContainer_template::heightLonCarrLeft()
{
set_specific();
return single_value->field_heightLonCarrLeft;
}

const INTEGER_template& ImpactReductionContainer_template::heightLonCarrLeft() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field heightLonCarrLeft of a non-specific template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
return single_value->field_heightLonCarrLeft;
}

INTEGER_template& ImpactReductionContainer_template::heightLonCarrRight()
{
set_specific();
return single_value->field_heightLonCarrRight;
}

const INTEGER_template& ImpactReductionContainer_template::heightLonCarrRight() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field heightLonCarrRight of a non-specific template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
return single_value->field_heightLonCarrRight;
}

INTEGER_template& ImpactReductionContainer_template::posLonCarrLeft()
{
set_specific();
return single_value->field_posLonCarrLeft;
}

const INTEGER_template& ImpactReductionContainer_template::posLonCarrLeft() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field posLonCarrLeft of a non-specific template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
return single_value->field_posLonCarrLeft;
}

INTEGER_template& ImpactReductionContainer_template::posLonCarrRight()
{
set_specific();
return single_value->field_posLonCarrRight;
}

const INTEGER_template& ImpactReductionContainer_template::posLonCarrRight() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field posLonCarrRight of a non-specific template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
return single_value->field_posLonCarrRight;
}

ITS__Container::PositionOfPillars_template& ImpactReductionContainer_template::positionOfPillars()
{
set_specific();
return single_value->field_positionOfPillars;
}

const ITS__Container::PositionOfPillars_template& ImpactReductionContainer_template::positionOfPillars() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field positionOfPillars of a non-specific template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
return single_value->field_positionOfPillars;
}

INTEGER_template& ImpactReductionContainer_template::posCentMass()
{
set_specific();
return single_value->field_posCentMass;
}

const INTEGER_template& ImpactReductionContainer_template::posCentMass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field posCentMass of a non-specific template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
return single_value->field_posCentMass;
}

INTEGER_template& ImpactReductionContainer_template::wheelBaseVehicle()
{
set_specific();
return single_value->field_wheelBaseVehicle;
}

const INTEGER_template& ImpactReductionContainer_template::wheelBaseVehicle() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field wheelBaseVehicle of a non-specific template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
return single_value->field_wheelBaseVehicle;
}

INTEGER_template& ImpactReductionContainer_template::turningRadius()
{
set_specific();
return single_value->field_turningRadius;
}

const INTEGER_template& ImpactReductionContainer_template::turningRadius() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field turningRadius of a non-specific template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
return single_value->field_turningRadius;
}

INTEGER_template& ImpactReductionContainer_template::posFrontAx()
{
set_specific();
return single_value->field_posFrontAx;
}

const INTEGER_template& ImpactReductionContainer_template::posFrontAx() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field posFrontAx of a non-specific template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
return single_value->field_posFrontAx;
}

BITSTRING_template& ImpactReductionContainer_template::positionOfOccupants()
{
set_specific();
return single_value->field_positionOfOccupants;
}

const BITSTRING_template& ImpactReductionContainer_template::positionOfOccupants() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field positionOfOccupants of a non-specific template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
return single_value->field_positionOfOccupants;
}

INTEGER_template& ImpactReductionContainer_template::vehicleMass()
{
set_specific();
return single_value->field_vehicleMass;
}

const INTEGER_template& ImpactReductionContainer_template::vehicleMass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field vehicleMass of a non-specific template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
return single_value->field_vehicleMass;
}

ITS__Container::RequestResponseIndication_template& ImpactReductionContainer_template::requestResponseIndication()
{
set_specific();
return single_value->field_requestResponseIndication;
}

const ITS__Container::RequestResponseIndication_template& ImpactReductionContainer_template::requestResponseIndication() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field requestResponseIndication of a non-specific template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
return single_value->field_requestResponseIndication;
}

int ImpactReductionContainer_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.ImpactReductionContainer which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 12;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.ImpactReductionContainer containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.ImpactReductionContainer containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.ImpactReductionContainer containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.ImpactReductionContainer containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.ImpactReductionContainer containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
  }
  return 0;
}

void ImpactReductionContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ heightLonCarrLeft := ");
single_value->field_heightLonCarrLeft.log();
TTCN_Logger::log_event_str(", heightLonCarrRight := ");
single_value->field_heightLonCarrRight.log();
TTCN_Logger::log_event_str(", posLonCarrLeft := ");
single_value->field_posLonCarrLeft.log();
TTCN_Logger::log_event_str(", posLonCarrRight := ");
single_value->field_posLonCarrRight.log();
TTCN_Logger::log_event_str(", positionOfPillars := ");
single_value->field_positionOfPillars.log();
TTCN_Logger::log_event_str(", posCentMass := ");
single_value->field_posCentMass.log();
TTCN_Logger::log_event_str(", wheelBaseVehicle := ");
single_value->field_wheelBaseVehicle.log();
TTCN_Logger::log_event_str(", turningRadius := ");
single_value->field_turningRadius.log();
TTCN_Logger::log_event_str(", posFrontAx := ");
single_value->field_posFrontAx.log();
TTCN_Logger::log_event_str(", positionOfOccupants := ");
single_value->field_positionOfOccupants.log();
TTCN_Logger::log_event_str(", vehicleMass := ");
single_value->field_vehicleMass.log();
TTCN_Logger::log_event_str(", requestResponseIndication := ");
single_value->field_requestResponseIndication.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ImpactReductionContainer_template::log_match(const ImpactReductionContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_heightLonCarrLeft.match(match_value.heightLonCarrLeft(), legacy)){
TTCN_Logger::log_logmatch_info(".heightLonCarrLeft");
single_value->field_heightLonCarrLeft.log_match(match_value.heightLonCarrLeft(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_heightLonCarrRight.match(match_value.heightLonCarrRight(), legacy)){
TTCN_Logger::log_logmatch_info(".heightLonCarrRight");
single_value->field_heightLonCarrRight.log_match(match_value.heightLonCarrRight(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_posLonCarrLeft.match(match_value.posLonCarrLeft(), legacy)){
TTCN_Logger::log_logmatch_info(".posLonCarrLeft");
single_value->field_posLonCarrLeft.log_match(match_value.posLonCarrLeft(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_posLonCarrRight.match(match_value.posLonCarrRight(), legacy)){
TTCN_Logger::log_logmatch_info(".posLonCarrRight");
single_value->field_posLonCarrRight.log_match(match_value.posLonCarrRight(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_positionOfPillars.match(match_value.positionOfPillars(), legacy)){
TTCN_Logger::log_logmatch_info(".positionOfPillars");
single_value->field_positionOfPillars.log_match(match_value.positionOfPillars(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_posCentMass.match(match_value.posCentMass(), legacy)){
TTCN_Logger::log_logmatch_info(".posCentMass");
single_value->field_posCentMass.log_match(match_value.posCentMass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_wheelBaseVehicle.match(match_value.wheelBaseVehicle(), legacy)){
TTCN_Logger::log_logmatch_info(".wheelBaseVehicle");
single_value->field_wheelBaseVehicle.log_match(match_value.wheelBaseVehicle(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_turningRadius.match(match_value.turningRadius(), legacy)){
TTCN_Logger::log_logmatch_info(".turningRadius");
single_value->field_turningRadius.log_match(match_value.turningRadius(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_posFrontAx.match(match_value.posFrontAx(), legacy)){
TTCN_Logger::log_logmatch_info(".posFrontAx");
single_value->field_posFrontAx.log_match(match_value.posFrontAx(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_positionOfOccupants.match(match_value.positionOfOccupants(), legacy)){
TTCN_Logger::log_logmatch_info(".positionOfOccupants");
single_value->field_positionOfOccupants.log_match(match_value.positionOfOccupants(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_vehicleMass.match(match_value.vehicleMass(), legacy)){
TTCN_Logger::log_logmatch_info(".vehicleMass");
single_value->field_vehicleMass.log_match(match_value.vehicleMass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_requestResponseIndication.match(match_value.requestResponseIndication(), legacy)){
TTCN_Logger::log_logmatch_info(".requestResponseIndication");
single_value->field_requestResponseIndication.log_match(match_value.requestResponseIndication(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ heightLonCarrLeft := ");
single_value->field_heightLonCarrLeft.log_match(match_value.heightLonCarrLeft(), legacy);
TTCN_Logger::log_event_str(", heightLonCarrRight := ");
single_value->field_heightLonCarrRight.log_match(match_value.heightLonCarrRight(), legacy);
TTCN_Logger::log_event_str(", posLonCarrLeft := ");
single_value->field_posLonCarrLeft.log_match(match_value.posLonCarrLeft(), legacy);
TTCN_Logger::log_event_str(", posLonCarrRight := ");
single_value->field_posLonCarrRight.log_match(match_value.posLonCarrRight(), legacy);
TTCN_Logger::log_event_str(", positionOfPillars := ");
single_value->field_positionOfPillars.log_match(match_value.positionOfPillars(), legacy);
TTCN_Logger::log_event_str(", posCentMass := ");
single_value->field_posCentMass.log_match(match_value.posCentMass(), legacy);
TTCN_Logger::log_event_str(", wheelBaseVehicle := ");
single_value->field_wheelBaseVehicle.log_match(match_value.wheelBaseVehicle(), legacy);
TTCN_Logger::log_event_str(", turningRadius := ");
single_value->field_turningRadius.log_match(match_value.turningRadius(), legacy);
TTCN_Logger::log_event_str(", posFrontAx := ");
single_value->field_posFrontAx.log_match(match_value.posFrontAx(), legacy);
TTCN_Logger::log_event_str(", positionOfOccupants := ");
single_value->field_positionOfOccupants.log_match(match_value.positionOfOccupants(), legacy);
TTCN_Logger::log_event_str(", vehicleMass := ");
single_value->field_vehicleMass.log_match(match_value.vehicleMass(), legacy);
TTCN_Logger::log_event_str(", requestResponseIndication := ");
single_value->field_requestResponseIndication.log_match(match_value.requestResponseIndication(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ImpactReductionContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_heightLonCarrLeft.encode_text(text_buf);
single_value->field_heightLonCarrRight.encode_text(text_buf);
single_value->field_posLonCarrLeft.encode_text(text_buf);
single_value->field_posLonCarrRight.encode_text(text_buf);
single_value->field_positionOfPillars.encode_text(text_buf);
single_value->field_posCentMass.encode_text(text_buf);
single_value->field_wheelBaseVehicle.encode_text(text_buf);
single_value->field_turningRadius.encode_text(text_buf);
single_value->field_posFrontAx.encode_text(text_buf);
single_value->field_positionOfOccupants.encode_text(text_buf);
single_value->field_vehicleMass.encode_text(text_buf);
single_value->field_requestResponseIndication.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
}
}

void ImpactReductionContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_heightLonCarrLeft.decode_text(text_buf);
single_value->field_heightLonCarrRight.decode_text(text_buf);
single_value->field_posLonCarrLeft.decode_text(text_buf);
single_value->field_posLonCarrRight.decode_text(text_buf);
single_value->field_positionOfPillars.decode_text(text_buf);
single_value->field_posCentMass.decode_text(text_buf);
single_value->field_wheelBaseVehicle.decode_text(text_buf);
single_value->field_turningRadius.decode_text(text_buf);
single_value->field_posFrontAx.decode_text(text_buf);
single_value->field_positionOfOccupants.decode_text(text_buf);
single_value->field_vehicleMass.decode_text(text_buf);
single_value->field_requestResponseIndication.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ImpactReductionContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DENM-PDU-Descriptions.ImpactReductionContainer.");
}
}

void ImpactReductionContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DENM-PDU-Descriptions.ImpactReductionContainer'");
    }
    if (strcmp("heightLonCarrLeft", param_field) == 0) {
      heightLonCarrLeft().set_param(param);
      return;
    } else if (strcmp("heightLonCarrRight", param_field) == 0) {
      heightLonCarrRight().set_param(param);
      return;
    } else if (strcmp("posLonCarrLeft", param_field) == 0) {
      posLonCarrLeft().set_param(param);
      return;
    } else if (strcmp("posLonCarrRight", param_field) == 0) {
      posLonCarrRight().set_param(param);
      return;
    } else if (strcmp("positionOfPillars", param_field) == 0) {
      positionOfPillars().set_param(param);
      return;
    } else if (strcmp("posCentMass", param_field) == 0) {
      posCentMass().set_param(param);
      return;
    } else if (strcmp("wheelBaseVehicle", param_field) == 0) {
      wheelBaseVehicle().set_param(param);
      return;
    } else if (strcmp("turningRadius", param_field) == 0) {
      turningRadius().set_param(param);
      return;
    } else if (strcmp("posFrontAx", param_field) == 0) {
      posFrontAx().set_param(param);
      return;
    } else if (strcmp("positionOfOccupants", param_field) == 0) {
      positionOfOccupants().set_param(param);
      return;
    } else if (strcmp("vehicleMass", param_field) == 0) {
      vehicleMass().set_param(param);
      return;
    } else if (strcmp("requestResponseIndication", param_field) == 0) {
      requestResponseIndication().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DENM-PDU-Descriptions.ImpactReductionContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ImpactReductionContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (12<mp->get_size()) {
      param.error("record template of type @DENM-PDU-Descriptions.ImpactReductionContainer has 12 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) heightLonCarrLeft().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) heightLonCarrRight().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) posLonCarrLeft().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) posLonCarrRight().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) positionOfPillars().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) posCentMass().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) wheelBaseVehicle().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) turningRadius().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) posFrontAx().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) positionOfOccupants().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) vehicleMass().set_param(*mp->get_elem(10));
    if (mp->get_size()>11 && mp->get_elem(11)->get_type()!=Module_Param::MP_NotUsed) requestResponseIndication().set_param(*mp->get_elem(11));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "heightLonCarrLeft")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          heightLonCarrLeft().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "heightLonCarrRight")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          heightLonCarrRight().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "posLonCarrLeft")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          posLonCarrLeft().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "posLonCarrRight")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          posLonCarrRight().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "positionOfPillars")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          positionOfPillars().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "posCentMass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          posCentMass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "wheelBaseVehicle")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          wheelBaseVehicle().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "turningRadius")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          turningRadius().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "posFrontAx")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          posFrontAx().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "positionOfOccupants")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          positionOfOccupants().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vehicleMass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vehicleMass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "requestResponseIndication")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          requestResponseIndication().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.ImpactReductionContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DENM-PDU-Descriptions.ImpactReductionContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ImpactReductionContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DENM-PDU-Descriptions.ImpactReductionContainer'");
    }
    if (strcmp("heightLonCarrLeft", param_field) == 0) {
      return heightLonCarrLeft().get_param(param_name);
    } else if (strcmp("heightLonCarrRight", param_field) == 0) {
      return heightLonCarrRight().get_param(param_name);
    } else if (strcmp("posLonCarrLeft", param_field) == 0) {
      return posLonCarrLeft().get_param(param_name);
    } else if (strcmp("posLonCarrRight", param_field) == 0) {
      return posLonCarrRight().get_param(param_name);
    } else if (strcmp("positionOfPillars", param_field) == 0) {
      return positionOfPillars().get_param(param_name);
    } else if (strcmp("posCentMass", param_field) == 0) {
      return posCentMass().get_param(param_name);
    } else if (strcmp("wheelBaseVehicle", param_field) == 0) {
      return wheelBaseVehicle().get_param(param_name);
    } else if (strcmp("turningRadius", param_field) == 0) {
      return turningRadius().get_param(param_name);
    } else if (strcmp("posFrontAx", param_field) == 0) {
      return posFrontAx().get_param(param_name);
    } else if (strcmp("positionOfOccupants", param_field) == 0) {
      return positionOfOccupants().get_param(param_name);
    } else if (strcmp("vehicleMass", param_field) == 0) {
      return vehicleMass().get_param(param_name);
    } else if (strcmp("requestResponseIndication", param_field) == 0) {
      return requestResponseIndication().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.ImpactReductionContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_heightLonCarrLeft = single_value->field_heightLonCarrLeft.get_param(param_name);
    mp_field_heightLonCarrLeft->set_id(new Module_Param_FieldName(mcopystr("heightLonCarrLeft")));
    mp->add_elem(mp_field_heightLonCarrLeft);
    Module_Param* mp_field_heightLonCarrRight = single_value->field_heightLonCarrRight.get_param(param_name);
    mp_field_heightLonCarrRight->set_id(new Module_Param_FieldName(mcopystr("heightLonCarrRight")));
    mp->add_elem(mp_field_heightLonCarrRight);
    Module_Param* mp_field_posLonCarrLeft = single_value->field_posLonCarrLeft.get_param(param_name);
    mp_field_posLonCarrLeft->set_id(new Module_Param_FieldName(mcopystr("posLonCarrLeft")));
    mp->add_elem(mp_field_posLonCarrLeft);
    Module_Param* mp_field_posLonCarrRight = single_value->field_posLonCarrRight.get_param(param_name);
    mp_field_posLonCarrRight->set_id(new Module_Param_FieldName(mcopystr("posLonCarrRight")));
    mp->add_elem(mp_field_posLonCarrRight);
    Module_Param* mp_field_positionOfPillars = single_value->field_positionOfPillars.get_param(param_name);
    mp_field_positionOfPillars->set_id(new Module_Param_FieldName(mcopystr("positionOfPillars")));
    mp->add_elem(mp_field_positionOfPillars);
    Module_Param* mp_field_posCentMass = single_value->field_posCentMass.get_param(param_name);
    mp_field_posCentMass->set_id(new Module_Param_FieldName(mcopystr("posCentMass")));
    mp->add_elem(mp_field_posCentMass);
    Module_Param* mp_field_wheelBaseVehicle = single_value->field_wheelBaseVehicle.get_param(param_name);
    mp_field_wheelBaseVehicle->set_id(new Module_Param_FieldName(mcopystr("wheelBaseVehicle")));
    mp->add_elem(mp_field_wheelBaseVehicle);
    Module_Param* mp_field_turningRadius = single_value->field_turningRadius.get_param(param_name);
    mp_field_turningRadius->set_id(new Module_Param_FieldName(mcopystr("turningRadius")));
    mp->add_elem(mp_field_turningRadius);
    Module_Param* mp_field_posFrontAx = single_value->field_posFrontAx.get_param(param_name);
    mp_field_posFrontAx->set_id(new Module_Param_FieldName(mcopystr("posFrontAx")));
    mp->add_elem(mp_field_posFrontAx);
    Module_Param* mp_field_positionOfOccupants = single_value->field_positionOfOccupants.get_param(param_name);
    mp_field_positionOfOccupants->set_id(new Module_Param_FieldName(mcopystr("positionOfOccupants")));
    mp->add_elem(mp_field_positionOfOccupants);
    Module_Param* mp_field_vehicleMass = single_value->field_vehicleMass.get_param(param_name);
    mp_field_vehicleMass->set_id(new Module_Param_FieldName(mcopystr("vehicleMass")));
    mp->add_elem(mp_field_vehicleMass);
    Module_Param* mp_field_requestResponseIndication = single_value->field_requestResponseIndication.get_param(param_name);
    mp_field_requestResponseIndication->set_id(new Module_Param_FieldName(mcopystr("requestResponseIndication")));
    mp->add_elem(mp_field_requestResponseIndication);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ImpactReductionContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_heightLonCarrLeft.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ImpactReductionContainer");
single_value->field_heightLonCarrRight.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ImpactReductionContainer");
single_value->field_posLonCarrLeft.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ImpactReductionContainer");
single_value->field_posLonCarrRight.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ImpactReductionContainer");
single_value->field_positionOfPillars.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ImpactReductionContainer");
single_value->field_posCentMass.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ImpactReductionContainer");
single_value->field_wheelBaseVehicle.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ImpactReductionContainer");
single_value->field_turningRadius.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ImpactReductionContainer");
single_value->field_posFrontAx.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ImpactReductionContainer");
single_value->field_positionOfOccupants.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ImpactReductionContainer");
single_value->field_vehicleMass.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ImpactReductionContainer");
single_value->field_requestResponseIndication.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ImpactReductionContainer");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DENM-PDU-Descriptions.ImpactReductionContainer");
}

boolean ImpactReductionContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ImpactReductionContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

RoadWorksContainerExtended::RoadWorksContainerExtended()
{
  bound_flag = FALSE;
}

RoadWorksContainerExtended::RoadWorksContainerExtended(const OPTIONAL<BITSTRING>& par_lightBarSirenInUse,
    const OPTIONAL<ITS__Container::ClosedLanes>& par_closedLanes,
    const OPTIONAL<ITS__Container::RestrictedTypes>& par_restriction,
    const OPTIONAL<INTEGER>& par_speedLimit,
    const OPTIONAL<ITS__Container::CauseCode>& par_incidentIndication,
    const OPTIONAL<ITS__Container::ItineraryPath>& par_recommendedPath,
    const OPTIONAL<ITS__Container::DeltaReferencePosition>& par_startingPointSpeedLimit,
    const OPTIONAL<ITS__Container::TrafficRule>& par_trafficFlowRule,
    const OPTIONAL<ReferenceDenms>& par_referenceDenms)
  :   field_lightBarSirenInUse(par_lightBarSirenInUse),
  field_closedLanes(par_closedLanes),
  field_restriction(par_restriction),
  field_speedLimit(par_speedLimit),
  field_incidentIndication(par_incidentIndication),
  field_recommendedPath(par_recommendedPath),
  field_startingPointSpeedLimit(par_startingPointSpeedLimit),
  field_trafficFlowRule(par_trafficFlowRule),
  field_referenceDenms(par_referenceDenms)
{
  bound_flag = TRUE;
}

RoadWorksContainerExtended::RoadWorksContainerExtended(const RoadWorksContainerExtended& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
bound_flag = TRUE;
if (other_value.lightBarSirenInUse().is_bound()) field_lightBarSirenInUse = other_value.lightBarSirenInUse();
else field_lightBarSirenInUse.clean_up();
if (other_value.closedLanes().is_bound()) field_closedLanes = other_value.closedLanes();
else field_closedLanes.clean_up();
if (other_value.restriction().is_bound()) field_restriction = other_value.restriction();
else field_restriction.clean_up();
if (other_value.speedLimit().is_bound()) field_speedLimit = other_value.speedLimit();
else field_speedLimit.clean_up();
if (other_value.incidentIndication().is_bound()) field_incidentIndication = other_value.incidentIndication();
else field_incidentIndication.clean_up();
if (other_value.recommendedPath().is_bound()) field_recommendedPath = other_value.recommendedPath();
else field_recommendedPath.clean_up();
if (other_value.startingPointSpeedLimit().is_bound()) field_startingPointSpeedLimit = other_value.startingPointSpeedLimit();
else field_startingPointSpeedLimit.clean_up();
if (other_value.trafficFlowRule().is_bound()) field_trafficFlowRule = other_value.trafficFlowRule();
else field_trafficFlowRule.clean_up();
if (other_value.referenceDenms().is_bound()) field_referenceDenms = other_value.referenceDenms();
else field_referenceDenms.clean_up();
}

void RoadWorksContainerExtended::clean_up()
{
field_lightBarSirenInUse.clean_up();
field_closedLanes.clean_up();
field_restriction.clean_up();
field_speedLimit.clean_up();
field_incidentIndication.clean_up();
field_recommendedPath.clean_up();
field_startingPointSpeedLimit.clean_up();
field_trafficFlowRule.clean_up();
field_referenceDenms.clean_up();
bound_flag = FALSE;
}

RoadWorksContainerExtended& RoadWorksContainerExtended::operator=(const RoadWorksContainerExtended& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
  bound_flag = TRUE;
  if (other_value.lightBarSirenInUse().is_bound()) field_lightBarSirenInUse = other_value.lightBarSirenInUse();
  else field_lightBarSirenInUse.clean_up();
  if (other_value.closedLanes().is_bound()) field_closedLanes = other_value.closedLanes();
  else field_closedLanes.clean_up();
  if (other_value.restriction().is_bound()) field_restriction = other_value.restriction();
  else field_restriction.clean_up();
  if (other_value.speedLimit().is_bound()) field_speedLimit = other_value.speedLimit();
  else field_speedLimit.clean_up();
  if (other_value.incidentIndication().is_bound()) field_incidentIndication = other_value.incidentIndication();
  else field_incidentIndication.clean_up();
  if (other_value.recommendedPath().is_bound()) field_recommendedPath = other_value.recommendedPath();
  else field_recommendedPath.clean_up();
  if (other_value.startingPointSpeedLimit().is_bound()) field_startingPointSpeedLimit = other_value.startingPointSpeedLimit();
  else field_startingPointSpeedLimit.clean_up();
  if (other_value.trafficFlowRule().is_bound()) field_trafficFlowRule = other_value.trafficFlowRule();
  else field_trafficFlowRule.clean_up();
  if (other_value.referenceDenms().is_bound()) field_referenceDenms = other_value.referenceDenms();
  else field_referenceDenms.clean_up();
}
return *this;
}

boolean RoadWorksContainerExtended::operator==(const RoadWorksContainerExtended& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_lightBarSirenInUse==other_value.field_lightBarSirenInUse
  && field_closedLanes==other_value.field_closedLanes
  && field_restriction==other_value.field_restriction
  && field_speedLimit==other_value.field_speedLimit
  && field_incidentIndication==other_value.field_incidentIndication
  && field_recommendedPath==other_value.field_recommendedPath
  && field_startingPointSpeedLimit==other_value.field_startingPointSpeedLimit
  && field_trafficFlowRule==other_value.field_trafficFlowRule
  && field_referenceDenms==other_value.field_referenceDenms;
}

boolean RoadWorksContainerExtended::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_lightBarSirenInUse.get_selection() || field_lightBarSirenInUse.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_closedLanes.get_selection() || field_closedLanes.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_restriction.get_selection() || field_restriction.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_speedLimit.get_selection() || field_speedLimit.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_incidentIndication.get_selection() || field_incidentIndication.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_recommendedPath.get_selection() || field_recommendedPath.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_startingPointSpeedLimit.get_selection() || field_startingPointSpeedLimit.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_trafficFlowRule.get_selection() || field_trafficFlowRule.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_referenceDenms.get_selection() || field_referenceDenms.is_bound()) return TRUE;
return FALSE;
}
boolean RoadWorksContainerExtended::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_lightBarSirenInUse.get_selection() && !field_lightBarSirenInUse.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_closedLanes.get_selection() && !field_closedLanes.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_restriction.get_selection() && !field_restriction.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_speedLimit.get_selection() && !field_speedLimit.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_incidentIndication.get_selection() && !field_incidentIndication.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_recommendedPath.get_selection() && !field_recommendedPath.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_startingPointSpeedLimit.get_selection() && !field_startingPointSpeedLimit.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_trafficFlowRule.get_selection() && !field_trafficFlowRule.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_referenceDenms.get_selection() && !field_referenceDenms.is_value()) return FALSE;
return TRUE;
}
int RoadWorksContainerExtended::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DENM-PDU-Descriptions.RoadWorksContainerExtended");
  int ret_val = 0;
  if (field_lightBarSirenInUse.ispresent()) ret_val++;
  if (field_closedLanes.ispresent()) ret_val++;
  if (field_restriction.ispresent()) ret_val++;
  if (field_speedLimit.ispresent()) ret_val++;
  if (field_incidentIndication.ispresent()) ret_val++;
  if (field_recommendedPath.ispresent()) ret_val++;
  if (field_startingPointSpeedLimit.ispresent()) ret_val++;
  if (field_trafficFlowRule.ispresent()) ret_val++;
  if (field_referenceDenms.ispresent()) ret_val++;
  return ret_val;
}

void RoadWorksContainerExtended::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ lightBarSirenInUse := ");
field_lightBarSirenInUse.log();
TTCN_Logger::log_event_str(", closedLanes := ");
field_closedLanes.log();
TTCN_Logger::log_event_str(", restriction := ");
field_restriction.log();
TTCN_Logger::log_event_str(", speedLimit := ");
field_speedLimit.log();
TTCN_Logger::log_event_str(", incidentIndication := ");
field_incidentIndication.log();
TTCN_Logger::log_event_str(", recommendedPath := ");
field_recommendedPath.log();
TTCN_Logger::log_event_str(", startingPointSpeedLimit := ");
field_startingPointSpeedLimit.log();
TTCN_Logger::log_event_str(", trafficFlowRule := ");
field_trafficFlowRule.log();
TTCN_Logger::log_event_str(", referenceDenms := ");
field_referenceDenms.log();
TTCN_Logger::log_event_str(" }");
}

void RoadWorksContainerExtended::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DENM-PDU-Descriptions.RoadWorksContainerExtended'");
    }
    if (strcmp("lightBarSirenInUse", param_field) == 0) {
      lightBarSirenInUse().set_param(param);
      return;
    } else if (strcmp("closedLanes", param_field) == 0) {
      closedLanes().set_param(param);
      return;
    } else if (strcmp("restriction", param_field) == 0) {
      restriction().set_param(param);
      return;
    } else if (strcmp("speedLimit", param_field) == 0) {
      speedLimit().set_param(param);
      return;
    } else if (strcmp("incidentIndication", param_field) == 0) {
      incidentIndication().set_param(param);
      return;
    } else if (strcmp("recommendedPath", param_field) == 0) {
      recommendedPath().set_param(param);
      return;
    } else if (strcmp("startingPointSpeedLimit", param_field) == 0) {
      startingPointSpeedLimit().set_param(param);
      return;
    } else if (strcmp("trafficFlowRule", param_field) == 0) {
      trafficFlowRule().set_param(param);
      return;
    } else if (strcmp("referenceDenms", param_field) == 0) {
      referenceDenms().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DENM-PDU-Descriptions.RoadWorksContainerExtended'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (9<mp->get_size()) {
      param.error("record value of type @DENM-PDU-Descriptions.RoadWorksContainerExtended has 9 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lightBarSirenInUse().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) closedLanes().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) restriction().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) speedLimit().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) incidentIndication().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) recommendedPath().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) startingPointSpeedLimit().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) trafficFlowRule().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) referenceDenms().set_param(*mp->get_elem(8));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lightBarSirenInUse")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lightBarSirenInUse().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "closedLanes")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          closedLanes().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "restriction")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          restriction().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speedLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speedLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "incidentIndication")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          incidentIndication().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "recommendedPath")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          recommendedPath().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "startingPointSpeedLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          startingPointSpeedLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficFlowRule")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficFlowRule().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "referenceDenms")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          referenceDenms().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.RoadWorksContainerExtended: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DENM-PDU-Descriptions.RoadWorksContainerExtended");
  }
}

Module_Param* RoadWorksContainerExtended::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DENM-PDU-Descriptions.RoadWorksContainerExtended'");
    }
    if (strcmp("lightBarSirenInUse", param_field) == 0) {
      return lightBarSirenInUse().get_param(param_name);
    } else if (strcmp("closedLanes", param_field) == 0) {
      return closedLanes().get_param(param_name);
    } else if (strcmp("restriction", param_field) == 0) {
      return restriction().get_param(param_name);
    } else if (strcmp("speedLimit", param_field) == 0) {
      return speedLimit().get_param(param_name);
    } else if (strcmp("incidentIndication", param_field) == 0) {
      return incidentIndication().get_param(param_name);
    } else if (strcmp("recommendedPath", param_field) == 0) {
      return recommendedPath().get_param(param_name);
    } else if (strcmp("startingPointSpeedLimit", param_field) == 0) {
      return startingPointSpeedLimit().get_param(param_name);
    } else if (strcmp("trafficFlowRule", param_field) == 0) {
      return trafficFlowRule().get_param(param_name);
    } else if (strcmp("referenceDenms", param_field) == 0) {
      return referenceDenms().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.RoadWorksContainerExtended'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_lightBarSirenInUse = field_lightBarSirenInUse.get_param(param_name);
  mp_field_lightBarSirenInUse->set_id(new Module_Param_FieldName(mcopystr("lightBarSirenInUse")));
  mp->add_elem(mp_field_lightBarSirenInUse);
  Module_Param* mp_field_closedLanes = field_closedLanes.get_param(param_name);
  mp_field_closedLanes->set_id(new Module_Param_FieldName(mcopystr("closedLanes")));
  mp->add_elem(mp_field_closedLanes);
  Module_Param* mp_field_restriction = field_restriction.get_param(param_name);
  mp_field_restriction->set_id(new Module_Param_FieldName(mcopystr("restriction")));
  mp->add_elem(mp_field_restriction);
  Module_Param* mp_field_speedLimit = field_speedLimit.get_param(param_name);
  mp_field_speedLimit->set_id(new Module_Param_FieldName(mcopystr("speedLimit")));
  mp->add_elem(mp_field_speedLimit);
  Module_Param* mp_field_incidentIndication = field_incidentIndication.get_param(param_name);
  mp_field_incidentIndication->set_id(new Module_Param_FieldName(mcopystr("incidentIndication")));
  mp->add_elem(mp_field_incidentIndication);
  Module_Param* mp_field_recommendedPath = field_recommendedPath.get_param(param_name);
  mp_field_recommendedPath->set_id(new Module_Param_FieldName(mcopystr("recommendedPath")));
  mp->add_elem(mp_field_recommendedPath);
  Module_Param* mp_field_startingPointSpeedLimit = field_startingPointSpeedLimit.get_param(param_name);
  mp_field_startingPointSpeedLimit->set_id(new Module_Param_FieldName(mcopystr("startingPointSpeedLimit")));
  mp->add_elem(mp_field_startingPointSpeedLimit);
  Module_Param* mp_field_trafficFlowRule = field_trafficFlowRule.get_param(param_name);
  mp_field_trafficFlowRule->set_id(new Module_Param_FieldName(mcopystr("trafficFlowRule")));
  mp->add_elem(mp_field_trafficFlowRule);
  Module_Param* mp_field_referenceDenms = field_referenceDenms.get_param(param_name);
  mp_field_referenceDenms->set_id(new Module_Param_FieldName(mcopystr("referenceDenms")));
  mp->add_elem(mp_field_referenceDenms);
  return mp;
  }

void RoadWorksContainerExtended::set_implicit_omit()
{
if (!lightBarSirenInUse().is_bound()) lightBarSirenInUse() = OMIT_VALUE;
else lightBarSirenInUse().set_implicit_omit();
if (!closedLanes().is_bound()) closedLanes() = OMIT_VALUE;
else closedLanes().set_implicit_omit();
if (!restriction().is_bound()) restriction() = OMIT_VALUE;
else restriction().set_implicit_omit();
if (!speedLimit().is_bound()) speedLimit() = OMIT_VALUE;
else speedLimit().set_implicit_omit();
if (!incidentIndication().is_bound()) incidentIndication() = OMIT_VALUE;
else incidentIndication().set_implicit_omit();
if (!recommendedPath().is_bound()) recommendedPath() = OMIT_VALUE;
else recommendedPath().set_implicit_omit();
if (!startingPointSpeedLimit().is_bound()) startingPointSpeedLimit() = OMIT_VALUE;
else startingPointSpeedLimit().set_implicit_omit();
if (!trafficFlowRule().is_bound()) trafficFlowRule() = OMIT_VALUE;
else trafficFlowRule().set_implicit_omit();
if (!referenceDenms().is_bound()) referenceDenms() = OMIT_VALUE;
else referenceDenms().set_implicit_omit();
}

void RoadWorksContainerExtended::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
field_lightBarSirenInUse.encode_text(text_buf);
field_closedLanes.encode_text(text_buf);
field_restriction.encode_text(text_buf);
field_speedLimit.encode_text(text_buf);
field_incidentIndication.encode_text(text_buf);
field_recommendedPath.encode_text(text_buf);
field_startingPointSpeedLimit.encode_text(text_buf);
field_trafficFlowRule.encode_text(text_buf);
field_referenceDenms.encode_text(text_buf);
}

void RoadWorksContainerExtended::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_lightBarSirenInUse.decode_text(text_buf);
field_closedLanes.decode_text(text_buf);
field_restriction.decode_text(text_buf);
field_speedLimit.decode_text(text_buf);
field_incidentIndication.decode_text(text_buf);
field_recommendedPath.decode_text(text_buf);
field_startingPointSpeedLimit.decode_text(text_buf);
field_trafficFlowRule.decode_text(text_buf);
field_referenceDenms.decode_text(text_buf);
}

void RoadWorksContainerExtended::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RoadWorksContainerExtended::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* RoadWorksContainerExtended::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("lightBarSirenInUse': ");
  new_tlv->add_TLV(field_lightBarSirenInUse.BER_encode_TLV(RoadWorksContainerExtended_lightBarSirenInUse_descr_, p_coding));
  ec_1.set_msg("closedLanes': ");
  new_tlv->add_TLV(field_closedLanes.BER_encode_TLV(RoadWorksContainerExtended_closedLanes_descr_, p_coding));
  ec_1.set_msg("restriction': ");
  new_tlv->add_TLV(field_restriction.BER_encode_TLV(RoadWorksContainerExtended_restriction_descr_, p_coding));
  ec_1.set_msg("speedLimit': ");
  new_tlv->add_TLV(field_speedLimit.BER_encode_TLV(RoadWorksContainerExtended_speedLimit_descr_, p_coding));
  ec_1.set_msg("incidentIndication': ");
  new_tlv->add_TLV(field_incidentIndication.BER_encode_TLV(RoadWorksContainerExtended_incidentIndication_descr_, p_coding));
  ec_1.set_msg("recommendedPath': ");
  new_tlv->add_TLV(field_recommendedPath.BER_encode_TLV(RoadWorksContainerExtended_recommendedPath_descr_, p_coding));
  ec_1.set_msg("startingPointSpeedLimit': ");
  new_tlv->add_TLV(field_startingPointSpeedLimit.BER_encode_TLV(RoadWorksContainerExtended_startingPointSpeedLimit_descr_, p_coding));
  ec_1.set_msg("trafficFlowRule': ");
  new_tlv->add_TLV(field_trafficFlowRule.BER_encode_TLV(RoadWorksContainerExtended_trafficFlowRule_descr_, p_coding));
  ec_1.set_msg("referenceDenms': ");
  new_tlv->add_TLV(field_referenceDenms.BER_encode_TLV(RoadWorksContainerExtended_referenceDenms_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean RoadWorksContainerExtended::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DENM-PDU-Descriptions.RoadWorksContainerExtended' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("lightBarSirenInUse': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_lightBarSirenInUse=OMIT_VALUE;
    else {
      field_lightBarSirenInUse.BER_decode_TLV(RoadWorksContainerExtended_lightBarSirenInUse_descr_, tmp_tlv, L_form);
      if(field_lightBarSirenInUse.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("closedLanes': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_closedLanes=OMIT_VALUE;
    else {
      field_closedLanes.BER_decode_TLV(RoadWorksContainerExtended_closedLanes_descr_, tmp_tlv, L_form);
      if(field_closedLanes.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("restriction': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_restriction=OMIT_VALUE;
    else {
      field_restriction.BER_decode_TLV(RoadWorksContainerExtended_restriction_descr_, tmp_tlv, L_form);
      if(field_restriction.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("speedLimit': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_speedLimit=OMIT_VALUE;
    else {
      field_speedLimit.BER_decode_TLV(RoadWorksContainerExtended_speedLimit_descr_, tmp_tlv, L_form);
      if(field_speedLimit.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("incidentIndication': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_incidentIndication=OMIT_VALUE;
    else {
      field_incidentIndication.BER_decode_TLV(RoadWorksContainerExtended_incidentIndication_descr_, tmp_tlv, L_form);
      if(field_incidentIndication.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("recommendedPath': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_recommendedPath=OMIT_VALUE;
    else {
      field_recommendedPath.BER_decode_TLV(RoadWorksContainerExtended_recommendedPath_descr_, tmp_tlv, L_form);
      if(field_recommendedPath.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("startingPointSpeedLimit': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_startingPointSpeedLimit=OMIT_VALUE;
    else {
      field_startingPointSpeedLimit.BER_decode_TLV(RoadWorksContainerExtended_startingPointSpeedLimit_descr_, tmp_tlv, L_form);
      if(field_startingPointSpeedLimit.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("trafficFlowRule': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_trafficFlowRule=OMIT_VALUE;
    else {
      field_trafficFlowRule.BER_decode_TLV(RoadWorksContainerExtended_trafficFlowRule_descr_, tmp_tlv, L_form);
      if(field_trafficFlowRule.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("referenceDenms': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_referenceDenms=OMIT_VALUE;
    else {
      field_referenceDenms.BER_decode_TLV(RoadWorksContainerExtended_referenceDenms_descr_, tmp_tlv, L_form);
      if(field_referenceDenms.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int RoadWorksContainerExtended::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_lightBarSirenInUse.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lightBarSirenInUse");
    enc_len += field_lightBarSirenInUse.JSON_encode(RoadWorksContainerExtended_lightBarSirenInUse_descr_, p_tok);
  }

  if (field_closedLanes.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "closedLanes");
    enc_len += field_closedLanes.JSON_encode(RoadWorksContainerExtended_closedLanes_descr_, p_tok);
  }

  if (field_restriction.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "restriction");
    enc_len += field_restriction.JSON_encode(RoadWorksContainerExtended_restriction_descr_, p_tok);
  }

  if (field_speedLimit.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "speedLimit");
    enc_len += field_speedLimit.JSON_encode(RoadWorksContainerExtended_speedLimit_descr_, p_tok);
  }

  if (field_incidentIndication.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "incidentIndication");
    enc_len += field_incidentIndication.JSON_encode(RoadWorksContainerExtended_incidentIndication_descr_, p_tok);
  }

  if (field_recommendedPath.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "recommendedPath");
    enc_len += field_recommendedPath.JSON_encode(RoadWorksContainerExtended_recommendedPath_descr_, p_tok);
  }

  if (field_startingPointSpeedLimit.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "startingPointSpeedLimit");
    enc_len += field_startingPointSpeedLimit.JSON_encode(RoadWorksContainerExtended_startingPointSpeedLimit_descr_, p_tok);
  }

  if (field_trafficFlowRule.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "trafficFlowRule");
    enc_len += field_trafficFlowRule.JSON_encode(RoadWorksContainerExtended_trafficFlowRule_descr_, p_tok);
  }

  if (field_referenceDenms.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "referenceDenms");
    enc_len += field_referenceDenms.JSON_encode(RoadWorksContainerExtended_referenceDenms_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int RoadWorksContainerExtended::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (18 == name_len && 0 == strncmp(fld_name, "lightBarSirenInUse", name_len)) {
         int ret_val = field_lightBarSirenInUse.JSON_decode(RoadWorksContainerExtended_lightBarSirenInUse_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lightBarSirenInUse");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "closedLanes", name_len)) {
         int ret_val = field_closedLanes.JSON_decode(RoadWorksContainerExtended_closedLanes_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "closedLanes");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "restriction", name_len)) {
         int ret_val = field_restriction.JSON_decode(RoadWorksContainerExtended_restriction_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "restriction");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "speedLimit", name_len)) {
         int ret_val = field_speedLimit.JSON_decode(RoadWorksContainerExtended_speedLimit_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "speedLimit");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "incidentIndication", name_len)) {
         int ret_val = field_incidentIndication.JSON_decode(RoadWorksContainerExtended_incidentIndication_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "incidentIndication");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "recommendedPath", name_len)) {
         int ret_val = field_recommendedPath.JSON_decode(RoadWorksContainerExtended_recommendedPath_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "recommendedPath");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (23 == name_len && 0 == strncmp(fld_name, "startingPointSpeedLimit", name_len)) {
         int ret_val = field_startingPointSpeedLimit.JSON_decode(RoadWorksContainerExtended_startingPointSpeedLimit_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "startingPointSpeedLimit");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "trafficFlowRule", name_len)) {
         int ret_val = field_trafficFlowRule.JSON_decode(RoadWorksContainerExtended_trafficFlowRule_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "trafficFlowRule");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "referenceDenms", name_len)) {
         int ret_val = field_referenceDenms.JSON_decode(RoadWorksContainerExtended_referenceDenms_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "referenceDenms");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_lightBarSirenInUse.is_bound()) {
    field_lightBarSirenInUse = OMIT_VALUE;
  }
if (!field_closedLanes.is_bound()) {
    field_closedLanes = OMIT_VALUE;
  }
if (!field_restriction.is_bound()) {
    field_restriction = OMIT_VALUE;
  }
if (!field_speedLimit.is_bound()) {
    field_speedLimit = OMIT_VALUE;
  }
if (!field_incidentIndication.is_bound()) {
    field_incidentIndication = OMIT_VALUE;
  }
if (!field_recommendedPath.is_bound()) {
    field_recommendedPath = OMIT_VALUE;
  }
if (!field_startingPointSpeedLimit.is_bound()) {
    field_startingPointSpeedLimit = OMIT_VALUE;
  }
if (!field_trafficFlowRule.is_bound()) {
    field_trafficFlowRule = OMIT_VALUE;
  }
if (!field_referenceDenms.is_bound()) {
    field_referenceDenms = OMIT_VALUE;
  }

  return dec_len;
}

struct RoadWorksContainerExtended_template::single_value_struct {
BITSTRING_template field_lightBarSirenInUse;
ITS__Container::ClosedLanes_template field_closedLanes;
ITS__Container::RestrictedTypes_template field_restriction;
INTEGER_template field_speedLimit;
ITS__Container::CauseCode_template field_incidentIndication;
ITS__Container::ItineraryPath_template field_recommendedPath;
ITS__Container::DeltaReferencePosition_template field_startingPointSpeedLimit;
ITS__Container::TrafficRule_template field_trafficFlowRule;
ReferenceDenms_template field_referenceDenms;
};

void RoadWorksContainerExtended_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_lightBarSirenInUse = ANY_OR_OMIT;
single_value->field_closedLanes = ANY_OR_OMIT;
single_value->field_restriction = ANY_OR_OMIT;
single_value->field_speedLimit = ANY_OR_OMIT;
single_value->field_incidentIndication = ANY_OR_OMIT;
single_value->field_recommendedPath = ANY_OR_OMIT;
single_value->field_startingPointSpeedLimit = ANY_OR_OMIT;
single_value->field_trafficFlowRule = ANY_OR_OMIT;
single_value->field_referenceDenms = ANY_OR_OMIT;
}
}
}

void RoadWorksContainerExtended_template::copy_value(const RoadWorksContainerExtended& other_value)
{
single_value = new single_value_struct;
if (other_value.lightBarSirenInUse().is_bound()) {
  if (other_value.lightBarSirenInUse().ispresent()) single_value->field_lightBarSirenInUse = other_value.lightBarSirenInUse()();
  else single_value->field_lightBarSirenInUse = OMIT_VALUE;
} else {
  single_value->field_lightBarSirenInUse.clean_up();
}
if (other_value.closedLanes().is_bound()) {
  if (other_value.closedLanes().ispresent()) single_value->field_closedLanes = other_value.closedLanes()();
  else single_value->field_closedLanes = OMIT_VALUE;
} else {
  single_value->field_closedLanes.clean_up();
}
if (other_value.restriction().is_bound()) {
  if (other_value.restriction().ispresent()) single_value->field_restriction = other_value.restriction()();
  else single_value->field_restriction = OMIT_VALUE;
} else {
  single_value->field_restriction.clean_up();
}
if (other_value.speedLimit().is_bound()) {
  if (other_value.speedLimit().ispresent()) single_value->field_speedLimit = other_value.speedLimit()();
  else single_value->field_speedLimit = OMIT_VALUE;
} else {
  single_value->field_speedLimit.clean_up();
}
if (other_value.incidentIndication().is_bound()) {
  if (other_value.incidentIndication().ispresent()) single_value->field_incidentIndication = other_value.incidentIndication()();
  else single_value->field_incidentIndication = OMIT_VALUE;
} else {
  single_value->field_incidentIndication.clean_up();
}
if (other_value.recommendedPath().is_bound()) {
  if (other_value.recommendedPath().ispresent()) single_value->field_recommendedPath = other_value.recommendedPath()();
  else single_value->field_recommendedPath = OMIT_VALUE;
} else {
  single_value->field_recommendedPath.clean_up();
}
if (other_value.startingPointSpeedLimit().is_bound()) {
  if (other_value.startingPointSpeedLimit().ispresent()) single_value->field_startingPointSpeedLimit = other_value.startingPointSpeedLimit()();
  else single_value->field_startingPointSpeedLimit = OMIT_VALUE;
} else {
  single_value->field_startingPointSpeedLimit.clean_up();
}
if (other_value.trafficFlowRule().is_bound()) {
  if (other_value.trafficFlowRule().ispresent()) single_value->field_trafficFlowRule = other_value.trafficFlowRule()();
  else single_value->field_trafficFlowRule = OMIT_VALUE;
} else {
  single_value->field_trafficFlowRule.clean_up();
}
if (other_value.referenceDenms().is_bound()) {
  if (other_value.referenceDenms().ispresent()) single_value->field_referenceDenms = other_value.referenceDenms()();
  else single_value->field_referenceDenms = OMIT_VALUE;
} else {
  single_value->field_referenceDenms.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void RoadWorksContainerExtended_template::copy_template(const RoadWorksContainerExtended_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.lightBarSirenInUse().get_selection()) {
single_value->field_lightBarSirenInUse = other_value.lightBarSirenInUse();
} else {
single_value->field_lightBarSirenInUse.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.closedLanes().get_selection()) {
single_value->field_closedLanes = other_value.closedLanes();
} else {
single_value->field_closedLanes.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.restriction().get_selection()) {
single_value->field_restriction = other_value.restriction();
} else {
single_value->field_restriction.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.speedLimit().get_selection()) {
single_value->field_speedLimit = other_value.speedLimit();
} else {
single_value->field_speedLimit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.incidentIndication().get_selection()) {
single_value->field_incidentIndication = other_value.incidentIndication();
} else {
single_value->field_incidentIndication.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.recommendedPath().get_selection()) {
single_value->field_recommendedPath = other_value.recommendedPath();
} else {
single_value->field_recommendedPath.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.startingPointSpeedLimit().get_selection()) {
single_value->field_startingPointSpeedLimit = other_value.startingPointSpeedLimit();
} else {
single_value->field_startingPointSpeedLimit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trafficFlowRule().get_selection()) {
single_value->field_trafficFlowRule = other_value.trafficFlowRule();
} else {
single_value->field_trafficFlowRule.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.referenceDenms().get_selection()) {
single_value->field_referenceDenms = other_value.referenceDenms();
} else {
single_value->field_referenceDenms.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RoadWorksContainerExtended_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
break;
}
set_selection(other_value);
}

RoadWorksContainerExtended_template::RoadWorksContainerExtended_template()
{
}

RoadWorksContainerExtended_template::RoadWorksContainerExtended_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RoadWorksContainerExtended_template::RoadWorksContainerExtended_template(const RoadWorksContainerExtended& other_value)
{
copy_value(other_value);
}

RoadWorksContainerExtended_template::RoadWorksContainerExtended_template(const OPTIONAL<RoadWorksContainerExtended>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RoadWorksContainerExtended&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended from an unbound optional field.");
}
}

RoadWorksContainerExtended_template::RoadWorksContainerExtended_template(const RoadWorksContainerExtended_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

RoadWorksContainerExtended_template::~RoadWorksContainerExtended_template()
{
clean_up();
}

RoadWorksContainerExtended_template& RoadWorksContainerExtended_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RoadWorksContainerExtended_template& RoadWorksContainerExtended_template::operator=(const RoadWorksContainerExtended& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RoadWorksContainerExtended_template& RoadWorksContainerExtended_template::operator=(const OPTIONAL<RoadWorksContainerExtended>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RoadWorksContainerExtended&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
}
return *this;
}

RoadWorksContainerExtended_template& RoadWorksContainerExtended_template::operator=(const RoadWorksContainerExtended_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RoadWorksContainerExtended_template::match(const RoadWorksContainerExtended& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.lightBarSirenInUse().is_bound()) return FALSE;
if((other_value.lightBarSirenInUse().ispresent() ? !single_value->field_lightBarSirenInUse.match((const BITSTRING&)other_value.lightBarSirenInUse(), legacy) : !single_value->field_lightBarSirenInUse.match_omit(legacy)))return FALSE;
if(!other_value.closedLanes().is_bound()) return FALSE;
if((other_value.closedLanes().ispresent() ? !single_value->field_closedLanes.match((const ITS__Container::ClosedLanes&)other_value.closedLanes(), legacy) : !single_value->field_closedLanes.match_omit(legacy)))return FALSE;
if(!other_value.restriction().is_bound()) return FALSE;
if((other_value.restriction().ispresent() ? !single_value->field_restriction.match((const ITS__Container::RestrictedTypes&)other_value.restriction(), legacy) : !single_value->field_restriction.match_omit(legacy)))return FALSE;
if(!other_value.speedLimit().is_bound()) return FALSE;
if((other_value.speedLimit().ispresent() ? !single_value->field_speedLimit.match((const INTEGER&)other_value.speedLimit(), legacy) : !single_value->field_speedLimit.match_omit(legacy)))return FALSE;
if(!other_value.incidentIndication().is_bound()) return FALSE;
if((other_value.incidentIndication().ispresent() ? !single_value->field_incidentIndication.match((const ITS__Container::CauseCode&)other_value.incidentIndication(), legacy) : !single_value->field_incidentIndication.match_omit(legacy)))return FALSE;
if(!other_value.recommendedPath().is_bound()) return FALSE;
if((other_value.recommendedPath().ispresent() ? !single_value->field_recommendedPath.match((const ITS__Container::ItineraryPath&)other_value.recommendedPath(), legacy) : !single_value->field_recommendedPath.match_omit(legacy)))return FALSE;
if(!other_value.startingPointSpeedLimit().is_bound()) return FALSE;
if((other_value.startingPointSpeedLimit().ispresent() ? !single_value->field_startingPointSpeedLimit.match((const ITS__Container::DeltaReferencePosition&)other_value.startingPointSpeedLimit(), legacy) : !single_value->field_startingPointSpeedLimit.match_omit(legacy)))return FALSE;
if(!other_value.trafficFlowRule().is_bound()) return FALSE;
if((other_value.trafficFlowRule().ispresent() ? !single_value->field_trafficFlowRule.match((const ITS__Container::TrafficRule&)other_value.trafficFlowRule(), legacy) : !single_value->field_trafficFlowRule.match_omit(legacy)))return FALSE;
if(!other_value.referenceDenms().is_bound()) return FALSE;
if((other_value.referenceDenms().ispresent() ? !single_value->field_referenceDenms.match((const ReferenceDenms&)other_value.referenceDenms(), legacy) : !single_value->field_referenceDenms.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
}
return FALSE;
}

boolean RoadWorksContainerExtended_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_lightBarSirenInUse.is_omit() || single_value->field_lightBarSirenInUse.is_bound()) return TRUE;
if (single_value->field_closedLanes.is_omit() || single_value->field_closedLanes.is_bound()) return TRUE;
if (single_value->field_restriction.is_omit() || single_value->field_restriction.is_bound()) return TRUE;
if (single_value->field_speedLimit.is_omit() || single_value->field_speedLimit.is_bound()) return TRUE;
if (single_value->field_incidentIndication.is_omit() || single_value->field_incidentIndication.is_bound()) return TRUE;
if (single_value->field_recommendedPath.is_omit() || single_value->field_recommendedPath.is_bound()) return TRUE;
if (single_value->field_startingPointSpeedLimit.is_omit() || single_value->field_startingPointSpeedLimit.is_bound()) return TRUE;
if (single_value->field_trafficFlowRule.is_omit() || single_value->field_trafficFlowRule.is_bound()) return TRUE;
if (single_value->field_referenceDenms.is_omit() || single_value->field_referenceDenms.is_bound()) return TRUE;
return FALSE;
}

boolean RoadWorksContainerExtended_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_lightBarSirenInUse.is_omit() && !single_value->field_lightBarSirenInUse.is_value()) return FALSE;
if (!single_value->field_closedLanes.is_omit() && !single_value->field_closedLanes.is_value()) return FALSE;
if (!single_value->field_restriction.is_omit() && !single_value->field_restriction.is_value()) return FALSE;
if (!single_value->field_speedLimit.is_omit() && !single_value->field_speedLimit.is_value()) return FALSE;
if (!single_value->field_incidentIndication.is_omit() && !single_value->field_incidentIndication.is_value()) return FALSE;
if (!single_value->field_recommendedPath.is_omit() && !single_value->field_recommendedPath.is_value()) return FALSE;
if (!single_value->field_startingPointSpeedLimit.is_omit() && !single_value->field_startingPointSpeedLimit.is_value()) return FALSE;
if (!single_value->field_trafficFlowRule.is_omit() && !single_value->field_trafficFlowRule.is_value()) return FALSE;
if (!single_value->field_referenceDenms.is_omit() && !single_value->field_referenceDenms.is_value()) return FALSE;
return TRUE;
}

void RoadWorksContainerExtended_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RoadWorksContainerExtended RoadWorksContainerExtended_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
RoadWorksContainerExtended ret_val;
if (single_value->field_lightBarSirenInUse.is_omit()) ret_val.lightBarSirenInUse() = OMIT_VALUE;
else if (single_value->field_lightBarSirenInUse.is_bound()) {
ret_val.lightBarSirenInUse() = single_value->field_lightBarSirenInUse.valueof();
}
if (single_value->field_closedLanes.is_omit()) ret_val.closedLanes() = OMIT_VALUE;
else if (single_value->field_closedLanes.is_bound()) {
ret_val.closedLanes() = single_value->field_closedLanes.valueof();
}
if (single_value->field_restriction.is_omit()) ret_val.restriction() = OMIT_VALUE;
else if (single_value->field_restriction.is_bound()) {
ret_val.restriction() = single_value->field_restriction.valueof();
}
if (single_value->field_speedLimit.is_omit()) ret_val.speedLimit() = OMIT_VALUE;
else if (single_value->field_speedLimit.is_bound()) {
ret_val.speedLimit() = single_value->field_speedLimit.valueof();
}
if (single_value->field_incidentIndication.is_omit()) ret_val.incidentIndication() = OMIT_VALUE;
else if (single_value->field_incidentIndication.is_bound()) {
ret_val.incidentIndication() = single_value->field_incidentIndication.valueof();
}
if (single_value->field_recommendedPath.is_omit()) ret_val.recommendedPath() = OMIT_VALUE;
else if (single_value->field_recommendedPath.is_bound()) {
ret_val.recommendedPath() = single_value->field_recommendedPath.valueof();
}
if (single_value->field_startingPointSpeedLimit.is_omit()) ret_val.startingPointSpeedLimit() = OMIT_VALUE;
else if (single_value->field_startingPointSpeedLimit.is_bound()) {
ret_val.startingPointSpeedLimit() = single_value->field_startingPointSpeedLimit.valueof();
}
if (single_value->field_trafficFlowRule.is_omit()) ret_val.trafficFlowRule() = OMIT_VALUE;
else if (single_value->field_trafficFlowRule.is_bound()) {
ret_val.trafficFlowRule() = single_value->field_trafficFlowRule.valueof();
}
if (single_value->field_referenceDenms.is_omit()) ret_val.referenceDenms() = OMIT_VALUE;
else if (single_value->field_referenceDenms.is_bound()) {
ret_val.referenceDenms() = single_value->field_referenceDenms.valueof();
}
return ret_val;
}

void RoadWorksContainerExtended_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RoadWorksContainerExtended_template[list_length];
}

RoadWorksContainerExtended_template& RoadWorksContainerExtended_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
return value_list.list_value[list_index];
}

BITSTRING_template& RoadWorksContainerExtended_template::lightBarSirenInUse()
{
set_specific();
return single_value->field_lightBarSirenInUse;
}

const BITSTRING_template& RoadWorksContainerExtended_template::lightBarSirenInUse() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lightBarSirenInUse of a non-specific template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
return single_value->field_lightBarSirenInUse;
}

ITS__Container::ClosedLanes_template& RoadWorksContainerExtended_template::closedLanes()
{
set_specific();
return single_value->field_closedLanes;
}

const ITS__Container::ClosedLanes_template& RoadWorksContainerExtended_template::closedLanes() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field closedLanes of a non-specific template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
return single_value->field_closedLanes;
}

ITS__Container::RestrictedTypes_template& RoadWorksContainerExtended_template::restriction()
{
set_specific();
return single_value->field_restriction;
}

const ITS__Container::RestrictedTypes_template& RoadWorksContainerExtended_template::restriction() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field restriction of a non-specific template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
return single_value->field_restriction;
}

INTEGER_template& RoadWorksContainerExtended_template::speedLimit()
{
set_specific();
return single_value->field_speedLimit;
}

const INTEGER_template& RoadWorksContainerExtended_template::speedLimit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field speedLimit of a non-specific template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
return single_value->field_speedLimit;
}

ITS__Container::CauseCode_template& RoadWorksContainerExtended_template::incidentIndication()
{
set_specific();
return single_value->field_incidentIndication;
}

const ITS__Container::CauseCode_template& RoadWorksContainerExtended_template::incidentIndication() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field incidentIndication of a non-specific template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
return single_value->field_incidentIndication;
}

ITS__Container::ItineraryPath_template& RoadWorksContainerExtended_template::recommendedPath()
{
set_specific();
return single_value->field_recommendedPath;
}

const ITS__Container::ItineraryPath_template& RoadWorksContainerExtended_template::recommendedPath() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field recommendedPath of a non-specific template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
return single_value->field_recommendedPath;
}

ITS__Container::DeltaReferencePosition_template& RoadWorksContainerExtended_template::startingPointSpeedLimit()
{
set_specific();
return single_value->field_startingPointSpeedLimit;
}

const ITS__Container::DeltaReferencePosition_template& RoadWorksContainerExtended_template::startingPointSpeedLimit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field startingPointSpeedLimit of a non-specific template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
return single_value->field_startingPointSpeedLimit;
}

ITS__Container::TrafficRule_template& RoadWorksContainerExtended_template::trafficFlowRule()
{
set_specific();
return single_value->field_trafficFlowRule;
}

const ITS__Container::TrafficRule_template& RoadWorksContainerExtended_template::trafficFlowRule() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trafficFlowRule of a non-specific template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
return single_value->field_trafficFlowRule;
}

ReferenceDenms_template& RoadWorksContainerExtended_template::referenceDenms()
{
set_specific();
return single_value->field_referenceDenms;
}

const ReferenceDenms_template& RoadWorksContainerExtended_template::referenceDenms() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field referenceDenms of a non-specific template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
return single_value->field_referenceDenms;
}

int RoadWorksContainerExtended_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 0;
      if (single_value->field_lightBarSirenInUse.is_present()) ret_val++;
      if (single_value->field_closedLanes.is_present()) ret_val++;
      if (single_value->field_restriction.is_present()) ret_val++;
      if (single_value->field_speedLimit.is_present()) ret_val++;
      if (single_value->field_incidentIndication.is_present()) ret_val++;
      if (single_value->field_recommendedPath.is_present()) ret_val++;
      if (single_value->field_startingPointSpeedLimit.is_present()) ret_val++;
      if (single_value->field_trafficFlowRule.is_present()) ret_val++;
      if (single_value->field_referenceDenms.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
  }
  return 0;
}

void RoadWorksContainerExtended_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ lightBarSirenInUse := ");
single_value->field_lightBarSirenInUse.log();
TTCN_Logger::log_event_str(", closedLanes := ");
single_value->field_closedLanes.log();
TTCN_Logger::log_event_str(", restriction := ");
single_value->field_restriction.log();
TTCN_Logger::log_event_str(", speedLimit := ");
single_value->field_speedLimit.log();
TTCN_Logger::log_event_str(", incidentIndication := ");
single_value->field_incidentIndication.log();
TTCN_Logger::log_event_str(", recommendedPath := ");
single_value->field_recommendedPath.log();
TTCN_Logger::log_event_str(", startingPointSpeedLimit := ");
single_value->field_startingPointSpeedLimit.log();
TTCN_Logger::log_event_str(", trafficFlowRule := ");
single_value->field_trafficFlowRule.log();
TTCN_Logger::log_event_str(", referenceDenms := ");
single_value->field_referenceDenms.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RoadWorksContainerExtended_template::log_match(const RoadWorksContainerExtended& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.lightBarSirenInUse().ispresent()){
if(!single_value->field_lightBarSirenInUse.match(match_value.lightBarSirenInUse(), legacy)){
TTCN_Logger::log_logmatch_info(".lightBarSirenInUse");
single_value->field_lightBarSirenInUse.log_match(match_value.lightBarSirenInUse(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_lightBarSirenInUse.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".lightBarSirenInUse := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_lightBarSirenInUse.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.closedLanes().ispresent()){
if(!single_value->field_closedLanes.match(match_value.closedLanes(), legacy)){
TTCN_Logger::log_logmatch_info(".closedLanes");
single_value->field_closedLanes.log_match(match_value.closedLanes(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_closedLanes.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".closedLanes := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_closedLanes.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.restriction().ispresent()){
if(!single_value->field_restriction.match(match_value.restriction(), legacy)){
TTCN_Logger::log_logmatch_info(".restriction");
single_value->field_restriction.log_match(match_value.restriction(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_restriction.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".restriction := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_restriction.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.speedLimit().ispresent()){
if(!single_value->field_speedLimit.match(match_value.speedLimit(), legacy)){
TTCN_Logger::log_logmatch_info(".speedLimit");
single_value->field_speedLimit.log_match(match_value.speedLimit(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_speedLimit.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".speedLimit := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_speedLimit.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.incidentIndication().ispresent()){
if(!single_value->field_incidentIndication.match(match_value.incidentIndication(), legacy)){
TTCN_Logger::log_logmatch_info(".incidentIndication");
single_value->field_incidentIndication.log_match(match_value.incidentIndication(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_incidentIndication.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".incidentIndication := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_incidentIndication.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.recommendedPath().ispresent()){
if(!single_value->field_recommendedPath.match(match_value.recommendedPath(), legacy)){
TTCN_Logger::log_logmatch_info(".recommendedPath");
single_value->field_recommendedPath.log_match(match_value.recommendedPath(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_recommendedPath.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".recommendedPath := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_recommendedPath.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.startingPointSpeedLimit().ispresent()){
if(!single_value->field_startingPointSpeedLimit.match(match_value.startingPointSpeedLimit(), legacy)){
TTCN_Logger::log_logmatch_info(".startingPointSpeedLimit");
single_value->field_startingPointSpeedLimit.log_match(match_value.startingPointSpeedLimit(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_startingPointSpeedLimit.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".startingPointSpeedLimit := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_startingPointSpeedLimit.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.trafficFlowRule().ispresent()){
if(!single_value->field_trafficFlowRule.match(match_value.trafficFlowRule(), legacy)){
TTCN_Logger::log_logmatch_info(".trafficFlowRule");
single_value->field_trafficFlowRule.log_match(match_value.trafficFlowRule(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_trafficFlowRule.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".trafficFlowRule := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_trafficFlowRule.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.referenceDenms().ispresent()){
if(!single_value->field_referenceDenms.match(match_value.referenceDenms(), legacy)){
TTCN_Logger::log_logmatch_info(".referenceDenms");
single_value->field_referenceDenms.log_match(match_value.referenceDenms(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_referenceDenms.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".referenceDenms := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_referenceDenms.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ lightBarSirenInUse := ");
if (match_value.lightBarSirenInUse().ispresent()) single_value->field_lightBarSirenInUse.log_match(match_value.lightBarSirenInUse(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_lightBarSirenInUse.log();
if (single_value->field_lightBarSirenInUse.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", closedLanes := ");
if (match_value.closedLanes().ispresent()) single_value->field_closedLanes.log_match(match_value.closedLanes(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_closedLanes.log();
if (single_value->field_closedLanes.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", restriction := ");
if (match_value.restriction().ispresent()) single_value->field_restriction.log_match(match_value.restriction(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_restriction.log();
if (single_value->field_restriction.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", speedLimit := ");
if (match_value.speedLimit().ispresent()) single_value->field_speedLimit.log_match(match_value.speedLimit(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_speedLimit.log();
if (single_value->field_speedLimit.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", incidentIndication := ");
if (match_value.incidentIndication().ispresent()) single_value->field_incidentIndication.log_match(match_value.incidentIndication(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_incidentIndication.log();
if (single_value->field_incidentIndication.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", recommendedPath := ");
if (match_value.recommendedPath().ispresent()) single_value->field_recommendedPath.log_match(match_value.recommendedPath(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_recommendedPath.log();
if (single_value->field_recommendedPath.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", startingPointSpeedLimit := ");
if (match_value.startingPointSpeedLimit().ispresent()) single_value->field_startingPointSpeedLimit.log_match(match_value.startingPointSpeedLimit(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_startingPointSpeedLimit.log();
if (single_value->field_startingPointSpeedLimit.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", trafficFlowRule := ");
if (match_value.trafficFlowRule().ispresent()) single_value->field_trafficFlowRule.log_match(match_value.trafficFlowRule(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_trafficFlowRule.log();
if (single_value->field_trafficFlowRule.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", referenceDenms := ");
if (match_value.referenceDenms().ispresent()) single_value->field_referenceDenms.log_match(match_value.referenceDenms(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_referenceDenms.log();
if (single_value->field_referenceDenms.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RoadWorksContainerExtended_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_lightBarSirenInUse.encode_text(text_buf);
single_value->field_closedLanes.encode_text(text_buf);
single_value->field_restriction.encode_text(text_buf);
single_value->field_speedLimit.encode_text(text_buf);
single_value->field_incidentIndication.encode_text(text_buf);
single_value->field_recommendedPath.encode_text(text_buf);
single_value->field_startingPointSpeedLimit.encode_text(text_buf);
single_value->field_trafficFlowRule.encode_text(text_buf);
single_value->field_referenceDenms.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
}
}

void RoadWorksContainerExtended_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_lightBarSirenInUse.decode_text(text_buf);
single_value->field_closedLanes.decode_text(text_buf);
single_value->field_restriction.decode_text(text_buf);
single_value->field_speedLimit.decode_text(text_buf);
single_value->field_incidentIndication.decode_text(text_buf);
single_value->field_recommendedPath.decode_text(text_buf);
single_value->field_startingPointSpeedLimit.decode_text(text_buf);
single_value->field_trafficFlowRule.decode_text(text_buf);
single_value->field_referenceDenms.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RoadWorksContainerExtended_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended.");
}
}

void RoadWorksContainerExtended_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DENM-PDU-Descriptions.RoadWorksContainerExtended'");
    }
    if (strcmp("lightBarSirenInUse", param_field) == 0) {
      lightBarSirenInUse().set_param(param);
      return;
    } else if (strcmp("closedLanes", param_field) == 0) {
      closedLanes().set_param(param);
      return;
    } else if (strcmp("restriction", param_field) == 0) {
      restriction().set_param(param);
      return;
    } else if (strcmp("speedLimit", param_field) == 0) {
      speedLimit().set_param(param);
      return;
    } else if (strcmp("incidentIndication", param_field) == 0) {
      incidentIndication().set_param(param);
      return;
    } else if (strcmp("recommendedPath", param_field) == 0) {
      recommendedPath().set_param(param);
      return;
    } else if (strcmp("startingPointSpeedLimit", param_field) == 0) {
      startingPointSpeedLimit().set_param(param);
      return;
    } else if (strcmp("trafficFlowRule", param_field) == 0) {
      trafficFlowRule().set_param(param);
      return;
    } else if (strcmp("referenceDenms", param_field) == 0) {
      referenceDenms().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DENM-PDU-Descriptions.RoadWorksContainerExtended'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RoadWorksContainerExtended_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (9<mp->get_size()) {
      param.error("record template of type @DENM-PDU-Descriptions.RoadWorksContainerExtended has 9 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) lightBarSirenInUse().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) closedLanes().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) restriction().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) speedLimit().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) incidentIndication().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) recommendedPath().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) startingPointSpeedLimit().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) trafficFlowRule().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) referenceDenms().set_param(*mp->get_elem(8));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lightBarSirenInUse")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lightBarSirenInUse().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "closedLanes")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          closedLanes().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "restriction")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          restriction().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speedLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speedLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "incidentIndication")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          incidentIndication().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "recommendedPath")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          recommendedPath().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "startingPointSpeedLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          startingPointSpeedLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficFlowRule")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficFlowRule().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "referenceDenms")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          referenceDenms().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.RoadWorksContainerExtended: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DENM-PDU-Descriptions.RoadWorksContainerExtended");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RoadWorksContainerExtended_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DENM-PDU-Descriptions.RoadWorksContainerExtended'");
    }
    if (strcmp("lightBarSirenInUse", param_field) == 0) {
      return lightBarSirenInUse().get_param(param_name);
    } else if (strcmp("closedLanes", param_field) == 0) {
      return closedLanes().get_param(param_name);
    } else if (strcmp("restriction", param_field) == 0) {
      return restriction().get_param(param_name);
    } else if (strcmp("speedLimit", param_field) == 0) {
      return speedLimit().get_param(param_name);
    } else if (strcmp("incidentIndication", param_field) == 0) {
      return incidentIndication().get_param(param_name);
    } else if (strcmp("recommendedPath", param_field) == 0) {
      return recommendedPath().get_param(param_name);
    } else if (strcmp("startingPointSpeedLimit", param_field) == 0) {
      return startingPointSpeedLimit().get_param(param_name);
    } else if (strcmp("trafficFlowRule", param_field) == 0) {
      return trafficFlowRule().get_param(param_name);
    } else if (strcmp("referenceDenms", param_field) == 0) {
      return referenceDenms().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.RoadWorksContainerExtended'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_lightBarSirenInUse = single_value->field_lightBarSirenInUse.get_param(param_name);
    mp_field_lightBarSirenInUse->set_id(new Module_Param_FieldName(mcopystr("lightBarSirenInUse")));
    mp->add_elem(mp_field_lightBarSirenInUse);
    Module_Param* mp_field_closedLanes = single_value->field_closedLanes.get_param(param_name);
    mp_field_closedLanes->set_id(new Module_Param_FieldName(mcopystr("closedLanes")));
    mp->add_elem(mp_field_closedLanes);
    Module_Param* mp_field_restriction = single_value->field_restriction.get_param(param_name);
    mp_field_restriction->set_id(new Module_Param_FieldName(mcopystr("restriction")));
    mp->add_elem(mp_field_restriction);
    Module_Param* mp_field_speedLimit = single_value->field_speedLimit.get_param(param_name);
    mp_field_speedLimit->set_id(new Module_Param_FieldName(mcopystr("speedLimit")));
    mp->add_elem(mp_field_speedLimit);
    Module_Param* mp_field_incidentIndication = single_value->field_incidentIndication.get_param(param_name);
    mp_field_incidentIndication->set_id(new Module_Param_FieldName(mcopystr("incidentIndication")));
    mp->add_elem(mp_field_incidentIndication);
    Module_Param* mp_field_recommendedPath = single_value->field_recommendedPath.get_param(param_name);
    mp_field_recommendedPath->set_id(new Module_Param_FieldName(mcopystr("recommendedPath")));
    mp->add_elem(mp_field_recommendedPath);
    Module_Param* mp_field_startingPointSpeedLimit = single_value->field_startingPointSpeedLimit.get_param(param_name);
    mp_field_startingPointSpeedLimit->set_id(new Module_Param_FieldName(mcopystr("startingPointSpeedLimit")));
    mp->add_elem(mp_field_startingPointSpeedLimit);
    Module_Param* mp_field_trafficFlowRule = single_value->field_trafficFlowRule.get_param(param_name);
    mp_field_trafficFlowRule->set_id(new Module_Param_FieldName(mcopystr("trafficFlowRule")));
    mp->add_elem(mp_field_trafficFlowRule);
    Module_Param* mp_field_referenceDenms = single_value->field_referenceDenms.get_param(param_name);
    mp_field_referenceDenms->set_id(new Module_Param_FieldName(mcopystr("referenceDenms")));
    mp->add_elem(mp_field_referenceDenms);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RoadWorksContainerExtended_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_lightBarSirenInUse.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.RoadWorksContainerExtended");
single_value->field_closedLanes.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.RoadWorksContainerExtended");
single_value->field_restriction.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.RoadWorksContainerExtended");
single_value->field_speedLimit.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.RoadWorksContainerExtended");
single_value->field_incidentIndication.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.RoadWorksContainerExtended");
single_value->field_recommendedPath.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.RoadWorksContainerExtended");
single_value->field_startingPointSpeedLimit.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.RoadWorksContainerExtended");
single_value->field_trafficFlowRule.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.RoadWorksContainerExtended");
single_value->field_referenceDenms.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.RoadWorksContainerExtended");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DENM-PDU-Descriptions.RoadWorksContainerExtended");
}

boolean RoadWorksContainerExtended_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RoadWorksContainerExtended_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const ITS__Container::ActionID ReferenceDenms::UNBOUND_ELEM;
ReferenceDenms::ReferenceDenms()
{
val_ptr = NULL;
}

ReferenceDenms::ReferenceDenms(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

ReferenceDenms::ReferenceDenms(const ReferenceDenms& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DENM-PDU-Descriptions.ReferenceDenms.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

ReferenceDenms::~ReferenceDenms()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void ReferenceDenms::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

ReferenceDenms& ReferenceDenms::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

ReferenceDenms& ReferenceDenms::operator=(const ReferenceDenms& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @DENM-PDU-Descriptions.ReferenceDenms.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean ReferenceDenms::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @DENM-PDU-Descriptions.ReferenceDenms.");
return val_ptr->n_elements == 0 ;
}

boolean ReferenceDenms::operator==(const ReferenceDenms& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @DENM-PDU-Descriptions.ReferenceDenms.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @DENM-PDU-Descriptions.ReferenceDenms.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

ITS__Container::ActionID& ReferenceDenms::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @DENM-PDU-Descriptions.ReferenceDenms using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (ITS__Container::ActionID**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new ITS__Container::ActionID(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new ITS__Container::ActionID;
}
return *val_ptr->value_elements[index_value];
}

ITS__Container::ActionID& ReferenceDenms::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DENM-PDU-Descriptions.ReferenceDenms.");
return (*this)[(int)index_value];
}

const ITS__Container::ActionID& ReferenceDenms::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @DENM-PDU-Descriptions.ReferenceDenms.");
if (index_value < 0) TTCN_error("Accessing an element of type @DENM-PDU-Descriptions.ReferenceDenms using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @DENM-PDU-Descriptions.ReferenceDenms: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const ITS__Container::ActionID& ReferenceDenms::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @DENM-PDU-Descriptions.ReferenceDenms.");
return (*this)[(int)index_value];
}

ReferenceDenms ReferenceDenms::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

ReferenceDenms ReferenceDenms::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

ReferenceDenms ReferenceDenms::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

ReferenceDenms ReferenceDenms::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @DENM-PDU-Descriptions.ReferenceDenms.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
ReferenceDenms ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new ITS__Container::ActionID(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

ReferenceDenms ReferenceDenms::operator+(const ReferenceDenms& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @DENM-PDU-Descriptions.ReferenceDenms concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
ReferenceDenms ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new ITS__Container::ActionID(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new ITS__Container::ActionID(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

ReferenceDenms ReferenceDenms::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @DENM-PDU-Descriptions.ReferenceDenms.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@DENM-PDU-Descriptions.ReferenceDenms","element");
ReferenceDenms ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new ITS__Container::ActionID(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

ReferenceDenms ReferenceDenms::replace(int index, int len, const ReferenceDenms& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @DENM-PDU-Descriptions.ReferenceDenms.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @DENM-PDU-Descriptions.ReferenceDenms.");
check_replace_arguments(val_ptr->n_elements, index, len, "@DENM-PDU-Descriptions.ReferenceDenms","element");
ReferenceDenms ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new ITS__Container::ActionID(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new ITS__Container::ActionID(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new ITS__Container::ActionID(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

ReferenceDenms ReferenceDenms::replace(int index, int len, const ReferenceDenms_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void ReferenceDenms::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @DENM-PDU-Descriptions.ReferenceDenms.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (ITS__Container::ActionID**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new ITS__Container::ActionID(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (ITS__Container::ActionID**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @DENM-PDU-Descriptions.ReferenceDenms: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (ITS__Container::ActionID**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean ReferenceDenms::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int ReferenceDenms::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @DENM-PDU-Descriptions.ReferenceDenms.");
return val_ptr->n_elements;
}

int ReferenceDenms::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @DENM-PDU-Descriptions.ReferenceDenms.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void ReferenceDenms::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void ReferenceDenms::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@DENM-PDU-Descriptions.ReferenceDenms'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@DENM-PDU-Descriptions.ReferenceDenms");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@DENM-PDU-Descriptions.ReferenceDenms");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* ReferenceDenms::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@DENM-PDU-Descriptions.ReferenceDenms'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void ReferenceDenms::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void ReferenceDenms::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @DENM-PDU-Descriptions.ReferenceDenms.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void ReferenceDenms::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @DENM-PDU-Descriptions.ReferenceDenms.");
val_ptr->value_elements = (ITS__Container::ActionID**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new ITS__Container::ActionID;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void ReferenceDenms::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ReferenceDenms::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* ReferenceDenms::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=BER_encode_chk_bound(is_bound());
  if(!new_tlv) {
    new_tlv=ASN_BER_TLV_t::construct(NULL);
    TTCN_EncDec_ErrorContext ec;
    for(int elem_i=0; elem_i<val_ptr->n_elements; elem_i++) {
      ec.set_msg("Component #%d: ", elem_i);
      new_tlv->add_TLV((*this)[elem_i].BER_encode_TLV(*p_td.oftype_descr, p_coding));
    }
  }
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean ReferenceDenms::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '%s' type: ", p_td.name);
  stripped_tlv.chk_constructed_flag(TRUE);
  clean_up();
  val_ptr = new recordof_setof_struct;
  val_ptr->ref_count = 1;
  val_ptr->n_elements = 0;
  val_ptr->value_elements = NULL;
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  TTCN_EncDec_ErrorContext ec_1("Component #");
  TTCN_EncDec_ErrorContext ec_2("0: ");
  while(BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv)) {
    val_ptr->value_elements = (ITS__Container::ActionID**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->n_elements++;
    val_ptr->value_elements[val_ptr->n_elements - 1] = new ITS__Container::ActionID;
    val_ptr->value_elements[val_ptr->n_elements - 1]->BER_decode_TLV(*p_td.oftype_descr, tmp_tlv, L_form);
    ec_2.set_msg("%d: ", val_ptr->n_elements);
  }
  return TRUE;
}

int ReferenceDenms::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DENM-PDU-Descriptions.ReferenceDenms.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int ReferenceDenms::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    ITS__Container::ActionID* val = new ITS__Container::ActionID;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (ITS__Container::ActionID**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void ReferenceDenms_template::copy_value(const ReferenceDenms& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @DENM-PDU-Descriptions.ReferenceDenms with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (ITS__Container::ActionID_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new ITS__Container::ActionID_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new ITS__Container::ActionID_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void ReferenceDenms_template::copy_template(const ReferenceDenms_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (ITS__Container::ActionID_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new ITS__Container::ActionID_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new ITS__Container::ActionID_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ReferenceDenms_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DENM-PDU-Descriptions.ReferenceDenms.");
break;
}
set_selection(other_value);
}

boolean ReferenceDenms_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const ReferenceDenms_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const ReferenceDenms*)value_ptr)[value_index], legacy);
else return ((const ReferenceDenms_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

ReferenceDenms_template::ReferenceDenms_template()
{
}

ReferenceDenms_template::ReferenceDenms_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

ReferenceDenms_template::ReferenceDenms_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

ReferenceDenms_template::ReferenceDenms_template(const ReferenceDenms& other_value)
{
copy_value(other_value);
}

ReferenceDenms_template::ReferenceDenms_template(const OPTIONAL<ReferenceDenms>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ReferenceDenms&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DENM-PDU-Descriptions.ReferenceDenms from an unbound optional field.");
}
}

ReferenceDenms_template::ReferenceDenms_template(const ReferenceDenms_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

ReferenceDenms_template::~ReferenceDenms_template()
{
clean_up();
}

void ReferenceDenms_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ReferenceDenms_template& ReferenceDenms_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ReferenceDenms_template& ReferenceDenms_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

ReferenceDenms_template& ReferenceDenms_template::operator=(const ReferenceDenms& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ReferenceDenms_template& ReferenceDenms_template::operator=(const OPTIONAL<ReferenceDenms>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ReferenceDenms&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DENM-PDU-Descriptions.ReferenceDenms.");
}
return *this;
}

ReferenceDenms_template& ReferenceDenms_template::operator=(const ReferenceDenms_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

ITS__Container::ActionID_template& ReferenceDenms_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DENM-PDU-Descriptions.ReferenceDenms using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @DENM-PDU-Descriptions.ReferenceDenms.");
    break;
}
return *single_value.value_elements[index_value];
}

ITS__Container::ActionID_template& ReferenceDenms_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DENM-PDU-Descriptions.ReferenceDenms.");
return (*this)[(int)index_value];
}

const ITS__Container::ActionID_template& ReferenceDenms_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @DENM-PDU-Descriptions.ReferenceDenms using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @DENM-PDU-Descriptions.ReferenceDenms.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @DENM-PDU-Descriptions.ReferenceDenms: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const ITS__Container::ActionID_template& ReferenceDenms_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @DENM-PDU-Descriptions.ReferenceDenms.");
return (*this)[(int)index_value];
}

void ReferenceDenms_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @DENM-PDU-Descriptions.ReferenceDenms.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (ITS__Container::ActionID_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new ITS__Container::ActionID_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new ITS__Container::ActionID_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (ITS__Container::ActionID_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int ReferenceDenms_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int ReferenceDenms_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @DENM-PDU-Descriptions.ReferenceDenms which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @DENM-PDU-Descriptions.ReferenceDenms containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @DENM-PDU-Descriptions.ReferenceDenms containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @DENM-PDU-Descriptions.ReferenceDenms containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @DENM-PDU-Descriptions.ReferenceDenms containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @DENM-PDU-Descriptions.ReferenceDenms containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @DENM-PDU-Descriptions.ReferenceDenms.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @DENM-PDU-Descriptions.ReferenceDenms");
}

boolean ReferenceDenms_template::match(const ReferenceDenms& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @DENM-PDU-Descriptions.ReferenceDenms.");
}
return FALSE;
}

boolean ReferenceDenms_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

ReferenceDenms ReferenceDenms_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @DENM-PDU-Descriptions.ReferenceDenms.");
ReferenceDenms ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

ReferenceDenms ReferenceDenms_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

ReferenceDenms ReferenceDenms_template::replace(int index, int len, const ReferenceDenms_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

ReferenceDenms ReferenceDenms_template::replace(int index, int len, const ReferenceDenms& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void ReferenceDenms_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new ReferenceDenms_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @DENM-PDU-Descriptions.ReferenceDenms.");
}
set_selection(template_type);
}

ReferenceDenms_template& ReferenceDenms_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @DENM-PDU-Descriptions.ReferenceDenms.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @DENM-PDU-Descriptions.ReferenceDenms.");
return value_list.list_value[list_index];
}

void ReferenceDenms_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void ReferenceDenms_template::log_match(const ReferenceDenms& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ReferenceDenms_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DENM-PDU-Descriptions.ReferenceDenms.");
}
}

void ReferenceDenms_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @DENM-PDU-Descriptions.ReferenceDenms.");
single_value.value_elements = (ITS__Container::ActionID_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new ITS__Container::ActionID_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ReferenceDenms_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @DENM-PDU-Descriptions.ReferenceDenms.");
}
}

boolean ReferenceDenms_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ReferenceDenms_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ReferenceDenms_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@DENM-PDU-Descriptions.ReferenceDenms'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ReferenceDenms_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@DENM-PDU-Descriptions.ReferenceDenms");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* ReferenceDenms_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@DENM-PDU-Descriptions.ReferenceDenms'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void ReferenceDenms_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.ReferenceDenms");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DENM-PDU-Descriptions.ReferenceDenms");
}

StationaryVehicleContainer::StationaryVehicleContainer()
{
  bound_flag = FALSE;
}

StationaryVehicleContainer::StationaryVehicleContainer(const OPTIONAL<ITS__Container::StationarySince>& par_stationarySince,
    const OPTIONAL<ITS__Container::CauseCode>& par_stationaryCause,
    const OPTIONAL<ITS__Container::DangerousGoodsExtended>& par_carryingDangerousGoods,
    const OPTIONAL<INTEGER>& par_numberOfOccupants,
    const OPTIONAL<ITS__Container::VehicleIdentification>& par_vehicleIdentification,
    const OPTIONAL<BITSTRING>& par_energyStorageType)
  :   field_stationarySince(par_stationarySince),
  field_stationaryCause(par_stationaryCause),
  field_carryingDangerousGoods(par_carryingDangerousGoods),
  field_numberOfOccupants(par_numberOfOccupants),
  field_vehicleIdentification(par_vehicleIdentification),
  field_energyStorageType(par_energyStorageType)
{
  bound_flag = TRUE;
}

StationaryVehicleContainer::StationaryVehicleContainer(const StationaryVehicleContainer& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
bound_flag = TRUE;
if (other_value.stationarySince().is_bound()) field_stationarySince = other_value.stationarySince();
else field_stationarySince.clean_up();
if (other_value.stationaryCause().is_bound()) field_stationaryCause = other_value.stationaryCause();
else field_stationaryCause.clean_up();
if (other_value.carryingDangerousGoods().is_bound()) field_carryingDangerousGoods = other_value.carryingDangerousGoods();
else field_carryingDangerousGoods.clean_up();
if (other_value.numberOfOccupants().is_bound()) field_numberOfOccupants = other_value.numberOfOccupants();
else field_numberOfOccupants.clean_up();
if (other_value.vehicleIdentification().is_bound()) field_vehicleIdentification = other_value.vehicleIdentification();
else field_vehicleIdentification.clean_up();
if (other_value.energyStorageType().is_bound()) field_energyStorageType = other_value.energyStorageType();
else field_energyStorageType.clean_up();
}

void StationaryVehicleContainer::clean_up()
{
field_stationarySince.clean_up();
field_stationaryCause.clean_up();
field_carryingDangerousGoods.clean_up();
field_numberOfOccupants.clean_up();
field_vehicleIdentification.clean_up();
field_energyStorageType.clean_up();
bound_flag = FALSE;
}

StationaryVehicleContainer& StationaryVehicleContainer::operator=(const StationaryVehicleContainer& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
  bound_flag = TRUE;
  if (other_value.stationarySince().is_bound()) field_stationarySince = other_value.stationarySince();
  else field_stationarySince.clean_up();
  if (other_value.stationaryCause().is_bound()) field_stationaryCause = other_value.stationaryCause();
  else field_stationaryCause.clean_up();
  if (other_value.carryingDangerousGoods().is_bound()) field_carryingDangerousGoods = other_value.carryingDangerousGoods();
  else field_carryingDangerousGoods.clean_up();
  if (other_value.numberOfOccupants().is_bound()) field_numberOfOccupants = other_value.numberOfOccupants();
  else field_numberOfOccupants.clean_up();
  if (other_value.vehicleIdentification().is_bound()) field_vehicleIdentification = other_value.vehicleIdentification();
  else field_vehicleIdentification.clean_up();
  if (other_value.energyStorageType().is_bound()) field_energyStorageType = other_value.energyStorageType();
  else field_energyStorageType.clean_up();
}
return *this;
}

boolean StationaryVehicleContainer::operator==(const StationaryVehicleContainer& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_stationarySince==other_value.field_stationarySince
  && field_stationaryCause==other_value.field_stationaryCause
  && field_carryingDangerousGoods==other_value.field_carryingDangerousGoods
  && field_numberOfOccupants==other_value.field_numberOfOccupants
  && field_vehicleIdentification==other_value.field_vehicleIdentification
  && field_energyStorageType==other_value.field_energyStorageType;
}

boolean StationaryVehicleContainer::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_stationarySince.get_selection() || field_stationarySince.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_stationaryCause.get_selection() || field_stationaryCause.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_carryingDangerousGoods.get_selection() || field_carryingDangerousGoods.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_numberOfOccupants.get_selection() || field_numberOfOccupants.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_vehicleIdentification.get_selection() || field_vehicleIdentification.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_energyStorageType.get_selection() || field_energyStorageType.is_bound()) return TRUE;
return FALSE;
}
boolean StationaryVehicleContainer::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_stationarySince.get_selection() && !field_stationarySince.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_stationaryCause.get_selection() && !field_stationaryCause.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_carryingDangerousGoods.get_selection() && !field_carryingDangerousGoods.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_numberOfOccupants.get_selection() && !field_numberOfOccupants.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_vehicleIdentification.get_selection() && !field_vehicleIdentification.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_energyStorageType.get_selection() && !field_energyStorageType.is_value()) return FALSE;
return TRUE;
}
int StationaryVehicleContainer::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DENM-PDU-Descriptions.StationaryVehicleContainer");
  int ret_val = 0;
  if (field_stationarySince.ispresent()) ret_val++;
  if (field_stationaryCause.ispresent()) ret_val++;
  if (field_carryingDangerousGoods.ispresent()) ret_val++;
  if (field_numberOfOccupants.ispresent()) ret_val++;
  if (field_vehicleIdentification.ispresent()) ret_val++;
  if (field_energyStorageType.ispresent()) ret_val++;
  return ret_val;
}

void StationaryVehicleContainer::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ stationarySince := ");
field_stationarySince.log();
TTCN_Logger::log_event_str(", stationaryCause := ");
field_stationaryCause.log();
TTCN_Logger::log_event_str(", carryingDangerousGoods := ");
field_carryingDangerousGoods.log();
TTCN_Logger::log_event_str(", numberOfOccupants := ");
field_numberOfOccupants.log();
TTCN_Logger::log_event_str(", vehicleIdentification := ");
field_vehicleIdentification.log();
TTCN_Logger::log_event_str(", energyStorageType := ");
field_energyStorageType.log();
TTCN_Logger::log_event_str(" }");
}

void StationaryVehicleContainer::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DENM-PDU-Descriptions.StationaryVehicleContainer'");
    }
    if (strcmp("stationarySince", param_field) == 0) {
      stationarySince().set_param(param);
      return;
    } else if (strcmp("stationaryCause", param_field) == 0) {
      stationaryCause().set_param(param);
      return;
    } else if (strcmp("carryingDangerousGoods", param_field) == 0) {
      carryingDangerousGoods().set_param(param);
      return;
    } else if (strcmp("numberOfOccupants", param_field) == 0) {
      numberOfOccupants().set_param(param);
      return;
    } else if (strcmp("vehicleIdentification", param_field) == 0) {
      vehicleIdentification().set_param(param);
      return;
    } else if (strcmp("energyStorageType", param_field) == 0) {
      energyStorageType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DENM-PDU-Descriptions.StationaryVehicleContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record value of type @DENM-PDU-Descriptions.StationaryVehicleContainer has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stationarySince().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) stationaryCause().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) carryingDangerousGoods().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) numberOfOccupants().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) vehicleIdentification().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) energyStorageType().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationarySince")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationarySince().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationaryCause")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationaryCause().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "carryingDangerousGoods")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          carryingDangerousGoods().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "numberOfOccupants")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          numberOfOccupants().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vehicleIdentification")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vehicleIdentification().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "energyStorageType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          energyStorageType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.StationaryVehicleContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DENM-PDU-Descriptions.StationaryVehicleContainer");
  }
}

Module_Param* StationaryVehicleContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DENM-PDU-Descriptions.StationaryVehicleContainer'");
    }
    if (strcmp("stationarySince", param_field) == 0) {
      return stationarySince().get_param(param_name);
    } else if (strcmp("stationaryCause", param_field) == 0) {
      return stationaryCause().get_param(param_name);
    } else if (strcmp("carryingDangerousGoods", param_field) == 0) {
      return carryingDangerousGoods().get_param(param_name);
    } else if (strcmp("numberOfOccupants", param_field) == 0) {
      return numberOfOccupants().get_param(param_name);
    } else if (strcmp("vehicleIdentification", param_field) == 0) {
      return vehicleIdentification().get_param(param_name);
    } else if (strcmp("energyStorageType", param_field) == 0) {
      return energyStorageType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.StationaryVehicleContainer'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_stationarySince = field_stationarySince.get_param(param_name);
  mp_field_stationarySince->set_id(new Module_Param_FieldName(mcopystr("stationarySince")));
  mp->add_elem(mp_field_stationarySince);
  Module_Param* mp_field_stationaryCause = field_stationaryCause.get_param(param_name);
  mp_field_stationaryCause->set_id(new Module_Param_FieldName(mcopystr("stationaryCause")));
  mp->add_elem(mp_field_stationaryCause);
  Module_Param* mp_field_carryingDangerousGoods = field_carryingDangerousGoods.get_param(param_name);
  mp_field_carryingDangerousGoods->set_id(new Module_Param_FieldName(mcopystr("carryingDangerousGoods")));
  mp->add_elem(mp_field_carryingDangerousGoods);
  Module_Param* mp_field_numberOfOccupants = field_numberOfOccupants.get_param(param_name);
  mp_field_numberOfOccupants->set_id(new Module_Param_FieldName(mcopystr("numberOfOccupants")));
  mp->add_elem(mp_field_numberOfOccupants);
  Module_Param* mp_field_vehicleIdentification = field_vehicleIdentification.get_param(param_name);
  mp_field_vehicleIdentification->set_id(new Module_Param_FieldName(mcopystr("vehicleIdentification")));
  mp->add_elem(mp_field_vehicleIdentification);
  Module_Param* mp_field_energyStorageType = field_energyStorageType.get_param(param_name);
  mp_field_energyStorageType->set_id(new Module_Param_FieldName(mcopystr("energyStorageType")));
  mp->add_elem(mp_field_energyStorageType);
  return mp;
  }

void StationaryVehicleContainer::set_implicit_omit()
{
if (!stationarySince().is_bound()) stationarySince() = OMIT_VALUE;
else stationarySince().set_implicit_omit();
if (!stationaryCause().is_bound()) stationaryCause() = OMIT_VALUE;
else stationaryCause().set_implicit_omit();
if (!carryingDangerousGoods().is_bound()) carryingDangerousGoods() = OMIT_VALUE;
else carryingDangerousGoods().set_implicit_omit();
if (!numberOfOccupants().is_bound()) numberOfOccupants() = OMIT_VALUE;
else numberOfOccupants().set_implicit_omit();
if (!vehicleIdentification().is_bound()) vehicleIdentification() = OMIT_VALUE;
else vehicleIdentification().set_implicit_omit();
if (!energyStorageType().is_bound()) energyStorageType() = OMIT_VALUE;
else energyStorageType().set_implicit_omit();
}

void StationaryVehicleContainer::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
field_stationarySince.encode_text(text_buf);
field_stationaryCause.encode_text(text_buf);
field_carryingDangerousGoods.encode_text(text_buf);
field_numberOfOccupants.encode_text(text_buf);
field_vehicleIdentification.encode_text(text_buf);
field_energyStorageType.encode_text(text_buf);
}

void StationaryVehicleContainer::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_stationarySince.decode_text(text_buf);
field_stationaryCause.decode_text(text_buf);
field_carryingDangerousGoods.decode_text(text_buf);
field_numberOfOccupants.decode_text(text_buf);
field_vehicleIdentification.decode_text(text_buf);
field_energyStorageType.decode_text(text_buf);
}

void StationaryVehicleContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void StationaryVehicleContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* StationaryVehicleContainer::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("stationarySince': ");
  new_tlv->add_TLV(field_stationarySince.BER_encode_TLV(StationaryVehicleContainer_stationarySince_descr_, p_coding));
  ec_1.set_msg("stationaryCause': ");
  new_tlv->add_TLV(field_stationaryCause.BER_encode_TLV(StationaryVehicleContainer_stationaryCause_descr_, p_coding));
  ec_1.set_msg("carryingDangerousGoods': ");
  new_tlv->add_TLV(field_carryingDangerousGoods.BER_encode_TLV(StationaryVehicleContainer_carryingDangerousGoods_descr_, p_coding));
  ec_1.set_msg("numberOfOccupants': ");
  new_tlv->add_TLV(field_numberOfOccupants.BER_encode_TLV(StationaryVehicleContainer_numberOfOccupants_descr_, p_coding));
  ec_1.set_msg("vehicleIdentification': ");
  new_tlv->add_TLV(field_vehicleIdentification.BER_encode_TLV(StationaryVehicleContainer_vehicleIdentification_descr_, p_coding));
  ec_1.set_msg("energyStorageType': ");
  new_tlv->add_TLV(field_energyStorageType.BER_encode_TLV(StationaryVehicleContainer_energyStorageType_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean StationaryVehicleContainer::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DENM-PDU-Descriptions.StationaryVehicleContainer' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("stationarySince': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_stationarySince=OMIT_VALUE;
    else {
      field_stationarySince.BER_decode_TLV(StationaryVehicleContainer_stationarySince_descr_, tmp_tlv, L_form);
      if(field_stationarySince.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("stationaryCause': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_stationaryCause=OMIT_VALUE;
    else {
      field_stationaryCause.BER_decode_TLV(StationaryVehicleContainer_stationaryCause_descr_, tmp_tlv, L_form);
      if(field_stationaryCause.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("carryingDangerousGoods': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_carryingDangerousGoods=OMIT_VALUE;
    else {
      field_carryingDangerousGoods.BER_decode_TLV(StationaryVehicleContainer_carryingDangerousGoods_descr_, tmp_tlv, L_form);
      if(field_carryingDangerousGoods.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("numberOfOccupants': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_numberOfOccupants=OMIT_VALUE;
    else {
      field_numberOfOccupants.BER_decode_TLV(StationaryVehicleContainer_numberOfOccupants_descr_, tmp_tlv, L_form);
      if(field_numberOfOccupants.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("vehicleIdentification': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_vehicleIdentification=OMIT_VALUE;
    else {
      field_vehicleIdentification.BER_decode_TLV(StationaryVehicleContainer_vehicleIdentification_descr_, tmp_tlv, L_form);
      if(field_vehicleIdentification.ispresent()) tlv_present=FALSE;
    }
    ec_2.set_msg("energyStorageType': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present) field_energyStorageType=OMIT_VALUE;
    else {
      field_energyStorageType.BER_decode_TLV(StationaryVehicleContainer_energyStorageType_descr_, tmp_tlv, L_form);
      if(field_energyStorageType.ispresent()) tlv_present=FALSE;
    }
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int StationaryVehicleContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_stationarySince.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "stationarySince");
    enc_len += field_stationarySince.JSON_encode(StationaryVehicleContainer_stationarySince_descr_, p_tok);
  }

  if (field_stationaryCause.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "stationaryCause");
    enc_len += field_stationaryCause.JSON_encode(StationaryVehicleContainer_stationaryCause_descr_, p_tok);
  }

  if (field_carryingDangerousGoods.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "carryingDangerousGoods");
    enc_len += field_carryingDangerousGoods.JSON_encode(StationaryVehicleContainer_carryingDangerousGoods_descr_, p_tok);
  }

  if (field_numberOfOccupants.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "numberOfOccupants");
    enc_len += field_numberOfOccupants.JSON_encode(StationaryVehicleContainer_numberOfOccupants_descr_, p_tok);
  }

  if (field_vehicleIdentification.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "vehicleIdentification");
    enc_len += field_vehicleIdentification.JSON_encode(StationaryVehicleContainer_vehicleIdentification_descr_, p_tok);
  }

  if (field_energyStorageType.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "energyStorageType");
    enc_len += field_energyStorageType.JSON_encode(StationaryVehicleContainer_energyStorageType_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int StationaryVehicleContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (15 == name_len && 0 == strncmp(fld_name, "stationarySince", name_len)) {
         int ret_val = field_stationarySince.JSON_decode(StationaryVehicleContainer_stationarySince_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "stationarySince");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "stationaryCause", name_len)) {
         int ret_val = field_stationaryCause.JSON_decode(StationaryVehicleContainer_stationaryCause_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "stationaryCause");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (22 == name_len && 0 == strncmp(fld_name, "carryingDangerousGoods", name_len)) {
         int ret_val = field_carryingDangerousGoods.JSON_decode(StationaryVehicleContainer_carryingDangerousGoods_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "carryingDangerousGoods");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "numberOfOccupants", name_len)) {
         int ret_val = field_numberOfOccupants.JSON_decode(StationaryVehicleContainer_numberOfOccupants_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "numberOfOccupants");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (21 == name_len && 0 == strncmp(fld_name, "vehicleIdentification", name_len)) {
         int ret_val = field_vehicleIdentification.JSON_decode(StationaryVehicleContainer_vehicleIdentification_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "vehicleIdentification");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "energyStorageType", name_len)) {
         int ret_val = field_energyStorageType.JSON_decode(StationaryVehicleContainer_energyStorageType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "energyStorageType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_stationarySince.is_bound()) {
    field_stationarySince = OMIT_VALUE;
  }
if (!field_stationaryCause.is_bound()) {
    field_stationaryCause = OMIT_VALUE;
  }
if (!field_carryingDangerousGoods.is_bound()) {
    field_carryingDangerousGoods = OMIT_VALUE;
  }
if (!field_numberOfOccupants.is_bound()) {
    field_numberOfOccupants = OMIT_VALUE;
  }
if (!field_vehicleIdentification.is_bound()) {
    field_vehicleIdentification = OMIT_VALUE;
  }
if (!field_energyStorageType.is_bound()) {
    field_energyStorageType = OMIT_VALUE;
  }

  return dec_len;
}

struct StationaryVehicleContainer_template::single_value_struct {
ITS__Container::StationarySince_template field_stationarySince;
ITS__Container::CauseCode_template field_stationaryCause;
ITS__Container::DangerousGoodsExtended_template field_carryingDangerousGoods;
INTEGER_template field_numberOfOccupants;
ITS__Container::VehicleIdentification_template field_vehicleIdentification;
BITSTRING_template field_energyStorageType;
};

void StationaryVehicleContainer_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_stationarySince = ANY_OR_OMIT;
single_value->field_stationaryCause = ANY_OR_OMIT;
single_value->field_carryingDangerousGoods = ANY_OR_OMIT;
single_value->field_numberOfOccupants = ANY_OR_OMIT;
single_value->field_vehicleIdentification = ANY_OR_OMIT;
single_value->field_energyStorageType = ANY_OR_OMIT;
}
}
}

void StationaryVehicleContainer_template::copy_value(const StationaryVehicleContainer& other_value)
{
single_value = new single_value_struct;
if (other_value.stationarySince().is_bound()) {
  if (other_value.stationarySince().ispresent()) single_value->field_stationarySince = other_value.stationarySince()();
  else single_value->field_stationarySince = OMIT_VALUE;
} else {
  single_value->field_stationarySince.clean_up();
}
if (other_value.stationaryCause().is_bound()) {
  if (other_value.stationaryCause().ispresent()) single_value->field_stationaryCause = other_value.stationaryCause()();
  else single_value->field_stationaryCause = OMIT_VALUE;
} else {
  single_value->field_stationaryCause.clean_up();
}
if (other_value.carryingDangerousGoods().is_bound()) {
  if (other_value.carryingDangerousGoods().ispresent()) single_value->field_carryingDangerousGoods = other_value.carryingDangerousGoods()();
  else single_value->field_carryingDangerousGoods = OMIT_VALUE;
} else {
  single_value->field_carryingDangerousGoods.clean_up();
}
if (other_value.numberOfOccupants().is_bound()) {
  if (other_value.numberOfOccupants().ispresent()) single_value->field_numberOfOccupants = other_value.numberOfOccupants()();
  else single_value->field_numberOfOccupants = OMIT_VALUE;
} else {
  single_value->field_numberOfOccupants.clean_up();
}
if (other_value.vehicleIdentification().is_bound()) {
  if (other_value.vehicleIdentification().ispresent()) single_value->field_vehicleIdentification = other_value.vehicleIdentification()();
  else single_value->field_vehicleIdentification = OMIT_VALUE;
} else {
  single_value->field_vehicleIdentification.clean_up();
}
if (other_value.energyStorageType().is_bound()) {
  if (other_value.energyStorageType().ispresent()) single_value->field_energyStorageType = other_value.energyStorageType()();
  else single_value->field_energyStorageType = OMIT_VALUE;
} else {
  single_value->field_energyStorageType.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void StationaryVehicleContainer_template::copy_template(const StationaryVehicleContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.stationarySince().get_selection()) {
single_value->field_stationarySince = other_value.stationarySince();
} else {
single_value->field_stationarySince.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.stationaryCause().get_selection()) {
single_value->field_stationaryCause = other_value.stationaryCause();
} else {
single_value->field_stationaryCause.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.carryingDangerousGoods().get_selection()) {
single_value->field_carryingDangerousGoods = other_value.carryingDangerousGoods();
} else {
single_value->field_carryingDangerousGoods.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.numberOfOccupants().get_selection()) {
single_value->field_numberOfOccupants = other_value.numberOfOccupants();
} else {
single_value->field_numberOfOccupants.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.vehicleIdentification().get_selection()) {
single_value->field_vehicleIdentification = other_value.vehicleIdentification();
} else {
single_value->field_vehicleIdentification.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.energyStorageType().get_selection()) {
single_value->field_energyStorageType = other_value.energyStorageType();
} else {
single_value->field_energyStorageType.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new StationaryVehicleContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
break;
}
set_selection(other_value);
}

StationaryVehicleContainer_template::StationaryVehicleContainer_template()
{
}

StationaryVehicleContainer_template::StationaryVehicleContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

StationaryVehicleContainer_template::StationaryVehicleContainer_template(const StationaryVehicleContainer& other_value)
{
copy_value(other_value);
}

StationaryVehicleContainer_template::StationaryVehicleContainer_template(const OPTIONAL<StationaryVehicleContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const StationaryVehicleContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DENM-PDU-Descriptions.StationaryVehicleContainer from an unbound optional field.");
}
}

StationaryVehicleContainer_template::StationaryVehicleContainer_template(const StationaryVehicleContainer_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

StationaryVehicleContainer_template::~StationaryVehicleContainer_template()
{
clean_up();
}

StationaryVehicleContainer_template& StationaryVehicleContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

StationaryVehicleContainer_template& StationaryVehicleContainer_template::operator=(const StationaryVehicleContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

StationaryVehicleContainer_template& StationaryVehicleContainer_template::operator=(const OPTIONAL<StationaryVehicleContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const StationaryVehicleContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
}
return *this;
}

StationaryVehicleContainer_template& StationaryVehicleContainer_template::operator=(const StationaryVehicleContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean StationaryVehicleContainer_template::match(const StationaryVehicleContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.stationarySince().is_bound()) return FALSE;
if((other_value.stationarySince().ispresent() ? !single_value->field_stationarySince.match((const ITS__Container::StationarySince&)other_value.stationarySince(), legacy) : !single_value->field_stationarySince.match_omit(legacy)))return FALSE;
if(!other_value.stationaryCause().is_bound()) return FALSE;
if((other_value.stationaryCause().ispresent() ? !single_value->field_stationaryCause.match((const ITS__Container::CauseCode&)other_value.stationaryCause(), legacy) : !single_value->field_stationaryCause.match_omit(legacy)))return FALSE;
if(!other_value.carryingDangerousGoods().is_bound()) return FALSE;
if((other_value.carryingDangerousGoods().ispresent() ? !single_value->field_carryingDangerousGoods.match((const ITS__Container::DangerousGoodsExtended&)other_value.carryingDangerousGoods(), legacy) : !single_value->field_carryingDangerousGoods.match_omit(legacy)))return FALSE;
if(!other_value.numberOfOccupants().is_bound()) return FALSE;
if((other_value.numberOfOccupants().ispresent() ? !single_value->field_numberOfOccupants.match((const INTEGER&)other_value.numberOfOccupants(), legacy) : !single_value->field_numberOfOccupants.match_omit(legacy)))return FALSE;
if(!other_value.vehicleIdentification().is_bound()) return FALSE;
if((other_value.vehicleIdentification().ispresent() ? !single_value->field_vehicleIdentification.match((const ITS__Container::VehicleIdentification&)other_value.vehicleIdentification(), legacy) : !single_value->field_vehicleIdentification.match_omit(legacy)))return FALSE;
if(!other_value.energyStorageType().is_bound()) return FALSE;
if((other_value.energyStorageType().ispresent() ? !single_value->field_energyStorageType.match((const BITSTRING&)other_value.energyStorageType(), legacy) : !single_value->field_energyStorageType.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
}
return FALSE;
}

boolean StationaryVehicleContainer_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_stationarySince.is_omit() || single_value->field_stationarySince.is_bound()) return TRUE;
if (single_value->field_stationaryCause.is_omit() || single_value->field_stationaryCause.is_bound()) return TRUE;
if (single_value->field_carryingDangerousGoods.is_omit() || single_value->field_carryingDangerousGoods.is_bound()) return TRUE;
if (single_value->field_numberOfOccupants.is_omit() || single_value->field_numberOfOccupants.is_bound()) return TRUE;
if (single_value->field_vehicleIdentification.is_omit() || single_value->field_vehicleIdentification.is_bound()) return TRUE;
if (single_value->field_energyStorageType.is_omit() || single_value->field_energyStorageType.is_bound()) return TRUE;
return FALSE;
}

boolean StationaryVehicleContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_stationarySince.is_omit() && !single_value->field_stationarySince.is_value()) return FALSE;
if (!single_value->field_stationaryCause.is_omit() && !single_value->field_stationaryCause.is_value()) return FALSE;
if (!single_value->field_carryingDangerousGoods.is_omit() && !single_value->field_carryingDangerousGoods.is_value()) return FALSE;
if (!single_value->field_numberOfOccupants.is_omit() && !single_value->field_numberOfOccupants.is_value()) return FALSE;
if (!single_value->field_vehicleIdentification.is_omit() && !single_value->field_vehicleIdentification.is_value()) return FALSE;
if (!single_value->field_energyStorageType.is_omit() && !single_value->field_energyStorageType.is_value()) return FALSE;
return TRUE;
}

void StationaryVehicleContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

StationaryVehicleContainer StationaryVehicleContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
StationaryVehicleContainer ret_val;
if (single_value->field_stationarySince.is_omit()) ret_val.stationarySince() = OMIT_VALUE;
else if (single_value->field_stationarySince.is_bound()) {
ret_val.stationarySince() = single_value->field_stationarySince.valueof();
}
if (single_value->field_stationaryCause.is_omit()) ret_val.stationaryCause() = OMIT_VALUE;
else if (single_value->field_stationaryCause.is_bound()) {
ret_val.stationaryCause() = single_value->field_stationaryCause.valueof();
}
if (single_value->field_carryingDangerousGoods.is_omit()) ret_val.carryingDangerousGoods() = OMIT_VALUE;
else if (single_value->field_carryingDangerousGoods.is_bound()) {
ret_val.carryingDangerousGoods() = single_value->field_carryingDangerousGoods.valueof();
}
if (single_value->field_numberOfOccupants.is_omit()) ret_val.numberOfOccupants() = OMIT_VALUE;
else if (single_value->field_numberOfOccupants.is_bound()) {
ret_val.numberOfOccupants() = single_value->field_numberOfOccupants.valueof();
}
if (single_value->field_vehicleIdentification.is_omit()) ret_val.vehicleIdentification() = OMIT_VALUE;
else if (single_value->field_vehicleIdentification.is_bound()) {
ret_val.vehicleIdentification() = single_value->field_vehicleIdentification.valueof();
}
if (single_value->field_energyStorageType.is_omit()) ret_val.energyStorageType() = OMIT_VALUE;
else if (single_value->field_energyStorageType.is_bound()) {
ret_val.energyStorageType() = single_value->field_energyStorageType.valueof();
}
return ret_val;
}

void StationaryVehicleContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new StationaryVehicleContainer_template[list_length];
}

StationaryVehicleContainer_template& StationaryVehicleContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
return value_list.list_value[list_index];
}

ITS__Container::StationarySince_template& StationaryVehicleContainer_template::stationarySince()
{
set_specific();
return single_value->field_stationarySince;
}

const ITS__Container::StationarySince_template& StationaryVehicleContainer_template::stationarySince() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stationarySince of a non-specific template of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
return single_value->field_stationarySince;
}

ITS__Container::CauseCode_template& StationaryVehicleContainer_template::stationaryCause()
{
set_specific();
return single_value->field_stationaryCause;
}

const ITS__Container::CauseCode_template& StationaryVehicleContainer_template::stationaryCause() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stationaryCause of a non-specific template of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
return single_value->field_stationaryCause;
}

ITS__Container::DangerousGoodsExtended_template& StationaryVehicleContainer_template::carryingDangerousGoods()
{
set_specific();
return single_value->field_carryingDangerousGoods;
}

const ITS__Container::DangerousGoodsExtended_template& StationaryVehicleContainer_template::carryingDangerousGoods() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field carryingDangerousGoods of a non-specific template of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
return single_value->field_carryingDangerousGoods;
}

INTEGER_template& StationaryVehicleContainer_template::numberOfOccupants()
{
set_specific();
return single_value->field_numberOfOccupants;
}

const INTEGER_template& StationaryVehicleContainer_template::numberOfOccupants() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field numberOfOccupants of a non-specific template of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
return single_value->field_numberOfOccupants;
}

ITS__Container::VehicleIdentification_template& StationaryVehicleContainer_template::vehicleIdentification()
{
set_specific();
return single_value->field_vehicleIdentification;
}

const ITS__Container::VehicleIdentification_template& StationaryVehicleContainer_template::vehicleIdentification() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field vehicleIdentification of a non-specific template of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
return single_value->field_vehicleIdentification;
}

BITSTRING_template& StationaryVehicleContainer_template::energyStorageType()
{
set_specific();
return single_value->field_energyStorageType;
}

const BITSTRING_template& StationaryVehicleContainer_template::energyStorageType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field energyStorageType of a non-specific template of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
return single_value->field_energyStorageType;
}

int StationaryVehicleContainer_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.StationaryVehicleContainer which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 0;
      if (single_value->field_stationarySince.is_present()) ret_val++;
      if (single_value->field_stationaryCause.is_present()) ret_val++;
      if (single_value->field_carryingDangerousGoods.is_present()) ret_val++;
      if (single_value->field_numberOfOccupants.is_present()) ret_val++;
      if (single_value->field_vehicleIdentification.is_present()) ret_val++;
      if (single_value->field_energyStorageType.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.StationaryVehicleContainer containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.StationaryVehicleContainer containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.StationaryVehicleContainer containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.StationaryVehicleContainer containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.StationaryVehicleContainer containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
  }
  return 0;
}

void StationaryVehicleContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ stationarySince := ");
single_value->field_stationarySince.log();
TTCN_Logger::log_event_str(", stationaryCause := ");
single_value->field_stationaryCause.log();
TTCN_Logger::log_event_str(", carryingDangerousGoods := ");
single_value->field_carryingDangerousGoods.log();
TTCN_Logger::log_event_str(", numberOfOccupants := ");
single_value->field_numberOfOccupants.log();
TTCN_Logger::log_event_str(", vehicleIdentification := ");
single_value->field_vehicleIdentification.log();
TTCN_Logger::log_event_str(", energyStorageType := ");
single_value->field_energyStorageType.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void StationaryVehicleContainer_template::log_match(const StationaryVehicleContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.stationarySince().ispresent()){
if(!single_value->field_stationarySince.match(match_value.stationarySince(), legacy)){
TTCN_Logger::log_logmatch_info(".stationarySince");
single_value->field_stationarySince.log_match(match_value.stationarySince(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_stationarySince.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".stationarySince := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_stationarySince.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.stationaryCause().ispresent()){
if(!single_value->field_stationaryCause.match(match_value.stationaryCause(), legacy)){
TTCN_Logger::log_logmatch_info(".stationaryCause");
single_value->field_stationaryCause.log_match(match_value.stationaryCause(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_stationaryCause.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".stationaryCause := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_stationaryCause.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.carryingDangerousGoods().ispresent()){
if(!single_value->field_carryingDangerousGoods.match(match_value.carryingDangerousGoods(), legacy)){
TTCN_Logger::log_logmatch_info(".carryingDangerousGoods");
single_value->field_carryingDangerousGoods.log_match(match_value.carryingDangerousGoods(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_carryingDangerousGoods.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".carryingDangerousGoods := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_carryingDangerousGoods.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.numberOfOccupants().ispresent()){
if(!single_value->field_numberOfOccupants.match(match_value.numberOfOccupants(), legacy)){
TTCN_Logger::log_logmatch_info(".numberOfOccupants");
single_value->field_numberOfOccupants.log_match(match_value.numberOfOccupants(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_numberOfOccupants.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".numberOfOccupants := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_numberOfOccupants.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.vehicleIdentification().ispresent()){
if(!single_value->field_vehicleIdentification.match(match_value.vehicleIdentification(), legacy)){
TTCN_Logger::log_logmatch_info(".vehicleIdentification");
single_value->field_vehicleIdentification.log_match(match_value.vehicleIdentification(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_vehicleIdentification.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".vehicleIdentification := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_vehicleIdentification.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.energyStorageType().ispresent()){
if(!single_value->field_energyStorageType.match(match_value.energyStorageType(), legacy)){
TTCN_Logger::log_logmatch_info(".energyStorageType");
single_value->field_energyStorageType.log_match(match_value.energyStorageType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_energyStorageType.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".energyStorageType := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_energyStorageType.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ stationarySince := ");
if (match_value.stationarySince().ispresent()) single_value->field_stationarySince.log_match(match_value.stationarySince(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_stationarySince.log();
if (single_value->field_stationarySince.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", stationaryCause := ");
if (match_value.stationaryCause().ispresent()) single_value->field_stationaryCause.log_match(match_value.stationaryCause(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_stationaryCause.log();
if (single_value->field_stationaryCause.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", carryingDangerousGoods := ");
if (match_value.carryingDangerousGoods().ispresent()) single_value->field_carryingDangerousGoods.log_match(match_value.carryingDangerousGoods(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_carryingDangerousGoods.log();
if (single_value->field_carryingDangerousGoods.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", numberOfOccupants := ");
if (match_value.numberOfOccupants().ispresent()) single_value->field_numberOfOccupants.log_match(match_value.numberOfOccupants(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_numberOfOccupants.log();
if (single_value->field_numberOfOccupants.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", vehicleIdentification := ");
if (match_value.vehicleIdentification().ispresent()) single_value->field_vehicleIdentification.log_match(match_value.vehicleIdentification(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_vehicleIdentification.log();
if (single_value->field_vehicleIdentification.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", energyStorageType := ");
if (match_value.energyStorageType().ispresent()) single_value->field_energyStorageType.log_match(match_value.energyStorageType(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_energyStorageType.log();
if (single_value->field_energyStorageType.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void StationaryVehicleContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_stationarySince.encode_text(text_buf);
single_value->field_stationaryCause.encode_text(text_buf);
single_value->field_carryingDangerousGoods.encode_text(text_buf);
single_value->field_numberOfOccupants.encode_text(text_buf);
single_value->field_vehicleIdentification.encode_text(text_buf);
single_value->field_energyStorageType.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
}
}

void StationaryVehicleContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_stationarySince.decode_text(text_buf);
single_value->field_stationaryCause.decode_text(text_buf);
single_value->field_carryingDangerousGoods.decode_text(text_buf);
single_value->field_numberOfOccupants.decode_text(text_buf);
single_value->field_vehicleIdentification.decode_text(text_buf);
single_value->field_energyStorageType.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new StationaryVehicleContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DENM-PDU-Descriptions.StationaryVehicleContainer.");
}
}

void StationaryVehicleContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DENM-PDU-Descriptions.StationaryVehicleContainer'");
    }
    if (strcmp("stationarySince", param_field) == 0) {
      stationarySince().set_param(param);
      return;
    } else if (strcmp("stationaryCause", param_field) == 0) {
      stationaryCause().set_param(param);
      return;
    } else if (strcmp("carryingDangerousGoods", param_field) == 0) {
      carryingDangerousGoods().set_param(param);
      return;
    } else if (strcmp("numberOfOccupants", param_field) == 0) {
      numberOfOccupants().set_param(param);
      return;
    } else if (strcmp("vehicleIdentification", param_field) == 0) {
      vehicleIdentification().set_param(param);
      return;
    } else if (strcmp("energyStorageType", param_field) == 0) {
      energyStorageType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DENM-PDU-Descriptions.StationaryVehicleContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    StationaryVehicleContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record template of type @DENM-PDU-Descriptions.StationaryVehicleContainer has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) stationarySince().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) stationaryCause().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) carryingDangerousGoods().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) numberOfOccupants().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) vehicleIdentification().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) energyStorageType().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationarySince")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationarySince().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationaryCause")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationaryCause().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "carryingDangerousGoods")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          carryingDangerousGoods().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "numberOfOccupants")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          numberOfOccupants().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vehicleIdentification")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vehicleIdentification().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "energyStorageType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          energyStorageType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.StationaryVehicleContainer: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DENM-PDU-Descriptions.StationaryVehicleContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* StationaryVehicleContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DENM-PDU-Descriptions.StationaryVehicleContainer'");
    }
    if (strcmp("stationarySince", param_field) == 0) {
      return stationarySince().get_param(param_name);
    } else if (strcmp("stationaryCause", param_field) == 0) {
      return stationaryCause().get_param(param_name);
    } else if (strcmp("carryingDangerousGoods", param_field) == 0) {
      return carryingDangerousGoods().get_param(param_name);
    } else if (strcmp("numberOfOccupants", param_field) == 0) {
      return numberOfOccupants().get_param(param_name);
    } else if (strcmp("vehicleIdentification", param_field) == 0) {
      return vehicleIdentification().get_param(param_name);
    } else if (strcmp("energyStorageType", param_field) == 0) {
      return energyStorageType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.StationaryVehicleContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_stationarySince = single_value->field_stationarySince.get_param(param_name);
    mp_field_stationarySince->set_id(new Module_Param_FieldName(mcopystr("stationarySince")));
    mp->add_elem(mp_field_stationarySince);
    Module_Param* mp_field_stationaryCause = single_value->field_stationaryCause.get_param(param_name);
    mp_field_stationaryCause->set_id(new Module_Param_FieldName(mcopystr("stationaryCause")));
    mp->add_elem(mp_field_stationaryCause);
    Module_Param* mp_field_carryingDangerousGoods = single_value->field_carryingDangerousGoods.get_param(param_name);
    mp_field_carryingDangerousGoods->set_id(new Module_Param_FieldName(mcopystr("carryingDangerousGoods")));
    mp->add_elem(mp_field_carryingDangerousGoods);
    Module_Param* mp_field_numberOfOccupants = single_value->field_numberOfOccupants.get_param(param_name);
    mp_field_numberOfOccupants->set_id(new Module_Param_FieldName(mcopystr("numberOfOccupants")));
    mp->add_elem(mp_field_numberOfOccupants);
    Module_Param* mp_field_vehicleIdentification = single_value->field_vehicleIdentification.get_param(param_name);
    mp_field_vehicleIdentification->set_id(new Module_Param_FieldName(mcopystr("vehicleIdentification")));
    mp->add_elem(mp_field_vehicleIdentification);
    Module_Param* mp_field_energyStorageType = single_value->field_energyStorageType.get_param(param_name);
    mp_field_energyStorageType->set_id(new Module_Param_FieldName(mcopystr("energyStorageType")));
    mp->add_elem(mp_field_energyStorageType);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void StationaryVehicleContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_stationarySince.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.StationaryVehicleContainer");
single_value->field_stationaryCause.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.StationaryVehicleContainer");
single_value->field_carryingDangerousGoods.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.StationaryVehicleContainer");
single_value->field_numberOfOccupants.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.StationaryVehicleContainer");
single_value->field_vehicleIdentification.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.StationaryVehicleContainer");
single_value->field_energyStorageType.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.StationaryVehicleContainer");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DENM-PDU-Descriptions.StationaryVehicleContainer");
}

boolean StationaryVehicleContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean StationaryVehicleContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

DENM::DENM()
{
  bound_flag = FALSE;
}

DENM::DENM(const ITS__Container::ItsPduHeader& par_header,
    const DecentralizedEnvironmentalNotificationMessage& par_denm)
  :   field_header(par_header),
  field_denm(par_denm)
{
  bound_flag = TRUE;
}

DENM::DENM(const DENM& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @DENM-PDU-Descriptions.DENM.");
bound_flag = TRUE;
if (other_value.header().is_bound()) field_header = other_value.header();
else field_header.clean_up();
if (other_value.denm().is_bound()) field_denm = other_value.denm();
else field_denm.clean_up();
}

void DENM::clean_up()
{
field_header.clean_up();
field_denm.clean_up();
bound_flag = FALSE;
}

DENM& DENM::operator=(const DENM& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @DENM-PDU-Descriptions.DENM.");
  bound_flag = TRUE;
  if (other_value.header().is_bound()) field_header = other_value.header();
  else field_header.clean_up();
  if (other_value.denm().is_bound()) field_denm = other_value.denm();
  else field_denm.clean_up();
}
return *this;
}

boolean DENM::operator==(const DENM& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_header==other_value.field_header
  && field_denm==other_value.field_denm;
}

boolean DENM::is_bound() const
{
if (bound_flag) return TRUE;
if(field_header.is_bound()) return TRUE;
if(field_denm.is_bound()) return TRUE;
return FALSE;
}
boolean DENM::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_header.is_value()) return FALSE;
if(!field_denm.is_value()) return FALSE;
return TRUE;
}
int DENM::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @DENM-PDU-Descriptions.DENM");
  return 2;
}

void DENM::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ header := ");
field_header.log();
TTCN_Logger::log_event_str(", denm := ");
field_denm.log();
TTCN_Logger::log_event_str(" }");
}

void DENM::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@DENM-PDU-Descriptions.DENM'");
    }
    if (strcmp("header", param_field) == 0) {
      header().set_param(param);
      return;
    } else if (strcmp("denm", param_field) == 0) {
      denm().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@DENM-PDU-Descriptions.DENM'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @DENM-PDU-Descriptions.DENM has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) denm().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "denm")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          denm().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.DENM: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@DENM-PDU-Descriptions.DENM");
  }
}

Module_Param* DENM::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@DENM-PDU-Descriptions.DENM'");
    }
    if (strcmp("header", param_field) == 0) {
      return header().get_param(param_name);
    } else if (strcmp("denm", param_field) == 0) {
      return denm().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.DENM'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_header = field_header.get_param(param_name);
  mp_field_header->set_id(new Module_Param_FieldName(mcopystr("header")));
  mp->add_elem(mp_field_header);
  Module_Param* mp_field_denm = field_denm.get_param(param_name);
  mp_field_denm->set_id(new Module_Param_FieldName(mcopystr("denm")));
  mp->add_elem(mp_field_denm);
  return mp;
  }

void DENM::set_implicit_omit()
{
if (header().is_bound()) header().set_implicit_omit();
if (denm().is_bound()) denm().set_implicit_omit();
}

void DENM::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @DENM-PDU-Descriptions.DENM.");
field_header.encode_text(text_buf);
field_denm.encode_text(text_buf);
}

void DENM::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_header.decode_text(text_buf);
field_denm.decode_text(text_buf);
}

void DENM::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void DENM::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

ASN_BER_TLV_t* DENM::BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const
{
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  BER_chk_descr(p_td);
  ASN_BER_TLV_t *new_tlv=ASN_BER_TLV_t::construct(NULL);
  TTCN_EncDec_ErrorContext ec_0("Component '");
  TTCN_EncDec_ErrorContext ec_1;
  ec_1.set_msg("header': ");
  new_tlv->add_TLV(field_header.BER_encode_TLV(DENM_header_descr_, p_coding));
  ec_1.set_msg("denm': ");
  new_tlv->add_TLV(field_denm.BER_encode_TLV(DENM_denm_descr_, p_coding));
  new_tlv=ASN_BER_V2TLV(new_tlv, p_td, p_coding);
  return new_tlv;
}

boolean DENM::BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form)
{
  bound_flag = TRUE;
  BER_chk_descr(p_td);
  ASN_BER_TLV_t stripped_tlv;
  BER_decode_strip_tags(*p_td.ber, p_tlv, L_form, stripped_tlv);
  TTCN_EncDec_ErrorContext ec_0("While decoding '@DENM-PDU-Descriptions.DENM' type: ");
  stripped_tlv.chk_constructed_flag(TRUE);
  size_t V_pos=0;
  ASN_BER_TLV_t tmp_tlv;
  boolean tlv_present=FALSE;
  {
    TTCN_EncDec_ErrorContext ec_1("Component '");
    TTCN_EncDec_ErrorContext ec_2;
    ec_2.set_msg("header': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_header.BER_decode_TLV(DENM_header_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
    ec_2.set_msg("denm': ");
    if(!tlv_present) tlv_present=BER_decode_constdTLV_next(stripped_tlv, V_pos, L_form, tmp_tlv);
    if(!tlv_present){
      ec_2.error(TTCN_EncDec::ET_INCOMPL_MSG,"Invalid or incomplete message was received.");
      return FALSE;
    }
    field_denm.BER_decode_TLV(DENM_denm_descr_, tmp_tlv, L_form);
    tlv_present=FALSE;
  }
  BER_decode_constdTLV_end(stripped_tlv, V_pos, L_form, tmp_tlv, tlv_present);
  return TRUE;
}

int DENM::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @DENM-PDU-Descriptions.DENM.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "header");
    enc_len += field_header.JSON_encode(DENM_header_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "denm");
    enc_len += field_denm.JSON_encode(DENM_denm_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int DENM::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (6 == name_len && 0 == strncmp(fld_name, "header", name_len)) {
         int ret_val = field_header.JSON_decode(DENM_header_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "header");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (4 == name_len && 0 == strncmp(fld_name, "denm", name_len)) {
         int ret_val = field_denm.JSON_decode(DENM_denm_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "denm");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_header.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "header");
    return JSON_ERROR_FATAL;
  }
if (!field_denm.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "denm");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct DENM_template::single_value_struct {
ITS__Container::ItsPduHeader_template field_header;
DecentralizedEnvironmentalNotificationMessage_template field_denm;
};

void DENM_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_header = ANY_VALUE;
single_value->field_denm = ANY_VALUE;
}
}
}

void DENM_template::copy_value(const DENM& other_value)
{
single_value = new single_value_struct;
if (other_value.header().is_bound()) {
  single_value->field_header = other_value.header();
} else {
  single_value->field_header.clean_up();
}
if (other_value.denm().is_bound()) {
  single_value->field_denm = other_value.denm();
} else {
  single_value->field_denm.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void DENM_template::copy_template(const DENM_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.header().get_selection()) {
single_value->field_header = other_value.header();
} else {
single_value->field_header.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.denm().get_selection()) {
single_value->field_denm = other_value.denm();
} else {
single_value->field_denm.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new DENM_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @DENM-PDU-Descriptions.DENM.");
break;
}
set_selection(other_value);
}

DENM_template::DENM_template()
{
}

DENM_template::DENM_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

DENM_template::DENM_template(const DENM& other_value)
{
copy_value(other_value);
}

DENM_template::DENM_template(const OPTIONAL<DENM>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DENM&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @DENM-PDU-Descriptions.DENM from an unbound optional field.");
}
}

DENM_template::DENM_template(const DENM_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

DENM_template::~DENM_template()
{
clean_up();
}

DENM_template& DENM_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

DENM_template& DENM_template::operator=(const DENM& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

DENM_template& DENM_template::operator=(const OPTIONAL<DENM>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DENM&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @DENM-PDU-Descriptions.DENM.");
}
return *this;
}

DENM_template& DENM_template::operator=(const DENM_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean DENM_template::match(const DENM& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.header().is_bound()) return FALSE;
if(!single_value->field_header.match(other_value.header(), legacy))return FALSE;
if(!other_value.denm().is_bound()) return FALSE;
if(!single_value->field_denm.match(other_value.denm(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @DENM-PDU-Descriptions.DENM.");
}
return FALSE;
}

boolean DENM_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_header.is_bound()) return TRUE;
if (single_value->field_denm.is_bound()) return TRUE;
return FALSE;
}

boolean DENM_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_header.is_value()) return FALSE;
if (!single_value->field_denm.is_value()) return FALSE;
return TRUE;
}

void DENM_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

DENM DENM_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @DENM-PDU-Descriptions.DENM.");
DENM ret_val;
if (single_value->field_header.is_bound()) {
ret_val.header() = single_value->field_header.valueof();
}
if (single_value->field_denm.is_bound()) {
ret_val.denm() = single_value->field_denm.valueof();
}
return ret_val;
}

void DENM_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @DENM-PDU-Descriptions.DENM.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new DENM_template[list_length];
}

DENM_template& DENM_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @DENM-PDU-Descriptions.DENM.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @DENM-PDU-Descriptions.DENM.");
return value_list.list_value[list_index];
}

ITS__Container::ItsPduHeader_template& DENM_template::header()
{
set_specific();
return single_value->field_header;
}

const ITS__Container::ItsPduHeader_template& DENM_template::header() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header of a non-specific template of type @DENM-PDU-Descriptions.DENM.");
return single_value->field_header;
}

DecentralizedEnvironmentalNotificationMessage_template& DENM_template::denm()
{
set_specific();
return single_value->field_denm;
}

const DecentralizedEnvironmentalNotificationMessage_template& DENM_template::denm() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field denm of a non-specific template of type @DENM-PDU-Descriptions.DENM.");
return single_value->field_denm;
}

int DENM_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.DENM which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.DENM containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.DENM containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.DENM containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.DENM containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @DENM-PDU-Descriptions.DENM containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @DENM-PDU-Descriptions.DENM.");
  }
  return 0;
}

void DENM_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log();
TTCN_Logger::log_event_str(", denm := ");
single_value->field_denm.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void DENM_template::log_match(const DENM& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_header.match(match_value.header(), legacy)){
TTCN_Logger::log_logmatch_info(".header");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_denm.match(match_value.denm(), legacy)){
TTCN_Logger::log_logmatch_info(".denm");
single_value->field_denm.log_match(match_value.denm(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ header := ");
single_value->field_header.log_match(match_value.header(), legacy);
TTCN_Logger::log_event_str(", denm := ");
single_value->field_denm.log_match(match_value.denm(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void DENM_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_header.encode_text(text_buf);
single_value->field_denm.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @DENM-PDU-Descriptions.DENM.");
}
}

void DENM_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_header.decode_text(text_buf);
single_value->field_denm.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new DENM_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @DENM-PDU-Descriptions.DENM.");
}
}

void DENM_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@DENM-PDU-Descriptions.DENM'");
    }
    if (strcmp("header", param_field) == 0) {
      header().set_param(param);
      return;
    } else if (strcmp("denm", param_field) == 0) {
      denm().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@DENM-PDU-Descriptions.DENM'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    DENM_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @DENM-PDU-Descriptions.DENM has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) header().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) denm().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "denm")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          denm().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @DENM-PDU-Descriptions.DENM: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@DENM-PDU-Descriptions.DENM");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* DENM_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@DENM-PDU-Descriptions.DENM'");
    }
    if (strcmp("header", param_field) == 0) {
      return header().get_param(param_name);
    } else if (strcmp("denm", param_field) == 0) {
      return denm().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@DENM-PDU-Descriptions.DENM'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_header = single_value->field_header.get_param(param_name);
    mp_field_header->set_id(new Module_Param_FieldName(mcopystr("header")));
    mp->add_elem(mp_field_header);
    Module_Param* mp_field_denm = single_value->field_denm.get_param(param_name);
    mp_field_denm->set_id(new Module_Param_FieldName(mcopystr("denm")));
    mp->add_elem(mp_field_denm);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void DENM_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_header.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.DENM");
single_value->field_denm.check_restriction(t_res, t_name ? t_name : "@DENM-PDU-Descriptions.DENM");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@DENM-PDU-Descriptions.DENM");
}

boolean DENM_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean DENM_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


/* Bodies of functions, altsteps and testcases */

boolean operator==(null_type, const ReferenceDenms& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @DENM-PDU-Descriptions.ReferenceDenms.");
return other_value.val_ptr->n_elements == 0;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("DENM.asn", 0, TTCN_Location::LOCATION_UNKNOWN, "DENM-PDU-Descriptions");
ITS__Container::module_object.pre_init_module();
const_ManagementContainer_validityDuration_defval_ = 600;
const_defaultValidity = 600;
}


} /* end of namespace */
