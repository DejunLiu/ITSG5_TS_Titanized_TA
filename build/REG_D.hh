// This C++ header file was generated by the ASN.1 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef REG__D_HH
#define REG__D_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "DSRC2.hh"

#if TTCN3_VERSION != 50400
#error Version mismatch detected.\
 Please check the version of the ASN.1 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef REG__D_HH
#endif

namespace REG__D {

/* Forward declarations of classes */

class EmissionType;
class EmissionType_template;
class PrioritizationResponse;
class PrioritizationResponse_template;
class PrioritizationResponseList;
class PrioritizationResponseList_template;
class VehicleToLanePositionList;
class VehicleToLanePositionList_template;
class VehicleToLanePosition;
class VehicleToLanePosition_template;
class Reg__ConnectionManeuverAssist;
class Reg__ConnectionManeuverAssist_template;
class Reg__IntersectionState;
class Reg__IntersectionState_template;
class Reg__MapData;
class Reg__MapData_template;
class SignalHeadLocationList;
class SignalHeadLocationList_template;
class SignalHeadLocation;
class SignalHeadLocation_template;
class Reg__Position3D;
class Reg__Position3D_template;
class Reg__RestrictionUserType;
class Reg__RestrictionUserType_template;

} /* end of namespace */

#ifndef REG__D_HH
#define REG__D_HH

namespace REG__D {

/* Class definitions */

class EmissionType : public Base_Type { // enum
friend class EmissionType_template;
public:
enum enum_type { typeA = 0, typeB = 1, typeC = 2, typeD = 3, typeE = 4, UNKNOWN_VALUE = 5, UNBOUND_VALUE = 6 };
private:
enum_type enum_value;

public:
EmissionType();
EmissionType(int other_value);
EmissionType(enum_type other_value);
EmissionType(const EmissionType& other_value);

EmissionType& operator=(int other_value);
EmissionType& operator=(enum_type other_value);
EmissionType& operator=(const EmissionType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const EmissionType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const EmissionType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const EmissionType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const EmissionType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const EmissionType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const EmissionType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const EmissionType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class EmissionType_template : public Base_Template {
union {
EmissionType::enum_type single_value;
struct {
unsigned int n_values;
EmissionType_template *list_value;
} value_list;
};

void copy_template(const EmissionType_template& other_value);

public:
EmissionType_template();
EmissionType_template(template_sel other_value);
EmissionType_template(int other_value);
EmissionType_template(EmissionType::enum_type other_value);
EmissionType_template(const EmissionType& other_value);
EmissionType_template(const OPTIONAL<EmissionType>& other_value);
EmissionType_template(const EmissionType_template& other_value);
~EmissionType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
EmissionType_template& operator=(template_sel other_value);
EmissionType_template& operator=(int other_value);
EmissionType_template& operator=(EmissionType::enum_type other_value);
EmissionType_template& operator=(const EmissionType& other_value);
EmissionType_template& operator=(const OPTIONAL<EmissionType>& other_value);
EmissionType_template& operator=(const EmissionType_template& other_value);

boolean match(EmissionType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const EmissionType& other_value, boolean legacy = FALSE) const;
EmissionType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EmissionType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const EmissionType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class PrioritizationResponse : public Base_Type {
  INTEGER field_stationID;
  DSRC2::PrioritizationResponseStatus field_priorState;
  INTEGER field_signalGroup;
  boolean bound_flag;
public:
  PrioritizationResponse();
  PrioritizationResponse(const INTEGER& par_stationID,
    const DSRC2::PrioritizationResponseStatus& par_priorState,
    const INTEGER& par_signalGroup);
  PrioritizationResponse(const PrioritizationResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  PrioritizationResponse& operator=(const PrioritizationResponse& other_value);
  boolean operator==(const PrioritizationResponse& other_value) const;
  inline boolean operator!=(const PrioritizationResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& stationID()
    {return field_stationID;}
  inline const INTEGER& stationID() const
    {return field_stationID;}
  inline DSRC2::PrioritizationResponseStatus& priorState()
    {return field_priorState;}
  inline const DSRC2::PrioritizationResponseStatus& priorState() const
    {return field_priorState;}
  inline INTEGER& signalGroup()
    {return field_signalGroup;}
  inline const INTEGER& signalGroup() const
    {return field_signalGroup;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PrioritizationResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
PrioritizationResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const PrioritizationResponse& other_value);
void copy_template(const PrioritizationResponse_template& other_value);

public:
PrioritizationResponse_template();
PrioritizationResponse_template(template_sel other_value);
PrioritizationResponse_template(const PrioritizationResponse& other_value);
PrioritizationResponse_template(const OPTIONAL<PrioritizationResponse>& other_value);
PrioritizationResponse_template(const PrioritizationResponse_template& other_value);
~PrioritizationResponse_template();
PrioritizationResponse_template& operator=(template_sel other_value);
PrioritizationResponse_template& operator=(const PrioritizationResponse& other_value);
PrioritizationResponse_template& operator=(const OPTIONAL<PrioritizationResponse>& other_value);
PrioritizationResponse_template& operator=(const PrioritizationResponse_template& other_value);
boolean match(const PrioritizationResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
PrioritizationResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PrioritizationResponse_template& list_item(unsigned int list_index) const;
INTEGER_template& stationID();
const INTEGER_template& stationID() const;
DSRC2::PrioritizationResponseStatus_template& priorState();
const DSRC2::PrioritizationResponseStatus_template& priorState() const;
INTEGER_template& signalGroup();
const INTEGER_template& signalGroup() const;
int size_of() const;
void log() const;
void log_match(const PrioritizationResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class PrioritizationResponseList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
PrioritizationResponse **value_elements;
} *val_ptr;

static const PrioritizationResponse UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PrioritizationResponseList& other_value);

public:
  typedef PrioritizationResponse of_type;
PrioritizationResponseList();
PrioritizationResponseList(null_type other_value);
PrioritizationResponseList(const PrioritizationResponseList& other_value);
~PrioritizationResponseList();

void clean_up();
PrioritizationResponseList& operator=(null_type other_value);
PrioritizationResponseList& operator=(const PrioritizationResponseList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PrioritizationResponseList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PrioritizationResponseList& other_value) const { return !(*this == other_value); }

PrioritizationResponse& operator[](int index_value);
PrioritizationResponse& operator[](const INTEGER& index_value);
const PrioritizationResponse& operator[](int index_value) const;
const PrioritizationResponse& operator[](const INTEGER& index_value) const;

PrioritizationResponseList operator<<=(int rotate_count) const;
PrioritizationResponseList operator<<=(const INTEGER& rotate_count) const;
PrioritizationResponseList operator>>=(int rotate_count) const;
PrioritizationResponseList operator>>=(const INTEGER& rotate_count) const;

PrioritizationResponseList operator+(const PrioritizationResponseList& other_value) const;

PrioritizationResponseList substr(int index, int returncount) const;

PrioritizationResponseList replace(int index, int len, const PrioritizationResponseList& repl) const;

PrioritizationResponseList replace(int index, int len, const PrioritizationResponseList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PrioritizationResponseList_template : public Record_Of_Template {
union {
struct {
int n_elements;
PrioritizationResponse_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PrioritizationResponseList_template *list_value;
} value_list;
};
void copy_value(const PrioritizationResponseList& other_value);
void copy_template(const PrioritizationResponseList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
PrioritizationResponseList_template();
PrioritizationResponseList_template(template_sel other_value);
PrioritizationResponseList_template(null_type other_value);
PrioritizationResponseList_template(const PrioritizationResponseList& other_value);
PrioritizationResponseList_template(const OPTIONAL<PrioritizationResponseList>& other_value);
PrioritizationResponseList_template(const PrioritizationResponseList_template& other_value);
~PrioritizationResponseList_template();

void clean_up();
PrioritizationResponseList_template& operator=(template_sel other_value);
PrioritizationResponseList_template& operator=(null_type other_value);
PrioritizationResponseList_template& operator=(const PrioritizationResponseList& other_value);
PrioritizationResponseList_template& operator=(const OPTIONAL<PrioritizationResponseList>& other_value);
PrioritizationResponseList_template& operator=(const PrioritizationResponseList_template& other_value);

PrioritizationResponse_template& operator[](int index_value);
PrioritizationResponse_template& operator[](const INTEGER& index_value);
const PrioritizationResponse_template& operator[](int index_value) const;
const PrioritizationResponse_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PrioritizationResponseList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PrioritizationResponseList valueof() const;
PrioritizationResponseList substr(int index, int returncount) const;

PrioritizationResponseList replace(int index, int len, const PrioritizationResponseList_template& repl) const;

PrioritizationResponseList replace(int index, int len, const PrioritizationResponseList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PrioritizationResponseList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PrioritizationResponseList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class VehicleToLanePositionList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
VehicleToLanePosition **value_elements;
} *val_ptr;

static const VehicleToLanePosition UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const VehicleToLanePositionList& other_value);

public:
  typedef VehicleToLanePosition of_type;
VehicleToLanePositionList();
VehicleToLanePositionList(null_type other_value);
VehicleToLanePositionList(const VehicleToLanePositionList& other_value);
~VehicleToLanePositionList();

void clean_up();
VehicleToLanePositionList& operator=(null_type other_value);
VehicleToLanePositionList& operator=(const VehicleToLanePositionList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const VehicleToLanePositionList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const VehicleToLanePositionList& other_value) const { return !(*this == other_value); }

VehicleToLanePosition& operator[](int index_value);
VehicleToLanePosition& operator[](const INTEGER& index_value);
const VehicleToLanePosition& operator[](int index_value) const;
const VehicleToLanePosition& operator[](const INTEGER& index_value) const;

VehicleToLanePositionList operator<<=(int rotate_count) const;
VehicleToLanePositionList operator<<=(const INTEGER& rotate_count) const;
VehicleToLanePositionList operator>>=(int rotate_count) const;
VehicleToLanePositionList operator>>=(const INTEGER& rotate_count) const;

VehicleToLanePositionList operator+(const VehicleToLanePositionList& other_value) const;

VehicleToLanePositionList substr(int index, int returncount) const;

VehicleToLanePositionList replace(int index, int len, const VehicleToLanePositionList& repl) const;

VehicleToLanePositionList replace(int index, int len, const VehicleToLanePositionList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class VehicleToLanePositionList_template : public Record_Of_Template {
union {
struct {
int n_elements;
VehicleToLanePosition_template **value_elements;
} single_value;
struct {
unsigned int n_values;
VehicleToLanePositionList_template *list_value;
} value_list;
};
void copy_value(const VehicleToLanePositionList& other_value);
void copy_template(const VehicleToLanePositionList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
VehicleToLanePositionList_template();
VehicleToLanePositionList_template(template_sel other_value);
VehicleToLanePositionList_template(null_type other_value);
VehicleToLanePositionList_template(const VehicleToLanePositionList& other_value);
VehicleToLanePositionList_template(const OPTIONAL<VehicleToLanePositionList>& other_value);
VehicleToLanePositionList_template(const VehicleToLanePositionList_template& other_value);
~VehicleToLanePositionList_template();

void clean_up();
VehicleToLanePositionList_template& operator=(template_sel other_value);
VehicleToLanePositionList_template& operator=(null_type other_value);
VehicleToLanePositionList_template& operator=(const VehicleToLanePositionList& other_value);
VehicleToLanePositionList_template& operator=(const OPTIONAL<VehicleToLanePositionList>& other_value);
VehicleToLanePositionList_template& operator=(const VehicleToLanePositionList_template& other_value);

VehicleToLanePosition_template& operator[](int index_value);
VehicleToLanePosition_template& operator[](const INTEGER& index_value);
const VehicleToLanePosition_template& operator[](int index_value) const;
const VehicleToLanePosition_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const VehicleToLanePositionList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
VehicleToLanePositionList valueof() const;
VehicleToLanePositionList substr(int index, int returncount) const;

VehicleToLanePositionList replace(int index, int len, const VehicleToLanePositionList_template& repl) const;

VehicleToLanePositionList replace(int index, int len, const VehicleToLanePositionList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
VehicleToLanePositionList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const VehicleToLanePositionList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class VehicleToLanePosition : public Base_Type {
  INTEGER field_stationID;
  INTEGER field_laneID;
  boolean bound_flag;
public:
  VehicleToLanePosition();
  VehicleToLanePosition(const INTEGER& par_stationID,
    const INTEGER& par_laneID);
  VehicleToLanePosition(const VehicleToLanePosition& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  VehicleToLanePosition& operator=(const VehicleToLanePosition& other_value);
  boolean operator==(const VehicleToLanePosition& other_value) const;
  inline boolean operator!=(const VehicleToLanePosition& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& stationID()
    {return field_stationID;}
  inline const INTEGER& stationID() const
    {return field_stationID;}
  inline INTEGER& laneID()
    {return field_laneID;}
  inline const INTEGER& laneID() const
    {return field_laneID;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class VehicleToLanePosition_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
VehicleToLanePosition_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const VehicleToLanePosition& other_value);
void copy_template(const VehicleToLanePosition_template& other_value);

public:
VehicleToLanePosition_template();
VehicleToLanePosition_template(template_sel other_value);
VehicleToLanePosition_template(const VehicleToLanePosition& other_value);
VehicleToLanePosition_template(const OPTIONAL<VehicleToLanePosition>& other_value);
VehicleToLanePosition_template(const VehicleToLanePosition_template& other_value);
~VehicleToLanePosition_template();
VehicleToLanePosition_template& operator=(template_sel other_value);
VehicleToLanePosition_template& operator=(const VehicleToLanePosition& other_value);
VehicleToLanePosition_template& operator=(const OPTIONAL<VehicleToLanePosition>& other_value);
VehicleToLanePosition_template& operator=(const VehicleToLanePosition_template& other_value);
boolean match(const VehicleToLanePosition& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
VehicleToLanePosition valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
VehicleToLanePosition_template& list_item(unsigned int list_index) const;
INTEGER_template& stationID();
const INTEGER_template& stationID() const;
INTEGER_template& laneID();
const INTEGER_template& laneID() const;
int size_of() const;
void log() const;
void log_match(const VehicleToLanePosition& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Reg__ConnectionManeuverAssist : public Base_Type {
  VehicleToLanePositionList field_vehicleToLanePositions;
  OPTIONAL<DSRC2::NodeOffsetPoint> field_rsuDistanceFromAnchor;
  boolean bound_flag;
public:
  Reg__ConnectionManeuverAssist();
  Reg__ConnectionManeuverAssist(const VehicleToLanePositionList& par_vehicleToLanePositions,
    const OPTIONAL<DSRC2::NodeOffsetPoint>& par_rsuDistanceFromAnchor);
  Reg__ConnectionManeuverAssist(const Reg__ConnectionManeuverAssist& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Reg__ConnectionManeuverAssist& operator=(const Reg__ConnectionManeuverAssist& other_value);
  boolean operator==(const Reg__ConnectionManeuverAssist& other_value) const;
  inline boolean operator!=(const Reg__ConnectionManeuverAssist& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline VehicleToLanePositionList& vehicleToLanePositions()
    {return field_vehicleToLanePositions;}
  inline const VehicleToLanePositionList& vehicleToLanePositions() const
    {return field_vehicleToLanePositions;}
  inline OPTIONAL<DSRC2::NodeOffsetPoint>& rsuDistanceFromAnchor()
    {return field_rsuDistanceFromAnchor;}
  inline const OPTIONAL<DSRC2::NodeOffsetPoint>& rsuDistanceFromAnchor() const
    {return field_rsuDistanceFromAnchor;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__ConnectionManeuverAssist_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Reg__ConnectionManeuverAssist_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Reg__ConnectionManeuverAssist& other_value);
void copy_template(const Reg__ConnectionManeuverAssist_template& other_value);

public:
Reg__ConnectionManeuverAssist_template();
Reg__ConnectionManeuverAssist_template(template_sel other_value);
Reg__ConnectionManeuverAssist_template(const Reg__ConnectionManeuverAssist& other_value);
Reg__ConnectionManeuverAssist_template(const OPTIONAL<Reg__ConnectionManeuverAssist>& other_value);
Reg__ConnectionManeuverAssist_template(const Reg__ConnectionManeuverAssist_template& other_value);
~Reg__ConnectionManeuverAssist_template();
Reg__ConnectionManeuverAssist_template& operator=(template_sel other_value);
Reg__ConnectionManeuverAssist_template& operator=(const Reg__ConnectionManeuverAssist& other_value);
Reg__ConnectionManeuverAssist_template& operator=(const OPTIONAL<Reg__ConnectionManeuverAssist>& other_value);
Reg__ConnectionManeuverAssist_template& operator=(const Reg__ConnectionManeuverAssist_template& other_value);
boolean match(const Reg__ConnectionManeuverAssist& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Reg__ConnectionManeuverAssist valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__ConnectionManeuverAssist_template& list_item(unsigned int list_index) const;
VehicleToLanePositionList_template& vehicleToLanePositions();
const VehicleToLanePositionList_template& vehicleToLanePositions() const;
DSRC2::NodeOffsetPoint_template& rsuDistanceFromAnchor();
const DSRC2::NodeOffsetPoint_template& rsuDistanceFromAnchor() const;
int size_of() const;
void log() const;
void log_match(const Reg__ConnectionManeuverAssist& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Reg__IntersectionState : public Base_Type {
  OPTIONAL<PrioritizationResponseList> field_activePrioritizations;
  boolean bound_flag;
public:
  Reg__IntersectionState();
  Reg__IntersectionState(const OPTIONAL<PrioritizationResponseList>& par_activePrioritizations);
  Reg__IntersectionState(const Reg__IntersectionState& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Reg__IntersectionState& operator=(const Reg__IntersectionState& other_value);
  boolean operator==(const Reg__IntersectionState& other_value) const;
  inline boolean operator!=(const Reg__IntersectionState& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<PrioritizationResponseList>& activePrioritizations()
    {return field_activePrioritizations;}
  inline const OPTIONAL<PrioritizationResponseList>& activePrioritizations() const
    {return field_activePrioritizations;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__IntersectionState_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Reg__IntersectionState_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Reg__IntersectionState& other_value);
void copy_template(const Reg__IntersectionState_template& other_value);

public:
Reg__IntersectionState_template();
Reg__IntersectionState_template(template_sel other_value);
Reg__IntersectionState_template(const Reg__IntersectionState& other_value);
Reg__IntersectionState_template(const OPTIONAL<Reg__IntersectionState>& other_value);
Reg__IntersectionState_template(const Reg__IntersectionState_template& other_value);
~Reg__IntersectionState_template();
Reg__IntersectionState_template& operator=(template_sel other_value);
Reg__IntersectionState_template& operator=(const Reg__IntersectionState& other_value);
Reg__IntersectionState_template& operator=(const OPTIONAL<Reg__IntersectionState>& other_value);
Reg__IntersectionState_template& operator=(const Reg__IntersectionState_template& other_value);
boolean match(const Reg__IntersectionState& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Reg__IntersectionState valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__IntersectionState_template& list_item(unsigned int list_index) const;
PrioritizationResponseList_template& activePrioritizations();
const PrioritizationResponseList_template& activePrioritizations() const;
int size_of() const;
void log() const;
void log_match(const Reg__IntersectionState& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Reg__MapData : public Base_Type {
  OPTIONAL<SignalHeadLocationList> field_signalHeadLocations;
  boolean bound_flag;
public:
  Reg__MapData();
  Reg__MapData(const OPTIONAL<SignalHeadLocationList>& par_signalHeadLocations);
  Reg__MapData(const Reg__MapData& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Reg__MapData& operator=(const Reg__MapData& other_value);
  boolean operator==(const Reg__MapData& other_value) const;
  inline boolean operator!=(const Reg__MapData& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<SignalHeadLocationList>& signalHeadLocations()
    {return field_signalHeadLocations;}
  inline const OPTIONAL<SignalHeadLocationList>& signalHeadLocations() const
    {return field_signalHeadLocations;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__MapData_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Reg__MapData_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Reg__MapData& other_value);
void copy_template(const Reg__MapData_template& other_value);

public:
Reg__MapData_template();
Reg__MapData_template(template_sel other_value);
Reg__MapData_template(const Reg__MapData& other_value);
Reg__MapData_template(const OPTIONAL<Reg__MapData>& other_value);
Reg__MapData_template(const Reg__MapData_template& other_value);
~Reg__MapData_template();
Reg__MapData_template& operator=(template_sel other_value);
Reg__MapData_template& operator=(const Reg__MapData& other_value);
Reg__MapData_template& operator=(const OPTIONAL<Reg__MapData>& other_value);
Reg__MapData_template& operator=(const Reg__MapData_template& other_value);
boolean match(const Reg__MapData& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Reg__MapData valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__MapData_template& list_item(unsigned int list_index) const;
SignalHeadLocationList_template& signalHeadLocations();
const SignalHeadLocationList_template& signalHeadLocations() const;
int size_of() const;
void log() const;
void log_match(const Reg__MapData& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SignalHeadLocationList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
SignalHeadLocation **value_elements;
} *val_ptr;

static const SignalHeadLocation UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const SignalHeadLocationList& other_value);

public:
  typedef SignalHeadLocation of_type;
SignalHeadLocationList();
SignalHeadLocationList(null_type other_value);
SignalHeadLocationList(const SignalHeadLocationList& other_value);
~SignalHeadLocationList();

void clean_up();
SignalHeadLocationList& operator=(null_type other_value);
SignalHeadLocationList& operator=(const SignalHeadLocationList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const SignalHeadLocationList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SignalHeadLocationList& other_value) const { return !(*this == other_value); }

SignalHeadLocation& operator[](int index_value);
SignalHeadLocation& operator[](const INTEGER& index_value);
const SignalHeadLocation& operator[](int index_value) const;
const SignalHeadLocation& operator[](const INTEGER& index_value) const;

SignalHeadLocationList operator<<=(int rotate_count) const;
SignalHeadLocationList operator<<=(const INTEGER& rotate_count) const;
SignalHeadLocationList operator>>=(int rotate_count) const;
SignalHeadLocationList operator>>=(const INTEGER& rotate_count) const;

SignalHeadLocationList operator+(const SignalHeadLocationList& other_value) const;

SignalHeadLocationList substr(int index, int returncount) const;

SignalHeadLocationList replace(int index, int len, const SignalHeadLocationList& repl) const;

SignalHeadLocationList replace(int index, int len, const SignalHeadLocationList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SignalHeadLocationList_template : public Record_Of_Template {
union {
struct {
int n_elements;
SignalHeadLocation_template **value_elements;
} single_value;
struct {
unsigned int n_values;
SignalHeadLocationList_template *list_value;
} value_list;
};
void copy_value(const SignalHeadLocationList& other_value);
void copy_template(const SignalHeadLocationList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
SignalHeadLocationList_template();
SignalHeadLocationList_template(template_sel other_value);
SignalHeadLocationList_template(null_type other_value);
SignalHeadLocationList_template(const SignalHeadLocationList& other_value);
SignalHeadLocationList_template(const OPTIONAL<SignalHeadLocationList>& other_value);
SignalHeadLocationList_template(const SignalHeadLocationList_template& other_value);
~SignalHeadLocationList_template();

void clean_up();
SignalHeadLocationList_template& operator=(template_sel other_value);
SignalHeadLocationList_template& operator=(null_type other_value);
SignalHeadLocationList_template& operator=(const SignalHeadLocationList& other_value);
SignalHeadLocationList_template& operator=(const OPTIONAL<SignalHeadLocationList>& other_value);
SignalHeadLocationList_template& operator=(const SignalHeadLocationList_template& other_value);

SignalHeadLocation_template& operator[](int index_value);
SignalHeadLocation_template& operator[](const INTEGER& index_value);
const SignalHeadLocation_template& operator[](int index_value) const;
const SignalHeadLocation_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const SignalHeadLocationList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
SignalHeadLocationList valueof() const;
SignalHeadLocationList substr(int index, int returncount) const;

SignalHeadLocationList replace(int index, int len, const SignalHeadLocationList_template& repl) const;

SignalHeadLocationList replace(int index, int len, const SignalHeadLocationList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
SignalHeadLocationList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SignalHeadLocationList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SignalHeadLocation : public Base_Type {
  DSRC2::NodeOffsetPoint field_node;
  INTEGER field_elevation;
  INTEGER field_signalGroupID;
  boolean bound_flag;
public:
  SignalHeadLocation();
  SignalHeadLocation(const DSRC2::NodeOffsetPoint& par_node,
    const INTEGER& par_elevation,
    const INTEGER& par_signalGroupID);
  SignalHeadLocation(const SignalHeadLocation& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SignalHeadLocation& operator=(const SignalHeadLocation& other_value);
  boolean operator==(const SignalHeadLocation& other_value) const;
  inline boolean operator!=(const SignalHeadLocation& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline DSRC2::NodeOffsetPoint& node()
    {return field_node;}
  inline const DSRC2::NodeOffsetPoint& node() const
    {return field_node;}
  inline INTEGER& elevation()
    {return field_elevation;}
  inline const INTEGER& elevation() const
    {return field_elevation;}
  inline INTEGER& signalGroupID()
    {return field_signalGroupID;}
  inline const INTEGER& signalGroupID() const
    {return field_signalGroupID;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SignalHeadLocation_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SignalHeadLocation_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SignalHeadLocation& other_value);
void copy_template(const SignalHeadLocation_template& other_value);

public:
SignalHeadLocation_template();
SignalHeadLocation_template(template_sel other_value);
SignalHeadLocation_template(const SignalHeadLocation& other_value);
SignalHeadLocation_template(const OPTIONAL<SignalHeadLocation>& other_value);
SignalHeadLocation_template(const SignalHeadLocation_template& other_value);
~SignalHeadLocation_template();
SignalHeadLocation_template& operator=(template_sel other_value);
SignalHeadLocation_template& operator=(const SignalHeadLocation& other_value);
SignalHeadLocation_template& operator=(const OPTIONAL<SignalHeadLocation>& other_value);
SignalHeadLocation_template& operator=(const SignalHeadLocation_template& other_value);
boolean match(const SignalHeadLocation& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SignalHeadLocation valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SignalHeadLocation_template& list_item(unsigned int list_index) const;
DSRC2::NodeOffsetPoint_template& node();
const DSRC2::NodeOffsetPoint_template& node() const;
INTEGER_template& elevation();
const INTEGER_template& elevation() const;
INTEGER_template& signalGroupID();
const INTEGER_template& signalGroupID() const;
int size_of() const;
void log() const;
void log_match(const SignalHeadLocation& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Reg__Position3D : public Base_Type {
  ITS__Container::Altitude field_altitude;
  boolean bound_flag;
public:
  Reg__Position3D();
  Reg__Position3D(const ITS__Container::Altitude& par_altitude);
  Reg__Position3D(const Reg__Position3D& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Reg__Position3D& operator=(const Reg__Position3D& other_value);
  boolean operator==(const Reg__Position3D& other_value) const;
  inline boolean operator!=(const Reg__Position3D& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ITS__Container::Altitude& altitude()
    {return field_altitude;}
  inline const ITS__Container::Altitude& altitude() const
    {return field_altitude;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__Position3D_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Reg__Position3D_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Reg__Position3D& other_value);
void copy_template(const Reg__Position3D_template& other_value);

public:
Reg__Position3D_template();
Reg__Position3D_template(template_sel other_value);
Reg__Position3D_template(const Reg__Position3D& other_value);
Reg__Position3D_template(const OPTIONAL<Reg__Position3D>& other_value);
Reg__Position3D_template(const Reg__Position3D_template& other_value);
~Reg__Position3D_template();
Reg__Position3D_template& operator=(template_sel other_value);
Reg__Position3D_template& operator=(const Reg__Position3D& other_value);
Reg__Position3D_template& operator=(const OPTIONAL<Reg__Position3D>& other_value);
Reg__Position3D_template& operator=(const Reg__Position3D_template& other_value);
boolean match(const Reg__Position3D& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Reg__Position3D valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__Position3D_template& list_item(unsigned int list_index) const;
ITS__Container::Altitude_template& altitude();
const ITS__Container::Altitude_template& altitude() const;
int size_of() const;
void log() const;
void log_match(const Reg__Position3D& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Reg__RestrictionUserType : public Base_Type {
  OPTIONAL<EmissionType> field_emission;
  boolean bound_flag;
public:
  Reg__RestrictionUserType();
  Reg__RestrictionUserType(const OPTIONAL<EmissionType>& par_emission);
  Reg__RestrictionUserType(const Reg__RestrictionUserType& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Reg__RestrictionUserType& operator=(const Reg__RestrictionUserType& other_value);
  boolean operator==(const Reg__RestrictionUserType& other_value) const;
  inline boolean operator!=(const Reg__RestrictionUserType& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<EmissionType>& emission()
    {return field_emission;}
  inline const OPTIONAL<EmissionType>& emission() const
    {return field_emission;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__RestrictionUserType_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Reg__RestrictionUserType_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Reg__RestrictionUserType& other_value);
void copy_template(const Reg__RestrictionUserType_template& other_value);

public:
Reg__RestrictionUserType_template();
Reg__RestrictionUserType_template(template_sel other_value);
Reg__RestrictionUserType_template(const Reg__RestrictionUserType& other_value);
Reg__RestrictionUserType_template(const OPTIONAL<Reg__RestrictionUserType>& other_value);
Reg__RestrictionUserType_template(const Reg__RestrictionUserType_template& other_value);
~Reg__RestrictionUserType_template();
Reg__RestrictionUserType_template& operator=(template_sel other_value);
Reg__RestrictionUserType_template& operator=(const Reg__RestrictionUserType& other_value);
Reg__RestrictionUserType_template& operator=(const OPTIONAL<Reg__RestrictionUserType>& other_value);
Reg__RestrictionUserType_template& operator=(const Reg__RestrictionUserType_template& other_value);
boolean match(const Reg__RestrictionUserType& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Reg__RestrictionUserType valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__RestrictionUserType_template& list_item(unsigned int list_index) const;
EmissionType_template& emission();
const EmissionType_template& emission() const;
int size_of() const;
void log() const;
void log_match(const Reg__RestrictionUserType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const PrioritizationResponseList& other_value);
inline boolean operator!=(null_type null_value, const PrioritizationResponseList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const VehicleToLanePositionList& other_value);
inline boolean operator!=(null_type null_value, const VehicleToLanePositionList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const SignalHeadLocationList& other_value);
inline boolean operator!=(null_type null_value, const SignalHeadLocationList& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const TTCN_JSONdescriptor_t EmissionType_json_;
extern const TTCN_Typedescriptor_t EmissionType_descr_;
extern const ASN_BERdescriptor_t PrioritizationResponse_stationID_ber_;
extern const TTCN_Typedescriptor_t PrioritizationResponse_stationID_descr_;
extern const ASN_BERdescriptor_t PrioritizationResponse_priorState_ber_;
extern const TTCN_Typedescriptor_t PrioritizationResponse_priorState_descr_;
extern const ASN_BERdescriptor_t PrioritizationResponse_signalGroup_ber_;
extern const TTCN_Typedescriptor_t PrioritizationResponse_signalGroup_descr_;
extern const TTCN_JSONdescriptor_t PrioritizationResponse_json_;
extern const TTCN_Typedescriptor_t PrioritizationResponse_descr_;
extern const TTCN_JSONdescriptor_t PrioritizationResponseList_json_;
extern const TTCN_Typedescriptor_t PrioritizationResponseList_descr_;
extern const TTCN_JSONdescriptor_t VehicleToLanePositionList_json_;
extern const TTCN_Typedescriptor_t VehicleToLanePositionList_descr_;
extern const ASN_BERdescriptor_t VehicleToLanePosition_stationID_ber_;
extern const TTCN_Typedescriptor_t VehicleToLanePosition_stationID_descr_;
extern const ASN_BERdescriptor_t VehicleToLanePosition_laneID_ber_;
extern const TTCN_Typedescriptor_t VehicleToLanePosition_laneID_descr_;
extern const TTCN_JSONdescriptor_t VehicleToLanePosition_json_;
extern const TTCN_Typedescriptor_t VehicleToLanePosition_descr_;
extern const ASN_BERdescriptor_t Reg__ConnectionManeuverAssist_vehicleToLanePositions_ber_;
extern const TTCN_Typedescriptor_t Reg__ConnectionManeuverAssist_vehicleToLanePositions_descr_;
extern const TTCN_JSONdescriptor_t Reg__ConnectionManeuverAssist_json_;
extern const TTCN_Typedescriptor_t Reg__ConnectionManeuverAssist_descr_;
extern const ASN_BERdescriptor_t Reg__ConnectionManeuverAssist_rsuDistanceFromAnchor_ber_;
extern const TTCN_Typedescriptor_t Reg__ConnectionManeuverAssist_rsuDistanceFromAnchor_descr_;
extern const TTCN_JSONdescriptor_t Reg__IntersectionState_json_;
extern const TTCN_Typedescriptor_t Reg__IntersectionState_descr_;
extern const ASN_BERdescriptor_t Reg__IntersectionState_activePrioritizations_ber_;
extern const TTCN_Typedescriptor_t Reg__IntersectionState_activePrioritizations_descr_;
extern const TTCN_JSONdescriptor_t Reg__MapData_json_;
extern const TTCN_Typedescriptor_t Reg__MapData_descr_;
extern const TTCN_JSONdescriptor_t SignalHeadLocationList_json_;
extern const TTCN_Typedescriptor_t SignalHeadLocationList_descr_;
extern const ASN_BERdescriptor_t SignalHeadLocation_node_ber_;
extern const TTCN_Typedescriptor_t SignalHeadLocation_node_descr_;
extern const ASN_BERdescriptor_t SignalHeadLocation_elevation_ber_;
extern const TTCN_Typedescriptor_t SignalHeadLocation_elevation_descr_;
extern const ASN_BERdescriptor_t SignalHeadLocation_signalGroupID_ber_;
extern const TTCN_Typedescriptor_t SignalHeadLocation_signalGroupID_descr_;
extern const TTCN_JSONdescriptor_t SignalHeadLocation_json_;
extern const TTCN_Typedescriptor_t SignalHeadLocation_descr_;
extern const ASN_BERdescriptor_t Reg__MapData_signalHeadLocations_ber_;
extern const TTCN_Typedescriptor_t Reg__MapData_signalHeadLocations_descr_;
extern const ASN_BERdescriptor_t Reg__Position3D_altitude_ber_;
extern const TTCN_Typedescriptor_t Reg__Position3D_altitude_descr_;
extern const TTCN_JSONdescriptor_t Reg__Position3D_json_;
extern const TTCN_Typedescriptor_t Reg__Position3D_descr_;
extern const TTCN_JSONdescriptor_t Reg__RestrictionUserType_json_;
extern const TTCN_Typedescriptor_t Reg__RestrictionUserType_descr_;
extern const ASN_BERdescriptor_t Reg__RestrictionUserType_emission_ber_;
extern const TTCN_Typedescriptor_t Reg__RestrictionUserType_emission_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
