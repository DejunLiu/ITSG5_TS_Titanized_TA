// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "LibItsGeoNetworking_TypesAndValues.hh"

namespace LibItsGeoNetworking__TypesAndValues {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();

/* Literal string constants */

static const CHARSTRING cs_8(5, "AREA1"),
cs_9(5, "AREA2"),
cs_0(3, "IUT"),
cs_1(3, "MTC"),
cs_10(12, "Message sent"),
cs_2(5, "NodeA"),
cs_3(5, "NodeB"),
cs_4(5, "NodeC"),
cs_5(5, "NodeD"),
cs_6(5, "NodeE"),
cs_7(5, "NodeF");
static const unsigned char module_checksum[] = { 0x70, 0x6e, 0xc3, 0x13, 0xdf, 0x1e, 0x44, 0xa9, 0xd1, 0x94, 0x29, 0x19, 0x92, 0x8e, 0x95, 0x60 };

/* Global variable definitions */

static CHARSTRING const_c__compIut;
const CHARSTRING& c__compIut = const_c__compIut;
static CHARSTRING const_c__compMTC;
const CHARSTRING& c__compMTC = const_c__compMTC;
static CHARSTRING const_c__compNodeA;
const CHARSTRING& c__compNodeA = const_c__compNodeA;
static CHARSTRING const_c__compNodeB;
const CHARSTRING& c__compNodeB = const_c__compNodeB;
static CHARSTRING const_c__compNodeC;
const CHARSTRING& c__compNodeC = const_c__compNodeC;
static CHARSTRING const_c__compNodeD;
const CHARSTRING& c__compNodeD = const_c__compNodeD;
static CHARSTRING const_c__compNodeE;
const CHARSTRING& c__compNodeE = const_c__compNodeE;
static CHARSTRING const_c__compNodeF;
const CHARSTRING& c__compNodeF = const_c__compNodeF;
static CHARSTRING const_c__area1;
const CHARSTRING& c__area1 = const_c__area1;
static CHARSTRING const_c__area2;
const CHARSTRING& c__area2 = const_c__area2;
static INTEGER const_c__latitudeFactorNodeA;
const INTEGER& c__latitudeFactorNodeA = const_c__latitudeFactorNodeA;
static INTEGER const_c__latitudeFactorNodeB;
const INTEGER& c__latitudeFactorNodeB = const_c__latitudeFactorNodeB;
static INTEGER const_c__latitudeFactorNodeC;
const INTEGER& c__latitudeFactorNodeC = const_c__latitudeFactorNodeC;
static INTEGER const_c__latitudeFactorNodeD;
const INTEGER& c__latitudeFactorNodeD = const_c__latitudeFactorNodeD;
static INTEGER const_c__latitudeFactorNodeE;
const INTEGER& c__latitudeFactorNodeE = const_c__latitudeFactorNodeE;
static INTEGER const_c__latitudeFactorNodeF;
const INTEGER& c__latitudeFactorNodeF = const_c__latitudeFactorNodeF;
static INTEGER const_c__longitudeFactorNodeA;
const INTEGER& c__longitudeFactorNodeA = const_c__longitudeFactorNodeA;
static INTEGER const_c__longitudeFactorNodeB;
const INTEGER& c__longitudeFactorNodeB = const_c__longitudeFactorNodeB;
static INTEGER const_c__longitudeFactorNodeC;
const INTEGER& c__longitudeFactorNodeC = const_c__longitudeFactorNodeC;
static INTEGER const_c__longitudeFactorNodeD;
const INTEGER& c__longitudeFactorNodeD = const_c__longitudeFactorNodeD;
static INTEGER const_c__longitudeFactorNodeE;
const INTEGER& c__longitudeFactorNodeE = const_c__longitudeFactorNodeE;
static INTEGER const_c__longitudeFactorNodeF;
const INTEGER& c__longitudeFactorNodeF = const_c__longitudeFactorNodeF;
static CHARSTRING const_c__msgSent;
const CHARSTRING& c__msgSent = const_c__msgSent;
static INTEGER const_c__defaultLifetime;
const INTEGER& c__defaultLifetime = const_c__defaultLifetime;
static INTEGER const_c__lifetime;
const INTEGER& c__lifetime = const_c__lifetime;
static FLOAT const_c__squareKm;
const FLOAT& c__squareKm = const_c__squareKm;
const XERdescriptor_t       PositionEntry_key_xer_ = { {"key>\n", "key>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t PositionEntry_key_descr_ = { "@LibItsGeoNetworking_TypesAndValues.PositionEntry.key", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &PositionEntry_key_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t TypeOfAddress_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for TypeOfAddress
const TTCN_JSONdescriptor_t TypeOfAddress_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t TypeOfAddress_descr_ = { "@LibItsGeoNetworking_TypesAndValues.TypeOfAddress", NULL, &TypeOfAddress_raw_, NULL, NULL, &TypeOfAddress_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t StationType_raw_ = {5,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for StationType
const TTCN_JSONdescriptor_t StationType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t StationType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.StationType", NULL, &StationType_raw_, NULL, NULL, &StationType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GN__Address_stationCountryCode_xer_ = { {"stationCountryCode>\n", "stationCountryCode>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GN__Address_stationCountryCode_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GN_Address.stationCountryCode", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt10_raw_, &INTEGER_text_, &GN__Address_stationCountryCode_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GN__Address_mid_xer_ = { {"mid>\n", "mid>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GN__Address_mid_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GN_Address.mid", &OCTETSTRING_ber_, &LibCommon__DataStrings::Oct6_raw_, &OCTETSTRING_text_, &GN__Address_mid_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GN__Address_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GN__Address
const TTCN_JSONdescriptor_t GN__Address_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GN__Address_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GN_Address", NULL, &GN__Address_raw_, NULL, NULL, &GN__Address_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       LongPosVector_timestamp_xer_ = { {"timestamp>\n", "timestamp>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t LongPosVector_timestamp_descr_ = { "@LibItsGeoNetworking_TypesAndValues.LongPosVector.timestamp", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt32_raw_, &INTEGER_text_, &LongPosVector_timestamp_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       LongPosVector_latitude_xer_ = { {"latitude>\n", "latitude>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t LongPosVector_latitude_descr_ = { "@LibItsGeoNetworking_TypesAndValues.LongPosVector.latitude", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::Int32_raw_, &INTEGER_text_, &LongPosVector_latitude_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       LongPosVector_longitude_xer_ = { {"longitude>\n", "longitude>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t LongPosVector_longitude_descr_ = { "@LibItsGeoNetworking_TypesAndValues.LongPosVector.longitude", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::Int32_raw_, &INTEGER_text_, &LongPosVector_longitude_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       LongPosVector_pai_xer_ = { {"pai>\n", "pai>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t LongPosVector_pai_descr_ = { "@LibItsGeoNetworking_TypesAndValues.LongPosVector.pai", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &LongPosVector_pai_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       LongPosVector_speed_xer_ = { {"speed>\n", "speed>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t LongPosVector_speed_descr_ = { "@LibItsGeoNetworking_TypesAndValues.LongPosVector.speed", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::Int15_raw_, &INTEGER_text_, &LongPosVector_speed_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       LongPosVector_heading_xer_ = { {"heading>\n", "heading>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t LongPosVector_heading_descr_ = { "@LibItsGeoNetworking_TypesAndValues.LongPosVector.heading", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &LongPosVector_heading_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t LongPosVector_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for LongPosVector
const TTCN_JSONdescriptor_t LongPosVector_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t LongPosVector_descr_ = { "@LibItsGeoNetworking_TypesAndValues.LongPosVector", NULL, &LongPosVector_raw_, NULL, NULL, &LongPosVector_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t PositionEntry_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for PositionEntry
const TTCN_JSONdescriptor_t PositionEntry_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t PositionEntry_descr_ = { "@LibItsGeoNetworking_TypesAndValues.PositionEntry", NULL, &PositionEntry_raw_, NULL, NULL, &PositionEntry_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t PositionTable_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for PositionTable
const TTCN_Typedescriptor_t PositionTable_descr_ = { "@LibItsGeoNetworking_TypesAndValues.PositionTable", NULL, &PositionTable_raw_, NULL, NULL, NULL, &PositionEntry_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Area_geoAreaPosLatitude_xer_ = { {"geoAreaPosLatitude>\n", "geoAreaPosLatitude>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Area_geoAreaPosLatitude_descr_ = { "@LibItsGeoNetworking_TypesAndValues.Area.geoAreaPosLatitude", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::Int32_raw_, &INTEGER_text_, &Area_geoAreaPosLatitude_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Area_geoAreaPosLongitude_xer_ = { {"geoAreaPosLongitude>\n", "geoAreaPosLongitude>\n"}, {21, 21}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Area_geoAreaPosLongitude_descr_ = { "@LibItsGeoNetworking_TypesAndValues.Area.geoAreaPosLongitude", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::Int32_raw_, &INTEGER_text_, &Area_geoAreaPosLongitude_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Area_distanceA_xer_ = { {"distanceA>\n", "distanceA>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Area_distanceA_descr_ = { "@LibItsGeoNetworking_TypesAndValues.Area.distanceA", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &Area_distanceA_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Area_distanceB_xer_ = { {"distanceB>\n", "distanceB>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Area_distanceB_descr_ = { "@LibItsGeoNetworking_TypesAndValues.Area.distanceB", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &Area_distanceB_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Area_angle_xer_ = { {"angle>\n", "angle>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Area_angle_descr_ = { "@LibItsGeoNetworking_TypesAndValues.Area.angle", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &Area_angle_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t Area_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for Area
const TTCN_JSONdescriptor_t Area_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Area_descr_ = { "@LibItsGeoNetworking_TypesAndValues.Area", NULL, &Area_raw_, NULL, NULL, &Area_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t HeaderSubTypeGeoBroadcast_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for HeaderSubTypeGeoBroadcast
const TTCN_JSONdescriptor_t HeaderSubTypeGeoBroadcast_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t HeaderSubTypeGeoBroadcast_descr_ = { "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast", NULL, &HeaderSubTypeGeoBroadcast_raw_, NULL, NULL, &HeaderSubTypeGeoBroadcast_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoBroadcastArea_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoBroadcastArea
const TTCN_JSONdescriptor_t GeoBroadcastArea_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GeoBroadcastArea_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea", NULL, &GeoBroadcastArea_raw_, NULL, NULL, &GeoBroadcastArea_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t HeaderSubTypeGeoAnycast_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for HeaderSubTypeGeoAnycast
const TTCN_JSONdescriptor_t HeaderSubTypeGeoAnycast_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t HeaderSubTypeGeoAnycast_descr_ = { "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast", NULL, &HeaderSubTypeGeoAnycast_raw_, NULL, NULL, &HeaderSubTypeGeoAnycast_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoAnycastArea_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoAnycastArea
const TTCN_JSONdescriptor_t GeoAnycastArea_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GeoAnycastArea_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoAnycastArea", NULL, &GeoAnycastArea_raw_, NULL, NULL, &GeoAnycastArea_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoShape_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoShape
const TTCN_JSONdescriptor_t GeoShape_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GeoShape_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoShape", NULL, &GeoShape_raw_, NULL, NULL, &GeoShape_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoArea_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoArea
const TTCN_JSONdescriptor_t GeoArea_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GeoArea_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoArea", NULL, &GeoArea_raw_, NULL, NULL, &GeoArea_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GeoAreaEntry_key_xer_ = { {"key>\n", "key>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GeoAreaEntry_key_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoAreaEntry.key", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &GeoAreaEntry_key_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoAreaEntry_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoAreaEntry
const TTCN_JSONdescriptor_t GeoAreaEntry_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GeoAreaEntry_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoAreaEntry", NULL, &GeoAreaEntry_raw_, NULL, NULL, &GeoAreaEntry_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoAreaTable_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoAreaTable
const TTCN_Typedescriptor_t GeoAreaTable_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoAreaTable", NULL, &GeoAreaTable_raw_, NULL, NULL, NULL, &GeoAreaEntry_descr_, TTCN_Typedescriptor_t::DONTCARE };
static INTEGER const_c__geoNwProtocolVersion;
const INTEGER& c__geoNwProtocolVersion = const_c__geoNwProtocolVersion;
static INTEGER const_c__hopLimit1;
const INTEGER& c__hopLimit1 = const_c__hopLimit1;
static INTEGER const_c__defaultHopLimit;
const INTEGER& c__defaultHopLimit = const_c__defaultHopLimit;
const TTCN_RAWdescriptor_t BasicHeader_version_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       BasicHeader_version_xer_ = { {"version>\n", "version>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t BasicHeader_version_descr_ = { "@LibItsGeoNetworking_TypesAndValues.BasicHeader.version", &INTEGER_ber_, &BasicHeader_version_raw_, &INTEGER_text_, &BasicHeader_version_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BasicNextHeader_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for BasicNextHeader
const TTCN_JSONdescriptor_t BasicNextHeader_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t BasicNextHeader_descr_ = { "@LibItsGeoNetworking_TypesAndValues.BasicNextHeader", NULL, &BasicNextHeader_raw_, NULL, NULL, &BasicNextHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BasicHeader_nextHeader_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for BasicHeader_nextHeader
const TTCN_Typedescriptor_t BasicHeader_nextHeader_descr_ = { "@LibItsGeoNetworking_TypesAndValues.BasicHeader.nextHeader", NULL, &BasicHeader_nextHeader_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BasicHeader_reserved_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       BasicHeader_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t BasicHeader_reserved_descr_ = { "@LibItsGeoNetworking_TypesAndValues.BasicHeader.reserved", &INTEGER_ber_, &BasicHeader_reserved_raw_, &INTEGER_text_, &BasicHeader_reserved_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Lifetime_multiplier_xer_ = { {"multiplier>\n", "multiplier>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Lifetime_multiplier_descr_ = { "@LibItsGeoNetworking_TypesAndValues.Lifetime.multiplier", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt6_raw_, &INTEGER_text_, &Lifetime_multiplier_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t LtBase_raw_ = {2,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for LtBase
const TTCN_JSONdescriptor_t LtBase_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t LtBase_descr_ = { "@LibItsGeoNetworking_TypesAndValues.LtBase", NULL, &LtBase_raw_, NULL, NULL, &LtBase_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t Lifetime_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for Lifetime
const TTCN_JSONdescriptor_t Lifetime_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Lifetime_descr_ = { "@LibItsGeoNetworking_TypesAndValues.Lifetime", NULL, &Lifetime_raw_, NULL, NULL, &Lifetime_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BasicHeader_lifeTime_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for BasicHeader_lifeTime
const TTCN_Typedescriptor_t BasicHeader_lifeTime_descr_ = { "@LibItsGeoNetworking_TypesAndValues.BasicHeader.lifeTime", NULL, &BasicHeader_lifeTime_raw_, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BasicHeader_routerHopLimit_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       BasicHeader_routerHopLimit_xer_ = { {"routerHopLimit>\n", "routerHopLimit>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t BasicHeader_routerHopLimit_descr_ = { "@LibItsGeoNetworking_TypesAndValues.BasicHeader.routerHopLimit", &INTEGER_ber_, &BasicHeader_routerHopLimit_raw_, &INTEGER_text_, &BasicHeader_routerHopLimit_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BasicHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for BasicHeader
const TTCN_JSONdescriptor_t BasicHeader_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t BasicHeader_descr_ = { "@LibItsGeoNetworking_TypesAndValues.BasicHeader", NULL, &BasicHeader_raw_, NULL, NULL, &BasicHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t NextHeader_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for NextHeader
const TTCN_JSONdescriptor_t NextHeader_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t NextHeader_descr_ = { "@LibItsGeoNetworking_TypesAndValues.NextHeader", NULL, &NextHeader_raw_, NULL, NULL, &NextHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t CommonHeader_nextHeader_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for CommonHeader_nextHeader
const TTCN_Typedescriptor_t CommonHeader_nextHeader_descr_ = { "@LibItsGeoNetworking_TypesAndValues.CommonHeader.nextHeader", NULL, &CommonHeader_nextHeader_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t CommonHeader_reserved_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       CommonHeader_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t CommonHeader_reserved_descr_ = { "@LibItsGeoNetworking_TypesAndValues.CommonHeader.reserved", &INTEGER_ber_, &CommonHeader_reserved_raw_, &INTEGER_text_, &CommonHeader_reserved_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t HeaderTST_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for HeaderTST
const TTCN_JSONdescriptor_t HeaderTST_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t HeaderTST_descr_ = { "@LibItsGeoNetworking_TypesAndValues.HeaderTST", NULL, &HeaderTST_raw_, NULL, NULL, &HeaderTST_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t HeaderType_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for HeaderType
const TTCN_JSONdescriptor_t HeaderType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t HeaderType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.HeaderType", NULL, &HeaderType_raw_, NULL, NULL, &HeaderType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AnyHeaderType_headerType_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AnyHeaderType_headerType
const TTCN_Typedescriptor_t AnyHeaderType_headerType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AnyHeaderType.headerType", NULL, &AnyHeaderType_headerType_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AnyHeaderType_headerSubType_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       AnyHeaderType_headerSubType_xer_ = { {"headerSubType>\n", "headerSubType>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t AnyHeaderType_headerSubType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AnyHeaderType.headerSubType", &INTEGER_ber_, &AnyHeaderType_headerSubType_raw_, &INTEGER_text_, &AnyHeaderType_headerSubType_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AnyHeaderType_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AnyHeaderType
const TTCN_JSONdescriptor_t AnyHeaderType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AnyHeaderType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AnyHeaderType", NULL, &AnyHeaderType_raw_, NULL, NULL, &AnyHeaderType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BeaconHeaderType_headerType_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for BeaconHeaderType_headerType
const TTCN_Typedescriptor_t BeaconHeaderType_headerType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.headerType", NULL, &BeaconHeaderType_headerType_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BeaconHeaderType_headerSubType_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       BeaconHeaderType_headerSubType_xer_ = { {"headerSubType>\n", "headerSubType>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t BeaconHeaderType_headerSubType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.headerSubType", &INTEGER_ber_, &BeaconHeaderType_headerSubType_raw_, &INTEGER_text_, &BeaconHeaderType_headerSubType_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BeaconHeaderType_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for BeaconHeaderType
const TTCN_JSONdescriptor_t BeaconHeaderType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t BeaconHeaderType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.BeaconHeaderType", NULL, &BeaconHeaderType_raw_, NULL, NULL, &BeaconHeaderType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoUnicastHeaderType_headerType_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoUnicastHeaderType_headerType
const TTCN_Typedescriptor_t GeoUnicastHeaderType_headerType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.headerType", NULL, &GeoUnicastHeaderType_headerType_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoUnicastHeaderType_headerSubType_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       GeoUnicastHeaderType_headerSubType_xer_ = { {"headerSubType>\n", "headerSubType>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GeoUnicastHeaderType_headerSubType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.headerSubType", &INTEGER_ber_, &GeoUnicastHeaderType_headerSubType_raw_, &INTEGER_text_, &GeoUnicastHeaderType_headerSubType_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoUnicastHeaderType_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoUnicastHeaderType
const TTCN_JSONdescriptor_t GeoUnicastHeaderType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GeoUnicastHeaderType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType", NULL, &GeoUnicastHeaderType_raw_, NULL, NULL, &GeoUnicastHeaderType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoAnycastHeaderType_headerType_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoAnycastHeaderType_headerType
const TTCN_Typedescriptor_t GeoAnycastHeaderType_headerType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.headerType", NULL, &GeoAnycastHeaderType_headerType_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoAnycastHeaderType_headerSubType_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoAnycastHeaderType_headerSubType
const TTCN_Typedescriptor_t GeoAnycastHeaderType_headerSubType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.headerSubType", NULL, &GeoAnycastHeaderType_headerSubType_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoAnycastHeaderType_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoAnycastHeaderType
const TTCN_JSONdescriptor_t GeoAnycastHeaderType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GeoAnycastHeaderType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType", NULL, &GeoAnycastHeaderType_raw_, NULL, NULL, &GeoAnycastHeaderType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoBroadcastHeaderType_headerType_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoBroadcastHeaderType_headerType
const TTCN_Typedescriptor_t GeoBroadcastHeaderType_headerType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.headerType", NULL, &GeoBroadcastHeaderType_headerType_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoBroadcastHeaderType_headerSubType_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoBroadcastHeaderType_headerSubType
const TTCN_Typedescriptor_t GeoBroadcastHeaderType_headerSubType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.headerSubType", NULL, &GeoBroadcastHeaderType_headerSubType_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoBroadcastHeaderType_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoBroadcastHeaderType
const TTCN_JSONdescriptor_t GeoBroadcastHeaderType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GeoBroadcastHeaderType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType", NULL, &GeoBroadcastHeaderType_raw_, NULL, NULL, &GeoBroadcastHeaderType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t TsbHeaderType_headerType_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for TsbHeaderType_headerType
const TTCN_Typedescriptor_t TsbHeaderType_headerType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.TsbHeaderType.headerType", NULL, &TsbHeaderType_headerType_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t HeaderSubTypeTSB_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for HeaderSubTypeTSB
const TTCN_JSONdescriptor_t HeaderSubTypeTSB_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t HeaderSubTypeTSB_descr_ = { "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB", NULL, &HeaderSubTypeTSB_raw_, NULL, NULL, &HeaderSubTypeTSB_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t TsbHeaderType_headerSubType_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for TsbHeaderType_headerSubType
const TTCN_Typedescriptor_t TsbHeaderType_headerSubType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.TsbHeaderType.headerSubType", NULL, &TsbHeaderType_headerSubType_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t TsbHeaderType_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for TsbHeaderType
const TTCN_JSONdescriptor_t TsbHeaderType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t TsbHeaderType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.TsbHeaderType", NULL, &TsbHeaderType_raw_, NULL, NULL, &TsbHeaderType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t LsHeaderType_headerType_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for LsHeaderType_headerType
const TTCN_Typedescriptor_t LsHeaderType_headerType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.LsHeaderType.headerType", NULL, &LsHeaderType_headerType_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t HeaderSubTypeLs_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for HeaderSubTypeLs
const TTCN_JSONdescriptor_t HeaderSubTypeLs_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t HeaderSubTypeLs_descr_ = { "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs", NULL, &HeaderSubTypeLs_raw_, NULL, NULL, &HeaderSubTypeLs_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t LsHeaderType_headerSubType_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for LsHeaderType_headerSubType
const TTCN_Typedescriptor_t LsHeaderType_headerSubType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.LsHeaderType.headerSubType", NULL, &LsHeaderType_headerSubType_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t LsHeaderType_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for LsHeaderType
const TTCN_JSONdescriptor_t LsHeaderType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t LsHeaderType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.LsHeaderType", NULL, &LsHeaderType_raw_, NULL, NULL, &LsHeaderType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SaHeaderType_headerType_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SaHeaderType_headerType
const TTCN_Typedescriptor_t SaHeaderType_headerType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.SaHeaderType.headerType", NULL, &SaHeaderType_headerType_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t HeaderSubTypeSa_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for HeaderSubTypeSa
const TTCN_JSONdescriptor_t HeaderSubTypeSa_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t HeaderSubTypeSa_descr_ = { "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa", NULL, &HeaderSubTypeSa_raw_, NULL, NULL, &HeaderSubTypeSa_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SaHeaderType_headerSubType_raw_ = {4,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SaHeaderType_headerSubType
const TTCN_Typedescriptor_t SaHeaderType_headerSubType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.SaHeaderType.headerSubType", NULL, &SaHeaderType_headerSubType_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SaHeaderType_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SaHeaderType
const TTCN_JSONdescriptor_t SaHeaderType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SaHeaderType_descr_ = { "@LibItsGeoNetworking_TypesAndValues.SaHeaderType", NULL, &SaHeaderType_raw_, NULL, NULL, &SaHeaderType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       HeaderTST_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t HeaderTST_reserved_descr_ = { "@LibItsGeoNetworking_TypesAndValues.HeaderTST.reserved", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &HeaderTST_reserved_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t CommonHeader_headerTST_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for CommonHeader_headerTST
const TTCN_Typedescriptor_t CommonHeader_headerTST_descr_ = { "@LibItsGeoNetworking_TypesAndValues.CommonHeader.headerTST", NULL, &CommonHeader_headerTST_raw_, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SCF_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SCF
const TTCN_JSONdescriptor_t SCF_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SCF_descr_ = { "@LibItsGeoNetworking_TypesAndValues.SCF", NULL, &SCF_raw_, NULL, NULL, &SCF_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ChannelOffload_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ChannelOffload
const TTCN_JSONdescriptor_t ChannelOffload_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ChannelOffload_descr_ = { "@LibItsGeoNetworking_TypesAndValues.ChannelOffload", NULL, &ChannelOffload_raw_, NULL, NULL, &ChannelOffload_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t TcId_raw_ = {6,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       TcId_xer_ = { {"TcId>\n", "TcId>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t TcId_descr_ = { "@LibItsGeoNetworking_TypesAndValues.TcId", &INTEGER_ber_, &TcId_raw_, &INTEGER_text_, &TcId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       TrafficClass_tcId_xer_ = { {"tcId>\n", "tcId>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t TrafficClass_tcId_descr_ = { "@LibItsGeoNetworking_TypesAndValues.TrafficClass.tcId", &INTEGER_ber_, &TcId_raw_, &INTEGER_text_, &TrafficClass_tcId_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t TrafficClass_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for TrafficClass
const TTCN_JSONdescriptor_t TrafficClass_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t TrafficClass_descr_ = { "@LibItsGeoNetworking_TypesAndValues.TrafficClass", NULL, &TrafficClass_raw_, NULL, NULL, &TrafficClass_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t CommonHeader_trafficClass_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for CommonHeader_trafficClass
const TTCN_Typedescriptor_t CommonHeader_trafficClass_descr_ = { "@LibItsGeoNetworking_TypesAndValues.CommonHeader.trafficClass", NULL, &CommonHeader_trafficClass_raw_, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t CommonHeader_flags_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,8};
const XERdescriptor_t       CommonHeader_flags_xer_ = { {"flags>\n", "flags>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t CommonHeader_flags_descr_ = { "@LibItsGeoNetworking_TypesAndValues.CommonHeader.flags", &BITSTRING_ber_, &CommonHeader_flags_raw_, NULL, &CommonHeader_flags_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t CommonHeader_plLength_raw_ = {16,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       CommonHeader_plLength_xer_ = { {"plLength>\n", "plLength>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t CommonHeader_plLength_descr_ = { "@LibItsGeoNetworking_TypesAndValues.CommonHeader.plLength", &INTEGER_ber_, &CommonHeader_plLength_raw_, &INTEGER_text_, &CommonHeader_plLength_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t CommonHeader_maxHopLimit_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       CommonHeader_maxHopLimit_xer_ = { {"maxHopLimit>\n", "maxHopLimit>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t CommonHeader_maxHopLimit_descr_ = { "@LibItsGeoNetworking_TypesAndValues.CommonHeader.maxHopLimit", &INTEGER_ber_, &CommonHeader_maxHopLimit_raw_, &INTEGER_text_, &CommonHeader_maxHopLimit_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t CommonHeader_reserved2_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       CommonHeader_reserved2_xer_ = { {"reserved2>\n", "reserved2>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t CommonHeader_reserved2_descr_ = { "@LibItsGeoNetworking_TypesAndValues.CommonHeader.reserved2", &INTEGER_ber_, &CommonHeader_reserved2_raw_, &INTEGER_text_, &CommonHeader_reserved2_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t CommonHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_MSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for CommonHeader
const TTCN_JSONdescriptor_t CommonHeader_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t CommonHeader_descr_ = { "@LibItsGeoNetworking_TypesAndValues.CommonHeader", NULL, &CommonHeader_raw_, NULL, NULL, &CommonHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GnNonSecuredPacket_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GnNonSecuredPacket
const TTCN_JSONdescriptor_t GnNonSecuredPacket_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GnNonSecuredPacket_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket", NULL, &GnNonSecuredPacket_raw_, NULL, NULL, &GnNonSecuredPacket_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtendedHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ExtendedHeader
const TTCN_JSONdescriptor_t ExtendedHeader_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ExtendedHeader_descr_ = { "@LibItsGeoNetworking_TypesAndValues.ExtendedHeader", NULL, &ExtendedHeader_raw_, NULL, NULL, &ExtendedHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GeoUnicastHeader_seqNumber_xer_ = { {"seqNumber>\n", "seqNumber>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GeoUnicastHeader_seqNumber_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.seqNumber", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &GeoUnicastHeader_seqNumber_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GeoUnicastHeader_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GeoUnicastHeader_reserved_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.reserved", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &GeoUnicastHeader_reserved_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ShortPosVector_timestamp_xer_ = { {"timestamp>\n", "timestamp>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ShortPosVector_timestamp_descr_ = { "@LibItsGeoNetworking_TypesAndValues.ShortPosVector.timestamp", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt32_raw_, &INTEGER_text_, &ShortPosVector_timestamp_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ShortPosVector_latitude_xer_ = { {"latitude>\n", "latitude>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ShortPosVector_latitude_descr_ = { "@LibItsGeoNetworking_TypesAndValues.ShortPosVector.latitude", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::Int32_raw_, &INTEGER_text_, &ShortPosVector_latitude_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ShortPosVector_longitude_xer_ = { {"longitude>\n", "longitude>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ShortPosVector_longitude_descr_ = { "@LibItsGeoNetworking_TypesAndValues.ShortPosVector.longitude", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::Int32_raw_, &INTEGER_text_, &ShortPosVector_longitude_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ShortPosVector_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ShortPosVector
const TTCN_JSONdescriptor_t ShortPosVector_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ShortPosVector_descr_ = { "@LibItsGeoNetworking_TypesAndValues.ShortPosVector", NULL, &ShortPosVector_raw_, NULL, NULL, &ShortPosVector_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoUnicastHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoUnicastHeader
const TTCN_JSONdescriptor_t GeoUnicastHeader_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GeoUnicastHeader_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader", NULL, &GeoUnicastHeader_raw_, NULL, NULL, &GeoUnicastHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       TSBHeader_seqNumber_xer_ = { {"seqNumber>\n", "seqNumber>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t TSBHeader_seqNumber_descr_ = { "@LibItsGeoNetworking_TypesAndValues.TSBHeader.seqNumber", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &TSBHeader_seqNumber_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       TSBHeader_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t TSBHeader_reserved_descr_ = { "@LibItsGeoNetworking_TypesAndValues.TSBHeader.reserved", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &TSBHeader_reserved_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t TSBHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for TSBHeader
const TTCN_JSONdescriptor_t TSBHeader_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t TSBHeader_descr_ = { "@LibItsGeoNetworking_TypesAndValues.TSBHeader", NULL, &TSBHeader_raw_, NULL, NULL, &TSBHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SHBHeader_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SHBHeader_reserved_descr_ = { "@LibItsGeoNetworking_TypesAndValues.SHBHeader.reserved", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt32_raw_, &INTEGER_text_, &SHBHeader_reserved_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SHBHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SHBHeader
const TTCN_JSONdescriptor_t SHBHeader_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SHBHeader_descr_ = { "@LibItsGeoNetworking_TypesAndValues.SHBHeader", NULL, &SHBHeader_raw_, NULL, NULL, &SHBHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GeoAnycastHeader_seqNumber_xer_ = { {"seqNumber>\n", "seqNumber>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GeoAnycastHeader_seqNumber_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.seqNumber", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &GeoAnycastHeader_seqNumber_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GeoAnycastHeader_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GeoAnycastHeader_reserved_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.reserved", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &GeoAnycastHeader_reserved_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GeoAnycastHeader_geoAreaPosLatitude_xer_ = { {"geoAreaPosLatitude>\n", "geoAreaPosLatitude>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GeoAnycastHeader_geoAreaPosLatitude_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.geoAreaPosLatitude", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::Int32_raw_, &INTEGER_text_, &GeoAnycastHeader_geoAreaPosLatitude_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GeoAnycastHeader_geoAreaPosLongitude_xer_ = { {"geoAreaPosLongitude>\n", "geoAreaPosLongitude>\n"}, {21, 21}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GeoAnycastHeader_geoAreaPosLongitude_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.geoAreaPosLongitude", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::Int32_raw_, &INTEGER_text_, &GeoAnycastHeader_geoAreaPosLongitude_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GeoAnycastHeader_distanceA_xer_ = { {"distanceA>\n", "distanceA>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GeoAnycastHeader_distanceA_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.distanceA", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &GeoAnycastHeader_distanceA_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GeoAnycastHeader_distanceB_xer_ = { {"distanceB>\n", "distanceB>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GeoAnycastHeader_distanceB_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.distanceB", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &GeoAnycastHeader_distanceB_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GeoAnycastHeader_angle_xer_ = { {"angle>\n", "angle>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GeoAnycastHeader_angle_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.angle", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &GeoAnycastHeader_angle_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GeoAnycastHeader_reserved2_xer_ = { {"reserved2>\n", "reserved2>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GeoAnycastHeader_reserved2_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.reserved2", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &GeoAnycastHeader_reserved2_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoAnycastHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoAnycastHeader
const TTCN_JSONdescriptor_t GeoAnycastHeader_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GeoAnycastHeader_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader", NULL, &GeoAnycastHeader_raw_, NULL, NULL, &GeoAnycastHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoBroadcastHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoBroadcastHeader
const TTCN_Typedescriptor_t GeoBroadcastHeader_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeader", NULL, &GeoBroadcastHeader_raw_, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t BeaconHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for BeaconHeader
const TTCN_JSONdescriptor_t BeaconHeader_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t BeaconHeader_descr_ = { "@LibItsGeoNetworking_TypesAndValues.BeaconHeader", NULL, &BeaconHeader_raw_, NULL, NULL, &BeaconHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       LSRequestHeader_seqNumber_xer_ = { {"seqNumber>\n", "seqNumber>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t LSRequestHeader_seqNumber_descr_ = { "@LibItsGeoNetworking_TypesAndValues.LSRequestHeader.seqNumber", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &LSRequestHeader_seqNumber_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       LSRequestHeader_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t LSRequestHeader_reserved_descr_ = { "@LibItsGeoNetworking_TypesAndValues.LSRequestHeader.reserved", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &LSRequestHeader_reserved_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t LSRequestHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for LSRequestHeader
const TTCN_JSONdescriptor_t LSRequestHeader_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t LSRequestHeader_descr_ = { "@LibItsGeoNetworking_TypesAndValues.LSRequestHeader", NULL, &LSRequestHeader_raw_, NULL, NULL, &LSRequestHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       LSReplyHeader_seqNumber_xer_ = { {"seqNumber>\n", "seqNumber>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t LSReplyHeader_seqNumber_descr_ = { "@LibItsGeoNetworking_TypesAndValues.LSReplyHeader.seqNumber", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &LSReplyHeader_seqNumber_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       LSReplyHeader_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t LSReplyHeader_reserved_descr_ = { "@LibItsGeoNetworking_TypesAndValues.LSReplyHeader.reserved", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &LSReplyHeader_reserved_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t LSReplyHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for LSReplyHeader
const TTCN_JSONdescriptor_t LSReplyHeader_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t LSReplyHeader_descr_ = { "@LibItsGeoNetworking_TypesAndValues.LSReplyHeader", NULL, &LSReplyHeader_raw_, NULL, NULL, &LSReplyHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       AnyHeader_seqNumber_xer_ = { {"seqNumber>\n", "seqNumber>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t AnyHeader_seqNumber_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AnyHeader.seqNumber", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &AnyHeader_seqNumber_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       AnyHeader_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t AnyHeader_reserved_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AnyHeader.reserved", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &AnyHeader_reserved_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AnyHeader_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AnyHeader
const TTCN_JSONdescriptor_t AnyHeader_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AnyHeader_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AnyHeader", NULL, &AnyHeader_raw_, NULL, NULL, &AnyHeader_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GnRawPayload_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       GnRawPayload_xer_ = { {"GnRawPayload>\n", "GnRawPayload>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GnRawPayload_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GnRawPayload", &OCTETSTRING_ber_, &GnRawPayload_raw_, &OCTETSTRING_text_, &GnRawPayload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Payload_rawPayload_xer_ = { {"rawPayload>\n", "rawPayload>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Payload_rawPayload_descr_ = { "@LibItsGeoNetworking_TypesAndValues.Payload.rawPayload", &OCTETSTRING_ber_, &GnRawPayload_raw_, &OCTETSTRING_text_, &Payload_rawPayload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t Payload_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for Payload
const TTCN_JSONdescriptor_t Payload_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Payload_descr_ = { "@LibItsGeoNetworking_TypesAndValues.Payload", NULL, &Payload_raw_, NULL, NULL, &Payload_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t DecodedPayload_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for DecodedPayload
const TTCN_JSONdescriptor_t DecodedPayload_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t DecodedPayload_descr_ = { "@LibItsGeoNetworking_TypesAndValues.DecodedPayload", NULL, &DecodedPayload_raw_, NULL, NULL, &DecodedPayload_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoNetworkingPacket_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoNetworkingPacket
const TTCN_JSONdescriptor_t GeoNetworkingPacket_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GeoNetworkingPacket_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket", NULL, &GeoNetworkingPacket_raw_, NULL, NULL, &GeoNetworkingPacket_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoNetworkingPdu_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoNetworkingPdu
const TTCN_JSONdescriptor_t GeoNetworkingPdu_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GeoNetworkingPdu_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu", NULL, &GeoNetworkingPdu_raw_, NULL, NULL, &GeoNetworkingPdu_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoUnicastForwardingAlgorithm_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoUnicastForwardingAlgorithm
const TTCN_Typedescriptor_t GeoUnicastForwardingAlgorithm_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm", NULL, &GeoUnicastForwardingAlgorithm_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeoBroadcastForwardingAlgorithm_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeoBroadcastForwardingAlgorithm
const TTCN_Typedescriptor_t GeoBroadcastForwardingAlgorithm_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm", NULL, &GeoBroadcastForwardingAlgorithm_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GnAddressConfigurationMethod_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GnAddressConfigurationMethod
const TTCN_Typedescriptor_t GnAddressConfigurationMethod_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod", NULL, &GnAddressConfigurationMethod_raw_, NULL, NULL, &ENUMERATED_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t UtGnTrigger_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for UtGnTrigger
const TTCN_JSONdescriptor_t UtGnTrigger_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t UtGnTrigger_descr_ = { "@LibItsGeoNetworking_TypesAndValues.UtGnTrigger", NULL, &UtGnTrigger_raw_, NULL, NULL, &UtGnTrigger_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GenerateGeoUnicastMessage_lifetime_xer_ = { {"lifetime>\n", "lifetime>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GenerateGeoUnicastMessage_lifetime_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.lifetime", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &GenerateGeoUnicastMessage_lifetime_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GenerateGeoUnicastMessage_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GenerateGeoUnicastMessage
const TTCN_JSONdescriptor_t GenerateGeoUnicastMessage_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GenerateGeoUnicastMessage_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage", NULL, &GenerateGeoUnicastMessage_raw_, NULL, NULL, &GenerateGeoUnicastMessage_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GenerateGeoBroadcastMessage_lifetime_xer_ = { {"lifetime>\n", "lifetime>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GenerateGeoBroadcastMessage_lifetime_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.lifetime", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &GenerateGeoBroadcastMessage_lifetime_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GenerateGeoBroadcastMessage_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GenerateGeoBroadcastMessage_reserved_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.reserved", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt24_raw_, &INTEGER_text_, &GenerateGeoBroadcastMessage_reserved_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GenerateGeoBroadcastMessage_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GenerateGeoBroadcastMessage
const TTCN_JSONdescriptor_t GenerateGeoBroadcastMessage_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GenerateGeoBroadcastMessage_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage", NULL, &GenerateGeoBroadcastMessage_raw_, NULL, NULL, &GenerateGeoBroadcastMessage_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GenerateGeoAnycastMessage_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GenerateGeoAnycastMessage
const TTCN_Typedescriptor_t GenerateGeoAnycastMessage_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GenerateGeoAnycastMessage", NULL, &GenerateGeoAnycastMessage_raw_, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GenerateSHBMessage_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GenerateSHBMessage
const TTCN_JSONdescriptor_t GenerateSHBMessage_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GenerateSHBMessage_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage", NULL, &GenerateSHBMessage_raw_, NULL, NULL, &GenerateSHBMessage_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GenerateTSBMessage_nbHops_xer_ = { {"nbHops>\n", "nbHops>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GenerateTSBMessage_nbHops_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.nbHops", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &GenerateTSBMessage_nbHops_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GenerateTSBMessage_lifetime_xer_ = { {"lifetime>\n", "lifetime>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GenerateTSBMessage_lifetime_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.lifetime", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &GenerateTSBMessage_lifetime_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GenerateTSBMessage_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GenerateTSBMessage
const TTCN_JSONdescriptor_t GenerateTSBMessage_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GenerateTSBMessage_descr_ = { "@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage", NULL, &GenerateTSBMessage_raw_, NULL, NULL, &GenerateTSBMessage_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       UtGnTriggerResult_utGnTriggerResult_xer_ = { {"utGnTriggerResult>\n", "utGnTriggerResult>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t UtGnTriggerResult_utGnTriggerResult_descr_ = { "@LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult.utGnTriggerResult", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &UtGnTriggerResult_utGnTriggerResult_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t UtGnTriggerResult_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for UtGnTriggerResult
const TTCN_JSONdescriptor_t UtGnTriggerResult_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t UtGnTriggerResult_descr_ = { "@LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult", NULL, &UtGnTriggerResult_raw_, NULL, NULL, &UtGnTriggerResult_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       UtGnEventInd_rawPayload_xer_ = { {"rawPayload>\n", "rawPayload>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t UtGnEventInd_rawPayload_descr_ = { "@LibItsGeoNetworking_TypesAndValues.UtGnEventInd.rawPayload", &OCTETSTRING_ber_, &GnRawPayload_raw_, &OCTETSTRING_text_, &UtGnEventInd_rawPayload_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t UtGnEventInd_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for UtGnEventInd
const TTCN_JSONdescriptor_t UtGnEventInd_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t UtGnEventInd_descr_ = { "@LibItsGeoNetworking_TypesAndValues.UtGnEventInd", NULL, &UtGnEventInd_raw_, NULL, NULL, &UtGnEventInd_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t UtGnEventIndList_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for UtGnEventIndList
const TTCN_Typedescriptor_t UtGnEventIndList_descr_ = { "@LibItsGeoNetworking_TypesAndValues.UtGnEventIndList", NULL, &UtGnEventIndList_raw_, NULL, NULL, NULL, &UtGnEventInd_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AcGnPrimitive_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AcGnPrimitive
const TTCN_JSONdescriptor_t AcGnPrimitive_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AcGnPrimitive_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive", NULL, &AcGnPrimitive_raw_, NULL, NULL, &AcGnPrimitive_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AcStartBeaconing_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AcStartBeaconing
const TTCN_JSONdescriptor_t AcStartBeaconing_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AcStartBeaconing_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AcStartBeaconing", NULL, &AcStartBeaconing_raw_, NULL, NULL, &AcStartBeaconing_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AcStopBeaconing_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AcStopBeaconing
const TTCN_JSONdescriptor_t AcStopBeaconing_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AcStopBeaconing_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AcStopBeaconing", NULL, &AcStopBeaconing_raw_, NULL, NULL, &AcStopBeaconing_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AcStartPassBeaconing_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AcStartPassBeaconing
const TTCN_JSONdescriptor_t AcStartPassBeaconing_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AcStartPassBeaconing_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing", NULL, &AcStartPassBeaconing_raw_, NULL, NULL, &AcStartPassBeaconing_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AcStopPassBeaconing_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AcStopPassBeaconing
const TTCN_JSONdescriptor_t AcStopPassBeaconing_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AcStopPassBeaconing_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing", NULL, &AcStopPassBeaconing_raw_, NULL, NULL, &AcStopPassBeaconing_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       AcStartBeaconingMultipleNeighbour_numberOfNeighbour_xer_ = { {"numberOfNeighbour>\n", "numberOfNeighbour>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t AcStartBeaconingMultipleNeighbour_numberOfNeighbour_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour.numberOfNeighbour", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &AcStartBeaconingMultipleNeighbour_numberOfNeighbour_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AcStartBeaconingMultipleNeighbour_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AcStartBeaconingMultipleNeighbour
const TTCN_JSONdescriptor_t AcStartBeaconingMultipleNeighbour_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AcStartBeaconingMultipleNeighbour_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour", NULL, &AcStartBeaconingMultipleNeighbour_raw_, NULL, NULL, &AcStartBeaconingMultipleNeighbour_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AcStopBeaconingMultipleNeighbour_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AcStopBeaconingMultipleNeighbour
const TTCN_JSONdescriptor_t AcStopBeaconingMultipleNeighbour_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AcStopBeaconingMultipleNeighbour_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour", NULL, &AcStopBeaconingMultipleNeighbour_raw_, NULL, NULL, &AcStopBeaconingMultipleNeighbour_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AcGetLongPosVector_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AcGetLongPosVector
const TTCN_JSONdescriptor_t AcGetLongPosVector_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AcGetLongPosVector_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector", NULL, &AcGetLongPosVector_raw_, NULL, NULL, &AcGetLongPosVector_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AcGnResponse_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AcGnResponse
const TTCN_JSONdescriptor_t AcGnResponse_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AcGnResponse_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AcGnResponse", NULL, &AcGnResponse_raw_, NULL, NULL, &AcGnResponse_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       AcGnResponseFailure_failure_xer_ = { {"failure>\n", "failure>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t AcGnResponseFailure_failure_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure.failure", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &AcGnResponseFailure_failure_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AcGnResponseFailure_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AcGnResponseFailure
const TTCN_JSONdescriptor_t AcGnResponseFailure_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AcGnResponseFailure_descr_ = { "@LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure", NULL, &AcGnResponseFailure_raw_, NULL, NULL, &AcGnResponseFailure_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const size_t num_namespaces = 0;
TTCN_Module module_object("LibItsGeoNetworking_TypesAndValues", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_5,
  current_runtime_version.requires_minor_version_4,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

TypeOfAddress::TypeOfAddress()
{
enum_value = UNBOUND_VALUE;
}

TypeOfAddress::TypeOfAddress(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

TypeOfAddress::TypeOfAddress(enum_type other_value)
{
enum_value = other_value;
}

TypeOfAddress::TypeOfAddress(const TypeOfAddress& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
enum_value = other_value.enum_value;
}

TypeOfAddress& TypeOfAddress::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

TypeOfAddress& TypeOfAddress::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

TypeOfAddress& TypeOfAddress::operator=(const TypeOfAddress& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
enum_value = other_value.enum_value;
return *this;
}

boolean TypeOfAddress::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
return enum_value == other_value;
}

boolean TypeOfAddress::operator==(const TypeOfAddress& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
return enum_value == other_value.enum_value;
}

boolean TypeOfAddress::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
return enum_value < other_value;
}

boolean TypeOfAddress::operator<(const TypeOfAddress& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
return enum_value < other_value.enum_value;
}

boolean TypeOfAddress::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
return enum_value > other_value;
}

boolean TypeOfAddress::operator>(const TypeOfAddress& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
return enum_value > other_value.enum_value;
}

const char *TypeOfAddress::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__manual: return "e_manual";
case e__initial: return "e_initial";
default: return "<unknown>";
}
}

TypeOfAddress::enum_type TypeOfAddress::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_manual")) return e__manual;
else if (!strcmp(str_par, "e_initial")) return e__initial;
else return UNKNOWN_VALUE;
}

boolean TypeOfAddress::is_valid_enum(int int_par)
{
switch (int_par) {
case 1:
case 0:
return TRUE;
default:
return FALSE;
}
}

int TypeOfAddress::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int TypeOfAddress::enum2int(const TypeOfAddress& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void TypeOfAddress::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.", int_val);
enum_value = (enum_type)int_val;
}

TypeOfAddress::operator TypeOfAddress::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
return enum_value;
}

void TypeOfAddress::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void TypeOfAddress::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsGeoNetworking_TypesAndValues.TypeOfAddress");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
  }
}

Module_Param* TypeOfAddress::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void TypeOfAddress::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
text_buf.push_int(enum_value);
}

void TypeOfAddress::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.", enum_value);
}

void TypeOfAddress::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void TypeOfAddress::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int TypeOfAddress::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 2, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int TypeOfAddress::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 2);
}

int TypeOfAddress::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int TypeOfAddress::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void TypeOfAddress_template::copy_template(const TypeOfAddress_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TypeOfAddress_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
}
}

TypeOfAddress_template::TypeOfAddress_template()
{
}

TypeOfAddress_template::TypeOfAddress_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

TypeOfAddress_template::TypeOfAddress_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!TypeOfAddress::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress with unknown numeric value %d.", other_value);
single_value = (TypeOfAddress::enum_type)other_value;
}

TypeOfAddress_template::TypeOfAddress_template(TypeOfAddress::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

TypeOfAddress_template::TypeOfAddress_template(const TypeOfAddress& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == TypeOfAddress::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
single_value = other_value.enum_value;
}

TypeOfAddress_template::TypeOfAddress_template(const OPTIONAL<TypeOfAddress>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (TypeOfAddress::enum_type)(const TypeOfAddress&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress from an unbound optional field.");
}
}

TypeOfAddress_template::TypeOfAddress_template(const TypeOfAddress_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

TypeOfAddress_template::~TypeOfAddress_template()
{
clean_up();
}

boolean TypeOfAddress_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean TypeOfAddress_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != TypeOfAddress::UNBOUND_VALUE;
}

void TypeOfAddress_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

TypeOfAddress_template& TypeOfAddress_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TypeOfAddress_template& TypeOfAddress_template::operator=(int other_value)
{
if (!TypeOfAddress::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (TypeOfAddress::enum_type)other_value;
return *this;
}

TypeOfAddress_template& TypeOfAddress_template::operator=(TypeOfAddress::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

TypeOfAddress_template& TypeOfAddress_template::operator=(const TypeOfAddress& other_value)
{
if (other_value.enum_value == TypeOfAddress::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

TypeOfAddress_template& TypeOfAddress_template::operator=(const OPTIONAL<TypeOfAddress>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (TypeOfAddress::enum_type)(const TypeOfAddress&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
}
return *this;
}

TypeOfAddress_template& TypeOfAddress_template::operator=(const TypeOfAddress_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean TypeOfAddress_template::match(TypeOfAddress::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
}
return FALSE;
}

boolean TypeOfAddress_template::match(const TypeOfAddress& other_value, boolean) const
{
if (other_value.enum_value == TypeOfAddress::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress with an unbound value.");
return match(other_value.enum_value);
}

TypeOfAddress::enum_type TypeOfAddress_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
return single_value;
}

void TypeOfAddress_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new TypeOfAddress_template[list_length];
}

TypeOfAddress_template& TypeOfAddress_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
return value_list.list_value[list_index];
}

void TypeOfAddress_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(TypeOfAddress::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void TypeOfAddress_template::log_match(const TypeOfAddress& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void TypeOfAddress_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
}
}

void TypeOfAddress_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (TypeOfAddress::enum_type)text_buf.pull_int().get_val();
if (!TypeOfAddress::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TypeOfAddress_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
}
}

boolean TypeOfAddress_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TypeOfAddress_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void TypeOfAddress_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    TypeOfAddress::enum_type enum_val = (enum_name != NULL) ? TypeOfAddress::str_to_enum(enum_name) : TypeOfAddress::UNKNOWN_VALUE;
    if (TypeOfAddress::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TypeOfAddress_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    TypeOfAddress::enum_type enum_val = TypeOfAddress::str_to_enum(mp->get_enumerated());
    if (!TypeOfAddress::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.TypeOfAddress.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsGeoNetworking_TypesAndValues.TypeOfAddress");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* TypeOfAddress_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(TypeOfAddress::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void TypeOfAddress_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.TypeOfAddress");
}

StationType::StationType()
{
enum_value = UNBOUND_VALUE;
}

StationType::StationType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

StationType::StationType(enum_type other_value)
{
enum_value = other_value;
}

StationType::StationType(const StationType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
enum_value = other_value.enum_value;
}

StationType& StationType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

StationType& StationType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

StationType& StationType::operator=(const StationType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
enum_value = other_value.enum_value;
return *this;
}

boolean StationType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
return enum_value == other_value;
}

boolean StationType::operator==(const StationType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
return enum_value == other_value.enum_value;
}

boolean StationType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
return enum_value < other_value;
}

boolean StationType::operator<(const StationType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
return enum_value < other_value.enum_value;
}

boolean StationType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
return enum_value > other_value;
}

boolean StationType::operator>(const StationType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
return enum_value > other_value.enum_value;
}

const char *StationType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__unknown: return "e_unknown";
case e__pedestrian: return "e_pedestrian";
case e__cyclist: return "e_cyclist";
case e__moped: return "e_moped";
case e__motorcycle: return "e_motorcycle";
case e__passengerCar: return "e_passengerCar";
case e__bus: return "e_bus";
case e__lightTruck: return "e_lightTruck";
case e__heavyTruck: return "e_heavyTruck";
case e__trailer: return "e_trailer";
case e__specialVehicle: return "e_specialVehicle";
case e__tram: return "e_tram";
case e__roadSideUnit: return "e_roadSideUnit";
default: return "<unknown>";
}
}

StationType::enum_type StationType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_unknown")) return e__unknown;
else if (!strcmp(str_par, "e_pedestrian")) return e__pedestrian;
else if (!strcmp(str_par, "e_cyclist")) return e__cyclist;
else if (!strcmp(str_par, "e_moped")) return e__moped;
else if (!strcmp(str_par, "e_motorcycle")) return e__motorcycle;
else if (!strcmp(str_par, "e_passengerCar")) return e__passengerCar;
else if (!strcmp(str_par, "e_bus")) return e__bus;
else if (!strcmp(str_par, "e_lightTruck")) return e__lightTruck;
else if (!strcmp(str_par, "e_heavyTruck")) return e__heavyTruck;
else if (!strcmp(str_par, "e_trailer")) return e__trailer;
else if (!strcmp(str_par, "e_specialVehicle")) return e__specialVehicle;
else if (!strcmp(str_par, "e_tram")) return e__tram;
else if (!strcmp(str_par, "e_roadSideUnit")) return e__roadSideUnit;
else return UNKNOWN_VALUE;
}

boolean StationType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 15:
return TRUE;
default:
return FALSE;
}
}

int StationType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int StationType::enum2int(const StationType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void StationType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.", int_val);
enum_value = (enum_type)int_val;
}

StationType::operator StationType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
return enum_value;
}

void StationType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void StationType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsGeoNetworking_TypesAndValues.StationType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.StationType.");
  }
}

Module_Param* StationType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void StationType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
text_buf.push_int(enum_value);
}

void StationType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.", enum_value);
}

void StationType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void StationType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int StationType::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 4, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int StationType::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 4);
}

int StationType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int StationType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void StationType_template::copy_template(const StationType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new StationType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
}
}

StationType_template::StationType_template()
{
}

StationType_template::StationType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

StationType_template::StationType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!StationType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType with unknown numeric value %d.", other_value);
single_value = (StationType::enum_type)other_value;
}

StationType_template::StationType_template(StationType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

StationType_template::StationType_template(const StationType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == StationType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
single_value = other_value.enum_value;
}

StationType_template::StationType_template(const OPTIONAL<StationType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (StationType::enum_type)(const StationType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType from an unbound optional field.");
}
}

StationType_template::StationType_template(const StationType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

StationType_template::~StationType_template()
{
clean_up();
}

boolean StationType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean StationType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != StationType::UNBOUND_VALUE;
}

void StationType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

StationType_template& StationType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

StationType_template& StationType_template::operator=(int other_value)
{
if (!StationType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (StationType::enum_type)other_value;
return *this;
}

StationType_template& StationType_template::operator=(StationType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

StationType_template& StationType_template::operator=(const StationType& other_value)
{
if (other_value.enum_value == StationType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

StationType_template& StationType_template::operator=(const OPTIONAL<StationType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (StationType::enum_type)(const StationType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
}
return *this;
}

StationType_template& StationType_template::operator=(const StationType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean StationType_template::match(StationType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
}
return FALSE;
}

boolean StationType_template::match(const StationType& other_value, boolean) const
{
if (other_value.enum_value == StationType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType with an unbound value.");
return match(other_value.enum_value);
}

StationType::enum_type StationType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
return single_value;
}

void StationType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new StationType_template[list_length];
}

StationType_template& StationType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
return value_list.list_value[list_index];
}

void StationType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(StationType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void StationType_template::log_match(const StationType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void StationType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
}
}

void StationType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (StationType::enum_type)text_buf.pull_int().get_val();
if (!StationType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new StationType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.StationType.");
}
}

boolean StationType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean StationType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void StationType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    StationType::enum_type enum_val = (enum_name != NULL) ? StationType::str_to_enum(enum_name) : StationType::UNKNOWN_VALUE;
    if (StationType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    StationType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    StationType::enum_type enum_val = StationType::str_to_enum(mp->get_enumerated());
    if (!StationType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.StationType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsGeoNetworking_TypesAndValues.StationType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* StationType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(StationType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void StationType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.StationType");
}

GN__Address::GN__Address()
{
  bound_flag = FALSE;
}

GN__Address::GN__Address(const TypeOfAddress& par_typeOfAddress,
    const StationType& par_stationType,
    const INTEGER& par_stationCountryCode,
    const OCTETSTRING& par_mid)
  :   field_typeOfAddress(par_typeOfAddress),
  field_stationType(par_stationType),
  field_stationCountryCode(par_stationCountryCode),
  field_mid(par_mid)
{
  bound_flag = TRUE;
}

GN__Address::GN__Address(const GN__Address& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
bound_flag = TRUE;
if (other_value.typeOfAddress().is_bound()) field_typeOfAddress = other_value.typeOfAddress();
else field_typeOfAddress.clean_up();
if (other_value.stationType().is_bound()) field_stationType = other_value.stationType();
else field_stationType.clean_up();
if (other_value.stationCountryCode().is_bound()) field_stationCountryCode = other_value.stationCountryCode();
else field_stationCountryCode.clean_up();
if (other_value.mid().is_bound()) field_mid = other_value.mid();
else field_mid.clean_up();
}

void GN__Address::clean_up()
{
field_typeOfAddress.clean_up();
field_stationType.clean_up();
field_stationCountryCode.clean_up();
field_mid.clean_up();
bound_flag = FALSE;
}

GN__Address& GN__Address::operator=(const GN__Address& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
  bound_flag = TRUE;
  if (other_value.typeOfAddress().is_bound()) field_typeOfAddress = other_value.typeOfAddress();
  else field_typeOfAddress.clean_up();
  if (other_value.stationType().is_bound()) field_stationType = other_value.stationType();
  else field_stationType.clean_up();
  if (other_value.stationCountryCode().is_bound()) field_stationCountryCode = other_value.stationCountryCode();
  else field_stationCountryCode.clean_up();
  if (other_value.mid().is_bound()) field_mid = other_value.mid();
  else field_mid.clean_up();
}
return *this;
}

boolean GN__Address::operator==(const GN__Address& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_typeOfAddress==other_value.field_typeOfAddress
  && field_stationType==other_value.field_stationType
  && field_stationCountryCode==other_value.field_stationCountryCode
  && field_mid==other_value.field_mid;
}

boolean GN__Address::is_bound() const
{
if (bound_flag) return TRUE;
if(field_typeOfAddress.is_bound()) return TRUE;
if(field_stationType.is_bound()) return TRUE;
if(field_stationCountryCode.is_bound()) return TRUE;
if(field_mid.is_bound()) return TRUE;
return FALSE;
}
boolean GN__Address::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_typeOfAddress.is_value()) return FALSE;
if(!field_stationType.is_value()) return FALSE;
if(!field_stationCountryCode.is_value()) return FALSE;
if(!field_mid.is_value()) return FALSE;
return TRUE;
}
int GN__Address::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GN_Address");
  return 4;
}

void GN__Address::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ typeOfAddress := ");
field_typeOfAddress.log();
TTCN_Logger::log_event_str(", stationType := ");
field_stationType.log();
TTCN_Logger::log_event_str(", stationCountryCode := ");
field_stationCountryCode.log();
TTCN_Logger::log_event_str(", mid := ");
field_mid.log();
TTCN_Logger::log_event_str(" }");
}

void GN__Address::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.GN_Address'");
    }
    if (strcmp("typeOfAddress", param_field) == 0) {
      typeOfAddress().set_param(param);
      return;
    } else if (strcmp("stationType", param_field) == 0) {
      stationType().set_param(param);
      return;
    } else if (strcmp("stationCountryCode", param_field) == 0) {
      stationCountryCode().set_param(param);
      return;
    } else if (strcmp("mid", param_field) == 0) {
      mid().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GN_Address'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.GN_Address has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) typeOfAddress().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) stationType().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) stationCountryCode().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) mid().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "typeOfAddress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          typeOfAddress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationCountryCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationCountryCode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mid")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mid().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GN_Address: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.GN_Address");
  }
}

Module_Param* GN__Address::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.GN_Address'");
    }
    if (strcmp("typeOfAddress", param_field) == 0) {
      return typeOfAddress().get_param(param_name);
    } else if (strcmp("stationType", param_field) == 0) {
      return stationType().get_param(param_name);
    } else if (strcmp("stationCountryCode", param_field) == 0) {
      return stationCountryCode().get_param(param_name);
    } else if (strcmp("mid", param_field) == 0) {
      return mid().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GN_Address'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_typeOfAddress = field_typeOfAddress.get_param(param_name);
  mp_field_typeOfAddress->set_id(new Module_Param_FieldName(mcopystr("typeOfAddress")));
  mp->add_elem(mp_field_typeOfAddress);
  Module_Param* mp_field_stationType = field_stationType.get_param(param_name);
  mp_field_stationType->set_id(new Module_Param_FieldName(mcopystr("stationType")));
  mp->add_elem(mp_field_stationType);
  Module_Param* mp_field_stationCountryCode = field_stationCountryCode.get_param(param_name);
  mp_field_stationCountryCode->set_id(new Module_Param_FieldName(mcopystr("stationCountryCode")));
  mp->add_elem(mp_field_stationCountryCode);
  Module_Param* mp_field_mid = field_mid.get_param(param_name);
  mp_field_mid->set_id(new Module_Param_FieldName(mcopystr("mid")));
  mp->add_elem(mp_field_mid);
  return mp;
  }

void GN__Address::set_implicit_omit()
{
if (typeOfAddress().is_bound()) typeOfAddress().set_implicit_omit();
if (stationType().is_bound()) stationType().set_implicit_omit();
if (stationCountryCode().is_bound()) stationCountryCode().set_implicit_omit();
if (mid().is_bound()) mid().set_implicit_omit();
}

void GN__Address::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
field_typeOfAddress.encode_text(text_buf);
field_stationType.encode_text(text_buf);
field_stationCountryCode.encode_text(text_buf);
field_mid.encode_text(text_buf);
}

void GN__Address::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_typeOfAddress.decode_text(text_buf);
field_stationType.decode_text(text_buf);
field_stationCountryCode.decode_text(text_buf);
field_mid.decode_text(text_buf);
}

void GN__Address::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GN__Address::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GN__Address::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_typeOfAddress.RAW_decode(TypeOfAddress_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_stationType.RAW_decode(StationType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_stationCountryCode.RAW_decode(LibCommon__BasicTypesAndValues::UInt10_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_mid.RAW_decode(LibCommon__DataStrings::Oct6_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GN__Address::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 4;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(4);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, TypeOfAddress_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, StationType_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__BasicTypesAndValues::UInt10_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, LibCommon__DataStrings::Oct6_descr_.raw);
  encoded_length += field_typeOfAddress.RAW_encode(TypeOfAddress_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_stationType.RAW_encode(StationType_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_stationCountryCode.RAW_encode(LibCommon__BasicTypesAndValues::UInt10_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_mid.RAW_encode(LibCommon__DataStrings::Oct6_descr_, *myleaf.body.node.nodes[3]);
  return myleaf.length = encoded_length;
}

int GN__Address::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "typeOfAddress");
    enc_len += field_typeOfAddress.JSON_encode(TypeOfAddress_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "stationType");
    enc_len += field_stationType.JSON_encode(StationType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "stationCountryCode");
    enc_len += field_stationCountryCode.JSON_encode(LibCommon__BasicTypesAndValues::UInt10_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "mid");
    enc_len += field_mid.JSON_encode(LibCommon__DataStrings::Oct6_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GN__Address::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (13 == name_len && 0 == strncmp(fld_name, "typeOfAddress", name_len)) {
         int ret_val = field_typeOfAddress.JSON_decode(TypeOfAddress_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "typeOfAddress");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "stationType", name_len)) {
         int ret_val = field_stationType.JSON_decode(StationType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "stationType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "stationCountryCode", name_len)) {
         int ret_val = field_stationCountryCode.JSON_decode(LibCommon__BasicTypesAndValues::UInt10_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "stationCountryCode");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (3 == name_len && 0 == strncmp(fld_name, "mid", name_len)) {
         int ret_val = field_mid.JSON_decode(LibCommon__DataStrings::Oct6_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "mid");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_typeOfAddress.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "typeOfAddress");
    return JSON_ERROR_FATAL;
  }
if (!field_stationType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "stationType");
    return JSON_ERROR_FATAL;
  }
if (!field_stationCountryCode.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "stationCountryCode");
    return JSON_ERROR_FATAL;
  }
if (!field_mid.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "mid");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GN__Address_template::single_value_struct {
TypeOfAddress_template field_typeOfAddress;
StationType_template field_stationType;
INTEGER_template field_stationCountryCode;
OCTETSTRING_template field_mid;
};

void GN__Address_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_typeOfAddress = ANY_VALUE;
single_value->field_stationType = ANY_VALUE;
single_value->field_stationCountryCode = ANY_VALUE;
single_value->field_mid = ANY_VALUE;
}
}
}

void GN__Address_template::copy_value(const GN__Address& other_value)
{
single_value = new single_value_struct;
if (other_value.typeOfAddress().is_bound()) {
  single_value->field_typeOfAddress = other_value.typeOfAddress();
} else {
  single_value->field_typeOfAddress.clean_up();
}
if (other_value.stationType().is_bound()) {
  single_value->field_stationType = other_value.stationType();
} else {
  single_value->field_stationType.clean_up();
}
if (other_value.stationCountryCode().is_bound()) {
  single_value->field_stationCountryCode = other_value.stationCountryCode();
} else {
  single_value->field_stationCountryCode.clean_up();
}
if (other_value.mid().is_bound()) {
  single_value->field_mid = other_value.mid();
} else {
  single_value->field_mid.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GN__Address_template::copy_template(const GN__Address_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.typeOfAddress().get_selection()) {
single_value->field_typeOfAddress = other_value.typeOfAddress();
} else {
single_value->field_typeOfAddress.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.stationType().get_selection()) {
single_value->field_stationType = other_value.stationType();
} else {
single_value->field_stationType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.stationCountryCode().get_selection()) {
single_value->field_stationCountryCode = other_value.stationCountryCode();
} else {
single_value->field_stationCountryCode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.mid().get_selection()) {
single_value->field_mid = other_value.mid();
} else {
single_value->field_mid.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GN__Address_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
break;
}
set_selection(other_value);
}

GN__Address_template::GN__Address_template()
{
}

GN__Address_template::GN__Address_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GN__Address_template::GN__Address_template(const GN__Address& other_value)
{
copy_value(other_value);
}

GN__Address_template::GN__Address_template(const OPTIONAL<GN__Address>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GN__Address&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GN_Address from an unbound optional field.");
}
}

GN__Address_template::GN__Address_template(const GN__Address_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GN__Address_template::~GN__Address_template()
{
clean_up();
}

GN__Address_template& GN__Address_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GN__Address_template& GN__Address_template::operator=(const GN__Address& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GN__Address_template& GN__Address_template::operator=(const OPTIONAL<GN__Address>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GN__Address&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
}
return *this;
}

GN__Address_template& GN__Address_template::operator=(const GN__Address_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GN__Address_template::match(const GN__Address& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.typeOfAddress().is_bound()) return FALSE;
if(!single_value->field_typeOfAddress.match(other_value.typeOfAddress(), legacy))return FALSE;
if(!other_value.stationType().is_bound()) return FALSE;
if(!single_value->field_stationType.match(other_value.stationType(), legacy))return FALSE;
if(!other_value.stationCountryCode().is_bound()) return FALSE;
if(!single_value->field_stationCountryCode.match(other_value.stationCountryCode(), legacy))return FALSE;
if(!other_value.mid().is_bound()) return FALSE;
if(!single_value->field_mid.match(other_value.mid(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
}
return FALSE;
}

boolean GN__Address_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_typeOfAddress.is_bound()) return TRUE;
if (single_value->field_stationType.is_bound()) return TRUE;
if (single_value->field_stationCountryCode.is_bound()) return TRUE;
if (single_value->field_mid.is_bound()) return TRUE;
return FALSE;
}

boolean GN__Address_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_typeOfAddress.is_value()) return FALSE;
if (!single_value->field_stationType.is_value()) return FALSE;
if (!single_value->field_stationCountryCode.is_value()) return FALSE;
if (!single_value->field_mid.is_value()) return FALSE;
return TRUE;
}

void GN__Address_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GN__Address GN__Address_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
GN__Address ret_val;
if (single_value->field_typeOfAddress.is_bound()) {
ret_val.typeOfAddress() = single_value->field_typeOfAddress.valueof();
}
if (single_value->field_stationType.is_bound()) {
ret_val.stationType() = single_value->field_stationType.valueof();
}
if (single_value->field_stationCountryCode.is_bound()) {
ret_val.stationCountryCode() = single_value->field_stationCountryCode.valueof();
}
if (single_value->field_mid.is_bound()) {
ret_val.mid() = single_value->field_mid.valueof();
}
return ret_val;
}

void GN__Address_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GN__Address_template[list_length];
}

GN__Address_template& GN__Address_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
return value_list.list_value[list_index];
}

TypeOfAddress_template& GN__Address_template::typeOfAddress()
{
set_specific();
return single_value->field_typeOfAddress;
}

const TypeOfAddress_template& GN__Address_template::typeOfAddress() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field typeOfAddress of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
return single_value->field_typeOfAddress;
}

StationType_template& GN__Address_template::stationType()
{
set_specific();
return single_value->field_stationType;
}

const StationType_template& GN__Address_template::stationType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stationType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
return single_value->field_stationType;
}

INTEGER_template& GN__Address_template::stationCountryCode()
{
set_specific();
return single_value->field_stationCountryCode;
}

const INTEGER_template& GN__Address_template::stationCountryCode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stationCountryCode of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
return single_value->field_stationCountryCode;
}

OCTETSTRING_template& GN__Address_template::mid()
{
set_specific();
return single_value->field_mid;
}

const OCTETSTRING_template& GN__Address_template::mid() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field mid of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
return single_value->field_mid;
}

int GN__Address_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GN_Address which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 4;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GN_Address containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GN_Address containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GN_Address containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GN_Address containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GN_Address containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
  }
  return 0;
}

void GN__Address_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ typeOfAddress := ");
single_value->field_typeOfAddress.log();
TTCN_Logger::log_event_str(", stationType := ");
single_value->field_stationType.log();
TTCN_Logger::log_event_str(", stationCountryCode := ");
single_value->field_stationCountryCode.log();
TTCN_Logger::log_event_str(", mid := ");
single_value->field_mid.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GN__Address_template::log_match(const GN__Address& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_typeOfAddress.match(match_value.typeOfAddress(), legacy)){
TTCN_Logger::log_logmatch_info(".typeOfAddress");
single_value->field_typeOfAddress.log_match(match_value.typeOfAddress(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_stationType.match(match_value.stationType(), legacy)){
TTCN_Logger::log_logmatch_info(".stationType");
single_value->field_stationType.log_match(match_value.stationType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_stationCountryCode.match(match_value.stationCountryCode(), legacy)){
TTCN_Logger::log_logmatch_info(".stationCountryCode");
single_value->field_stationCountryCode.log_match(match_value.stationCountryCode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_mid.match(match_value.mid(), legacy)){
TTCN_Logger::log_logmatch_info(".mid");
single_value->field_mid.log_match(match_value.mid(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ typeOfAddress := ");
single_value->field_typeOfAddress.log_match(match_value.typeOfAddress(), legacy);
TTCN_Logger::log_event_str(", stationType := ");
single_value->field_stationType.log_match(match_value.stationType(), legacy);
TTCN_Logger::log_event_str(", stationCountryCode := ");
single_value->field_stationCountryCode.log_match(match_value.stationCountryCode(), legacy);
TTCN_Logger::log_event_str(", mid := ");
single_value->field_mid.log_match(match_value.mid(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GN__Address_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_typeOfAddress.encode_text(text_buf);
single_value->field_stationType.encode_text(text_buf);
single_value->field_stationCountryCode.encode_text(text_buf);
single_value->field_mid.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
}
}

void GN__Address_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_typeOfAddress.decode_text(text_buf);
single_value->field_stationType.decode_text(text_buf);
single_value->field_stationCountryCode.decode_text(text_buf);
single_value->field_mid.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GN__Address_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.GN_Address.");
}
}

void GN__Address_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.GN_Address'");
    }
    if (strcmp("typeOfAddress", param_field) == 0) {
      typeOfAddress().set_param(param);
      return;
    } else if (strcmp("stationType", param_field) == 0) {
      stationType().set_param(param);
      return;
    } else if (strcmp("stationCountryCode", param_field) == 0) {
      stationCountryCode().set_param(param);
      return;
    } else if (strcmp("mid", param_field) == 0) {
      mid().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.GN_Address'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GN__Address_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.GN_Address has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) typeOfAddress().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) stationType().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) stationCountryCode().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) mid().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "typeOfAddress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          typeOfAddress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationCountryCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationCountryCode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "mid")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          mid().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GN_Address: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.GN_Address");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GN__Address_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.GN_Address'");
    }
    if (strcmp("typeOfAddress", param_field) == 0) {
      return typeOfAddress().get_param(param_name);
    } else if (strcmp("stationType", param_field) == 0) {
      return stationType().get_param(param_name);
    } else if (strcmp("stationCountryCode", param_field) == 0) {
      return stationCountryCode().get_param(param_name);
    } else if (strcmp("mid", param_field) == 0) {
      return mid().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GN_Address'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_typeOfAddress = single_value->field_typeOfAddress.get_param(param_name);
    mp_field_typeOfAddress->set_id(new Module_Param_FieldName(mcopystr("typeOfAddress")));
    mp->add_elem(mp_field_typeOfAddress);
    Module_Param* mp_field_stationType = single_value->field_stationType.get_param(param_name);
    mp_field_stationType->set_id(new Module_Param_FieldName(mcopystr("stationType")));
    mp->add_elem(mp_field_stationType);
    Module_Param* mp_field_stationCountryCode = single_value->field_stationCountryCode.get_param(param_name);
    mp_field_stationCountryCode->set_id(new Module_Param_FieldName(mcopystr("stationCountryCode")));
    mp->add_elem(mp_field_stationCountryCode);
    Module_Param* mp_field_mid = single_value->field_mid.get_param(param_name);
    mp_field_mid->set_id(new Module_Param_FieldName(mcopystr("mid")));
    mp->add_elem(mp_field_mid);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GN__Address_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_typeOfAddress.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GN_Address");
single_value->field_stationType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GN_Address");
single_value->field_stationCountryCode.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GN_Address");
single_value->field_mid.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GN_Address");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GN_Address");
}

boolean GN__Address_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GN__Address_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

LongPosVector::LongPosVector()
{
  bound_flag = FALSE;
}

LongPosVector::LongPosVector(const GN__Address& par_gnAddr,
    const INTEGER& par_timestamp,
    const INTEGER& par_latitude,
    const INTEGER& par_longitude,
    const BITSTRING& par_pai,
    const INTEGER& par_speed,
    const INTEGER& par_heading)
  :   field_gnAddr(par_gnAddr),
  field_timestamp(par_timestamp),
  field_latitude(par_latitude),
  field_longitude(par_longitude),
  field_pai(par_pai),
  field_speed(par_speed),
  field_heading(par_heading)
{
  bound_flag = TRUE;
}

LongPosVector::LongPosVector(const LongPosVector& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
bound_flag = TRUE;
if (other_value.gnAddr().is_bound()) field_gnAddr = other_value.gnAddr();
else field_gnAddr.clean_up();
if (other_value.timestamp().is_bound()) field_timestamp = other_value.timestamp();
else field_timestamp.clean_up();
if (other_value.latitude().is_bound()) field_latitude = other_value.latitude();
else field_latitude.clean_up();
if (other_value.longitude().is_bound()) field_longitude = other_value.longitude();
else field_longitude.clean_up();
if (other_value.pai().is_bound()) field_pai = other_value.pai();
else field_pai.clean_up();
if (other_value.speed().is_bound()) field_speed = other_value.speed();
else field_speed.clean_up();
if (other_value.heading().is_bound()) field_heading = other_value.heading();
else field_heading.clean_up();
}

void LongPosVector::clean_up()
{
field_gnAddr.clean_up();
field_timestamp.clean_up();
field_latitude.clean_up();
field_longitude.clean_up();
field_pai.clean_up();
field_speed.clean_up();
field_heading.clean_up();
bound_flag = FALSE;
}

LongPosVector& LongPosVector::operator=(const LongPosVector& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
  bound_flag = TRUE;
  if (other_value.gnAddr().is_bound()) field_gnAddr = other_value.gnAddr();
  else field_gnAddr.clean_up();
  if (other_value.timestamp().is_bound()) field_timestamp = other_value.timestamp();
  else field_timestamp.clean_up();
  if (other_value.latitude().is_bound()) field_latitude = other_value.latitude();
  else field_latitude.clean_up();
  if (other_value.longitude().is_bound()) field_longitude = other_value.longitude();
  else field_longitude.clean_up();
  if (other_value.pai().is_bound()) field_pai = other_value.pai();
  else field_pai.clean_up();
  if (other_value.speed().is_bound()) field_speed = other_value.speed();
  else field_speed.clean_up();
  if (other_value.heading().is_bound()) field_heading = other_value.heading();
  else field_heading.clean_up();
}
return *this;
}

boolean LongPosVector::operator==(const LongPosVector& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_gnAddr==other_value.field_gnAddr
  && field_timestamp==other_value.field_timestamp
  && field_latitude==other_value.field_latitude
  && field_longitude==other_value.field_longitude
  && field_pai==other_value.field_pai
  && field_speed==other_value.field_speed
  && field_heading==other_value.field_heading;
}

boolean LongPosVector::is_bound() const
{
if (bound_flag) return TRUE;
if(field_gnAddr.is_bound()) return TRUE;
if(field_timestamp.is_bound()) return TRUE;
if(field_latitude.is_bound()) return TRUE;
if(field_longitude.is_bound()) return TRUE;
if(field_pai.is_bound()) return TRUE;
if(field_speed.is_bound()) return TRUE;
if(field_heading.is_bound()) return TRUE;
return FALSE;
}
boolean LongPosVector::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_gnAddr.is_value()) return FALSE;
if(!field_timestamp.is_value()) return FALSE;
if(!field_latitude.is_value()) return FALSE;
if(!field_longitude.is_value()) return FALSE;
if(!field_pai.is_value()) return FALSE;
if(!field_speed.is_value()) return FALSE;
if(!field_heading.is_value()) return FALSE;
return TRUE;
}
int LongPosVector::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.LongPosVector");
  return 7;
}

void LongPosVector::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ gnAddr := ");
field_gnAddr.log();
TTCN_Logger::log_event_str(", timestamp := ");
field_timestamp.log();
TTCN_Logger::log_event_str(", latitude := ");
field_latitude.log();
TTCN_Logger::log_event_str(", longitude := ");
field_longitude.log();
TTCN_Logger::log_event_str(", pai := ");
field_pai.log();
TTCN_Logger::log_event_str(", speed := ");
field_speed.log();
TTCN_Logger::log_event_str(", heading := ");
field_heading.log();
TTCN_Logger::log_event_str(" }");
}

void LongPosVector::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.LongPosVector'");
    }
    if (strcmp("gnAddr", param_field) == 0) {
      gnAddr().set_param(param);
      return;
    } else if (strcmp("timestamp", param_field) == 0) {
      timestamp().set_param(param);
      return;
    } else if (strcmp("latitude", param_field) == 0) {
      latitude().set_param(param);
      return;
    } else if (strcmp("longitude", param_field) == 0) {
      longitude().set_param(param);
      return;
    } else if (strcmp("pai", param_field) == 0) {
      pai().set_param(param);
      return;
    } else if (strcmp("speed", param_field) == 0) {
      speed().set_param(param);
      return;
    } else if (strcmp("heading", param_field) == 0) {
      heading().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.LongPosVector'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (7<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.LongPosVector has 7 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) gnAddr().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) timestamp().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) latitude().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) longitude().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) pai().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) speed().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) heading().set_param(*mp->get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnAddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnAddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "timestamp")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          timestamp().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "latitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          latitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "longitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          longitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pai")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pai().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speed().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "heading")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          heading().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.LongPosVector: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.LongPosVector");
  }
}

Module_Param* LongPosVector::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.LongPosVector'");
    }
    if (strcmp("gnAddr", param_field) == 0) {
      return gnAddr().get_param(param_name);
    } else if (strcmp("timestamp", param_field) == 0) {
      return timestamp().get_param(param_name);
    } else if (strcmp("latitude", param_field) == 0) {
      return latitude().get_param(param_name);
    } else if (strcmp("longitude", param_field) == 0) {
      return longitude().get_param(param_name);
    } else if (strcmp("pai", param_field) == 0) {
      return pai().get_param(param_name);
    } else if (strcmp("speed", param_field) == 0) {
      return speed().get_param(param_name);
    } else if (strcmp("heading", param_field) == 0) {
      return heading().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.LongPosVector'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_gnAddr = field_gnAddr.get_param(param_name);
  mp_field_gnAddr->set_id(new Module_Param_FieldName(mcopystr("gnAddr")));
  mp->add_elem(mp_field_gnAddr);
  Module_Param* mp_field_timestamp = field_timestamp.get_param(param_name);
  mp_field_timestamp->set_id(new Module_Param_FieldName(mcopystr("timestamp")));
  mp->add_elem(mp_field_timestamp);
  Module_Param* mp_field_latitude = field_latitude.get_param(param_name);
  mp_field_latitude->set_id(new Module_Param_FieldName(mcopystr("latitude")));
  mp->add_elem(mp_field_latitude);
  Module_Param* mp_field_longitude = field_longitude.get_param(param_name);
  mp_field_longitude->set_id(new Module_Param_FieldName(mcopystr("longitude")));
  mp->add_elem(mp_field_longitude);
  Module_Param* mp_field_pai = field_pai.get_param(param_name);
  mp_field_pai->set_id(new Module_Param_FieldName(mcopystr("pai")));
  mp->add_elem(mp_field_pai);
  Module_Param* mp_field_speed = field_speed.get_param(param_name);
  mp_field_speed->set_id(new Module_Param_FieldName(mcopystr("speed")));
  mp->add_elem(mp_field_speed);
  Module_Param* mp_field_heading = field_heading.get_param(param_name);
  mp_field_heading->set_id(new Module_Param_FieldName(mcopystr("heading")));
  mp->add_elem(mp_field_heading);
  return mp;
  }

void LongPosVector::set_implicit_omit()
{
if (gnAddr().is_bound()) gnAddr().set_implicit_omit();
if (timestamp().is_bound()) timestamp().set_implicit_omit();
if (latitude().is_bound()) latitude().set_implicit_omit();
if (longitude().is_bound()) longitude().set_implicit_omit();
if (pai().is_bound()) pai().set_implicit_omit();
if (speed().is_bound()) speed().set_implicit_omit();
if (heading().is_bound()) heading().set_implicit_omit();
}

void LongPosVector::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
field_gnAddr.encode_text(text_buf);
field_timestamp.encode_text(text_buf);
field_latitude.encode_text(text_buf);
field_longitude.encode_text(text_buf);
field_pai.encode_text(text_buf);
field_speed.encode_text(text_buf);
field_heading.encode_text(text_buf);
}

void LongPosVector::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_gnAddr.decode_text(text_buf);
field_timestamp.decode_text(text_buf);
field_latitude.decode_text(text_buf);
field_longitude.decode_text(text_buf);
field_pai.decode_text(text_buf);
field_speed.decode_text(text_buf);
field_heading.decode_text(text_buf);
}

void LongPosVector::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void LongPosVector::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int LongPosVector::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_gnAddr.RAW_decode(GN__Address_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_timestamp.RAW_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_latitude.RAW_decode(LibCommon__BasicTypesAndValues::Int32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_longitude.RAW_decode(LibCommon__BasicTypesAndValues::Int32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_pai.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_speed.RAW_decode(LibCommon__BasicTypesAndValues::Int15_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_heading.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int LongPosVector::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 7;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(7);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, GN__Address_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt32_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__BasicTypesAndValues::Int32_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, LibCommon__BasicTypesAndValues::Int32_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, LibCommon__BasicTypesAndValues::Int15_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  encoded_length += field_gnAddr.RAW_encode(GN__Address_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_timestamp.RAW_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_latitude.RAW_encode(LibCommon__BasicTypesAndValues::Int32_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_longitude.RAW_encode(LibCommon__BasicTypesAndValues::Int32_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_pai.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_speed.RAW_encode(LibCommon__BasicTypesAndValues::Int15_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_heading.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[6]);
  return myleaf.length = encoded_length;
}

int LongPosVector::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnAddr");
    enc_len += field_gnAddr.JSON_encode(GN__Address_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "timestamp");
    enc_len += field_timestamp.JSON_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "latitude");
    enc_len += field_latitude.JSON_encode(LibCommon__BasicTypesAndValues::Int32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "longitude");
    enc_len += field_longitude.JSON_encode(LibCommon__BasicTypesAndValues::Int32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "pai");
    enc_len += field_pai.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "speed");
    enc_len += field_speed.JSON_encode(LibCommon__BasicTypesAndValues::Int15_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "heading");
    enc_len += field_heading.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int LongPosVector::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (6 == name_len && 0 == strncmp(fld_name, "gnAddr", name_len)) {
         int ret_val = field_gnAddr.JSON_decode(GN__Address_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnAddr");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "timestamp", name_len)) {
         int ret_val = field_timestamp.JSON_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "timestamp");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "latitude", name_len)) {
         int ret_val = field_latitude.JSON_decode(LibCommon__BasicTypesAndValues::Int32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "latitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "longitude", name_len)) {
         int ret_val = field_longitude.JSON_decode(LibCommon__BasicTypesAndValues::Int32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "longitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (3 == name_len && 0 == strncmp(fld_name, "pai", name_len)) {
         int ret_val = field_pai.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "pai");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (5 == name_len && 0 == strncmp(fld_name, "speed", name_len)) {
         int ret_val = field_speed.JSON_decode(LibCommon__BasicTypesAndValues::Int15_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "speed");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "heading", name_len)) {
         int ret_val = field_heading.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "heading");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_gnAddr.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnAddr");
    return JSON_ERROR_FATAL;
  }
if (!field_timestamp.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "timestamp");
    return JSON_ERROR_FATAL;
  }
if (!field_latitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "latitude");
    return JSON_ERROR_FATAL;
  }
if (!field_longitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "longitude");
    return JSON_ERROR_FATAL;
  }
if (!field_pai.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "pai");
    return JSON_ERROR_FATAL;
  }
if (!field_speed.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "speed");
    return JSON_ERROR_FATAL;
  }
if (!field_heading.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "heading");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct LongPosVector_template::single_value_struct {
GN__Address_template field_gnAddr;
INTEGER_template field_timestamp;
INTEGER_template field_latitude;
INTEGER_template field_longitude;
BITSTRING_template field_pai;
INTEGER_template field_speed;
INTEGER_template field_heading;
};

void LongPosVector_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_gnAddr = ANY_VALUE;
single_value->field_timestamp = ANY_VALUE;
single_value->field_latitude = ANY_VALUE;
single_value->field_longitude = ANY_VALUE;
single_value->field_pai = ANY_VALUE;
single_value->field_speed = ANY_VALUE;
single_value->field_heading = ANY_VALUE;
}
}
}

void LongPosVector_template::copy_value(const LongPosVector& other_value)
{
single_value = new single_value_struct;
if (other_value.gnAddr().is_bound()) {
  single_value->field_gnAddr = other_value.gnAddr();
} else {
  single_value->field_gnAddr.clean_up();
}
if (other_value.timestamp().is_bound()) {
  single_value->field_timestamp = other_value.timestamp();
} else {
  single_value->field_timestamp.clean_up();
}
if (other_value.latitude().is_bound()) {
  single_value->field_latitude = other_value.latitude();
} else {
  single_value->field_latitude.clean_up();
}
if (other_value.longitude().is_bound()) {
  single_value->field_longitude = other_value.longitude();
} else {
  single_value->field_longitude.clean_up();
}
if (other_value.pai().is_bound()) {
  single_value->field_pai = other_value.pai();
} else {
  single_value->field_pai.clean_up();
}
if (other_value.speed().is_bound()) {
  single_value->field_speed = other_value.speed();
} else {
  single_value->field_speed.clean_up();
}
if (other_value.heading().is_bound()) {
  single_value->field_heading = other_value.heading();
} else {
  single_value->field_heading.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void LongPosVector_template::copy_template(const LongPosVector_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.gnAddr().get_selection()) {
single_value->field_gnAddr = other_value.gnAddr();
} else {
single_value->field_gnAddr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.timestamp().get_selection()) {
single_value->field_timestamp = other_value.timestamp();
} else {
single_value->field_timestamp.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.latitude().get_selection()) {
single_value->field_latitude = other_value.latitude();
} else {
single_value->field_latitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.longitude().get_selection()) {
single_value->field_longitude = other_value.longitude();
} else {
single_value->field_longitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.pai().get_selection()) {
single_value->field_pai = other_value.pai();
} else {
single_value->field_pai.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.speed().get_selection()) {
single_value->field_speed = other_value.speed();
} else {
single_value->field_speed.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.heading().get_selection()) {
single_value->field_heading = other_value.heading();
} else {
single_value->field_heading.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new LongPosVector_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
break;
}
set_selection(other_value);
}

LongPosVector_template::LongPosVector_template()
{
}

LongPosVector_template::LongPosVector_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

LongPosVector_template::LongPosVector_template(const LongPosVector& other_value)
{
copy_value(other_value);
}

LongPosVector_template::LongPosVector_template(const OPTIONAL<LongPosVector>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LongPosVector&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector from an unbound optional field.");
}
}

LongPosVector_template::LongPosVector_template(const LongPosVector_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

LongPosVector_template::~LongPosVector_template()
{
clean_up();
}

LongPosVector_template& LongPosVector_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

LongPosVector_template& LongPosVector_template::operator=(const LongPosVector& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

LongPosVector_template& LongPosVector_template::operator=(const OPTIONAL<LongPosVector>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LongPosVector&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
}
return *this;
}

LongPosVector_template& LongPosVector_template::operator=(const LongPosVector_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean LongPosVector_template::match(const LongPosVector& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.gnAddr().is_bound()) return FALSE;
if(!single_value->field_gnAddr.match(other_value.gnAddr(), legacy))return FALSE;
if(!other_value.timestamp().is_bound()) return FALSE;
if(!single_value->field_timestamp.match(other_value.timestamp(), legacy))return FALSE;
if(!other_value.latitude().is_bound()) return FALSE;
if(!single_value->field_latitude.match(other_value.latitude(), legacy))return FALSE;
if(!other_value.longitude().is_bound()) return FALSE;
if(!single_value->field_longitude.match(other_value.longitude(), legacy))return FALSE;
if(!other_value.pai().is_bound()) return FALSE;
if(!single_value->field_pai.match(other_value.pai(), legacy))return FALSE;
if(!other_value.speed().is_bound()) return FALSE;
if(!single_value->field_speed.match(other_value.speed(), legacy))return FALSE;
if(!other_value.heading().is_bound()) return FALSE;
if(!single_value->field_heading.match(other_value.heading(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
}
return FALSE;
}

boolean LongPosVector_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_gnAddr.is_bound()) return TRUE;
if (single_value->field_timestamp.is_bound()) return TRUE;
if (single_value->field_latitude.is_bound()) return TRUE;
if (single_value->field_longitude.is_bound()) return TRUE;
if (single_value->field_pai.is_bound()) return TRUE;
if (single_value->field_speed.is_bound()) return TRUE;
if (single_value->field_heading.is_bound()) return TRUE;
return FALSE;
}

boolean LongPosVector_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_gnAddr.is_value()) return FALSE;
if (!single_value->field_timestamp.is_value()) return FALSE;
if (!single_value->field_latitude.is_value()) return FALSE;
if (!single_value->field_longitude.is_value()) return FALSE;
if (!single_value->field_pai.is_value()) return FALSE;
if (!single_value->field_speed.is_value()) return FALSE;
if (!single_value->field_heading.is_value()) return FALSE;
return TRUE;
}

void LongPosVector_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

LongPosVector LongPosVector_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
LongPosVector ret_val;
if (single_value->field_gnAddr.is_bound()) {
ret_val.gnAddr() = single_value->field_gnAddr.valueof();
}
if (single_value->field_timestamp.is_bound()) {
ret_val.timestamp() = single_value->field_timestamp.valueof();
}
if (single_value->field_latitude.is_bound()) {
ret_val.latitude() = single_value->field_latitude.valueof();
}
if (single_value->field_longitude.is_bound()) {
ret_val.longitude() = single_value->field_longitude.valueof();
}
if (single_value->field_pai.is_bound()) {
ret_val.pai() = single_value->field_pai.valueof();
}
if (single_value->field_speed.is_bound()) {
ret_val.speed() = single_value->field_speed.valueof();
}
if (single_value->field_heading.is_bound()) {
ret_val.heading() = single_value->field_heading.valueof();
}
return ret_val;
}

void LongPosVector_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new LongPosVector_template[list_length];
}

LongPosVector_template& LongPosVector_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
return value_list.list_value[list_index];
}

GN__Address_template& LongPosVector_template::gnAddr()
{
set_specific();
return single_value->field_gnAddr;
}

const GN__Address_template& LongPosVector_template::gnAddr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnAddr of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
return single_value->field_gnAddr;
}

INTEGER_template& LongPosVector_template::timestamp()
{
set_specific();
return single_value->field_timestamp;
}

const INTEGER_template& LongPosVector_template::timestamp() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field timestamp of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
return single_value->field_timestamp;
}

INTEGER_template& LongPosVector_template::latitude()
{
set_specific();
return single_value->field_latitude;
}

const INTEGER_template& LongPosVector_template::latitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field latitude of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
return single_value->field_latitude;
}

INTEGER_template& LongPosVector_template::longitude()
{
set_specific();
return single_value->field_longitude;
}

const INTEGER_template& LongPosVector_template::longitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field longitude of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
return single_value->field_longitude;
}

BITSTRING_template& LongPosVector_template::pai()
{
set_specific();
return single_value->field_pai;
}

const BITSTRING_template& LongPosVector_template::pai() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field pai of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
return single_value->field_pai;
}

INTEGER_template& LongPosVector_template::speed()
{
set_specific();
return single_value->field_speed;
}

const INTEGER_template& LongPosVector_template::speed() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field speed of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
return single_value->field_speed;
}

INTEGER_template& LongPosVector_template::heading()
{
set_specific();
return single_value->field_heading;
}

const INTEGER_template& LongPosVector_template::heading() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field heading of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
return single_value->field_heading;
}

int LongPosVector_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 7;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
  }
  return 0;
}

void LongPosVector_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ gnAddr := ");
single_value->field_gnAddr.log();
TTCN_Logger::log_event_str(", timestamp := ");
single_value->field_timestamp.log();
TTCN_Logger::log_event_str(", latitude := ");
single_value->field_latitude.log();
TTCN_Logger::log_event_str(", longitude := ");
single_value->field_longitude.log();
TTCN_Logger::log_event_str(", pai := ");
single_value->field_pai.log();
TTCN_Logger::log_event_str(", speed := ");
single_value->field_speed.log();
TTCN_Logger::log_event_str(", heading := ");
single_value->field_heading.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void LongPosVector_template::log_match(const LongPosVector& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_gnAddr.match(match_value.gnAddr(), legacy)){
TTCN_Logger::log_logmatch_info(".gnAddr");
single_value->field_gnAddr.log_match(match_value.gnAddr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_timestamp.match(match_value.timestamp(), legacy)){
TTCN_Logger::log_logmatch_info(".timestamp");
single_value->field_timestamp.log_match(match_value.timestamp(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_latitude.match(match_value.latitude(), legacy)){
TTCN_Logger::log_logmatch_info(".latitude");
single_value->field_latitude.log_match(match_value.latitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_longitude.match(match_value.longitude(), legacy)){
TTCN_Logger::log_logmatch_info(".longitude");
single_value->field_longitude.log_match(match_value.longitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_pai.match(match_value.pai(), legacy)){
TTCN_Logger::log_logmatch_info(".pai");
single_value->field_pai.log_match(match_value.pai(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_speed.match(match_value.speed(), legacy)){
TTCN_Logger::log_logmatch_info(".speed");
single_value->field_speed.log_match(match_value.speed(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_heading.match(match_value.heading(), legacy)){
TTCN_Logger::log_logmatch_info(".heading");
single_value->field_heading.log_match(match_value.heading(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ gnAddr := ");
single_value->field_gnAddr.log_match(match_value.gnAddr(), legacy);
TTCN_Logger::log_event_str(", timestamp := ");
single_value->field_timestamp.log_match(match_value.timestamp(), legacy);
TTCN_Logger::log_event_str(", latitude := ");
single_value->field_latitude.log_match(match_value.latitude(), legacy);
TTCN_Logger::log_event_str(", longitude := ");
single_value->field_longitude.log_match(match_value.longitude(), legacy);
TTCN_Logger::log_event_str(", pai := ");
single_value->field_pai.log_match(match_value.pai(), legacy);
TTCN_Logger::log_event_str(", speed := ");
single_value->field_speed.log_match(match_value.speed(), legacy);
TTCN_Logger::log_event_str(", heading := ");
single_value->field_heading.log_match(match_value.heading(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void LongPosVector_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_gnAddr.encode_text(text_buf);
single_value->field_timestamp.encode_text(text_buf);
single_value->field_latitude.encode_text(text_buf);
single_value->field_longitude.encode_text(text_buf);
single_value->field_pai.encode_text(text_buf);
single_value->field_speed.encode_text(text_buf);
single_value->field_heading.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
}
}

void LongPosVector_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_gnAddr.decode_text(text_buf);
single_value->field_timestamp.decode_text(text_buf);
single_value->field_latitude.decode_text(text_buf);
single_value->field_longitude.decode_text(text_buf);
single_value->field_pai.decode_text(text_buf);
single_value->field_speed.decode_text(text_buf);
single_value->field_heading.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new LongPosVector_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector.");
}
}

void LongPosVector_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.LongPosVector'");
    }
    if (strcmp("gnAddr", param_field) == 0) {
      gnAddr().set_param(param);
      return;
    } else if (strcmp("timestamp", param_field) == 0) {
      timestamp().set_param(param);
      return;
    } else if (strcmp("latitude", param_field) == 0) {
      latitude().set_param(param);
      return;
    } else if (strcmp("longitude", param_field) == 0) {
      longitude().set_param(param);
      return;
    } else if (strcmp("pai", param_field) == 0) {
      pai().set_param(param);
      return;
    } else if (strcmp("speed", param_field) == 0) {
      speed().set_param(param);
      return;
    } else if (strcmp("heading", param_field) == 0) {
      heading().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.LongPosVector'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    LongPosVector_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (7<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.LongPosVector has 7 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) gnAddr().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) timestamp().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) latitude().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) longitude().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) pai().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) speed().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) heading().set_param(*mp->get_elem(6));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnAddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnAddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "timestamp")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          timestamp().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "latitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          latitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "longitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          longitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pai")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pai().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speed")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speed().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "heading")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          heading().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.LongPosVector: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.LongPosVector");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* LongPosVector_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.LongPosVector'");
    }
    if (strcmp("gnAddr", param_field) == 0) {
      return gnAddr().get_param(param_name);
    } else if (strcmp("timestamp", param_field) == 0) {
      return timestamp().get_param(param_name);
    } else if (strcmp("latitude", param_field) == 0) {
      return latitude().get_param(param_name);
    } else if (strcmp("longitude", param_field) == 0) {
      return longitude().get_param(param_name);
    } else if (strcmp("pai", param_field) == 0) {
      return pai().get_param(param_name);
    } else if (strcmp("speed", param_field) == 0) {
      return speed().get_param(param_name);
    } else if (strcmp("heading", param_field) == 0) {
      return heading().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.LongPosVector'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_gnAddr = single_value->field_gnAddr.get_param(param_name);
    mp_field_gnAddr->set_id(new Module_Param_FieldName(mcopystr("gnAddr")));
    mp->add_elem(mp_field_gnAddr);
    Module_Param* mp_field_timestamp = single_value->field_timestamp.get_param(param_name);
    mp_field_timestamp->set_id(new Module_Param_FieldName(mcopystr("timestamp")));
    mp->add_elem(mp_field_timestamp);
    Module_Param* mp_field_latitude = single_value->field_latitude.get_param(param_name);
    mp_field_latitude->set_id(new Module_Param_FieldName(mcopystr("latitude")));
    mp->add_elem(mp_field_latitude);
    Module_Param* mp_field_longitude = single_value->field_longitude.get_param(param_name);
    mp_field_longitude->set_id(new Module_Param_FieldName(mcopystr("longitude")));
    mp->add_elem(mp_field_longitude);
    Module_Param* mp_field_pai = single_value->field_pai.get_param(param_name);
    mp_field_pai->set_id(new Module_Param_FieldName(mcopystr("pai")));
    mp->add_elem(mp_field_pai);
    Module_Param* mp_field_speed = single_value->field_speed.get_param(param_name);
    mp_field_speed->set_id(new Module_Param_FieldName(mcopystr("speed")));
    mp->add_elem(mp_field_speed);
    Module_Param* mp_field_heading = single_value->field_heading.get_param(param_name);
    mp_field_heading->set_id(new Module_Param_FieldName(mcopystr("heading")));
    mp->add_elem(mp_field_heading);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void LongPosVector_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_gnAddr.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LongPosVector");
single_value->field_timestamp.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LongPosVector");
single_value->field_latitude.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LongPosVector");
single_value->field_longitude.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LongPosVector");
single_value->field_pai.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LongPosVector");
single_value->field_speed.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LongPosVector");
single_value->field_heading.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LongPosVector");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LongPosVector");
}

boolean LongPosVector_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean LongPosVector_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

PositionEntry::PositionEntry()
{
  bound_flag = FALSE;
}

PositionEntry::PositionEntry(const CHARSTRING& par_key,
    const LongPosVector& par_position)
  :   field_key(par_key),
  field_position(par_position)
{
  bound_flag = TRUE;
}

PositionEntry::PositionEntry(const PositionEntry& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.PositionEntry.");
bound_flag = TRUE;
if (other_value.key().is_bound()) field_key = other_value.key();
else field_key.clean_up();
if (other_value.position().is_bound()) field_position = other_value.position();
else field_position.clean_up();
}

void PositionEntry::clean_up()
{
field_key.clean_up();
field_position.clean_up();
bound_flag = FALSE;
}

PositionEntry& PositionEntry::operator=(const PositionEntry& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.PositionEntry.");
  bound_flag = TRUE;
  if (other_value.key().is_bound()) field_key = other_value.key();
  else field_key.clean_up();
  if (other_value.position().is_bound()) field_position = other_value.position();
  else field_position.clean_up();
}
return *this;
}

boolean PositionEntry::operator==(const PositionEntry& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_key==other_value.field_key
  && field_position==other_value.field_position;
}

boolean PositionEntry::is_bound() const
{
if (bound_flag) return TRUE;
if(field_key.is_bound()) return TRUE;
if(field_position.is_bound()) return TRUE;
return FALSE;
}
boolean PositionEntry::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_key.is_value()) return FALSE;
if(!field_position.is_value()) return FALSE;
return TRUE;
}
int PositionEntry::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.PositionEntry");
  return 2;
}

void PositionEntry::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ key := ");
field_key.log();
TTCN_Logger::log_event_str(", position := ");
field_position.log();
TTCN_Logger::log_event_str(" }");
}

void PositionEntry::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.PositionEntry'");
    }
    if (strcmp("key", param_field) == 0) {
      key().set_param(param);
      return;
    } else if (strcmp("position", param_field) == 0) {
      position().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.PositionEntry'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.PositionEntry has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) key().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) position().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "position")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          position().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.PositionEntry: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.PositionEntry");
  }
}

Module_Param* PositionEntry::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.PositionEntry'");
    }
    if (strcmp("key", param_field) == 0) {
      return key().get_param(param_name);
    } else if (strcmp("position", param_field) == 0) {
      return position().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.PositionEntry'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_key = field_key.get_param(param_name);
  mp_field_key->set_id(new Module_Param_FieldName(mcopystr("key")));
  mp->add_elem(mp_field_key);
  Module_Param* mp_field_position = field_position.get_param(param_name);
  mp_field_position->set_id(new Module_Param_FieldName(mcopystr("position")));
  mp->add_elem(mp_field_position);
  return mp;
  }

void PositionEntry::set_implicit_omit()
{
if (key().is_bound()) key().set_implicit_omit();
if (position().is_bound()) position().set_implicit_omit();
}

void PositionEntry::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.PositionEntry.");
field_key.encode_text(text_buf);
field_position.encode_text(text_buf);
}

void PositionEntry::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_key.decode_text(text_buf);
field_position.decode_text(text_buf);
}

void PositionEntry::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PositionEntry::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PositionEntry::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_key.RAW_decode(CHARSTRING_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_position.RAW_decode(LongPosVector_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int PositionEntry::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, CHARSTRING_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LongPosVector_descr_.raw);
  encoded_length += field_key.RAW_encode(CHARSTRING_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_position.RAW_encode(LongPosVector_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int PositionEntry::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.PositionEntry.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "key");
    enc_len += field_key.JSON_encode(CHARSTRING_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "position");
    enc_len += field_position.JSON_encode(LongPosVector_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int PositionEntry::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (3 == name_len && 0 == strncmp(fld_name, "key", name_len)) {
         int ret_val = field_key.JSON_decode(CHARSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "key");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "position", name_len)) {
         int ret_val = field_position.JSON_decode(LongPosVector_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "position");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_key.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "key");
    return JSON_ERROR_FATAL;
  }
if (!field_position.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "position");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct PositionEntry_template::single_value_struct {
CHARSTRING_template field_key;
LongPosVector_template field_position;
};

void PositionEntry_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_key = ANY_VALUE;
single_value->field_position = ANY_VALUE;
}
}
}

void PositionEntry_template::copy_value(const PositionEntry& other_value)
{
single_value = new single_value_struct;
if (other_value.key().is_bound()) {
  single_value->field_key = other_value.key();
} else {
  single_value->field_key.clean_up();
}
if (other_value.position().is_bound()) {
  single_value->field_position = other_value.position();
} else {
  single_value->field_position.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PositionEntry_template::copy_template(const PositionEntry_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.key().get_selection()) {
single_value->field_key = other_value.key();
} else {
single_value->field_key.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.position().get_selection()) {
single_value->field_position = other_value.position();
} else {
single_value->field_position.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PositionEntry_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry.");
break;
}
set_selection(other_value);
}

PositionEntry_template::PositionEntry_template()
{
}

PositionEntry_template::PositionEntry_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PositionEntry_template::PositionEntry_template(const PositionEntry& other_value)
{
copy_value(other_value);
}

PositionEntry_template::PositionEntry_template(const OPTIONAL<PositionEntry>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PositionEntry&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry from an unbound optional field.");
}
}

PositionEntry_template::PositionEntry_template(const PositionEntry_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PositionEntry_template::~PositionEntry_template()
{
clean_up();
}

PositionEntry_template& PositionEntry_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PositionEntry_template& PositionEntry_template::operator=(const PositionEntry& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PositionEntry_template& PositionEntry_template::operator=(const OPTIONAL<PositionEntry>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PositionEntry&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry.");
}
return *this;
}

PositionEntry_template& PositionEntry_template::operator=(const PositionEntry_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PositionEntry_template::match(const PositionEntry& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.key().is_bound()) return FALSE;
if(!single_value->field_key.match(other_value.key(), legacy))return FALSE;
if(!other_value.position().is_bound()) return FALSE;
if(!single_value->field_position.match(other_value.position(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry.");
}
return FALSE;
}

boolean PositionEntry_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_key.is_bound()) return TRUE;
if (single_value->field_position.is_bound()) return TRUE;
return FALSE;
}

boolean PositionEntry_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_key.is_value()) return FALSE;
if (!single_value->field_position.is_value()) return FALSE;
return TRUE;
}

void PositionEntry_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PositionEntry PositionEntry_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry.");
PositionEntry ret_val;
if (single_value->field_key.is_bound()) {
ret_val.key() = single_value->field_key.valueof();
}
if (single_value->field_position.is_bound()) {
ret_val.position() = single_value->field_position.valueof();
}
return ret_val;
}

void PositionEntry_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PositionEntry_template[list_length];
}

PositionEntry_template& PositionEntry_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry.");
return value_list.list_value[list_index];
}

CHARSTRING_template& PositionEntry_template::key()
{
set_specific();
return single_value->field_key;
}

const CHARSTRING_template& PositionEntry_template::key() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field key of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry.");
return single_value->field_key;
}

LongPosVector_template& PositionEntry_template::position()
{
set_specific();
return single_value->field_position;
}

const LongPosVector_template& PositionEntry_template::position() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field position of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry.");
return single_value->field_position;
}

int PositionEntry_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry.");
  }
  return 0;
}

void PositionEntry_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ key := ");
single_value->field_key.log();
TTCN_Logger::log_event_str(", position := ");
single_value->field_position.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PositionEntry_template::log_match(const PositionEntry& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_key.match(match_value.key(), legacy)){
TTCN_Logger::log_logmatch_info(".key");
single_value->field_key.log_match(match_value.key(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_position.match(match_value.position(), legacy)){
TTCN_Logger::log_logmatch_info(".position");
single_value->field_position.log_match(match_value.position(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ key := ");
single_value->field_key.log_match(match_value.key(), legacy);
TTCN_Logger::log_event_str(", position := ");
single_value->field_position.log_match(match_value.position(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PositionEntry_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_key.encode_text(text_buf);
single_value->field_position.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry.");
}
}

void PositionEntry_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_key.decode_text(text_buf);
single_value->field_position.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PositionEntry_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry.");
}
}

void PositionEntry_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.PositionEntry'");
    }
    if (strcmp("key", param_field) == 0) {
      key().set_param(param);
      return;
    } else if (strcmp("position", param_field) == 0) {
      position().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.PositionEntry'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PositionEntry_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.PositionEntry has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) key().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) position().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "position")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          position().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.PositionEntry: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.PositionEntry");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* PositionEntry_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.PositionEntry'");
    }
    if (strcmp("key", param_field) == 0) {
      return key().get_param(param_name);
    } else if (strcmp("position", param_field) == 0) {
      return position().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.PositionEntry'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_key = single_value->field_key.get_param(param_name);
    mp_field_key->set_id(new Module_Param_FieldName(mcopystr("key")));
    mp->add_elem(mp_field_key);
    Module_Param* mp_field_position = single_value->field_position.get_param(param_name);
    mp_field_position->set_id(new Module_Param_FieldName(mcopystr("position")));
    mp->add_elem(mp_field_position);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void PositionEntry_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_key.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.PositionEntry");
single_value->field_position.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.PositionEntry");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.PositionEntry");
}

boolean PositionEntry_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PositionEntry_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const PositionEntry PositionTable::UNBOUND_ELEM;
PositionTable::PositionTable()
{
val_ptr = NULL;
}

PositionTable::PositionTable(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

PositionTable::PositionTable(const PositionTable& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

PositionTable::~PositionTable()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void PositionTable::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

PositionTable& PositionTable::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

PositionTable& PositionTable::operator=(const PositionTable& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean PositionTable::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
return val_ptr->n_elements == 0 ;
}

boolean PositionTable::operator==(const PositionTable& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

PositionEntry& PositionTable::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsGeoNetworking_TypesAndValues.PositionTable using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (PositionEntry**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new PositionEntry(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new PositionEntry;
}
return *val_ptr->value_elements[index_value];
}

PositionEntry& PositionTable::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
return (*this)[(int)index_value];
}

const PositionEntry& PositionTable::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsGeoNetworking_TypesAndValues.PositionTable using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsGeoNetworking_TypesAndValues.PositionTable: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const PositionEntry& PositionTable::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
return (*this)[(int)index_value];
}

PositionTable PositionTable::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

PositionTable PositionTable::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

PositionTable PositionTable::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

PositionTable PositionTable::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
PositionTable ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new PositionEntry(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

PositionTable PositionTable::operator+(const PositionTable& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsGeoNetworking_TypesAndValues.PositionTable concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
PositionTable ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new PositionEntry(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new PositionEntry(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

PositionTable PositionTable::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsGeoNetworking_TypesAndValues.PositionTable","element");
PositionTable ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new PositionEntry(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

PositionTable PositionTable::replace(int index, int len, const PositionTable& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsGeoNetworking_TypesAndValues.PositionTable","element");
PositionTable ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new PositionEntry(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new PositionEntry(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new PositionEntry(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

PositionTable PositionTable::replace(int index, int len, const PositionTable_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void PositionTable::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (PositionEntry**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new PositionEntry(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (PositionEntry**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsGeoNetworking_TypesAndValues.PositionTable: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (PositionEntry**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean PositionTable::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int PositionTable::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
return val_ptr->n_elements;
}

int PositionTable::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void PositionTable::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void PositionTable::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@LibItsGeoNetworking_TypesAndValues.PositionTable'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@LibItsGeoNetworking_TypesAndValues.PositionTable");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@LibItsGeoNetworking_TypesAndValues.PositionTable");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* PositionTable::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@LibItsGeoNetworking_TypesAndValues.PositionTable'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void PositionTable::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void PositionTable::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void PositionTable::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
val_ptr->value_elements = (PositionEntry**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new PositionEntry;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void PositionTable::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PositionTable::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PositionTable::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int PositionTable::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

void PositionTable_template::copy_value(const PositionTable& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsGeoNetworking_TypesAndValues.PositionTable with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (PositionEntry_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new PositionEntry_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new PositionEntry_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void PositionTable_template::copy_template(const PositionTable_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (PositionEntry_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new PositionEntry_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new PositionEntry_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PositionTable_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
break;
}
set_selection(other_value);
}

boolean PositionTable_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const PositionTable_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const PositionTable*)value_ptr)[value_index], legacy);
else return ((const PositionTable_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

PositionTable_template::PositionTable_template()
{
}

PositionTable_template::PositionTable_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

PositionTable_template::PositionTable_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

PositionTable_template::PositionTable_template(const PositionTable& other_value)
{
copy_value(other_value);
}

PositionTable_template::PositionTable_template(const OPTIONAL<PositionTable>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PositionTable&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.PositionTable from an unbound optional field.");
}
}

PositionTable_template::PositionTable_template(const PositionTable_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

PositionTable_template::~PositionTable_template()
{
clean_up();
}

void PositionTable_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PositionTable_template& PositionTable_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PositionTable_template& PositionTable_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

PositionTable_template& PositionTable_template::operator=(const PositionTable& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PositionTable_template& PositionTable_template::operator=(const OPTIONAL<PositionTable>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PositionTable&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
}
return *this;
}

PositionTable_template& PositionTable_template::operator=(const PositionTable_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

PositionEntry_template& PositionTable_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsGeoNetworking_TypesAndValues.PositionTable using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
    break;
}
return *single_value.value_elements[index_value];
}

PositionEntry_template& PositionTable_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
return (*this)[(int)index_value];
}

const PositionEntry_template& PositionTable_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsGeoNetworking_TypesAndValues.PositionTable using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsGeoNetworking_TypesAndValues.PositionTable: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const PositionEntry_template& PositionTable_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
return (*this)[(int)index_value];
}

void PositionTable_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (PositionEntry_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new PositionEntry_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new PositionEntry_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (PositionEntry_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int PositionTable_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int PositionTable_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.PositionTable which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.PositionTable containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.PositionTable containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.PositionTable containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.PositionTable containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.PositionTable containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.PositionTable.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsGeoNetworking_TypesAndValues.PositionTable");
}

boolean PositionTable_template::match(const PositionTable& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
}
return FALSE;
}

boolean PositionTable_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

PositionTable PositionTable_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
PositionTable ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

PositionTable PositionTable_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

PositionTable PositionTable_template::replace(int index, int len, const PositionTable_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

PositionTable PositionTable_template::replace(int index, int len, const PositionTable& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void PositionTable_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new PositionTable_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
}
set_selection(template_type);
}

PositionTable_template& PositionTable_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
return value_list.list_value[list_index];
}

void PositionTable_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void PositionTable_template::log_match(const PositionTable& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PositionTable_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
}
}

void PositionTable_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
single_value.value_elements = (PositionEntry_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new PositionEntry_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PositionTable_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
}
}

boolean PositionTable_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PositionTable_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PositionTable_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@LibItsGeoNetworking_TypesAndValues.PositionTable'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PositionTable_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@LibItsGeoNetworking_TypesAndValues.PositionTable");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* PositionTable_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@LibItsGeoNetworking_TypesAndValues.PositionTable'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void PositionTable_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.PositionTable");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.PositionTable");
}

Area::Area()
{
  bound_flag = FALSE;
}

Area::Area(const INTEGER& par_geoAreaPosLatitude,
    const INTEGER& par_geoAreaPosLongitude,
    const INTEGER& par_distanceA,
    const INTEGER& par_distanceB,
    const INTEGER& par_angle)
  :   field_geoAreaPosLatitude(par_geoAreaPosLatitude),
  field_geoAreaPosLongitude(par_geoAreaPosLongitude),
  field_distanceA(par_distanceA),
  field_distanceB(par_distanceB),
  field_angle(par_angle)
{
  bound_flag = TRUE;
}

Area::Area(const Area& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.Area.");
bound_flag = TRUE;
if (other_value.geoAreaPosLatitude().is_bound()) field_geoAreaPosLatitude = other_value.geoAreaPosLatitude();
else field_geoAreaPosLatitude.clean_up();
if (other_value.geoAreaPosLongitude().is_bound()) field_geoAreaPosLongitude = other_value.geoAreaPosLongitude();
else field_geoAreaPosLongitude.clean_up();
if (other_value.distanceA().is_bound()) field_distanceA = other_value.distanceA();
else field_distanceA.clean_up();
if (other_value.distanceB().is_bound()) field_distanceB = other_value.distanceB();
else field_distanceB.clean_up();
if (other_value.angle().is_bound()) field_angle = other_value.angle();
else field_angle.clean_up();
}

void Area::clean_up()
{
field_geoAreaPosLatitude.clean_up();
field_geoAreaPosLongitude.clean_up();
field_distanceA.clean_up();
field_distanceB.clean_up();
field_angle.clean_up();
bound_flag = FALSE;
}

Area& Area::operator=(const Area& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.Area.");
  bound_flag = TRUE;
  if (other_value.geoAreaPosLatitude().is_bound()) field_geoAreaPosLatitude = other_value.geoAreaPosLatitude();
  else field_geoAreaPosLatitude.clean_up();
  if (other_value.geoAreaPosLongitude().is_bound()) field_geoAreaPosLongitude = other_value.geoAreaPosLongitude();
  else field_geoAreaPosLongitude.clean_up();
  if (other_value.distanceA().is_bound()) field_distanceA = other_value.distanceA();
  else field_distanceA.clean_up();
  if (other_value.distanceB().is_bound()) field_distanceB = other_value.distanceB();
  else field_distanceB.clean_up();
  if (other_value.angle().is_bound()) field_angle = other_value.angle();
  else field_angle.clean_up();
}
return *this;
}

boolean Area::operator==(const Area& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_geoAreaPosLatitude==other_value.field_geoAreaPosLatitude
  && field_geoAreaPosLongitude==other_value.field_geoAreaPosLongitude
  && field_distanceA==other_value.field_distanceA
  && field_distanceB==other_value.field_distanceB
  && field_angle==other_value.field_angle;
}

boolean Area::is_bound() const
{
if (bound_flag) return TRUE;
if(field_geoAreaPosLatitude.is_bound()) return TRUE;
if(field_geoAreaPosLongitude.is_bound()) return TRUE;
if(field_distanceA.is_bound()) return TRUE;
if(field_distanceB.is_bound()) return TRUE;
if(field_angle.is_bound()) return TRUE;
return FALSE;
}
boolean Area::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_geoAreaPosLatitude.is_value()) return FALSE;
if(!field_geoAreaPosLongitude.is_value()) return FALSE;
if(!field_distanceA.is_value()) return FALSE;
if(!field_distanceB.is_value()) return FALSE;
if(!field_angle.is_value()) return FALSE;
return TRUE;
}
int Area::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.Area");
  return 5;
}

void Area::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ geoAreaPosLatitude := ");
field_geoAreaPosLatitude.log();
TTCN_Logger::log_event_str(", geoAreaPosLongitude := ");
field_geoAreaPosLongitude.log();
TTCN_Logger::log_event_str(", distanceA := ");
field_distanceA.log();
TTCN_Logger::log_event_str(", distanceB := ");
field_distanceB.log();
TTCN_Logger::log_event_str(", angle := ");
field_angle.log();
TTCN_Logger::log_event_str(" }");
}

void Area::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.Area'");
    }
    if (strcmp("geoAreaPosLatitude", param_field) == 0) {
      geoAreaPosLatitude().set_param(param);
      return;
    } else if (strcmp("geoAreaPosLongitude", param_field) == 0) {
      geoAreaPosLongitude().set_param(param);
      return;
    } else if (strcmp("distanceA", param_field) == 0) {
      distanceA().set_param(param);
      return;
    } else if (strcmp("distanceB", param_field) == 0) {
      distanceB().set_param(param);
      return;
    } else if (strcmp("angle", param_field) == 0) {
      angle().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.Area'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.Area has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) geoAreaPosLatitude().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) geoAreaPosLongitude().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) distanceA().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) distanceB().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) angle().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoAreaPosLatitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoAreaPosLatitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoAreaPosLongitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoAreaPosLongitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "distanceA")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          distanceA().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "distanceB")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          distanceB().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "angle")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          angle().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.Area: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.Area");
  }
}

Module_Param* Area::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.Area'");
    }
    if (strcmp("geoAreaPosLatitude", param_field) == 0) {
      return geoAreaPosLatitude().get_param(param_name);
    } else if (strcmp("geoAreaPosLongitude", param_field) == 0) {
      return geoAreaPosLongitude().get_param(param_name);
    } else if (strcmp("distanceA", param_field) == 0) {
      return distanceA().get_param(param_name);
    } else if (strcmp("distanceB", param_field) == 0) {
      return distanceB().get_param(param_name);
    } else if (strcmp("angle", param_field) == 0) {
      return angle().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.Area'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_geoAreaPosLatitude = field_geoAreaPosLatitude.get_param(param_name);
  mp_field_geoAreaPosLatitude->set_id(new Module_Param_FieldName(mcopystr("geoAreaPosLatitude")));
  mp->add_elem(mp_field_geoAreaPosLatitude);
  Module_Param* mp_field_geoAreaPosLongitude = field_geoAreaPosLongitude.get_param(param_name);
  mp_field_geoAreaPosLongitude->set_id(new Module_Param_FieldName(mcopystr("geoAreaPosLongitude")));
  mp->add_elem(mp_field_geoAreaPosLongitude);
  Module_Param* mp_field_distanceA = field_distanceA.get_param(param_name);
  mp_field_distanceA->set_id(new Module_Param_FieldName(mcopystr("distanceA")));
  mp->add_elem(mp_field_distanceA);
  Module_Param* mp_field_distanceB = field_distanceB.get_param(param_name);
  mp_field_distanceB->set_id(new Module_Param_FieldName(mcopystr("distanceB")));
  mp->add_elem(mp_field_distanceB);
  Module_Param* mp_field_angle = field_angle.get_param(param_name);
  mp_field_angle->set_id(new Module_Param_FieldName(mcopystr("angle")));
  mp->add_elem(mp_field_angle);
  return mp;
  }

void Area::set_implicit_omit()
{
if (geoAreaPosLatitude().is_bound()) geoAreaPosLatitude().set_implicit_omit();
if (geoAreaPosLongitude().is_bound()) geoAreaPosLongitude().set_implicit_omit();
if (distanceA().is_bound()) distanceA().set_implicit_omit();
if (distanceB().is_bound()) distanceB().set_implicit_omit();
if (angle().is_bound()) angle().set_implicit_omit();
}

void Area::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.Area.");
field_geoAreaPosLatitude.encode_text(text_buf);
field_geoAreaPosLongitude.encode_text(text_buf);
field_distanceA.encode_text(text_buf);
field_distanceB.encode_text(text_buf);
field_angle.encode_text(text_buf);
}

void Area::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_geoAreaPosLatitude.decode_text(text_buf);
field_geoAreaPosLongitude.decode_text(text_buf);
field_distanceA.decode_text(text_buf);
field_distanceB.decode_text(text_buf);
field_angle.decode_text(text_buf);
}

void Area::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Area::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int Area::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_geoAreaPosLatitude.RAW_decode(LibCommon__BasicTypesAndValues::Int32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_geoAreaPosLongitude.RAW_decode(LibCommon__BasicTypesAndValues::Int32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_distanceA.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_distanceB.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_angle.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int Area::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 5;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(5);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::Int32_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::Int32_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  encoded_length += field_geoAreaPosLatitude.RAW_encode(LibCommon__BasicTypesAndValues::Int32_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_geoAreaPosLongitude.RAW_encode(LibCommon__BasicTypesAndValues::Int32_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_distanceA.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_distanceB.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_angle.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[4]);
  return myleaf.length = encoded_length;
}

int Area::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.Area.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoAreaPosLatitude");
    enc_len += field_geoAreaPosLatitude.JSON_encode(LibCommon__BasicTypesAndValues::Int32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoAreaPosLongitude");
    enc_len += field_geoAreaPosLongitude.JSON_encode(LibCommon__BasicTypesAndValues::Int32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "distanceA");
    enc_len += field_distanceA.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "distanceB");
    enc_len += field_distanceB.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "angle");
    enc_len += field_angle.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Area::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (18 == name_len && 0 == strncmp(fld_name, "geoAreaPosLatitude", name_len)) {
         int ret_val = field_geoAreaPosLatitude.JSON_decode(LibCommon__BasicTypesAndValues::Int32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoAreaPosLatitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (19 == name_len && 0 == strncmp(fld_name, "geoAreaPosLongitude", name_len)) {
         int ret_val = field_geoAreaPosLongitude.JSON_decode(LibCommon__BasicTypesAndValues::Int32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoAreaPosLongitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "distanceA", name_len)) {
         int ret_val = field_distanceA.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "distanceA");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "distanceB", name_len)) {
         int ret_val = field_distanceB.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "distanceB");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (5 == name_len && 0 == strncmp(fld_name, "angle", name_len)) {
         int ret_val = field_angle.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "angle");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_geoAreaPosLatitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoAreaPosLatitude");
    return JSON_ERROR_FATAL;
  }
if (!field_geoAreaPosLongitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoAreaPosLongitude");
    return JSON_ERROR_FATAL;
  }
if (!field_distanceA.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "distanceA");
    return JSON_ERROR_FATAL;
  }
if (!field_distanceB.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "distanceB");
    return JSON_ERROR_FATAL;
  }
if (!field_angle.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "angle");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct Area_template::single_value_struct {
INTEGER_template field_geoAreaPosLatitude;
INTEGER_template field_geoAreaPosLongitude;
INTEGER_template field_distanceA;
INTEGER_template field_distanceB;
INTEGER_template field_angle;
};

void Area_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_geoAreaPosLatitude = ANY_VALUE;
single_value->field_geoAreaPosLongitude = ANY_VALUE;
single_value->field_distanceA = ANY_VALUE;
single_value->field_distanceB = ANY_VALUE;
single_value->field_angle = ANY_VALUE;
}
}
}

void Area_template::copy_value(const Area& other_value)
{
single_value = new single_value_struct;
if (other_value.geoAreaPosLatitude().is_bound()) {
  single_value->field_geoAreaPosLatitude = other_value.geoAreaPosLatitude();
} else {
  single_value->field_geoAreaPosLatitude.clean_up();
}
if (other_value.geoAreaPosLongitude().is_bound()) {
  single_value->field_geoAreaPosLongitude = other_value.geoAreaPosLongitude();
} else {
  single_value->field_geoAreaPosLongitude.clean_up();
}
if (other_value.distanceA().is_bound()) {
  single_value->field_distanceA = other_value.distanceA();
} else {
  single_value->field_distanceA.clean_up();
}
if (other_value.distanceB().is_bound()) {
  single_value->field_distanceB = other_value.distanceB();
} else {
  single_value->field_distanceB.clean_up();
}
if (other_value.angle().is_bound()) {
  single_value->field_angle = other_value.angle();
} else {
  single_value->field_angle.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Area_template::copy_template(const Area_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.geoAreaPosLatitude().get_selection()) {
single_value->field_geoAreaPosLatitude = other_value.geoAreaPosLatitude();
} else {
single_value->field_geoAreaPosLatitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoAreaPosLongitude().get_selection()) {
single_value->field_geoAreaPosLongitude = other_value.geoAreaPosLongitude();
} else {
single_value->field_geoAreaPosLongitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.distanceA().get_selection()) {
single_value->field_distanceA = other_value.distanceA();
} else {
single_value->field_distanceA.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.distanceB().get_selection()) {
single_value->field_distanceB = other_value.distanceB();
} else {
single_value->field_distanceB.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.angle().get_selection()) {
single_value->field_angle = other_value.angle();
} else {
single_value->field_angle.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Area_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.Area.");
break;
}
set_selection(other_value);
}

Area_template::Area_template()
{
}

Area_template::Area_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Area_template::Area_template(const Area& other_value)
{
copy_value(other_value);
}

Area_template::Area_template(const OPTIONAL<Area>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Area&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.Area from an unbound optional field.");
}
}

Area_template::Area_template(const Area_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Area_template::~Area_template()
{
clean_up();
}

Area_template& Area_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Area_template& Area_template::operator=(const Area& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Area_template& Area_template::operator=(const OPTIONAL<Area>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Area&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.Area.");
}
return *this;
}

Area_template& Area_template::operator=(const Area_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Area_template::match(const Area& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.geoAreaPosLatitude().is_bound()) return FALSE;
if(!single_value->field_geoAreaPosLatitude.match(other_value.geoAreaPosLatitude(), legacy))return FALSE;
if(!other_value.geoAreaPosLongitude().is_bound()) return FALSE;
if(!single_value->field_geoAreaPosLongitude.match(other_value.geoAreaPosLongitude(), legacy))return FALSE;
if(!other_value.distanceA().is_bound()) return FALSE;
if(!single_value->field_distanceA.match(other_value.distanceA(), legacy))return FALSE;
if(!other_value.distanceB().is_bound()) return FALSE;
if(!single_value->field_distanceB.match(other_value.distanceB(), legacy))return FALSE;
if(!other_value.angle().is_bound()) return FALSE;
if(!single_value->field_angle.match(other_value.angle(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.Area.");
}
return FALSE;
}

boolean Area_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_geoAreaPosLatitude.is_bound()) return TRUE;
if (single_value->field_geoAreaPosLongitude.is_bound()) return TRUE;
if (single_value->field_distanceA.is_bound()) return TRUE;
if (single_value->field_distanceB.is_bound()) return TRUE;
if (single_value->field_angle.is_bound()) return TRUE;
return FALSE;
}

boolean Area_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_geoAreaPosLatitude.is_value()) return FALSE;
if (!single_value->field_geoAreaPosLongitude.is_value()) return FALSE;
if (!single_value->field_distanceA.is_value()) return FALSE;
if (!single_value->field_distanceB.is_value()) return FALSE;
if (!single_value->field_angle.is_value()) return FALSE;
return TRUE;
}

void Area_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Area Area_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.Area.");
Area ret_val;
if (single_value->field_geoAreaPosLatitude.is_bound()) {
ret_val.geoAreaPosLatitude() = single_value->field_geoAreaPosLatitude.valueof();
}
if (single_value->field_geoAreaPosLongitude.is_bound()) {
ret_val.geoAreaPosLongitude() = single_value->field_geoAreaPosLongitude.valueof();
}
if (single_value->field_distanceA.is_bound()) {
ret_val.distanceA() = single_value->field_distanceA.valueof();
}
if (single_value->field_distanceB.is_bound()) {
ret_val.distanceB() = single_value->field_distanceB.valueof();
}
if (single_value->field_angle.is_bound()) {
ret_val.angle() = single_value->field_angle.valueof();
}
return ret_val;
}

void Area_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.Area.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Area_template[list_length];
}

Area_template& Area_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.Area.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.Area.");
return value_list.list_value[list_index];
}

INTEGER_template& Area_template::geoAreaPosLatitude()
{
set_specific();
return single_value->field_geoAreaPosLatitude;
}

const INTEGER_template& Area_template::geoAreaPosLatitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoAreaPosLatitude of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.Area.");
return single_value->field_geoAreaPosLatitude;
}

INTEGER_template& Area_template::geoAreaPosLongitude()
{
set_specific();
return single_value->field_geoAreaPosLongitude;
}

const INTEGER_template& Area_template::geoAreaPosLongitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoAreaPosLongitude of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.Area.");
return single_value->field_geoAreaPosLongitude;
}

INTEGER_template& Area_template::distanceA()
{
set_specific();
return single_value->field_distanceA;
}

const INTEGER_template& Area_template::distanceA() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field distanceA of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.Area.");
return single_value->field_distanceA;
}

INTEGER_template& Area_template::distanceB()
{
set_specific();
return single_value->field_distanceB;
}

const INTEGER_template& Area_template::distanceB() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field distanceB of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.Area.");
return single_value->field_distanceB;
}

INTEGER_template& Area_template::angle()
{
set_specific();
return single_value->field_angle;
}

const INTEGER_template& Area_template::angle() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field angle of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.Area.");
return single_value->field_angle;
}

int Area_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Area which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 5;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Area containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Area containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Area containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Area containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Area containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.Area.");
  }
  return 0;
}

void Area_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ geoAreaPosLatitude := ");
single_value->field_geoAreaPosLatitude.log();
TTCN_Logger::log_event_str(", geoAreaPosLongitude := ");
single_value->field_geoAreaPosLongitude.log();
TTCN_Logger::log_event_str(", distanceA := ");
single_value->field_distanceA.log();
TTCN_Logger::log_event_str(", distanceB := ");
single_value->field_distanceB.log();
TTCN_Logger::log_event_str(", angle := ");
single_value->field_angle.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Area_template::log_match(const Area& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_geoAreaPosLatitude.match(match_value.geoAreaPosLatitude(), legacy)){
TTCN_Logger::log_logmatch_info(".geoAreaPosLatitude");
single_value->field_geoAreaPosLatitude.log_match(match_value.geoAreaPosLatitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoAreaPosLongitude.match(match_value.geoAreaPosLongitude(), legacy)){
TTCN_Logger::log_logmatch_info(".geoAreaPosLongitude");
single_value->field_geoAreaPosLongitude.log_match(match_value.geoAreaPosLongitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_distanceA.match(match_value.distanceA(), legacy)){
TTCN_Logger::log_logmatch_info(".distanceA");
single_value->field_distanceA.log_match(match_value.distanceA(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_distanceB.match(match_value.distanceB(), legacy)){
TTCN_Logger::log_logmatch_info(".distanceB");
single_value->field_distanceB.log_match(match_value.distanceB(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_angle.match(match_value.angle(), legacy)){
TTCN_Logger::log_logmatch_info(".angle");
single_value->field_angle.log_match(match_value.angle(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ geoAreaPosLatitude := ");
single_value->field_geoAreaPosLatitude.log_match(match_value.geoAreaPosLatitude(), legacy);
TTCN_Logger::log_event_str(", geoAreaPosLongitude := ");
single_value->field_geoAreaPosLongitude.log_match(match_value.geoAreaPosLongitude(), legacy);
TTCN_Logger::log_event_str(", distanceA := ");
single_value->field_distanceA.log_match(match_value.distanceA(), legacy);
TTCN_Logger::log_event_str(", distanceB := ");
single_value->field_distanceB.log_match(match_value.distanceB(), legacy);
TTCN_Logger::log_event_str(", angle := ");
single_value->field_angle.log_match(match_value.angle(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Area_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_geoAreaPosLatitude.encode_text(text_buf);
single_value->field_geoAreaPosLongitude.encode_text(text_buf);
single_value->field_distanceA.encode_text(text_buf);
single_value->field_distanceB.encode_text(text_buf);
single_value->field_angle.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.Area.");
}
}

void Area_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_geoAreaPosLatitude.decode_text(text_buf);
single_value->field_geoAreaPosLongitude.decode_text(text_buf);
single_value->field_distanceA.decode_text(text_buf);
single_value->field_distanceB.decode_text(text_buf);
single_value->field_angle.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Area_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.Area.");
}
}

void Area_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.Area'");
    }
    if (strcmp("geoAreaPosLatitude", param_field) == 0) {
      geoAreaPosLatitude().set_param(param);
      return;
    } else if (strcmp("geoAreaPosLongitude", param_field) == 0) {
      geoAreaPosLongitude().set_param(param);
      return;
    } else if (strcmp("distanceA", param_field) == 0) {
      distanceA().set_param(param);
      return;
    } else if (strcmp("distanceB", param_field) == 0) {
      distanceB().set_param(param);
      return;
    } else if (strcmp("angle", param_field) == 0) {
      angle().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.Area'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Area_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.Area has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) geoAreaPosLatitude().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) geoAreaPosLongitude().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) distanceA().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) distanceB().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) angle().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoAreaPosLatitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoAreaPosLatitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoAreaPosLongitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoAreaPosLongitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "distanceA")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          distanceA().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "distanceB")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          distanceB().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "angle")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          angle().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.Area: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.Area");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Area_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.Area'");
    }
    if (strcmp("geoAreaPosLatitude", param_field) == 0) {
      return geoAreaPosLatitude().get_param(param_name);
    } else if (strcmp("geoAreaPosLongitude", param_field) == 0) {
      return geoAreaPosLongitude().get_param(param_name);
    } else if (strcmp("distanceA", param_field) == 0) {
      return distanceA().get_param(param_name);
    } else if (strcmp("distanceB", param_field) == 0) {
      return distanceB().get_param(param_name);
    } else if (strcmp("angle", param_field) == 0) {
      return angle().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.Area'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_geoAreaPosLatitude = single_value->field_geoAreaPosLatitude.get_param(param_name);
    mp_field_geoAreaPosLatitude->set_id(new Module_Param_FieldName(mcopystr("geoAreaPosLatitude")));
    mp->add_elem(mp_field_geoAreaPosLatitude);
    Module_Param* mp_field_geoAreaPosLongitude = single_value->field_geoAreaPosLongitude.get_param(param_name);
    mp_field_geoAreaPosLongitude->set_id(new Module_Param_FieldName(mcopystr("geoAreaPosLongitude")));
    mp->add_elem(mp_field_geoAreaPosLongitude);
    Module_Param* mp_field_distanceA = single_value->field_distanceA.get_param(param_name);
    mp_field_distanceA->set_id(new Module_Param_FieldName(mcopystr("distanceA")));
    mp->add_elem(mp_field_distanceA);
    Module_Param* mp_field_distanceB = single_value->field_distanceB.get_param(param_name);
    mp_field_distanceB->set_id(new Module_Param_FieldName(mcopystr("distanceB")));
    mp->add_elem(mp_field_distanceB);
    Module_Param* mp_field_angle = single_value->field_angle.get_param(param_name);
    mp_field_angle->set_id(new Module_Param_FieldName(mcopystr("angle")));
    mp->add_elem(mp_field_angle);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Area_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_geoAreaPosLatitude.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.Area");
single_value->field_geoAreaPosLongitude.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.Area");
single_value->field_distanceA.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.Area");
single_value->field_distanceB.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.Area");
single_value->field_angle.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.Area");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.Area");
}

boolean Area_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Area_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

HeaderSubTypeGeoBroadcast::HeaderSubTypeGeoBroadcast()
{
enum_value = UNBOUND_VALUE;
}

HeaderSubTypeGeoBroadcast::HeaderSubTypeGeoBroadcast(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

HeaderSubTypeGeoBroadcast::HeaderSubTypeGeoBroadcast(enum_type other_value)
{
enum_value = other_value;
}

HeaderSubTypeGeoBroadcast::HeaderSubTypeGeoBroadcast(const HeaderSubTypeGeoBroadcast& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
enum_value = other_value.enum_value;
}

HeaderSubTypeGeoBroadcast& HeaderSubTypeGeoBroadcast::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

HeaderSubTypeGeoBroadcast& HeaderSubTypeGeoBroadcast::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

HeaderSubTypeGeoBroadcast& HeaderSubTypeGeoBroadcast::operator=(const HeaderSubTypeGeoBroadcast& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
enum_value = other_value.enum_value;
return *this;
}

boolean HeaderSubTypeGeoBroadcast::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
return enum_value == other_value;
}

boolean HeaderSubTypeGeoBroadcast::operator==(const HeaderSubTypeGeoBroadcast& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
return enum_value == other_value.enum_value;
}

boolean HeaderSubTypeGeoBroadcast::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
return enum_value < other_value;
}

boolean HeaderSubTypeGeoBroadcast::operator<(const HeaderSubTypeGeoBroadcast& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
return enum_value < other_value.enum_value;
}

boolean HeaderSubTypeGeoBroadcast::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
return enum_value > other_value;
}

boolean HeaderSubTypeGeoBroadcast::operator>(const HeaderSubTypeGeoBroadcast& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
return enum_value > other_value.enum_value;
}

const char *HeaderSubTypeGeoBroadcast::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__geoBroadcastCircle: return "e_geoBroadcastCircle";
case e__geoBroadcastRect: return "e_geoBroadcastRect";
case e__geoBroadcastElip: return "e_geoBroadcastElip";
case e__reserved: return "e_reserved";
default: return "<unknown>";
}
}

HeaderSubTypeGeoBroadcast::enum_type HeaderSubTypeGeoBroadcast::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_geoBroadcastCircle")) return e__geoBroadcastCircle;
else if (!strcmp(str_par, "e_geoBroadcastRect")) return e__geoBroadcastRect;
else if (!strcmp(str_par, "e_geoBroadcastElip")) return e__geoBroadcastElip;
else if (!strcmp(str_par, "e_reserved")) return e__reserved;
else return UNKNOWN_VALUE;
}

boolean HeaderSubTypeGeoBroadcast::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int HeaderSubTypeGeoBroadcast::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int HeaderSubTypeGeoBroadcast::enum2int(const HeaderSubTypeGeoBroadcast& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void HeaderSubTypeGeoBroadcast::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.", int_val);
enum_value = (enum_type)int_val;
}

HeaderSubTypeGeoBroadcast::operator HeaderSubTypeGeoBroadcast::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
return enum_value;
}

void HeaderSubTypeGeoBroadcast::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void HeaderSubTypeGeoBroadcast::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
  }
}

Module_Param* HeaderSubTypeGeoBroadcast::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void HeaderSubTypeGeoBroadcast::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
text_buf.push_int(enum_value);
}

void HeaderSubTypeGeoBroadcast::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.", enum_value);
}

void HeaderSubTypeGeoBroadcast::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void HeaderSubTypeGeoBroadcast::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int HeaderSubTypeGeoBroadcast::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int HeaderSubTypeGeoBroadcast::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

int HeaderSubTypeGeoBroadcast::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int HeaderSubTypeGeoBroadcast::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void HeaderSubTypeGeoBroadcast_template::copy_template(const HeaderSubTypeGeoBroadcast_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new HeaderSubTypeGeoBroadcast_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
}
}

HeaderSubTypeGeoBroadcast_template::HeaderSubTypeGeoBroadcast_template()
{
}

HeaderSubTypeGeoBroadcast_template::HeaderSubTypeGeoBroadcast_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

HeaderSubTypeGeoBroadcast_template::HeaderSubTypeGeoBroadcast_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!HeaderSubTypeGeoBroadcast::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast with unknown numeric value %d.", other_value);
single_value = (HeaderSubTypeGeoBroadcast::enum_type)other_value;
}

HeaderSubTypeGeoBroadcast_template::HeaderSubTypeGeoBroadcast_template(HeaderSubTypeGeoBroadcast::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

HeaderSubTypeGeoBroadcast_template::HeaderSubTypeGeoBroadcast_template(const HeaderSubTypeGeoBroadcast& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == HeaderSubTypeGeoBroadcast::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
single_value = other_value.enum_value;
}

HeaderSubTypeGeoBroadcast_template::HeaderSubTypeGeoBroadcast_template(const OPTIONAL<HeaderSubTypeGeoBroadcast>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (HeaderSubTypeGeoBroadcast::enum_type)(const HeaderSubTypeGeoBroadcast&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast from an unbound optional field.");
}
}

HeaderSubTypeGeoBroadcast_template::HeaderSubTypeGeoBroadcast_template(const HeaderSubTypeGeoBroadcast_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

HeaderSubTypeGeoBroadcast_template::~HeaderSubTypeGeoBroadcast_template()
{
clean_up();
}

boolean HeaderSubTypeGeoBroadcast_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean HeaderSubTypeGeoBroadcast_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != HeaderSubTypeGeoBroadcast::UNBOUND_VALUE;
}

void HeaderSubTypeGeoBroadcast_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

HeaderSubTypeGeoBroadcast_template& HeaderSubTypeGeoBroadcast_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

HeaderSubTypeGeoBroadcast_template& HeaderSubTypeGeoBroadcast_template::operator=(int other_value)
{
if (!HeaderSubTypeGeoBroadcast::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (HeaderSubTypeGeoBroadcast::enum_type)other_value;
return *this;
}

HeaderSubTypeGeoBroadcast_template& HeaderSubTypeGeoBroadcast_template::operator=(HeaderSubTypeGeoBroadcast::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

HeaderSubTypeGeoBroadcast_template& HeaderSubTypeGeoBroadcast_template::operator=(const HeaderSubTypeGeoBroadcast& other_value)
{
if (other_value.enum_value == HeaderSubTypeGeoBroadcast::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

HeaderSubTypeGeoBroadcast_template& HeaderSubTypeGeoBroadcast_template::operator=(const OPTIONAL<HeaderSubTypeGeoBroadcast>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (HeaderSubTypeGeoBroadcast::enum_type)(const HeaderSubTypeGeoBroadcast&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
}
return *this;
}

HeaderSubTypeGeoBroadcast_template& HeaderSubTypeGeoBroadcast_template::operator=(const HeaderSubTypeGeoBroadcast_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean HeaderSubTypeGeoBroadcast_template::match(HeaderSubTypeGeoBroadcast::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
}
return FALSE;
}

boolean HeaderSubTypeGeoBroadcast_template::match(const HeaderSubTypeGeoBroadcast& other_value, boolean) const
{
if (other_value.enum_value == HeaderSubTypeGeoBroadcast::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast with an unbound value.");
return match(other_value.enum_value);
}

HeaderSubTypeGeoBroadcast::enum_type HeaderSubTypeGeoBroadcast_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
return single_value;
}

void HeaderSubTypeGeoBroadcast_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new HeaderSubTypeGeoBroadcast_template[list_length];
}

HeaderSubTypeGeoBroadcast_template& HeaderSubTypeGeoBroadcast_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
return value_list.list_value[list_index];
}

void HeaderSubTypeGeoBroadcast_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(HeaderSubTypeGeoBroadcast::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void HeaderSubTypeGeoBroadcast_template::log_match(const HeaderSubTypeGeoBroadcast& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void HeaderSubTypeGeoBroadcast_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
}
}

void HeaderSubTypeGeoBroadcast_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (HeaderSubTypeGeoBroadcast::enum_type)text_buf.pull_int().get_val();
if (!HeaderSubTypeGeoBroadcast::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new HeaderSubTypeGeoBroadcast_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
}
}

boolean HeaderSubTypeGeoBroadcast_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean HeaderSubTypeGeoBroadcast_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void HeaderSubTypeGeoBroadcast_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    HeaderSubTypeGeoBroadcast::enum_type enum_val = (enum_name != NULL) ? HeaderSubTypeGeoBroadcast::str_to_enum(enum_name) : HeaderSubTypeGeoBroadcast::UNKNOWN_VALUE;
    if (HeaderSubTypeGeoBroadcast::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    HeaderSubTypeGeoBroadcast_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    HeaderSubTypeGeoBroadcast::enum_type enum_val = HeaderSubTypeGeoBroadcast::str_to_enum(mp->get_enumerated());
    if (!HeaderSubTypeGeoBroadcast::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* HeaderSubTypeGeoBroadcast_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(HeaderSubTypeGeoBroadcast::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void HeaderSubTypeGeoBroadcast_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoBroadcast");
}

GeoBroadcastArea::GeoBroadcastArea()
{
  bound_flag = FALSE;
}

GeoBroadcastArea::GeoBroadcastArea(const HeaderSubTypeGeoBroadcast& par_geoBroadcastSubType,
    const Area& par_geoBroadcastArea)
  :   field_geoBroadcastSubType(par_geoBroadcastSubType),
  field_geoBroadcastArea(par_geoBroadcastArea)
{
  bound_flag = TRUE;
}

GeoBroadcastArea::GeoBroadcastArea(const GeoBroadcastArea& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea.");
bound_flag = TRUE;
if (other_value.geoBroadcastSubType().is_bound()) field_geoBroadcastSubType = other_value.geoBroadcastSubType();
else field_geoBroadcastSubType.clean_up();
if (other_value.geoBroadcastArea().is_bound()) field_geoBroadcastArea = other_value.geoBroadcastArea();
else field_geoBroadcastArea.clean_up();
}

void GeoBroadcastArea::clean_up()
{
field_geoBroadcastSubType.clean_up();
field_geoBroadcastArea.clean_up();
bound_flag = FALSE;
}

GeoBroadcastArea& GeoBroadcastArea::operator=(const GeoBroadcastArea& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea.");
  bound_flag = TRUE;
  if (other_value.geoBroadcastSubType().is_bound()) field_geoBroadcastSubType = other_value.geoBroadcastSubType();
  else field_geoBroadcastSubType.clean_up();
  if (other_value.geoBroadcastArea().is_bound()) field_geoBroadcastArea = other_value.geoBroadcastArea();
  else field_geoBroadcastArea.clean_up();
}
return *this;
}

boolean GeoBroadcastArea::operator==(const GeoBroadcastArea& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_geoBroadcastSubType==other_value.field_geoBroadcastSubType
  && field_geoBroadcastArea==other_value.field_geoBroadcastArea;
}

boolean GeoBroadcastArea::is_bound() const
{
if (bound_flag) return TRUE;
if(field_geoBroadcastSubType.is_bound()) return TRUE;
if(field_geoBroadcastArea.is_bound()) return TRUE;
return FALSE;
}
boolean GeoBroadcastArea::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_geoBroadcastSubType.is_value()) return FALSE;
if(!field_geoBroadcastArea.is_value()) return FALSE;
return TRUE;
}
int GeoBroadcastArea::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea");
  return 2;
}

void GeoBroadcastArea::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ geoBroadcastSubType := ");
field_geoBroadcastSubType.log();
TTCN_Logger::log_event_str(", geoBroadcastArea := ");
field_geoBroadcastArea.log();
TTCN_Logger::log_event_str(" }");
}

void GeoBroadcastArea::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea'");
    }
    if (strcmp("geoBroadcastSubType", param_field) == 0) {
      geoBroadcastSubType().set_param(param);
      return;
    } else if (strcmp("geoBroadcastArea", param_field) == 0) {
      geoBroadcastArea().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) geoBroadcastSubType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) geoBroadcastArea().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoBroadcastSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoBroadcastSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoBroadcastArea")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoBroadcastArea().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea");
  }
}

Module_Param* GeoBroadcastArea::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea'");
    }
    if (strcmp("geoBroadcastSubType", param_field) == 0) {
      return geoBroadcastSubType().get_param(param_name);
    } else if (strcmp("geoBroadcastArea", param_field) == 0) {
      return geoBroadcastArea().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_geoBroadcastSubType = field_geoBroadcastSubType.get_param(param_name);
  mp_field_geoBroadcastSubType->set_id(new Module_Param_FieldName(mcopystr("geoBroadcastSubType")));
  mp->add_elem(mp_field_geoBroadcastSubType);
  Module_Param* mp_field_geoBroadcastArea = field_geoBroadcastArea.get_param(param_name);
  mp_field_geoBroadcastArea->set_id(new Module_Param_FieldName(mcopystr("geoBroadcastArea")));
  mp->add_elem(mp_field_geoBroadcastArea);
  return mp;
  }

void GeoBroadcastArea::set_implicit_omit()
{
if (geoBroadcastSubType().is_bound()) geoBroadcastSubType().set_implicit_omit();
if (geoBroadcastArea().is_bound()) geoBroadcastArea().set_implicit_omit();
}

void GeoBroadcastArea::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea.");
field_geoBroadcastSubType.encode_text(text_buf);
field_geoBroadcastArea.encode_text(text_buf);
}

void GeoBroadcastArea::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_geoBroadcastSubType.decode_text(text_buf);
field_geoBroadcastArea.decode_text(text_buf);
}

void GeoBroadcastArea::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GeoBroadcastArea::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GeoBroadcastArea::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_geoBroadcastSubType.RAW_decode(HeaderSubTypeGeoBroadcast_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_geoBroadcastArea.RAW_decode(Area_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GeoBroadcastArea::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, HeaderSubTypeGeoBroadcast_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, Area_descr_.raw);
  encoded_length += field_geoBroadcastSubType.RAW_encode(HeaderSubTypeGeoBroadcast_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_geoBroadcastArea.RAW_encode(Area_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int GeoBroadcastArea::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoBroadcastSubType");
    enc_len += field_geoBroadcastSubType.JSON_encode(HeaderSubTypeGeoBroadcast_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoBroadcastArea");
    enc_len += field_geoBroadcastArea.JSON_encode(Area_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GeoBroadcastArea::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (19 == name_len && 0 == strncmp(fld_name, "geoBroadcastSubType", name_len)) {
         int ret_val = field_geoBroadcastSubType.JSON_decode(HeaderSubTypeGeoBroadcast_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoBroadcastSubType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (16 == name_len && 0 == strncmp(fld_name, "geoBroadcastArea", name_len)) {
         int ret_val = field_geoBroadcastArea.JSON_decode(Area_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoBroadcastArea");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_geoBroadcastSubType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoBroadcastSubType");
    return JSON_ERROR_FATAL;
  }
if (!field_geoBroadcastArea.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoBroadcastArea");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GeoBroadcastArea_template::single_value_struct {
HeaderSubTypeGeoBroadcast_template field_geoBroadcastSubType;
Area_template field_geoBroadcastArea;
};

void GeoBroadcastArea_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_geoBroadcastSubType = ANY_VALUE;
single_value->field_geoBroadcastArea = ANY_VALUE;
}
}
}

void GeoBroadcastArea_template::copy_value(const GeoBroadcastArea& other_value)
{
single_value = new single_value_struct;
if (other_value.geoBroadcastSubType().is_bound()) {
  single_value->field_geoBroadcastSubType = other_value.geoBroadcastSubType();
} else {
  single_value->field_geoBroadcastSubType.clean_up();
}
if (other_value.geoBroadcastArea().is_bound()) {
  single_value->field_geoBroadcastArea = other_value.geoBroadcastArea();
} else {
  single_value->field_geoBroadcastArea.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GeoBroadcastArea_template::copy_template(const GeoBroadcastArea_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.geoBroadcastSubType().get_selection()) {
single_value->field_geoBroadcastSubType = other_value.geoBroadcastSubType();
} else {
single_value->field_geoBroadcastSubType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoBroadcastArea().get_selection()) {
single_value->field_geoBroadcastArea = other_value.geoBroadcastArea();
} else {
single_value->field_geoBroadcastArea.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GeoBroadcastArea_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea.");
break;
}
set_selection(other_value);
}

GeoBroadcastArea_template::GeoBroadcastArea_template()
{
}

GeoBroadcastArea_template::GeoBroadcastArea_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GeoBroadcastArea_template::GeoBroadcastArea_template(const GeoBroadcastArea& other_value)
{
copy_value(other_value);
}

GeoBroadcastArea_template::GeoBroadcastArea_template(const OPTIONAL<GeoBroadcastArea>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoBroadcastArea&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea from an unbound optional field.");
}
}

GeoBroadcastArea_template::GeoBroadcastArea_template(const GeoBroadcastArea_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GeoBroadcastArea_template::~GeoBroadcastArea_template()
{
clean_up();
}

GeoBroadcastArea_template& GeoBroadcastArea_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GeoBroadcastArea_template& GeoBroadcastArea_template::operator=(const GeoBroadcastArea& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GeoBroadcastArea_template& GeoBroadcastArea_template::operator=(const OPTIONAL<GeoBroadcastArea>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoBroadcastArea&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea.");
}
return *this;
}

GeoBroadcastArea_template& GeoBroadcastArea_template::operator=(const GeoBroadcastArea_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GeoBroadcastArea_template::match(const GeoBroadcastArea& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.geoBroadcastSubType().is_bound()) return FALSE;
if(!single_value->field_geoBroadcastSubType.match(other_value.geoBroadcastSubType(), legacy))return FALSE;
if(!other_value.geoBroadcastArea().is_bound()) return FALSE;
if(!single_value->field_geoBroadcastArea.match(other_value.geoBroadcastArea(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea.");
}
return FALSE;
}

boolean GeoBroadcastArea_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_geoBroadcastSubType.is_bound()) return TRUE;
if (single_value->field_geoBroadcastArea.is_bound()) return TRUE;
return FALSE;
}

boolean GeoBroadcastArea_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_geoBroadcastSubType.is_value()) return FALSE;
if (!single_value->field_geoBroadcastArea.is_value()) return FALSE;
return TRUE;
}

void GeoBroadcastArea_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GeoBroadcastArea GeoBroadcastArea_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea.");
GeoBroadcastArea ret_val;
if (single_value->field_geoBroadcastSubType.is_bound()) {
ret_val.geoBroadcastSubType() = single_value->field_geoBroadcastSubType.valueof();
}
if (single_value->field_geoBroadcastArea.is_bound()) {
ret_val.geoBroadcastArea() = single_value->field_geoBroadcastArea.valueof();
}
return ret_val;
}

void GeoBroadcastArea_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GeoBroadcastArea_template[list_length];
}

GeoBroadcastArea_template& GeoBroadcastArea_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea.");
return value_list.list_value[list_index];
}

HeaderSubTypeGeoBroadcast_template& GeoBroadcastArea_template::geoBroadcastSubType()
{
set_specific();
return single_value->field_geoBroadcastSubType;
}

const HeaderSubTypeGeoBroadcast_template& GeoBroadcastArea_template::geoBroadcastSubType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoBroadcastSubType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea.");
return single_value->field_geoBroadcastSubType;
}

Area_template& GeoBroadcastArea_template::geoBroadcastArea()
{
set_specific();
return single_value->field_geoBroadcastArea;
}

const Area_template& GeoBroadcastArea_template::geoBroadcastArea() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoBroadcastArea of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea.");
return single_value->field_geoBroadcastArea;
}

int GeoBroadcastArea_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea.");
  }
  return 0;
}

void GeoBroadcastArea_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ geoBroadcastSubType := ");
single_value->field_geoBroadcastSubType.log();
TTCN_Logger::log_event_str(", geoBroadcastArea := ");
single_value->field_geoBroadcastArea.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GeoBroadcastArea_template::log_match(const GeoBroadcastArea& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_geoBroadcastSubType.match(match_value.geoBroadcastSubType(), legacy)){
TTCN_Logger::log_logmatch_info(".geoBroadcastSubType");
single_value->field_geoBroadcastSubType.log_match(match_value.geoBroadcastSubType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoBroadcastArea.match(match_value.geoBroadcastArea(), legacy)){
TTCN_Logger::log_logmatch_info(".geoBroadcastArea");
single_value->field_geoBroadcastArea.log_match(match_value.geoBroadcastArea(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ geoBroadcastSubType := ");
single_value->field_geoBroadcastSubType.log_match(match_value.geoBroadcastSubType(), legacy);
TTCN_Logger::log_event_str(", geoBroadcastArea := ");
single_value->field_geoBroadcastArea.log_match(match_value.geoBroadcastArea(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GeoBroadcastArea_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_geoBroadcastSubType.encode_text(text_buf);
single_value->field_geoBroadcastArea.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea.");
}
}

void GeoBroadcastArea_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_geoBroadcastSubType.decode_text(text_buf);
single_value->field_geoBroadcastArea.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GeoBroadcastArea_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea.");
}
}

void GeoBroadcastArea_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea'");
    }
    if (strcmp("geoBroadcastSubType", param_field) == 0) {
      geoBroadcastSubType().set_param(param);
      return;
    } else if (strcmp("geoBroadcastArea", param_field) == 0) {
      geoBroadcastArea().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GeoBroadcastArea_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) geoBroadcastSubType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) geoBroadcastArea().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoBroadcastSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoBroadcastSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoBroadcastArea")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoBroadcastArea().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GeoBroadcastArea_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea'");
    }
    if (strcmp("geoBroadcastSubType", param_field) == 0) {
      return geoBroadcastSubType().get_param(param_name);
    } else if (strcmp("geoBroadcastArea", param_field) == 0) {
      return geoBroadcastArea().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_geoBroadcastSubType = single_value->field_geoBroadcastSubType.get_param(param_name);
    mp_field_geoBroadcastSubType->set_id(new Module_Param_FieldName(mcopystr("geoBroadcastSubType")));
    mp->add_elem(mp_field_geoBroadcastSubType);
    Module_Param* mp_field_geoBroadcastArea = single_value->field_geoBroadcastArea.get_param(param_name);
    mp_field_geoBroadcastArea->set_id(new Module_Param_FieldName(mcopystr("geoBroadcastArea")));
    mp->add_elem(mp_field_geoBroadcastArea);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GeoBroadcastArea_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_geoBroadcastSubType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea");
single_value->field_geoBroadcastArea.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastArea");
}

boolean GeoBroadcastArea_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GeoBroadcastArea_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

HeaderSubTypeGeoAnycast::HeaderSubTypeGeoAnycast()
{
enum_value = UNBOUND_VALUE;
}

HeaderSubTypeGeoAnycast::HeaderSubTypeGeoAnycast(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

HeaderSubTypeGeoAnycast::HeaderSubTypeGeoAnycast(enum_type other_value)
{
enum_value = other_value;
}

HeaderSubTypeGeoAnycast::HeaderSubTypeGeoAnycast(const HeaderSubTypeGeoAnycast& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
enum_value = other_value.enum_value;
}

HeaderSubTypeGeoAnycast& HeaderSubTypeGeoAnycast::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

HeaderSubTypeGeoAnycast& HeaderSubTypeGeoAnycast::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

HeaderSubTypeGeoAnycast& HeaderSubTypeGeoAnycast::operator=(const HeaderSubTypeGeoAnycast& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
enum_value = other_value.enum_value;
return *this;
}

boolean HeaderSubTypeGeoAnycast::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
return enum_value == other_value;
}

boolean HeaderSubTypeGeoAnycast::operator==(const HeaderSubTypeGeoAnycast& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
return enum_value == other_value.enum_value;
}

boolean HeaderSubTypeGeoAnycast::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
return enum_value < other_value;
}

boolean HeaderSubTypeGeoAnycast::operator<(const HeaderSubTypeGeoAnycast& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
return enum_value < other_value.enum_value;
}

boolean HeaderSubTypeGeoAnycast::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
return enum_value > other_value;
}

boolean HeaderSubTypeGeoAnycast::operator>(const HeaderSubTypeGeoAnycast& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
return enum_value > other_value.enum_value;
}

const char *HeaderSubTypeGeoAnycast::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__geoAnycastCircle: return "e_geoAnycastCircle";
case e__geoAnycastRect: return "e_geoAnycastRect";
case e__geoAnycastElip: return "e_geoAnycastElip";
case e__reserved: return "e_reserved";
default: return "<unknown>";
}
}

HeaderSubTypeGeoAnycast::enum_type HeaderSubTypeGeoAnycast::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_geoAnycastCircle")) return e__geoAnycastCircle;
else if (!strcmp(str_par, "e_geoAnycastRect")) return e__geoAnycastRect;
else if (!strcmp(str_par, "e_geoAnycastElip")) return e__geoAnycastElip;
else if (!strcmp(str_par, "e_reserved")) return e__reserved;
else return UNKNOWN_VALUE;
}

boolean HeaderSubTypeGeoAnycast::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int HeaderSubTypeGeoAnycast::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int HeaderSubTypeGeoAnycast::enum2int(const HeaderSubTypeGeoAnycast& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void HeaderSubTypeGeoAnycast::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.", int_val);
enum_value = (enum_type)int_val;
}

HeaderSubTypeGeoAnycast::operator HeaderSubTypeGeoAnycast::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
return enum_value;
}

void HeaderSubTypeGeoAnycast::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void HeaderSubTypeGeoAnycast::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
  }
}

Module_Param* HeaderSubTypeGeoAnycast::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void HeaderSubTypeGeoAnycast::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
text_buf.push_int(enum_value);
}

void HeaderSubTypeGeoAnycast::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.", enum_value);
}

void HeaderSubTypeGeoAnycast::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void HeaderSubTypeGeoAnycast::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int HeaderSubTypeGeoAnycast::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int HeaderSubTypeGeoAnycast::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

int HeaderSubTypeGeoAnycast::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int HeaderSubTypeGeoAnycast::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void HeaderSubTypeGeoAnycast_template::copy_template(const HeaderSubTypeGeoAnycast_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new HeaderSubTypeGeoAnycast_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
}
}

HeaderSubTypeGeoAnycast_template::HeaderSubTypeGeoAnycast_template()
{
}

HeaderSubTypeGeoAnycast_template::HeaderSubTypeGeoAnycast_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

HeaderSubTypeGeoAnycast_template::HeaderSubTypeGeoAnycast_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!HeaderSubTypeGeoAnycast::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast with unknown numeric value %d.", other_value);
single_value = (HeaderSubTypeGeoAnycast::enum_type)other_value;
}

HeaderSubTypeGeoAnycast_template::HeaderSubTypeGeoAnycast_template(HeaderSubTypeGeoAnycast::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

HeaderSubTypeGeoAnycast_template::HeaderSubTypeGeoAnycast_template(const HeaderSubTypeGeoAnycast& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == HeaderSubTypeGeoAnycast::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
single_value = other_value.enum_value;
}

HeaderSubTypeGeoAnycast_template::HeaderSubTypeGeoAnycast_template(const OPTIONAL<HeaderSubTypeGeoAnycast>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (HeaderSubTypeGeoAnycast::enum_type)(const HeaderSubTypeGeoAnycast&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast from an unbound optional field.");
}
}

HeaderSubTypeGeoAnycast_template::HeaderSubTypeGeoAnycast_template(const HeaderSubTypeGeoAnycast_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

HeaderSubTypeGeoAnycast_template::~HeaderSubTypeGeoAnycast_template()
{
clean_up();
}

boolean HeaderSubTypeGeoAnycast_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean HeaderSubTypeGeoAnycast_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != HeaderSubTypeGeoAnycast::UNBOUND_VALUE;
}

void HeaderSubTypeGeoAnycast_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

HeaderSubTypeGeoAnycast_template& HeaderSubTypeGeoAnycast_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

HeaderSubTypeGeoAnycast_template& HeaderSubTypeGeoAnycast_template::operator=(int other_value)
{
if (!HeaderSubTypeGeoAnycast::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (HeaderSubTypeGeoAnycast::enum_type)other_value;
return *this;
}

HeaderSubTypeGeoAnycast_template& HeaderSubTypeGeoAnycast_template::operator=(HeaderSubTypeGeoAnycast::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

HeaderSubTypeGeoAnycast_template& HeaderSubTypeGeoAnycast_template::operator=(const HeaderSubTypeGeoAnycast& other_value)
{
if (other_value.enum_value == HeaderSubTypeGeoAnycast::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

HeaderSubTypeGeoAnycast_template& HeaderSubTypeGeoAnycast_template::operator=(const OPTIONAL<HeaderSubTypeGeoAnycast>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (HeaderSubTypeGeoAnycast::enum_type)(const HeaderSubTypeGeoAnycast&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
}
return *this;
}

HeaderSubTypeGeoAnycast_template& HeaderSubTypeGeoAnycast_template::operator=(const HeaderSubTypeGeoAnycast_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean HeaderSubTypeGeoAnycast_template::match(HeaderSubTypeGeoAnycast::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
}
return FALSE;
}

boolean HeaderSubTypeGeoAnycast_template::match(const HeaderSubTypeGeoAnycast& other_value, boolean) const
{
if (other_value.enum_value == HeaderSubTypeGeoAnycast::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast with an unbound value.");
return match(other_value.enum_value);
}

HeaderSubTypeGeoAnycast::enum_type HeaderSubTypeGeoAnycast_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
return single_value;
}

void HeaderSubTypeGeoAnycast_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new HeaderSubTypeGeoAnycast_template[list_length];
}

HeaderSubTypeGeoAnycast_template& HeaderSubTypeGeoAnycast_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
return value_list.list_value[list_index];
}

void HeaderSubTypeGeoAnycast_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(HeaderSubTypeGeoAnycast::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void HeaderSubTypeGeoAnycast_template::log_match(const HeaderSubTypeGeoAnycast& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void HeaderSubTypeGeoAnycast_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
}
}

void HeaderSubTypeGeoAnycast_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (HeaderSubTypeGeoAnycast::enum_type)text_buf.pull_int().get_val();
if (!HeaderSubTypeGeoAnycast::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new HeaderSubTypeGeoAnycast_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
}
}

boolean HeaderSubTypeGeoAnycast_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean HeaderSubTypeGeoAnycast_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void HeaderSubTypeGeoAnycast_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    HeaderSubTypeGeoAnycast::enum_type enum_val = (enum_name != NULL) ? HeaderSubTypeGeoAnycast::str_to_enum(enum_name) : HeaderSubTypeGeoAnycast::UNKNOWN_VALUE;
    if (HeaderSubTypeGeoAnycast::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    HeaderSubTypeGeoAnycast_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    HeaderSubTypeGeoAnycast::enum_type enum_val = HeaderSubTypeGeoAnycast::str_to_enum(mp->get_enumerated());
    if (!HeaderSubTypeGeoAnycast::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* HeaderSubTypeGeoAnycast_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(HeaderSubTypeGeoAnycast::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void HeaderSubTypeGeoAnycast_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeGeoAnycast");
}

GeoAnycastArea::GeoAnycastArea()
{
  bound_flag = FALSE;
}

GeoAnycastArea::GeoAnycastArea(const HeaderSubTypeGeoAnycast& par_geoAnycastSubType,
    const Area& par_geoAnycastArea)
  :   field_geoAnycastSubType(par_geoAnycastSubType),
  field_geoAnycastArea(par_geoAnycastArea)
{
  bound_flag = TRUE;
}

GeoAnycastArea::GeoAnycastArea(const GeoAnycastArea& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea.");
bound_flag = TRUE;
if (other_value.geoAnycastSubType().is_bound()) field_geoAnycastSubType = other_value.geoAnycastSubType();
else field_geoAnycastSubType.clean_up();
if (other_value.geoAnycastArea().is_bound()) field_geoAnycastArea = other_value.geoAnycastArea();
else field_geoAnycastArea.clean_up();
}

void GeoAnycastArea::clean_up()
{
field_geoAnycastSubType.clean_up();
field_geoAnycastArea.clean_up();
bound_flag = FALSE;
}

GeoAnycastArea& GeoAnycastArea::operator=(const GeoAnycastArea& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea.");
  bound_flag = TRUE;
  if (other_value.geoAnycastSubType().is_bound()) field_geoAnycastSubType = other_value.geoAnycastSubType();
  else field_geoAnycastSubType.clean_up();
  if (other_value.geoAnycastArea().is_bound()) field_geoAnycastArea = other_value.geoAnycastArea();
  else field_geoAnycastArea.clean_up();
}
return *this;
}

boolean GeoAnycastArea::operator==(const GeoAnycastArea& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_geoAnycastSubType==other_value.field_geoAnycastSubType
  && field_geoAnycastArea==other_value.field_geoAnycastArea;
}

boolean GeoAnycastArea::is_bound() const
{
if (bound_flag) return TRUE;
if(field_geoAnycastSubType.is_bound()) return TRUE;
if(field_geoAnycastArea.is_bound()) return TRUE;
return FALSE;
}
boolean GeoAnycastArea::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_geoAnycastSubType.is_value()) return FALSE;
if(!field_geoAnycastArea.is_value()) return FALSE;
return TRUE;
}
int GeoAnycastArea::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea");
  return 2;
}

void GeoAnycastArea::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ geoAnycastSubType := ");
field_geoAnycastSubType.log();
TTCN_Logger::log_event_str(", geoAnycastArea := ");
field_geoAnycastArea.log();
TTCN_Logger::log_event_str(" }");
}

void GeoAnycastArea::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastArea'");
    }
    if (strcmp("geoAnycastSubType", param_field) == 0) {
      geoAnycastSubType().set_param(param);
      return;
    } else if (strcmp("geoAnycastArea", param_field) == 0) {
      geoAnycastArea().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastArea'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) geoAnycastSubType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) geoAnycastArea().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoAnycastSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoAnycastSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoAnycastArea")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoAnycastArea().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.GeoAnycastArea");
  }
}

Module_Param* GeoAnycastArea::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastArea'");
    }
    if (strcmp("geoAnycastSubType", param_field) == 0) {
      return geoAnycastSubType().get_param(param_name);
    } else if (strcmp("geoAnycastArea", param_field) == 0) {
      return geoAnycastArea().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastArea'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_geoAnycastSubType = field_geoAnycastSubType.get_param(param_name);
  mp_field_geoAnycastSubType->set_id(new Module_Param_FieldName(mcopystr("geoAnycastSubType")));
  mp->add_elem(mp_field_geoAnycastSubType);
  Module_Param* mp_field_geoAnycastArea = field_geoAnycastArea.get_param(param_name);
  mp_field_geoAnycastArea->set_id(new Module_Param_FieldName(mcopystr("geoAnycastArea")));
  mp->add_elem(mp_field_geoAnycastArea);
  return mp;
  }

void GeoAnycastArea::set_implicit_omit()
{
if (geoAnycastSubType().is_bound()) geoAnycastSubType().set_implicit_omit();
if (geoAnycastArea().is_bound()) geoAnycastArea().set_implicit_omit();
}

void GeoAnycastArea::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea.");
field_geoAnycastSubType.encode_text(text_buf);
field_geoAnycastArea.encode_text(text_buf);
}

void GeoAnycastArea::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_geoAnycastSubType.decode_text(text_buf);
field_geoAnycastArea.decode_text(text_buf);
}

void GeoAnycastArea::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GeoAnycastArea::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GeoAnycastArea::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_geoAnycastSubType.RAW_decode(HeaderSubTypeGeoAnycast_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_geoAnycastArea.RAW_decode(Area_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GeoAnycastArea::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, HeaderSubTypeGeoAnycast_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, Area_descr_.raw);
  encoded_length += field_geoAnycastSubType.RAW_encode(HeaderSubTypeGeoAnycast_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_geoAnycastArea.RAW_encode(Area_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int GeoAnycastArea::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoAnycastSubType");
    enc_len += field_geoAnycastSubType.JSON_encode(HeaderSubTypeGeoAnycast_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoAnycastArea");
    enc_len += field_geoAnycastArea.JSON_encode(Area_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GeoAnycastArea::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (17 == name_len && 0 == strncmp(fld_name, "geoAnycastSubType", name_len)) {
         int ret_val = field_geoAnycastSubType.JSON_decode(HeaderSubTypeGeoAnycast_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoAnycastSubType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "geoAnycastArea", name_len)) {
         int ret_val = field_geoAnycastArea.JSON_decode(Area_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoAnycastArea");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_geoAnycastSubType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoAnycastSubType");
    return JSON_ERROR_FATAL;
  }
if (!field_geoAnycastArea.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoAnycastArea");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GeoAnycastArea_template::single_value_struct {
HeaderSubTypeGeoAnycast_template field_geoAnycastSubType;
Area_template field_geoAnycastArea;
};

void GeoAnycastArea_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_geoAnycastSubType = ANY_VALUE;
single_value->field_geoAnycastArea = ANY_VALUE;
}
}
}

void GeoAnycastArea_template::copy_value(const GeoAnycastArea& other_value)
{
single_value = new single_value_struct;
if (other_value.geoAnycastSubType().is_bound()) {
  single_value->field_geoAnycastSubType = other_value.geoAnycastSubType();
} else {
  single_value->field_geoAnycastSubType.clean_up();
}
if (other_value.geoAnycastArea().is_bound()) {
  single_value->field_geoAnycastArea = other_value.geoAnycastArea();
} else {
  single_value->field_geoAnycastArea.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GeoAnycastArea_template::copy_template(const GeoAnycastArea_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.geoAnycastSubType().get_selection()) {
single_value->field_geoAnycastSubType = other_value.geoAnycastSubType();
} else {
single_value->field_geoAnycastSubType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoAnycastArea().get_selection()) {
single_value->field_geoAnycastArea = other_value.geoAnycastArea();
} else {
single_value->field_geoAnycastArea.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GeoAnycastArea_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea.");
break;
}
set_selection(other_value);
}

GeoAnycastArea_template::GeoAnycastArea_template()
{
}

GeoAnycastArea_template::GeoAnycastArea_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GeoAnycastArea_template::GeoAnycastArea_template(const GeoAnycastArea& other_value)
{
copy_value(other_value);
}

GeoAnycastArea_template::GeoAnycastArea_template(const OPTIONAL<GeoAnycastArea>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoAnycastArea&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea from an unbound optional field.");
}
}

GeoAnycastArea_template::GeoAnycastArea_template(const GeoAnycastArea_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GeoAnycastArea_template::~GeoAnycastArea_template()
{
clean_up();
}

GeoAnycastArea_template& GeoAnycastArea_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GeoAnycastArea_template& GeoAnycastArea_template::operator=(const GeoAnycastArea& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GeoAnycastArea_template& GeoAnycastArea_template::operator=(const OPTIONAL<GeoAnycastArea>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoAnycastArea&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea.");
}
return *this;
}

GeoAnycastArea_template& GeoAnycastArea_template::operator=(const GeoAnycastArea_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GeoAnycastArea_template::match(const GeoAnycastArea& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.geoAnycastSubType().is_bound()) return FALSE;
if(!single_value->field_geoAnycastSubType.match(other_value.geoAnycastSubType(), legacy))return FALSE;
if(!other_value.geoAnycastArea().is_bound()) return FALSE;
if(!single_value->field_geoAnycastArea.match(other_value.geoAnycastArea(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea.");
}
return FALSE;
}

boolean GeoAnycastArea_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_geoAnycastSubType.is_bound()) return TRUE;
if (single_value->field_geoAnycastArea.is_bound()) return TRUE;
return FALSE;
}

boolean GeoAnycastArea_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_geoAnycastSubType.is_value()) return FALSE;
if (!single_value->field_geoAnycastArea.is_value()) return FALSE;
return TRUE;
}

void GeoAnycastArea_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GeoAnycastArea GeoAnycastArea_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea.");
GeoAnycastArea ret_val;
if (single_value->field_geoAnycastSubType.is_bound()) {
ret_val.geoAnycastSubType() = single_value->field_geoAnycastSubType.valueof();
}
if (single_value->field_geoAnycastArea.is_bound()) {
ret_val.geoAnycastArea() = single_value->field_geoAnycastArea.valueof();
}
return ret_val;
}

void GeoAnycastArea_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GeoAnycastArea_template[list_length];
}

GeoAnycastArea_template& GeoAnycastArea_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea.");
return value_list.list_value[list_index];
}

HeaderSubTypeGeoAnycast_template& GeoAnycastArea_template::geoAnycastSubType()
{
set_specific();
return single_value->field_geoAnycastSubType;
}

const HeaderSubTypeGeoAnycast_template& GeoAnycastArea_template::geoAnycastSubType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoAnycastSubType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea.");
return single_value->field_geoAnycastSubType;
}

Area_template& GeoAnycastArea_template::geoAnycastArea()
{
set_specific();
return single_value->field_geoAnycastArea;
}

const Area_template& GeoAnycastArea_template::geoAnycastArea() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoAnycastArea of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea.");
return single_value->field_geoAnycastArea;
}

int GeoAnycastArea_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea.");
  }
  return 0;
}

void GeoAnycastArea_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ geoAnycastSubType := ");
single_value->field_geoAnycastSubType.log();
TTCN_Logger::log_event_str(", geoAnycastArea := ");
single_value->field_geoAnycastArea.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GeoAnycastArea_template::log_match(const GeoAnycastArea& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_geoAnycastSubType.match(match_value.geoAnycastSubType(), legacy)){
TTCN_Logger::log_logmatch_info(".geoAnycastSubType");
single_value->field_geoAnycastSubType.log_match(match_value.geoAnycastSubType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoAnycastArea.match(match_value.geoAnycastArea(), legacy)){
TTCN_Logger::log_logmatch_info(".geoAnycastArea");
single_value->field_geoAnycastArea.log_match(match_value.geoAnycastArea(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ geoAnycastSubType := ");
single_value->field_geoAnycastSubType.log_match(match_value.geoAnycastSubType(), legacy);
TTCN_Logger::log_event_str(", geoAnycastArea := ");
single_value->field_geoAnycastArea.log_match(match_value.geoAnycastArea(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GeoAnycastArea_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_geoAnycastSubType.encode_text(text_buf);
single_value->field_geoAnycastArea.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea.");
}
}

void GeoAnycastArea_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_geoAnycastSubType.decode_text(text_buf);
single_value->field_geoAnycastArea.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GeoAnycastArea_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea.");
}
}

void GeoAnycastArea_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastArea'");
    }
    if (strcmp("geoAnycastSubType", param_field) == 0) {
      geoAnycastSubType().set_param(param);
      return;
    } else if (strcmp("geoAnycastArea", param_field) == 0) {
      geoAnycastArea().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastArea'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GeoAnycastArea_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) geoAnycastSubType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) geoAnycastArea().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoAnycastSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoAnycastSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoAnycastArea")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoAnycastArea().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoAnycastArea: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.GeoAnycastArea");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GeoAnycastArea_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastArea'");
    }
    if (strcmp("geoAnycastSubType", param_field) == 0) {
      return geoAnycastSubType().get_param(param_name);
    } else if (strcmp("geoAnycastArea", param_field) == 0) {
      return geoAnycastArea().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastArea'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_geoAnycastSubType = single_value->field_geoAnycastSubType.get_param(param_name);
    mp_field_geoAnycastSubType->set_id(new Module_Param_FieldName(mcopystr("geoAnycastSubType")));
    mp->add_elem(mp_field_geoAnycastSubType);
    Module_Param* mp_field_geoAnycastArea = single_value->field_geoAnycastArea.get_param(param_name);
    mp_field_geoAnycastArea->set_id(new Module_Param_FieldName(mcopystr("geoAnycastArea")));
    mp->add_elem(mp_field_geoAnycastArea);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GeoAnycastArea_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_geoAnycastSubType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAnycastArea");
single_value->field_geoAnycastArea.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAnycastArea");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAnycastArea");
}

boolean GeoAnycastArea_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GeoAnycastArea_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

GeoShape::GeoShape()
{
enum_value = UNBOUND_VALUE;
}

GeoShape::GeoShape(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

GeoShape::GeoShape(enum_type other_value)
{
enum_value = other_value;
}

GeoShape::GeoShape(const GeoShape& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
enum_value = other_value.enum_value;
}

GeoShape& GeoShape::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

GeoShape& GeoShape::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

GeoShape& GeoShape::operator=(const GeoShape& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
enum_value = other_value.enum_value;
return *this;
}

boolean GeoShape::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
return enum_value == other_value;
}

boolean GeoShape::operator==(const GeoShape& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
return enum_value == other_value.enum_value;
}

boolean GeoShape::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
return enum_value < other_value;
}

boolean GeoShape::operator<(const GeoShape& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
return enum_value < other_value.enum_value;
}

boolean GeoShape::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
return enum_value > other_value;
}

boolean GeoShape::operator>(const GeoShape& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
return enum_value > other_value.enum_value;
}

const char *GeoShape::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__geoCircle: return "e_geoCircle";
case e__geoRect: return "e_geoRect";
case e__geoElip: return "e_geoElip";
case e__reserved: return "e_reserved";
default: return "<unknown>";
}
}

GeoShape::enum_type GeoShape::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_geoCircle")) return e__geoCircle;
else if (!strcmp(str_par, "e_geoRect")) return e__geoRect;
else if (!strcmp(str_par, "e_geoElip")) return e__geoElip;
else if (!strcmp(str_par, "e_reserved")) return e__reserved;
else return UNKNOWN_VALUE;
}

boolean GeoShape::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int GeoShape::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int GeoShape::enum2int(const GeoShape& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void GeoShape::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.", int_val);
enum_value = (enum_type)int_val;
}

GeoShape::operator GeoShape::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
return enum_value;
}

void GeoShape::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void GeoShape::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsGeoNetworking_TypesAndValues.GeoShape");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
  }
}

Module_Param* GeoShape::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void GeoShape::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
text_buf.push_int(enum_value);
}

void GeoShape::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.", enum_value);
}

void GeoShape::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GeoShape::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GeoShape::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int GeoShape::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

int GeoShape::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int GeoShape::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void GeoShape_template::copy_template(const GeoShape_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GeoShape_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
}
}

GeoShape_template::GeoShape_template()
{
}

GeoShape_template::GeoShape_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GeoShape_template::GeoShape_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!GeoShape::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape with unknown numeric value %d.", other_value);
single_value = (GeoShape::enum_type)other_value;
}

GeoShape_template::GeoShape_template(GeoShape::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

GeoShape_template::GeoShape_template(const GeoShape& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == GeoShape::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
single_value = other_value.enum_value;
}

GeoShape_template::GeoShape_template(const OPTIONAL<GeoShape>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GeoShape::enum_type)(const GeoShape&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape from an unbound optional field.");
}
}

GeoShape_template::GeoShape_template(const GeoShape_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

GeoShape_template::~GeoShape_template()
{
clean_up();
}

boolean GeoShape_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean GeoShape_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != GeoShape::UNBOUND_VALUE;
}

void GeoShape_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

GeoShape_template& GeoShape_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GeoShape_template& GeoShape_template::operator=(int other_value)
{
if (!GeoShape::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (GeoShape::enum_type)other_value;
return *this;
}

GeoShape_template& GeoShape_template::operator=(GeoShape::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

GeoShape_template& GeoShape_template::operator=(const GeoShape& other_value)
{
if (other_value.enum_value == GeoShape::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

GeoShape_template& GeoShape_template::operator=(const OPTIONAL<GeoShape>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GeoShape::enum_type)(const GeoShape&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
}
return *this;
}

GeoShape_template& GeoShape_template::operator=(const GeoShape_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GeoShape_template::match(GeoShape::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
}
return FALSE;
}

boolean GeoShape_template::match(const GeoShape& other_value, boolean) const
{
if (other_value.enum_value == GeoShape::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape with an unbound value.");
return match(other_value.enum_value);
}

GeoShape::enum_type GeoShape_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
return single_value;
}

void GeoShape_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GeoShape_template[list_length];
}

GeoShape_template& GeoShape_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
return value_list.list_value[list_index];
}

void GeoShape_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(GeoShape::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GeoShape_template::log_match(const GeoShape& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void GeoShape_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
}
}

void GeoShape_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (GeoShape::enum_type)text_buf.pull_int().get_val();
if (!GeoShape::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GeoShape_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
}
}

boolean GeoShape_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GeoShape_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GeoShape_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    GeoShape::enum_type enum_val = (enum_name != NULL) ? GeoShape::str_to_enum(enum_name) : GeoShape::UNKNOWN_VALUE;
    if (GeoShape::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GeoShape_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    GeoShape::enum_type enum_val = GeoShape::str_to_enum(mp->get_enumerated());
    if (!GeoShape::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.GeoShape.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsGeoNetworking_TypesAndValues.GeoShape");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GeoShape_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(GeoShape::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GeoShape_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoShape");
}

GeoArea::GeoArea()
{
  bound_flag = FALSE;
}

GeoArea::GeoArea(const GeoShape& par_shape,
    const Area& par_area)
  :   field_shape(par_shape),
  field_area(par_area)
{
  bound_flag = TRUE;
}

GeoArea::GeoArea(const GeoArea& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoArea.");
bound_flag = TRUE;
if (other_value.shape().is_bound()) field_shape = other_value.shape();
else field_shape.clean_up();
if (other_value.area().is_bound()) field_area = other_value.area();
else field_area.clean_up();
}

void GeoArea::clean_up()
{
field_shape.clean_up();
field_area.clean_up();
bound_flag = FALSE;
}

GeoArea& GeoArea::operator=(const GeoArea& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoArea.");
  bound_flag = TRUE;
  if (other_value.shape().is_bound()) field_shape = other_value.shape();
  else field_shape.clean_up();
  if (other_value.area().is_bound()) field_area = other_value.area();
  else field_area.clean_up();
}
return *this;
}

boolean GeoArea::operator==(const GeoArea& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_shape==other_value.field_shape
  && field_area==other_value.field_area;
}

boolean GeoArea::is_bound() const
{
if (bound_flag) return TRUE;
if(field_shape.is_bound()) return TRUE;
if(field_area.is_bound()) return TRUE;
return FALSE;
}
boolean GeoArea::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_shape.is_value()) return FALSE;
if(!field_area.is_value()) return FALSE;
return TRUE;
}
int GeoArea::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoArea");
  return 2;
}

void GeoArea::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ shape := ");
field_shape.log();
TTCN_Logger::log_event_str(", area := ");
field_area.log();
TTCN_Logger::log_event_str(" }");
}

void GeoArea::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.GeoArea'");
    }
    if (strcmp("shape", param_field) == 0) {
      shape().set_param(param);
      return;
    } else if (strcmp("area", param_field) == 0) {
      area().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoArea'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.GeoArea has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) shape().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) area().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "shape")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          shape().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "area")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          area().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoArea: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.GeoArea");
  }
}

Module_Param* GeoArea::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.GeoArea'");
    }
    if (strcmp("shape", param_field) == 0) {
      return shape().get_param(param_name);
    } else if (strcmp("area", param_field) == 0) {
      return area().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoArea'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_shape = field_shape.get_param(param_name);
  mp_field_shape->set_id(new Module_Param_FieldName(mcopystr("shape")));
  mp->add_elem(mp_field_shape);
  Module_Param* mp_field_area = field_area.get_param(param_name);
  mp_field_area->set_id(new Module_Param_FieldName(mcopystr("area")));
  mp->add_elem(mp_field_area);
  return mp;
  }

void GeoArea::set_implicit_omit()
{
if (shape().is_bound()) shape().set_implicit_omit();
if (area().is_bound()) area().set_implicit_omit();
}

void GeoArea::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoArea.");
field_shape.encode_text(text_buf);
field_area.encode_text(text_buf);
}

void GeoArea::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_shape.decode_text(text_buf);
field_area.decode_text(text_buf);
}

void GeoArea::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GeoArea::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GeoArea::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_shape.RAW_decode(GeoShape_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_area.RAW_decode(Area_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GeoArea::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, GeoShape_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, Area_descr_.raw);
  encoded_length += field_shape.RAW_encode(GeoShape_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_area.RAW_encode(Area_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int GeoArea::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoArea.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "shape");
    enc_len += field_shape.JSON_encode(GeoShape_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "area");
    enc_len += field_area.JSON_encode(Area_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GeoArea::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (5 == name_len && 0 == strncmp(fld_name, "shape", name_len)) {
         int ret_val = field_shape.JSON_decode(GeoShape_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "shape");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (4 == name_len && 0 == strncmp(fld_name, "area", name_len)) {
         int ret_val = field_area.JSON_decode(Area_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "area");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_shape.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "shape");
    return JSON_ERROR_FATAL;
  }
if (!field_area.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "area");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GeoArea_template::single_value_struct {
GeoShape_template field_shape;
Area_template field_area;
};

void GeoArea_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_shape = ANY_VALUE;
single_value->field_area = ANY_VALUE;
}
}
}

void GeoArea_template::copy_value(const GeoArea& other_value)
{
single_value = new single_value_struct;
if (other_value.shape().is_bound()) {
  single_value->field_shape = other_value.shape();
} else {
  single_value->field_shape.clean_up();
}
if (other_value.area().is_bound()) {
  single_value->field_area = other_value.area();
} else {
  single_value->field_area.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GeoArea_template::copy_template(const GeoArea_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.shape().get_selection()) {
single_value->field_shape = other_value.shape();
} else {
single_value->field_shape.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.area().get_selection()) {
single_value->field_area = other_value.area();
} else {
single_value->field_area.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GeoArea_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoArea.");
break;
}
set_selection(other_value);
}

GeoArea_template::GeoArea_template()
{
}

GeoArea_template::GeoArea_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GeoArea_template::GeoArea_template(const GeoArea& other_value)
{
copy_value(other_value);
}

GeoArea_template::GeoArea_template(const OPTIONAL<GeoArea>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoArea&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GeoArea from an unbound optional field.");
}
}

GeoArea_template::GeoArea_template(const GeoArea_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GeoArea_template::~GeoArea_template()
{
clean_up();
}

GeoArea_template& GeoArea_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GeoArea_template& GeoArea_template::operator=(const GeoArea& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GeoArea_template& GeoArea_template::operator=(const OPTIONAL<GeoArea>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoArea&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GeoArea.");
}
return *this;
}

GeoArea_template& GeoArea_template::operator=(const GeoArea_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GeoArea_template::match(const GeoArea& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.shape().is_bound()) return FALSE;
if(!single_value->field_shape.match(other_value.shape(), legacy))return FALSE;
if(!other_value.area().is_bound()) return FALSE;
if(!single_value->field_area.match(other_value.area(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoArea.");
}
return FALSE;
}

boolean GeoArea_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_shape.is_bound()) return TRUE;
if (single_value->field_area.is_bound()) return TRUE;
return FALSE;
}

boolean GeoArea_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_shape.is_value()) return FALSE;
if (!single_value->field_area.is_value()) return FALSE;
return TRUE;
}

void GeoArea_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GeoArea GeoArea_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoArea.");
GeoArea ret_val;
if (single_value->field_shape.is_bound()) {
ret_val.shape() = single_value->field_shape.valueof();
}
if (single_value->field_area.is_bound()) {
ret_val.area() = single_value->field_area.valueof();
}
return ret_val;
}

void GeoArea_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.GeoArea.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GeoArea_template[list_length];
}

GeoArea_template& GeoArea_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GeoArea.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GeoArea.");
return value_list.list_value[list_index];
}

GeoShape_template& GeoArea_template::shape()
{
set_specific();
return single_value->field_shape;
}

const GeoShape_template& GeoArea_template::shape() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field shape of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoArea.");
return single_value->field_shape;
}

Area_template& GeoArea_template::area()
{
set_specific();
return single_value->field_area;
}

const Area_template& GeoArea_template::area() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field area of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoArea.");
return single_value->field_area;
}

int GeoArea_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoArea which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoArea containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoArea containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoArea containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoArea containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoArea containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoArea.");
  }
  return 0;
}

void GeoArea_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ shape := ");
single_value->field_shape.log();
TTCN_Logger::log_event_str(", area := ");
single_value->field_area.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GeoArea_template::log_match(const GeoArea& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_shape.match(match_value.shape(), legacy)){
TTCN_Logger::log_logmatch_info(".shape");
single_value->field_shape.log_match(match_value.shape(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_area.match(match_value.area(), legacy)){
TTCN_Logger::log_logmatch_info(".area");
single_value->field_area.log_match(match_value.area(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ shape := ");
single_value->field_shape.log_match(match_value.shape(), legacy);
TTCN_Logger::log_event_str(", area := ");
single_value->field_area.log_match(match_value.area(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GeoArea_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_shape.encode_text(text_buf);
single_value->field_area.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoArea.");
}
}

void GeoArea_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_shape.decode_text(text_buf);
single_value->field_area.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GeoArea_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.GeoArea.");
}
}

void GeoArea_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoArea'");
    }
    if (strcmp("shape", param_field) == 0) {
      shape().set_param(param);
      return;
    } else if (strcmp("area", param_field) == 0) {
      area().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.GeoArea'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GeoArea_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.GeoArea has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) shape().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) area().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "shape")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          shape().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "area")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          area().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoArea: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.GeoArea");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GeoArea_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoArea'");
    }
    if (strcmp("shape", param_field) == 0) {
      return shape().get_param(param_name);
    } else if (strcmp("area", param_field) == 0) {
      return area().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoArea'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_shape = single_value->field_shape.get_param(param_name);
    mp_field_shape->set_id(new Module_Param_FieldName(mcopystr("shape")));
    mp->add_elem(mp_field_shape);
    Module_Param* mp_field_area = single_value->field_area.get_param(param_name);
    mp_field_area->set_id(new Module_Param_FieldName(mcopystr("area")));
    mp->add_elem(mp_field_area);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GeoArea_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_shape.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoArea");
single_value->field_area.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoArea");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoArea");
}

boolean GeoArea_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GeoArea_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

GeoAreaEntry::GeoAreaEntry()
{
  bound_flag = FALSE;
}

GeoAreaEntry::GeoAreaEntry(const CHARSTRING& par_key,
    const GeoArea& par_geoArea)
  :   field_key(par_key),
  field_geoArea(par_geoArea)
{
  bound_flag = TRUE;
}

GeoAreaEntry::GeoAreaEntry(const GeoAreaEntry& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry.");
bound_flag = TRUE;
if (other_value.key().is_bound()) field_key = other_value.key();
else field_key.clean_up();
if (other_value.geoArea().is_bound()) field_geoArea = other_value.geoArea();
else field_geoArea.clean_up();
}

void GeoAreaEntry::clean_up()
{
field_key.clean_up();
field_geoArea.clean_up();
bound_flag = FALSE;
}

GeoAreaEntry& GeoAreaEntry::operator=(const GeoAreaEntry& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry.");
  bound_flag = TRUE;
  if (other_value.key().is_bound()) field_key = other_value.key();
  else field_key.clean_up();
  if (other_value.geoArea().is_bound()) field_geoArea = other_value.geoArea();
  else field_geoArea.clean_up();
}
return *this;
}

boolean GeoAreaEntry::operator==(const GeoAreaEntry& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_key==other_value.field_key
  && field_geoArea==other_value.field_geoArea;
}

boolean GeoAreaEntry::is_bound() const
{
if (bound_flag) return TRUE;
if(field_key.is_bound()) return TRUE;
if(field_geoArea.is_bound()) return TRUE;
return FALSE;
}
boolean GeoAreaEntry::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_key.is_value()) return FALSE;
if(!field_geoArea.is_value()) return FALSE;
return TRUE;
}
int GeoAreaEntry::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry");
  return 2;
}

void GeoAreaEntry::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ key := ");
field_key.log();
TTCN_Logger::log_event_str(", geoArea := ");
field_geoArea.log();
TTCN_Logger::log_event_str(" }");
}

void GeoAreaEntry::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.GeoAreaEntry'");
    }
    if (strcmp("key", param_field) == 0) {
      key().set_param(param);
      return;
    } else if (strcmp("geoArea", param_field) == 0) {
      geoArea().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoAreaEntry'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) key().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) geoArea().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoArea")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoArea().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.GeoAreaEntry");
  }
}

Module_Param* GeoAreaEntry::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.GeoAreaEntry'");
    }
    if (strcmp("key", param_field) == 0) {
      return key().get_param(param_name);
    } else if (strcmp("geoArea", param_field) == 0) {
      return geoArea().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoAreaEntry'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_key = field_key.get_param(param_name);
  mp_field_key->set_id(new Module_Param_FieldName(mcopystr("key")));
  mp->add_elem(mp_field_key);
  Module_Param* mp_field_geoArea = field_geoArea.get_param(param_name);
  mp_field_geoArea->set_id(new Module_Param_FieldName(mcopystr("geoArea")));
  mp->add_elem(mp_field_geoArea);
  return mp;
  }

void GeoAreaEntry::set_implicit_omit()
{
if (key().is_bound()) key().set_implicit_omit();
if (geoArea().is_bound()) geoArea().set_implicit_omit();
}

void GeoAreaEntry::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry.");
field_key.encode_text(text_buf);
field_geoArea.encode_text(text_buf);
}

void GeoAreaEntry::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_key.decode_text(text_buf);
field_geoArea.decode_text(text_buf);
}

void GeoAreaEntry::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GeoAreaEntry::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GeoAreaEntry::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_key.RAW_decode(CHARSTRING_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_geoArea.RAW_decode(GeoArea_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GeoAreaEntry::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, CHARSTRING_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, GeoArea_descr_.raw);
  encoded_length += field_key.RAW_encode(CHARSTRING_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_geoArea.RAW_encode(GeoArea_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int GeoAreaEntry::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "key");
    enc_len += field_key.JSON_encode(CHARSTRING_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoArea");
    enc_len += field_geoArea.JSON_encode(GeoArea_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GeoAreaEntry::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (3 == name_len && 0 == strncmp(fld_name, "key", name_len)) {
         int ret_val = field_key.JSON_decode(CHARSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "key");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "geoArea", name_len)) {
         int ret_val = field_geoArea.JSON_decode(GeoArea_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoArea");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_key.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "key");
    return JSON_ERROR_FATAL;
  }
if (!field_geoArea.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoArea");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GeoAreaEntry_template::single_value_struct {
CHARSTRING_template field_key;
GeoArea_template field_geoArea;
};

void GeoAreaEntry_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_key = ANY_VALUE;
single_value->field_geoArea = ANY_VALUE;
}
}
}

void GeoAreaEntry_template::copy_value(const GeoAreaEntry& other_value)
{
single_value = new single_value_struct;
if (other_value.key().is_bound()) {
  single_value->field_key = other_value.key();
} else {
  single_value->field_key.clean_up();
}
if (other_value.geoArea().is_bound()) {
  single_value->field_geoArea = other_value.geoArea();
} else {
  single_value->field_geoArea.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GeoAreaEntry_template::copy_template(const GeoAreaEntry_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.key().get_selection()) {
single_value->field_key = other_value.key();
} else {
single_value->field_key.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoArea().get_selection()) {
single_value->field_geoArea = other_value.geoArea();
} else {
single_value->field_geoArea.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GeoAreaEntry_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry.");
break;
}
set_selection(other_value);
}

GeoAreaEntry_template::GeoAreaEntry_template()
{
}

GeoAreaEntry_template::GeoAreaEntry_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GeoAreaEntry_template::GeoAreaEntry_template(const GeoAreaEntry& other_value)
{
copy_value(other_value);
}

GeoAreaEntry_template::GeoAreaEntry_template(const OPTIONAL<GeoAreaEntry>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoAreaEntry&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry from an unbound optional field.");
}
}

GeoAreaEntry_template::GeoAreaEntry_template(const GeoAreaEntry_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GeoAreaEntry_template::~GeoAreaEntry_template()
{
clean_up();
}

GeoAreaEntry_template& GeoAreaEntry_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GeoAreaEntry_template& GeoAreaEntry_template::operator=(const GeoAreaEntry& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GeoAreaEntry_template& GeoAreaEntry_template::operator=(const OPTIONAL<GeoAreaEntry>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoAreaEntry&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry.");
}
return *this;
}

GeoAreaEntry_template& GeoAreaEntry_template::operator=(const GeoAreaEntry_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GeoAreaEntry_template::match(const GeoAreaEntry& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.key().is_bound()) return FALSE;
if(!single_value->field_key.match(other_value.key(), legacy))return FALSE;
if(!other_value.geoArea().is_bound()) return FALSE;
if(!single_value->field_geoArea.match(other_value.geoArea(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry.");
}
return FALSE;
}

boolean GeoAreaEntry_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_key.is_bound()) return TRUE;
if (single_value->field_geoArea.is_bound()) return TRUE;
return FALSE;
}

boolean GeoAreaEntry_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_key.is_value()) return FALSE;
if (!single_value->field_geoArea.is_value()) return FALSE;
return TRUE;
}

void GeoAreaEntry_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GeoAreaEntry GeoAreaEntry_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry.");
GeoAreaEntry ret_val;
if (single_value->field_key.is_bound()) {
ret_val.key() = single_value->field_key.valueof();
}
if (single_value->field_geoArea.is_bound()) {
ret_val.geoArea() = single_value->field_geoArea.valueof();
}
return ret_val;
}

void GeoAreaEntry_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GeoAreaEntry_template[list_length];
}

GeoAreaEntry_template& GeoAreaEntry_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry.");
return value_list.list_value[list_index];
}

CHARSTRING_template& GeoAreaEntry_template::key()
{
set_specific();
return single_value->field_key;
}

const CHARSTRING_template& GeoAreaEntry_template::key() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field key of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry.");
return single_value->field_key;
}

GeoArea_template& GeoAreaEntry_template::geoArea()
{
set_specific();
return single_value->field_geoArea;
}

const GeoArea_template& GeoAreaEntry_template::geoArea() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoArea of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry.");
return single_value->field_geoArea;
}

int GeoAreaEntry_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry.");
  }
  return 0;
}

void GeoAreaEntry_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ key := ");
single_value->field_key.log();
TTCN_Logger::log_event_str(", geoArea := ");
single_value->field_geoArea.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GeoAreaEntry_template::log_match(const GeoAreaEntry& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_key.match(match_value.key(), legacy)){
TTCN_Logger::log_logmatch_info(".key");
single_value->field_key.log_match(match_value.key(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoArea.match(match_value.geoArea(), legacy)){
TTCN_Logger::log_logmatch_info(".geoArea");
single_value->field_geoArea.log_match(match_value.geoArea(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ key := ");
single_value->field_key.log_match(match_value.key(), legacy);
TTCN_Logger::log_event_str(", geoArea := ");
single_value->field_geoArea.log_match(match_value.geoArea(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GeoAreaEntry_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_key.encode_text(text_buf);
single_value->field_geoArea.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry.");
}
}

void GeoAreaEntry_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_key.decode_text(text_buf);
single_value->field_geoArea.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GeoAreaEntry_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry.");
}
}

void GeoAreaEntry_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoAreaEntry'");
    }
    if (strcmp("key", param_field) == 0) {
      key().set_param(param);
      return;
    } else if (strcmp("geoArea", param_field) == 0) {
      geoArea().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.GeoAreaEntry'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GeoAreaEntry_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) key().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) geoArea().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoArea")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoArea().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoAreaEntry: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.GeoAreaEntry");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GeoAreaEntry_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoAreaEntry'");
    }
    if (strcmp("key", param_field) == 0) {
      return key().get_param(param_name);
    } else if (strcmp("geoArea", param_field) == 0) {
      return geoArea().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoAreaEntry'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_key = single_value->field_key.get_param(param_name);
    mp_field_key->set_id(new Module_Param_FieldName(mcopystr("key")));
    mp->add_elem(mp_field_key);
    Module_Param* mp_field_geoArea = single_value->field_geoArea.get_param(param_name);
    mp_field_geoArea->set_id(new Module_Param_FieldName(mcopystr("geoArea")));
    mp->add_elem(mp_field_geoArea);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GeoAreaEntry_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_key.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAreaEntry");
single_value->field_geoArea.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAreaEntry");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAreaEntry");
}

boolean GeoAreaEntry_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GeoAreaEntry_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const GeoAreaEntry GeoAreaTable::UNBOUND_ELEM;
GeoAreaTable::GeoAreaTable()
{
val_ptr = NULL;
}

GeoAreaTable::GeoAreaTable(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

GeoAreaTable::GeoAreaTable(const GeoAreaTable& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

GeoAreaTable::~GeoAreaTable()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void GeoAreaTable::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

GeoAreaTable& GeoAreaTable::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

GeoAreaTable& GeoAreaTable::operator=(const GeoAreaTable& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean GeoAreaTable::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
return val_ptr->n_elements == 0 ;
}

boolean GeoAreaTable::operator==(const GeoAreaTable& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

GeoAreaEntry& GeoAreaTable::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (GeoAreaEntry**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new GeoAreaEntry(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new GeoAreaEntry;
}
return *val_ptr->value_elements[index_value];
}

GeoAreaEntry& GeoAreaTable::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
return (*this)[(int)index_value];
}

const GeoAreaEntry& GeoAreaTable::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const GeoAreaEntry& GeoAreaTable::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
return (*this)[(int)index_value];
}

GeoAreaTable GeoAreaTable::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

GeoAreaTable GeoAreaTable::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

GeoAreaTable GeoAreaTable::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

GeoAreaTable GeoAreaTable::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
GeoAreaTable ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new GeoAreaEntry(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

GeoAreaTable GeoAreaTable::operator+(const GeoAreaTable& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsGeoNetworking_TypesAndValues.GeoAreaTable concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
GeoAreaTable ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new GeoAreaEntry(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new GeoAreaEntry(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

GeoAreaTable GeoAreaTable::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsGeoNetworking_TypesAndValues.GeoAreaTable","element");
GeoAreaTable ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new GeoAreaEntry(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

GeoAreaTable GeoAreaTable::replace(int index, int len, const GeoAreaTable& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsGeoNetworking_TypesAndValues.GeoAreaTable","element");
GeoAreaTable ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new GeoAreaEntry(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new GeoAreaEntry(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new GeoAreaEntry(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

GeoAreaTable GeoAreaTable::replace(int index, int len, const GeoAreaTable_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void GeoAreaTable::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (GeoAreaEntry**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new GeoAreaEntry(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (GeoAreaEntry**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (GeoAreaEntry**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean GeoAreaTable::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int GeoAreaTable::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
return val_ptr->n_elements;
}

int GeoAreaTable::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void GeoAreaTable::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void GeoAreaTable::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@LibItsGeoNetworking_TypesAndValues.GeoAreaTable'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@LibItsGeoNetworking_TypesAndValues.GeoAreaTable");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@LibItsGeoNetworking_TypesAndValues.GeoAreaTable");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* GeoAreaTable::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@LibItsGeoNetworking_TypesAndValues.GeoAreaTable'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void GeoAreaTable::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void GeoAreaTable::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void GeoAreaTable::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
val_ptr->value_elements = (GeoAreaEntry**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new GeoAreaEntry;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void GeoAreaTable::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GeoAreaTable::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GeoAreaTable::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int GeoAreaTable::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

void GeoAreaTable_template::copy_value(const GeoAreaTable& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (GeoAreaEntry_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new GeoAreaEntry_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new GeoAreaEntry_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void GeoAreaTable_template::copy_template(const GeoAreaTable_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (GeoAreaEntry_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new GeoAreaEntry_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new GeoAreaEntry_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GeoAreaTable_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
break;
}
set_selection(other_value);
}

boolean GeoAreaTable_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const GeoAreaTable_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const GeoAreaTable*)value_ptr)[value_index], legacy);
else return ((const GeoAreaTable_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

GeoAreaTable_template::GeoAreaTable_template()
{
}

GeoAreaTable_template::GeoAreaTable_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

GeoAreaTable_template::GeoAreaTable_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

GeoAreaTable_template::GeoAreaTable_template(const GeoAreaTable& other_value)
{
copy_value(other_value);
}

GeoAreaTable_template::GeoAreaTable_template(const OPTIONAL<GeoAreaTable>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoAreaTable&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable from an unbound optional field.");
}
}

GeoAreaTable_template::GeoAreaTable_template(const GeoAreaTable_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

GeoAreaTable_template::~GeoAreaTable_template()
{
clean_up();
}

void GeoAreaTable_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GeoAreaTable_template& GeoAreaTable_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GeoAreaTable_template& GeoAreaTable_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

GeoAreaTable_template& GeoAreaTable_template::operator=(const GeoAreaTable& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GeoAreaTable_template& GeoAreaTable_template::operator=(const OPTIONAL<GeoAreaTable>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoAreaTable&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
}
return *this;
}

GeoAreaTable_template& GeoAreaTable_template::operator=(const GeoAreaTable_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

GeoAreaEntry_template& GeoAreaTable_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
    break;
}
return *single_value.value_elements[index_value];
}

GeoAreaEntry_template& GeoAreaTable_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
return (*this)[(int)index_value];
}

const GeoAreaEntry_template& GeoAreaTable_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const GeoAreaEntry_template& GeoAreaTable_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
return (*this)[(int)index_value];
}

void GeoAreaTable_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (GeoAreaEntry_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new GeoAreaEntry_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new GeoAreaEntry_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (GeoAreaEntry_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int GeoAreaTable_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int GeoAreaTable_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable");
}

boolean GeoAreaTable_template::match(const GeoAreaTable& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
}
return FALSE;
}

boolean GeoAreaTable_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

GeoAreaTable GeoAreaTable_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
GeoAreaTable ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

GeoAreaTable GeoAreaTable_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

GeoAreaTable GeoAreaTable_template::replace(int index, int len, const GeoAreaTable_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

GeoAreaTable GeoAreaTable_template::replace(int index, int len, const GeoAreaTable& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void GeoAreaTable_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new GeoAreaTable_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
}
set_selection(template_type);
}

GeoAreaTable_template& GeoAreaTable_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
return value_list.list_value[list_index];
}

void GeoAreaTable_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void GeoAreaTable_template::log_match(const GeoAreaTable& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GeoAreaTable_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
}
}

void GeoAreaTable_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
single_value.value_elements = (GeoAreaEntry_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new GeoAreaEntry_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GeoAreaTable_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
}
}

boolean GeoAreaTable_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GeoAreaTable_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GeoAreaTable_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@LibItsGeoNetworking_TypesAndValues.GeoAreaTable'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GeoAreaTable_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@LibItsGeoNetworking_TypesAndValues.GeoAreaTable");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* GeoAreaTable_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@LibItsGeoNetworking_TypesAndValues.GeoAreaTable'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void GeoAreaTable_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAreaTable");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAreaTable");
}

BasicNextHeader::BasicNextHeader()
{
enum_value = UNBOUND_VALUE;
}

BasicNextHeader::BasicNextHeader(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

BasicNextHeader::BasicNextHeader(enum_type other_value)
{
enum_value = other_value;
}

BasicNextHeader::BasicNextHeader(const BasicNextHeader& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
enum_value = other_value.enum_value;
}

BasicNextHeader& BasicNextHeader::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

BasicNextHeader& BasicNextHeader::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

BasicNextHeader& BasicNextHeader::operator=(const BasicNextHeader& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
enum_value = other_value.enum_value;
return *this;
}

boolean BasicNextHeader::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
return enum_value == other_value;
}

boolean BasicNextHeader::operator==(const BasicNextHeader& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
return enum_value == other_value.enum_value;
}

boolean BasicNextHeader::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
return enum_value < other_value;
}

boolean BasicNextHeader::operator<(const BasicNextHeader& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
return enum_value < other_value.enum_value;
}

boolean BasicNextHeader::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
return enum_value > other_value;
}

boolean BasicNextHeader::operator>(const BasicNextHeader& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
return enum_value > other_value.enum_value;
}

const char *BasicNextHeader::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__any: return "e_any";
case e__commonHeader: return "e_commonHeader";
case e__securedPacket: return "e_securedPacket";
case e__reserved: return "e_reserved";
default: return "<unknown>";
}
}

BasicNextHeader::enum_type BasicNextHeader::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_any")) return e__any;
else if (!strcmp(str_par, "e_commonHeader")) return e__commonHeader;
else if (!strcmp(str_par, "e_securedPacket")) return e__securedPacket;
else if (!strcmp(str_par, "e_reserved")) return e__reserved;
else return UNKNOWN_VALUE;
}

boolean BasicNextHeader::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int BasicNextHeader::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int BasicNextHeader::enum2int(const BasicNextHeader& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void BasicNextHeader::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.", int_val);
enum_value = (enum_type)int_val;
}

BasicNextHeader::operator BasicNextHeader::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
return enum_value;
}

void BasicNextHeader::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void BasicNextHeader::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsGeoNetworking_TypesAndValues.BasicNextHeader");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
  }
}

Module_Param* BasicNextHeader::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void BasicNextHeader::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
text_buf.push_int(enum_value);
}

void BasicNextHeader::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.", enum_value);
}

void BasicNextHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void BasicNextHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int BasicNextHeader::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int BasicNextHeader::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

int BasicNextHeader::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int BasicNextHeader::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void BasicNextHeader_template::copy_template(const BasicNextHeader_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new BasicNextHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
}
}

BasicNextHeader_template::BasicNextHeader_template()
{
}

BasicNextHeader_template::BasicNextHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

BasicNextHeader_template::BasicNextHeader_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!BasicNextHeader::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader with unknown numeric value %d.", other_value);
single_value = (BasicNextHeader::enum_type)other_value;
}

BasicNextHeader_template::BasicNextHeader_template(BasicNextHeader::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

BasicNextHeader_template::BasicNextHeader_template(const BasicNextHeader& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == BasicNextHeader::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
single_value = other_value.enum_value;
}

BasicNextHeader_template::BasicNextHeader_template(const OPTIONAL<BasicNextHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (BasicNextHeader::enum_type)(const BasicNextHeader&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader from an unbound optional field.");
}
}

BasicNextHeader_template::BasicNextHeader_template(const BasicNextHeader_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

BasicNextHeader_template::~BasicNextHeader_template()
{
clean_up();
}

boolean BasicNextHeader_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean BasicNextHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != BasicNextHeader::UNBOUND_VALUE;
}

void BasicNextHeader_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

BasicNextHeader_template& BasicNextHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BasicNextHeader_template& BasicNextHeader_template::operator=(int other_value)
{
if (!BasicNextHeader::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (BasicNextHeader::enum_type)other_value;
return *this;
}

BasicNextHeader_template& BasicNextHeader_template::operator=(BasicNextHeader::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

BasicNextHeader_template& BasicNextHeader_template::operator=(const BasicNextHeader& other_value)
{
if (other_value.enum_value == BasicNextHeader::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

BasicNextHeader_template& BasicNextHeader_template::operator=(const OPTIONAL<BasicNextHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (BasicNextHeader::enum_type)(const BasicNextHeader&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
}
return *this;
}

BasicNextHeader_template& BasicNextHeader_template::operator=(const BasicNextHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean BasicNextHeader_template::match(BasicNextHeader::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
}
return FALSE;
}

boolean BasicNextHeader_template::match(const BasicNextHeader& other_value, boolean) const
{
if (other_value.enum_value == BasicNextHeader::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader with an unbound value.");
return match(other_value.enum_value);
}

BasicNextHeader::enum_type BasicNextHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
return single_value;
}

void BasicNextHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new BasicNextHeader_template[list_length];
}

BasicNextHeader_template& BasicNextHeader_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
return value_list.list_value[list_index];
}

void BasicNextHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(BasicNextHeader::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void BasicNextHeader_template::log_match(const BasicNextHeader& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void BasicNextHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
}
}

void BasicNextHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (BasicNextHeader::enum_type)text_buf.pull_int().get_val();
if (!BasicNextHeader::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new BasicNextHeader_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
}
}

boolean BasicNextHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean BasicNextHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void BasicNextHeader_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    BasicNextHeader::enum_type enum_val = (enum_name != NULL) ? BasicNextHeader::str_to_enum(enum_name) : BasicNextHeader::UNKNOWN_VALUE;
    if (BasicNextHeader::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    BasicNextHeader_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    BasicNextHeader::enum_type enum_val = BasicNextHeader::str_to_enum(mp->get_enumerated());
    if (!BasicNextHeader::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.BasicNextHeader.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsGeoNetworking_TypesAndValues.BasicNextHeader");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* BasicNextHeader_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(BasicNextHeader::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void BasicNextHeader_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.BasicNextHeader");
}

LtBase::LtBase()
{
enum_value = UNBOUND_VALUE;
}

LtBase::LtBase(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

LtBase::LtBase(enum_type other_value)
{
enum_value = other_value;
}

LtBase::LtBase(const LtBase& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
enum_value = other_value.enum_value;
}

LtBase& LtBase::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

LtBase& LtBase::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

LtBase& LtBase::operator=(const LtBase& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
enum_value = other_value.enum_value;
return *this;
}

boolean LtBase::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
return enum_value == other_value;
}

boolean LtBase::operator==(const LtBase& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
return enum_value == other_value.enum_value;
}

boolean LtBase::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
return enum_value < other_value;
}

boolean LtBase::operator<(const LtBase& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
return enum_value < other_value.enum_value;
}

boolean LtBase::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
return enum_value > other_value;
}

boolean LtBase::operator>(const LtBase& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
return enum_value > other_value.enum_value;
}

const char *LtBase::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__50ms: return "e_50ms";
case e__1s: return "e_1s";
case e__10s: return "e_10s";
case e__100s: return "e_100s";
default: return "<unknown>";
}
}

LtBase::enum_type LtBase::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_50ms")) return e__50ms;
else if (!strcmp(str_par, "e_1s")) return e__1s;
else if (!strcmp(str_par, "e_10s")) return e__10s;
else if (!strcmp(str_par, "e_100s")) return e__100s;
else return UNKNOWN_VALUE;
}

boolean LtBase::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int LtBase::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int LtBase::enum2int(const LtBase& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void LtBase::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.", int_val);
enum_value = (enum_type)int_val;
}

LtBase::operator LtBase::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
return enum_value;
}

void LtBase::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void LtBase::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsGeoNetworking_TypesAndValues.LtBase");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.LtBase.");
  }
}

Module_Param* LtBase::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void LtBase::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
text_buf.push_int(enum_value);
}

void LtBase::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.", enum_value);
}

void LtBase::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void LtBase::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int LtBase::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int LtBase::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

int LtBase::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int LtBase::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void LtBase_template::copy_template(const LtBase_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new LtBase_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
}
}

LtBase_template::LtBase_template()
{
}

LtBase_template::LtBase_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

LtBase_template::LtBase_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!LtBase::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase with unknown numeric value %d.", other_value);
single_value = (LtBase::enum_type)other_value;
}

LtBase_template::LtBase_template(LtBase::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

LtBase_template::LtBase_template(const LtBase& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == LtBase::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
single_value = other_value.enum_value;
}

LtBase_template::LtBase_template(const OPTIONAL<LtBase>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (LtBase::enum_type)(const LtBase&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase from an unbound optional field.");
}
}

LtBase_template::LtBase_template(const LtBase_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

LtBase_template::~LtBase_template()
{
clean_up();
}

boolean LtBase_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean LtBase_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != LtBase::UNBOUND_VALUE;
}

void LtBase_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

LtBase_template& LtBase_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

LtBase_template& LtBase_template::operator=(int other_value)
{
if (!LtBase::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (LtBase::enum_type)other_value;
return *this;
}

LtBase_template& LtBase_template::operator=(LtBase::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

LtBase_template& LtBase_template::operator=(const LtBase& other_value)
{
if (other_value.enum_value == LtBase::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

LtBase_template& LtBase_template::operator=(const OPTIONAL<LtBase>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (LtBase::enum_type)(const LtBase&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
}
return *this;
}

LtBase_template& LtBase_template::operator=(const LtBase_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean LtBase_template::match(LtBase::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
}
return FALSE;
}

boolean LtBase_template::match(const LtBase& other_value, boolean) const
{
if (other_value.enum_value == LtBase::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase with an unbound value.");
return match(other_value.enum_value);
}

LtBase::enum_type LtBase_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
return single_value;
}

void LtBase_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new LtBase_template[list_length];
}

LtBase_template& LtBase_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
return value_list.list_value[list_index];
}

void LtBase_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(LtBase::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void LtBase_template::log_match(const LtBase& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void LtBase_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
}
}

void LtBase_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (LtBase::enum_type)text_buf.pull_int().get_val();
if (!LtBase::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new LtBase_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.LtBase.");
}
}

boolean LtBase_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean LtBase_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void LtBase_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    LtBase::enum_type enum_val = (enum_name != NULL) ? LtBase::str_to_enum(enum_name) : LtBase::UNKNOWN_VALUE;
    if (LtBase::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    LtBase_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    LtBase::enum_type enum_val = LtBase::str_to_enum(mp->get_enumerated());
    if (!LtBase::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.LtBase.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsGeoNetworking_TypesAndValues.LtBase");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* LtBase_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(LtBase::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void LtBase_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LtBase");
}

Lifetime::Lifetime()
{
  bound_flag = FALSE;
}

Lifetime::Lifetime(const INTEGER& par_multiplier,
    const LtBase& par_ltBase)
  :   field_multiplier(par_multiplier),
  field_ltBase(par_ltBase)
{
  bound_flag = TRUE;
}

Lifetime::Lifetime(const Lifetime& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.Lifetime.");
bound_flag = TRUE;
if (other_value.multiplier().is_bound()) field_multiplier = other_value.multiplier();
else field_multiplier.clean_up();
if (other_value.ltBase().is_bound()) field_ltBase = other_value.ltBase();
else field_ltBase.clean_up();
}

void Lifetime::clean_up()
{
field_multiplier.clean_up();
field_ltBase.clean_up();
bound_flag = FALSE;
}

Lifetime& Lifetime::operator=(const Lifetime& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.Lifetime.");
  bound_flag = TRUE;
  if (other_value.multiplier().is_bound()) field_multiplier = other_value.multiplier();
  else field_multiplier.clean_up();
  if (other_value.ltBase().is_bound()) field_ltBase = other_value.ltBase();
  else field_ltBase.clean_up();
}
return *this;
}

boolean Lifetime::operator==(const Lifetime& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_multiplier==other_value.field_multiplier
  && field_ltBase==other_value.field_ltBase;
}

boolean Lifetime::is_bound() const
{
if (bound_flag) return TRUE;
if(field_multiplier.is_bound()) return TRUE;
if(field_ltBase.is_bound()) return TRUE;
return FALSE;
}
boolean Lifetime::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_multiplier.is_value()) return FALSE;
if(!field_ltBase.is_value()) return FALSE;
return TRUE;
}
int Lifetime::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.Lifetime");
  return 2;
}

void Lifetime::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ multiplier := ");
field_multiplier.log();
TTCN_Logger::log_event_str(", ltBase := ");
field_ltBase.log();
TTCN_Logger::log_event_str(" }");
}

void Lifetime::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.Lifetime'");
    }
    if (strcmp("multiplier", param_field) == 0) {
      multiplier().set_param(param);
      return;
    } else if (strcmp("ltBase", param_field) == 0) {
      ltBase().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.Lifetime'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.Lifetime has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) multiplier().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ltBase().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "multiplier")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          multiplier().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ltBase")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ltBase().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.Lifetime: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.Lifetime");
  }
}

Module_Param* Lifetime::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.Lifetime'");
    }
    if (strcmp("multiplier", param_field) == 0) {
      return multiplier().get_param(param_name);
    } else if (strcmp("ltBase", param_field) == 0) {
      return ltBase().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.Lifetime'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_multiplier = field_multiplier.get_param(param_name);
  mp_field_multiplier->set_id(new Module_Param_FieldName(mcopystr("multiplier")));
  mp->add_elem(mp_field_multiplier);
  Module_Param* mp_field_ltBase = field_ltBase.get_param(param_name);
  mp_field_ltBase->set_id(new Module_Param_FieldName(mcopystr("ltBase")));
  mp->add_elem(mp_field_ltBase);
  return mp;
  }

void Lifetime::set_implicit_omit()
{
if (multiplier().is_bound()) multiplier().set_implicit_omit();
if (ltBase().is_bound()) ltBase().set_implicit_omit();
}

void Lifetime::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.Lifetime.");
field_multiplier.encode_text(text_buf);
field_ltBase.encode_text(text_buf);
}

void Lifetime::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_multiplier.decode_text(text_buf);
field_ltBase.decode_text(text_buf);
}

void Lifetime::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Lifetime::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int Lifetime::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_multiplier.RAW_decode(LibCommon__BasicTypesAndValues::UInt6_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_ltBase.RAW_decode(LtBase_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int Lifetime::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt6_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LtBase_descr_.raw);
  encoded_length += field_multiplier.RAW_encode(LibCommon__BasicTypesAndValues::UInt6_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_ltBase.RAW_encode(LtBase_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int Lifetime::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.Lifetime.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "multiplier");
    enc_len += field_multiplier.JSON_encode(LibCommon__BasicTypesAndValues::UInt6_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ltBase");
    enc_len += field_ltBase.JSON_encode(LtBase_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Lifetime::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "multiplier", name_len)) {
         int ret_val = field_multiplier.JSON_decode(LibCommon__BasicTypesAndValues::UInt6_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "multiplier");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "ltBase", name_len)) {
         int ret_val = field_ltBase.JSON_decode(LtBase_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ltBase");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_multiplier.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "multiplier");
    return JSON_ERROR_FATAL;
  }
if (!field_ltBase.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "ltBase");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct Lifetime_template::single_value_struct {
INTEGER_template field_multiplier;
LtBase_template field_ltBase;
};

void Lifetime_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_multiplier = ANY_VALUE;
single_value->field_ltBase = ANY_VALUE;
}
}
}

void Lifetime_template::copy_value(const Lifetime& other_value)
{
single_value = new single_value_struct;
if (other_value.multiplier().is_bound()) {
  single_value->field_multiplier = other_value.multiplier();
} else {
  single_value->field_multiplier.clean_up();
}
if (other_value.ltBase().is_bound()) {
  single_value->field_ltBase = other_value.ltBase();
} else {
  single_value->field_ltBase.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Lifetime_template::copy_template(const Lifetime_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.multiplier().get_selection()) {
single_value->field_multiplier = other_value.multiplier();
} else {
single_value->field_multiplier.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ltBase().get_selection()) {
single_value->field_ltBase = other_value.ltBase();
} else {
single_value->field_ltBase.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Lifetime_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.Lifetime.");
break;
}
set_selection(other_value);
}

Lifetime_template::Lifetime_template()
{
}

Lifetime_template::Lifetime_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Lifetime_template::Lifetime_template(const Lifetime& other_value)
{
copy_value(other_value);
}

Lifetime_template::Lifetime_template(const OPTIONAL<Lifetime>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Lifetime&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.Lifetime from an unbound optional field.");
}
}

Lifetime_template::Lifetime_template(const Lifetime_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Lifetime_template::~Lifetime_template()
{
clean_up();
}

Lifetime_template& Lifetime_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Lifetime_template& Lifetime_template::operator=(const Lifetime& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Lifetime_template& Lifetime_template::operator=(const OPTIONAL<Lifetime>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Lifetime&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.Lifetime.");
}
return *this;
}

Lifetime_template& Lifetime_template::operator=(const Lifetime_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Lifetime_template::match(const Lifetime& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.multiplier().is_bound()) return FALSE;
if(!single_value->field_multiplier.match(other_value.multiplier(), legacy))return FALSE;
if(!other_value.ltBase().is_bound()) return FALSE;
if(!single_value->field_ltBase.match(other_value.ltBase(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.Lifetime.");
}
return FALSE;
}

boolean Lifetime_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_multiplier.is_bound()) return TRUE;
if (single_value->field_ltBase.is_bound()) return TRUE;
return FALSE;
}

boolean Lifetime_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_multiplier.is_value()) return FALSE;
if (!single_value->field_ltBase.is_value()) return FALSE;
return TRUE;
}

void Lifetime_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Lifetime Lifetime_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.Lifetime.");
Lifetime ret_val;
if (single_value->field_multiplier.is_bound()) {
ret_val.multiplier() = single_value->field_multiplier.valueof();
}
if (single_value->field_ltBase.is_bound()) {
ret_val.ltBase() = single_value->field_ltBase.valueof();
}
return ret_val;
}

void Lifetime_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.Lifetime.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Lifetime_template[list_length];
}

Lifetime_template& Lifetime_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.Lifetime.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.Lifetime.");
return value_list.list_value[list_index];
}

INTEGER_template& Lifetime_template::multiplier()
{
set_specific();
return single_value->field_multiplier;
}

const INTEGER_template& Lifetime_template::multiplier() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field multiplier of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.Lifetime.");
return single_value->field_multiplier;
}

LtBase_template& Lifetime_template::ltBase()
{
set_specific();
return single_value->field_ltBase;
}

const LtBase_template& Lifetime_template::ltBase() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ltBase of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.Lifetime.");
return single_value->field_ltBase;
}

int Lifetime_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Lifetime which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Lifetime containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Lifetime containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Lifetime containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Lifetime containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Lifetime containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.Lifetime.");
  }
  return 0;
}

void Lifetime_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ multiplier := ");
single_value->field_multiplier.log();
TTCN_Logger::log_event_str(", ltBase := ");
single_value->field_ltBase.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Lifetime_template::log_match(const Lifetime& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_multiplier.match(match_value.multiplier(), legacy)){
TTCN_Logger::log_logmatch_info(".multiplier");
single_value->field_multiplier.log_match(match_value.multiplier(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ltBase.match(match_value.ltBase(), legacy)){
TTCN_Logger::log_logmatch_info(".ltBase");
single_value->field_ltBase.log_match(match_value.ltBase(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ multiplier := ");
single_value->field_multiplier.log_match(match_value.multiplier(), legacy);
TTCN_Logger::log_event_str(", ltBase := ");
single_value->field_ltBase.log_match(match_value.ltBase(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Lifetime_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_multiplier.encode_text(text_buf);
single_value->field_ltBase.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.Lifetime.");
}
}

void Lifetime_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_multiplier.decode_text(text_buf);
single_value->field_ltBase.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Lifetime_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.Lifetime.");
}
}

void Lifetime_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.Lifetime'");
    }
    if (strcmp("multiplier", param_field) == 0) {
      multiplier().set_param(param);
      return;
    } else if (strcmp("ltBase", param_field) == 0) {
      ltBase().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.Lifetime'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Lifetime_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.Lifetime has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) multiplier().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ltBase().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "multiplier")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          multiplier().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ltBase")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ltBase().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.Lifetime: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.Lifetime");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Lifetime_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.Lifetime'");
    }
    if (strcmp("multiplier", param_field) == 0) {
      return multiplier().get_param(param_name);
    } else if (strcmp("ltBase", param_field) == 0) {
      return ltBase().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.Lifetime'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_multiplier = single_value->field_multiplier.get_param(param_name);
    mp_field_multiplier->set_id(new Module_Param_FieldName(mcopystr("multiplier")));
    mp->add_elem(mp_field_multiplier);
    Module_Param* mp_field_ltBase = single_value->field_ltBase.get_param(param_name);
    mp_field_ltBase->set_id(new Module_Param_FieldName(mcopystr("ltBase")));
    mp->add_elem(mp_field_ltBase);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Lifetime_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_multiplier.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.Lifetime");
single_value->field_ltBase.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.Lifetime");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.Lifetime");
}

boolean Lifetime_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Lifetime_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

BasicHeader::BasicHeader()
{
  bound_flag = FALSE;
}

BasicHeader::BasicHeader(const INTEGER& par_version,
    const BasicNextHeader& par_nextHeader,
    const INTEGER& par_reserved,
    const Lifetime& par_lifeTime,
    const INTEGER& par_routerHopLimit)
  :   field_version(par_version),
  field_nextHeader(par_nextHeader),
  field_reserved(par_reserved),
  field_lifeTime(par_lifeTime),
  field_routerHopLimit(par_routerHopLimit)
{
  bound_flag = TRUE;
}

BasicHeader::BasicHeader(const BasicHeader& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
bound_flag = TRUE;
if (other_value.version().is_bound()) field_version = other_value.version();
else field_version.clean_up();
if (other_value.nextHeader().is_bound()) field_nextHeader = other_value.nextHeader();
else field_nextHeader.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
if (other_value.lifeTime().is_bound()) field_lifeTime = other_value.lifeTime();
else field_lifeTime.clean_up();
if (other_value.routerHopLimit().is_bound()) field_routerHopLimit = other_value.routerHopLimit();
else field_routerHopLimit.clean_up();
}

void BasicHeader::clean_up()
{
field_version.clean_up();
field_nextHeader.clean_up();
field_reserved.clean_up();
field_lifeTime.clean_up();
field_routerHopLimit.clean_up();
bound_flag = FALSE;
}

BasicHeader& BasicHeader::operator=(const BasicHeader& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
  bound_flag = TRUE;
  if (other_value.version().is_bound()) field_version = other_value.version();
  else field_version.clean_up();
  if (other_value.nextHeader().is_bound()) field_nextHeader = other_value.nextHeader();
  else field_nextHeader.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
  if (other_value.lifeTime().is_bound()) field_lifeTime = other_value.lifeTime();
  else field_lifeTime.clean_up();
  if (other_value.routerHopLimit().is_bound()) field_routerHopLimit = other_value.routerHopLimit();
  else field_routerHopLimit.clean_up();
}
return *this;
}

boolean BasicHeader::operator==(const BasicHeader& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_version==other_value.field_version
  && field_nextHeader==other_value.field_nextHeader
  && field_reserved==other_value.field_reserved
  && field_lifeTime==other_value.field_lifeTime
  && field_routerHopLimit==other_value.field_routerHopLimit;
}

boolean BasicHeader::is_bound() const
{
if (bound_flag) return TRUE;
if(field_version.is_bound()) return TRUE;
if(field_nextHeader.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
if(field_lifeTime.is_bound()) return TRUE;
if(field_routerHopLimit.is_bound()) return TRUE;
return FALSE;
}
boolean BasicHeader::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_version.is_value()) return FALSE;
if(!field_nextHeader.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
if(!field_lifeTime.is_value()) return FALSE;
if(!field_routerHopLimit.is_value()) return FALSE;
return TRUE;
}
int BasicHeader::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.BasicHeader");
  return 5;
}

void BasicHeader::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ version := ");
field_version.log();
TTCN_Logger::log_event_str(", nextHeader := ");
field_nextHeader.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(", lifeTime := ");
field_lifeTime.log();
TTCN_Logger::log_event_str(", routerHopLimit := ");
field_routerHopLimit.log();
TTCN_Logger::log_event_str(" }");
}

void BasicHeader::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.BasicHeader'");
    }
    if (strcmp("version", param_field) == 0) {
      version().set_param(param);
      return;
    } else if (strcmp("nextHeader", param_field) == 0) {
      nextHeader().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("lifeTime", param_field) == 0) {
      lifeTime().set_param(param);
      return;
    } else if (strcmp("routerHopLimit", param_field) == 0) {
      routerHopLimit().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.BasicHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.BasicHeader has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) nextHeader().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) lifeTime().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) routerHopLimit().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lifeTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lifeTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "routerHopLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          routerHopLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.BasicHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.BasicHeader");
  }
}

Module_Param* BasicHeader::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.BasicHeader'");
    }
    if (strcmp("version", param_field) == 0) {
      return version().get_param(param_name);
    } else if (strcmp("nextHeader", param_field) == 0) {
      return nextHeader().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("lifeTime", param_field) == 0) {
      return lifeTime().get_param(param_name);
    } else if (strcmp("routerHopLimit", param_field) == 0) {
      return routerHopLimit().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.BasicHeader'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_version = field_version.get_param(param_name);
  mp_field_version->set_id(new Module_Param_FieldName(mcopystr("version")));
  mp->add_elem(mp_field_version);
  Module_Param* mp_field_nextHeader = field_nextHeader.get_param(param_name);
  mp_field_nextHeader->set_id(new Module_Param_FieldName(mcopystr("nextHeader")));
  mp->add_elem(mp_field_nextHeader);
  Module_Param* mp_field_reserved = field_reserved.get_param(param_name);
  mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
  mp->add_elem(mp_field_reserved);
  Module_Param* mp_field_lifeTime = field_lifeTime.get_param(param_name);
  mp_field_lifeTime->set_id(new Module_Param_FieldName(mcopystr("lifeTime")));
  mp->add_elem(mp_field_lifeTime);
  Module_Param* mp_field_routerHopLimit = field_routerHopLimit.get_param(param_name);
  mp_field_routerHopLimit->set_id(new Module_Param_FieldName(mcopystr("routerHopLimit")));
  mp->add_elem(mp_field_routerHopLimit);
  return mp;
  }

void BasicHeader::set_implicit_omit()
{
if (version().is_bound()) version().set_implicit_omit();
if (nextHeader().is_bound()) nextHeader().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
if (lifeTime().is_bound()) lifeTime().set_implicit_omit();
if (routerHopLimit().is_bound()) routerHopLimit().set_implicit_omit();
}

void BasicHeader::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
field_version.encode_text(text_buf);
field_nextHeader.encode_text(text_buf);
field_reserved.encode_text(text_buf);
field_lifeTime.encode_text(text_buf);
field_routerHopLimit.encode_text(text_buf);
}

void BasicHeader::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_version.decode_text(text_buf);
field_nextHeader.decode_text(text_buf);
field_reserved.decode_text(text_buf);
field_lifeTime.decode_text(text_buf);
field_routerHopLimit.decode_text(text_buf);
}

void BasicHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void BasicHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int BasicHeader::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_version.RAW_decode(BasicHeader_version_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_nextHeader.RAW_decode(BasicHeader_nextHeader_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved.RAW_decode(BasicHeader_reserved_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_lifeTime.RAW_decode(BasicHeader_lifeTime_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_routerHopLimit.RAW_decode(BasicHeader_routerHopLimit_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int BasicHeader::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 5;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(5);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, BasicHeader_version_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, BasicHeader_nextHeader_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, BasicHeader_reserved_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, BasicHeader_lifeTime_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, BasicHeader_routerHopLimit_descr_.raw);
  encoded_length += field_version.RAW_encode(BasicHeader_version_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_nextHeader.RAW_encode(BasicHeader_nextHeader_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_reserved.RAW_encode(BasicHeader_reserved_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_lifeTime.RAW_encode(BasicHeader_lifeTime_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_routerHopLimit.RAW_encode(BasicHeader_routerHopLimit_descr_, *myleaf.body.node.nodes[4]);
  return myleaf.length = encoded_length;
}

int BasicHeader::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "version");
    enc_len += field_version.JSON_encode(BasicHeader_version_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "nextHeader");
    enc_len += field_nextHeader.JSON_encode(BasicHeader_nextHeader_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(BasicHeader_reserved_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lifeTime");
    enc_len += field_lifeTime.JSON_encode(BasicHeader_lifeTime_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "routerHopLimit");
    enc_len += field_routerHopLimit.JSON_encode(BasicHeader_routerHopLimit_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int BasicHeader::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (7 == name_len && 0 == strncmp(fld_name, "version", name_len)) {
         int ret_val = field_version.JSON_decode(BasicHeader_version_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "version");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "nextHeader", name_len)) {
         int ret_val = field_nextHeader.JSON_decode(BasicHeader_nextHeader_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "nextHeader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
         int ret_val = field_reserved.JSON_decode(BasicHeader_reserved_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "lifeTime", name_len)) {
         int ret_val = field_lifeTime.JSON_decode(BasicHeader_lifeTime_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lifeTime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "routerHopLimit", name_len)) {
         int ret_val = field_routerHopLimit.JSON_decode(BasicHeader_routerHopLimit_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "routerHopLimit");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_version.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "version");
    return JSON_ERROR_FATAL;
  }
if (!field_nextHeader.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "nextHeader");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }
if (!field_lifeTime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "lifeTime");
    return JSON_ERROR_FATAL;
  }
if (!field_routerHopLimit.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "routerHopLimit");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct BasicHeader_template::single_value_struct {
INTEGER_template field_version;
BasicNextHeader_template field_nextHeader;
INTEGER_template field_reserved;
Lifetime_template field_lifeTime;
INTEGER_template field_routerHopLimit;
};

void BasicHeader_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_version = ANY_VALUE;
single_value->field_nextHeader = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
single_value->field_lifeTime = ANY_VALUE;
single_value->field_routerHopLimit = ANY_VALUE;
}
}
}

void BasicHeader_template::copy_value(const BasicHeader& other_value)
{
single_value = new single_value_struct;
if (other_value.version().is_bound()) {
  single_value->field_version = other_value.version();
} else {
  single_value->field_version.clean_up();
}
if (other_value.nextHeader().is_bound()) {
  single_value->field_nextHeader = other_value.nextHeader();
} else {
  single_value->field_nextHeader.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
if (other_value.lifeTime().is_bound()) {
  single_value->field_lifeTime = other_value.lifeTime();
} else {
  single_value->field_lifeTime.clean_up();
}
if (other_value.routerHopLimit().is_bound()) {
  single_value->field_routerHopLimit = other_value.routerHopLimit();
} else {
  single_value->field_routerHopLimit.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void BasicHeader_template::copy_template(const BasicHeader_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.version().get_selection()) {
single_value->field_version = other_value.version();
} else {
single_value->field_version.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.nextHeader().get_selection()) {
single_value->field_nextHeader = other_value.nextHeader();
} else {
single_value->field_nextHeader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lifeTime().get_selection()) {
single_value->field_lifeTime = other_value.lifeTime();
} else {
single_value->field_lifeTime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.routerHopLimit().get_selection()) {
single_value->field_routerHopLimit = other_value.routerHopLimit();
} else {
single_value->field_routerHopLimit.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new BasicHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
break;
}
set_selection(other_value);
}

BasicHeader_template::BasicHeader_template()
{
}

BasicHeader_template::BasicHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

BasicHeader_template::BasicHeader_template(const BasicHeader& other_value)
{
copy_value(other_value);
}

BasicHeader_template::BasicHeader_template(const OPTIONAL<BasicHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BasicHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader from an unbound optional field.");
}
}

BasicHeader_template::BasicHeader_template(const BasicHeader_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

BasicHeader_template::~BasicHeader_template()
{
clean_up();
}

BasicHeader_template& BasicHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BasicHeader_template& BasicHeader_template::operator=(const BasicHeader& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

BasicHeader_template& BasicHeader_template::operator=(const OPTIONAL<BasicHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BasicHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
}
return *this;
}

BasicHeader_template& BasicHeader_template::operator=(const BasicHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean BasicHeader_template::match(const BasicHeader& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.version().is_bound()) return FALSE;
if(!single_value->field_version.match(other_value.version(), legacy))return FALSE;
if(!other_value.nextHeader().is_bound()) return FALSE;
if(!single_value->field_nextHeader.match(other_value.nextHeader(), legacy))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved(), legacy))return FALSE;
if(!other_value.lifeTime().is_bound()) return FALSE;
if(!single_value->field_lifeTime.match(other_value.lifeTime(), legacy))return FALSE;
if(!other_value.routerHopLimit().is_bound()) return FALSE;
if(!single_value->field_routerHopLimit.match(other_value.routerHopLimit(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
}
return FALSE;
}

boolean BasicHeader_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_version.is_bound()) return TRUE;
if (single_value->field_nextHeader.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
if (single_value->field_lifeTime.is_bound()) return TRUE;
if (single_value->field_routerHopLimit.is_bound()) return TRUE;
return FALSE;
}

boolean BasicHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_version.is_value()) return FALSE;
if (!single_value->field_nextHeader.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
if (!single_value->field_lifeTime.is_value()) return FALSE;
if (!single_value->field_routerHopLimit.is_value()) return FALSE;
return TRUE;
}

void BasicHeader_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

BasicHeader BasicHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
BasicHeader ret_val;
if (single_value->field_version.is_bound()) {
ret_val.version() = single_value->field_version.valueof();
}
if (single_value->field_nextHeader.is_bound()) {
ret_val.nextHeader() = single_value->field_nextHeader.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
if (single_value->field_lifeTime.is_bound()) {
ret_val.lifeTime() = single_value->field_lifeTime.valueof();
}
if (single_value->field_routerHopLimit.is_bound()) {
ret_val.routerHopLimit() = single_value->field_routerHopLimit.valueof();
}
return ret_val;
}

void BasicHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new BasicHeader_template[list_length];
}

BasicHeader_template& BasicHeader_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
return value_list.list_value[list_index];
}

INTEGER_template& BasicHeader_template::version()
{
set_specific();
return single_value->field_version;
}

const INTEGER_template& BasicHeader_template::version() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field version of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
return single_value->field_version;
}

BasicNextHeader_template& BasicHeader_template::nextHeader()
{
set_specific();
return single_value->field_nextHeader;
}

const BasicNextHeader_template& BasicHeader_template::nextHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field nextHeader of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
return single_value->field_nextHeader;
}

INTEGER_template& BasicHeader_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const INTEGER_template& BasicHeader_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
return single_value->field_reserved;
}

Lifetime_template& BasicHeader_template::lifeTime()
{
set_specific();
return single_value->field_lifeTime;
}

const Lifetime_template& BasicHeader_template::lifeTime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lifeTime of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
return single_value->field_lifeTime;
}

INTEGER_template& BasicHeader_template::routerHopLimit()
{
set_specific();
return single_value->field_routerHopLimit;
}

const INTEGER_template& BasicHeader_template::routerHopLimit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field routerHopLimit of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
return single_value->field_routerHopLimit;
}

int BasicHeader_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 5;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
  }
  return 0;
}

void BasicHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log();
TTCN_Logger::log_event_str(", nextHeader := ");
single_value->field_nextHeader.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(", lifeTime := ");
single_value->field_lifeTime.log();
TTCN_Logger::log_event_str(", routerHopLimit := ");
single_value->field_routerHopLimit.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void BasicHeader_template::log_match(const BasicHeader& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_version.match(match_value.version(), legacy)){
TTCN_Logger::log_logmatch_info(".version");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_nextHeader.match(match_value.nextHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".nextHeader");
single_value->field_nextHeader.log_match(match_value.nextHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_lifeTime.match(match_value.lifeTime(), legacy)){
TTCN_Logger::log_logmatch_info(".lifeTime");
single_value->field_lifeTime.log_match(match_value.lifeTime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_routerHopLimit.match(match_value.routerHopLimit(), legacy)){
TTCN_Logger::log_logmatch_info(".routerHopLimit");
single_value->field_routerHopLimit.log_match(match_value.routerHopLimit(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::log_event_str(", nextHeader := ");
single_value->field_nextHeader.log_match(match_value.nextHeader(), legacy);
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::log_event_str(", lifeTime := ");
single_value->field_lifeTime.log_match(match_value.lifeTime(), legacy);
TTCN_Logger::log_event_str(", routerHopLimit := ");
single_value->field_routerHopLimit.log_match(match_value.routerHopLimit(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void BasicHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_version.encode_text(text_buf);
single_value->field_nextHeader.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
single_value->field_lifeTime.encode_text(text_buf);
single_value->field_routerHopLimit.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
}
}

void BasicHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_version.decode_text(text_buf);
single_value->field_nextHeader.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
single_value->field_lifeTime.decode_text(text_buf);
single_value->field_routerHopLimit.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new BasicHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader.");
}
}

void BasicHeader_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.BasicHeader'");
    }
    if (strcmp("version", param_field) == 0) {
      version().set_param(param);
      return;
    } else if (strcmp("nextHeader", param_field) == 0) {
      nextHeader().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("lifeTime", param_field) == 0) {
      lifeTime().set_param(param);
      return;
    } else if (strcmp("routerHopLimit", param_field) == 0) {
      routerHopLimit().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.BasicHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    BasicHeader_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.BasicHeader has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) nextHeader().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) lifeTime().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) routerHopLimit().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lifeTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lifeTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "routerHopLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          routerHopLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.BasicHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.BasicHeader");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* BasicHeader_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.BasicHeader'");
    }
    if (strcmp("version", param_field) == 0) {
      return version().get_param(param_name);
    } else if (strcmp("nextHeader", param_field) == 0) {
      return nextHeader().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("lifeTime", param_field) == 0) {
      return lifeTime().get_param(param_name);
    } else if (strcmp("routerHopLimit", param_field) == 0) {
      return routerHopLimit().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.BasicHeader'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_version = single_value->field_version.get_param(param_name);
    mp_field_version->set_id(new Module_Param_FieldName(mcopystr("version")));
    mp->add_elem(mp_field_version);
    Module_Param* mp_field_nextHeader = single_value->field_nextHeader.get_param(param_name);
    mp_field_nextHeader->set_id(new Module_Param_FieldName(mcopystr("nextHeader")));
    mp->add_elem(mp_field_nextHeader);
    Module_Param* mp_field_reserved = single_value->field_reserved.get_param(param_name);
    mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
    mp->add_elem(mp_field_reserved);
    Module_Param* mp_field_lifeTime = single_value->field_lifeTime.get_param(param_name);
    mp_field_lifeTime->set_id(new Module_Param_FieldName(mcopystr("lifeTime")));
    mp->add_elem(mp_field_lifeTime);
    Module_Param* mp_field_routerHopLimit = single_value->field_routerHopLimit.get_param(param_name);
    mp_field_routerHopLimit->set_id(new Module_Param_FieldName(mcopystr("routerHopLimit")));
    mp->add_elem(mp_field_routerHopLimit);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void BasicHeader_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_version.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.BasicHeader");
single_value->field_nextHeader.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.BasicHeader");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.BasicHeader");
single_value->field_lifeTime.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.BasicHeader");
single_value->field_routerHopLimit.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.BasicHeader");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.BasicHeader");
}

boolean BasicHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean BasicHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

NextHeader::NextHeader()
{
enum_value = UNBOUND_VALUE;
}

NextHeader::NextHeader(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

NextHeader::NextHeader(enum_type other_value)
{
enum_value = other_value;
}

NextHeader::NextHeader(const NextHeader& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
enum_value = other_value.enum_value;
}

NextHeader& NextHeader::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

NextHeader& NextHeader::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

NextHeader& NextHeader::operator=(const NextHeader& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
enum_value = other_value.enum_value;
return *this;
}

boolean NextHeader::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
return enum_value == other_value;
}

boolean NextHeader::operator==(const NextHeader& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
return enum_value == other_value.enum_value;
}

boolean NextHeader::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
return enum_value < other_value;
}

boolean NextHeader::operator<(const NextHeader& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
return enum_value < other_value.enum_value;
}

boolean NextHeader::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
return enum_value > other_value;
}

boolean NextHeader::operator>(const NextHeader& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
return enum_value > other_value.enum_value;
}

const char *NextHeader::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__any: return "e_any";
case e__btpA: return "e_btpA";
case e__btpB: return "e_btpB";
case e__ipv6: return "e_ipv6";
case e__reserved: return "e_reserved";
default: return "<unknown>";
}
}

NextHeader::enum_type NextHeader::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_any")) return e__any;
else if (!strcmp(str_par, "e_btpA")) return e__btpA;
else if (!strcmp(str_par, "e_btpB")) return e__btpB;
else if (!strcmp(str_par, "e_ipv6")) return e__ipv6;
else if (!strcmp(str_par, "e_reserved")) return e__reserved;
else return UNKNOWN_VALUE;
}

boolean NextHeader::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
return TRUE;
default:
return FALSE;
}
}

int NextHeader::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int NextHeader::enum2int(const NextHeader& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void NextHeader::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.", int_val);
enum_value = (enum_type)int_val;
}

NextHeader::operator NextHeader::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
return enum_value;
}

void NextHeader::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void NextHeader::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsGeoNetworking_TypesAndValues.NextHeader");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
  }
}

Module_Param* NextHeader::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void NextHeader::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
text_buf.push_int(enum_value);
}

void NextHeader::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.", enum_value);
}

void NextHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void NextHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int NextHeader::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int NextHeader::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

int NextHeader::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int NextHeader::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void NextHeader_template::copy_template(const NextHeader_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new NextHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
}
}

NextHeader_template::NextHeader_template()
{
}

NextHeader_template::NextHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

NextHeader_template::NextHeader_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!NextHeader::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader with unknown numeric value %d.", other_value);
single_value = (NextHeader::enum_type)other_value;
}

NextHeader_template::NextHeader_template(NextHeader::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

NextHeader_template::NextHeader_template(const NextHeader& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == NextHeader::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
single_value = other_value.enum_value;
}

NextHeader_template::NextHeader_template(const OPTIONAL<NextHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (NextHeader::enum_type)(const NextHeader&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader from an unbound optional field.");
}
}

NextHeader_template::NextHeader_template(const NextHeader_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

NextHeader_template::~NextHeader_template()
{
clean_up();
}

boolean NextHeader_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean NextHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != NextHeader::UNBOUND_VALUE;
}

void NextHeader_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

NextHeader_template& NextHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

NextHeader_template& NextHeader_template::operator=(int other_value)
{
if (!NextHeader::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (NextHeader::enum_type)other_value;
return *this;
}

NextHeader_template& NextHeader_template::operator=(NextHeader::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

NextHeader_template& NextHeader_template::operator=(const NextHeader& other_value)
{
if (other_value.enum_value == NextHeader::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

NextHeader_template& NextHeader_template::operator=(const OPTIONAL<NextHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (NextHeader::enum_type)(const NextHeader&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
}
return *this;
}

NextHeader_template& NextHeader_template::operator=(const NextHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean NextHeader_template::match(NextHeader::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
}
return FALSE;
}

boolean NextHeader_template::match(const NextHeader& other_value, boolean) const
{
if (other_value.enum_value == NextHeader::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader with an unbound value.");
return match(other_value.enum_value);
}

NextHeader::enum_type NextHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
return single_value;
}

void NextHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new NextHeader_template[list_length];
}

NextHeader_template& NextHeader_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
return value_list.list_value[list_index];
}

void NextHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(NextHeader::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void NextHeader_template::log_match(const NextHeader& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void NextHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
}
}

void NextHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (NextHeader::enum_type)text_buf.pull_int().get_val();
if (!NextHeader::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new NextHeader_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
}
}

boolean NextHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean NextHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void NextHeader_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    NextHeader::enum_type enum_val = (enum_name != NULL) ? NextHeader::str_to_enum(enum_name) : NextHeader::UNKNOWN_VALUE;
    if (NextHeader::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    NextHeader_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    NextHeader::enum_type enum_val = NextHeader::str_to_enum(mp->get_enumerated());
    if (!NextHeader::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.NextHeader.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsGeoNetworking_TypesAndValues.NextHeader");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* NextHeader_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(NextHeader::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void NextHeader_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.NextHeader");
}

void HeaderTST::copy_value(const HeaderTST& other_value)
{
switch (other_value.union_selection) {
case ALT_anyHdr:
field_anyHdr = new AnyHeaderType(*other_value.field_anyHdr);
break;
case ALT_beaconHdr:
field_beaconHdr = new BeaconHeaderType(*other_value.field_beaconHdr);
break;
case ALT_geoUnicastHdr:
field_geoUnicastHdr = new GeoUnicastHeaderType(*other_value.field_geoUnicastHdr);
break;
case ALT_geoAnycastHdr:
field_geoAnycastHdr = new GeoAnycastHeaderType(*other_value.field_geoAnycastHdr);
break;
case ALT_geoBroadcastHdr:
field_geoBroadcastHdr = new GeoBroadcastHeaderType(*other_value.field_geoBroadcastHdr);
break;
case ALT_tsbHdr:
field_tsbHdr = new TsbHeaderType(*other_value.field_tsbHdr);
break;
case ALT_lsHdr:
field_lsHdr = new LsHeaderType(*other_value.field_lsHdr);
break;
case ALT_saHdr:
field_saHdr = new SaHeaderType(*other_value.field_saHdr);
break;
case ALT_reserved:
field_reserved = new INTEGER(*other_value.field_reserved);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
}
union_selection = other_value.union_selection;
}

HeaderTST::HeaderTST()
{
union_selection = UNBOUND_VALUE;
}

HeaderTST::HeaderTST(const HeaderTST& other_value)
: Base_Type(){
copy_value(other_value);
}

HeaderTST::~HeaderTST()
{
clean_up();
}

HeaderTST& HeaderTST::operator=(const HeaderTST& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean HeaderTST::operator==(const HeaderTST& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_anyHdr:
return *field_anyHdr == *other_value.field_anyHdr;
case ALT_beaconHdr:
return *field_beaconHdr == *other_value.field_beaconHdr;
case ALT_geoUnicastHdr:
return *field_geoUnicastHdr == *other_value.field_geoUnicastHdr;
case ALT_geoAnycastHdr:
return *field_geoAnycastHdr == *other_value.field_geoAnycastHdr;
case ALT_geoBroadcastHdr:
return *field_geoBroadcastHdr == *other_value.field_geoBroadcastHdr;
case ALT_tsbHdr:
return *field_tsbHdr == *other_value.field_tsbHdr;
case ALT_lsHdr:
return *field_lsHdr == *other_value.field_lsHdr;
case ALT_saHdr:
return *field_saHdr == *other_value.field_saHdr;
case ALT_reserved:
return *field_reserved == *other_value.field_reserved;
default:
return FALSE;
}
}

AnyHeaderType& HeaderTST::anyHdr()
{
if (union_selection != ALT_anyHdr) {
clean_up();
field_anyHdr = new AnyHeaderType;
union_selection = ALT_anyHdr;
}
return *field_anyHdr;
}

const AnyHeaderType& HeaderTST::anyHdr() const
{
if (union_selection != ALT_anyHdr) TTCN_error("Using non-selected field anyHdr in a value of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *field_anyHdr;
}

BeaconHeaderType& HeaderTST::beaconHdr()
{
if (union_selection != ALT_beaconHdr) {
clean_up();
field_beaconHdr = new BeaconHeaderType;
union_selection = ALT_beaconHdr;
}
return *field_beaconHdr;
}

const BeaconHeaderType& HeaderTST::beaconHdr() const
{
if (union_selection != ALT_beaconHdr) TTCN_error("Using non-selected field beaconHdr in a value of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *field_beaconHdr;
}

GeoUnicastHeaderType& HeaderTST::geoUnicastHdr()
{
if (union_selection != ALT_geoUnicastHdr) {
clean_up();
field_geoUnicastHdr = new GeoUnicastHeaderType;
union_selection = ALT_geoUnicastHdr;
}
return *field_geoUnicastHdr;
}

const GeoUnicastHeaderType& HeaderTST::geoUnicastHdr() const
{
if (union_selection != ALT_geoUnicastHdr) TTCN_error("Using non-selected field geoUnicastHdr in a value of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *field_geoUnicastHdr;
}

GeoAnycastHeaderType& HeaderTST::geoAnycastHdr()
{
if (union_selection != ALT_geoAnycastHdr) {
clean_up();
field_geoAnycastHdr = new GeoAnycastHeaderType;
union_selection = ALT_geoAnycastHdr;
}
return *field_geoAnycastHdr;
}

const GeoAnycastHeaderType& HeaderTST::geoAnycastHdr() const
{
if (union_selection != ALT_geoAnycastHdr) TTCN_error("Using non-selected field geoAnycastHdr in a value of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *field_geoAnycastHdr;
}

GeoBroadcastHeaderType& HeaderTST::geoBroadcastHdr()
{
if (union_selection != ALT_geoBroadcastHdr) {
clean_up();
field_geoBroadcastHdr = new GeoBroadcastHeaderType;
union_selection = ALT_geoBroadcastHdr;
}
return *field_geoBroadcastHdr;
}

const GeoBroadcastHeaderType& HeaderTST::geoBroadcastHdr() const
{
if (union_selection != ALT_geoBroadcastHdr) TTCN_error("Using non-selected field geoBroadcastHdr in a value of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *field_geoBroadcastHdr;
}

TsbHeaderType& HeaderTST::tsbHdr()
{
if (union_selection != ALT_tsbHdr) {
clean_up();
field_tsbHdr = new TsbHeaderType;
union_selection = ALT_tsbHdr;
}
return *field_tsbHdr;
}

const TsbHeaderType& HeaderTST::tsbHdr() const
{
if (union_selection != ALT_tsbHdr) TTCN_error("Using non-selected field tsbHdr in a value of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *field_tsbHdr;
}

LsHeaderType& HeaderTST::lsHdr()
{
if (union_selection != ALT_lsHdr) {
clean_up();
field_lsHdr = new LsHeaderType;
union_selection = ALT_lsHdr;
}
return *field_lsHdr;
}

const LsHeaderType& HeaderTST::lsHdr() const
{
if (union_selection != ALT_lsHdr) TTCN_error("Using non-selected field lsHdr in a value of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *field_lsHdr;
}

SaHeaderType& HeaderTST::saHdr()
{
if (union_selection != ALT_saHdr) {
clean_up();
field_saHdr = new SaHeaderType;
union_selection = ALT_saHdr;
}
return *field_saHdr;
}

const SaHeaderType& HeaderTST::saHdr() const
{
if (union_selection != ALT_saHdr) TTCN_error("Using non-selected field saHdr in a value of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *field_saHdr;
}

INTEGER& HeaderTST::reserved()
{
if (union_selection != ALT_reserved) {
clean_up();
field_reserved = new INTEGER;
union_selection = ALT_reserved;
}
return *field_reserved;
}

const INTEGER& HeaderTST::reserved() const
{
if (union_selection != ALT_reserved) TTCN_error("Using non-selected field reserved in a value of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *field_reserved;
}

boolean HeaderTST::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return union_selection == checked_selection;
}

boolean HeaderTST::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean HeaderTST::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_anyHdr: return field_anyHdr->is_value();
case ALT_beaconHdr: return field_beaconHdr->is_value();
case ALT_geoUnicastHdr: return field_geoUnicastHdr->is_value();
case ALT_geoAnycastHdr: return field_geoAnycastHdr->is_value();
case ALT_geoBroadcastHdr: return field_geoBroadcastHdr->is_value();
case ALT_tsbHdr: return field_tsbHdr->is_value();
case ALT_lsHdr: return field_lsHdr->is_value();
case ALT_saHdr: return field_saHdr->is_value();
case ALT_reserved: return field_reserved->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void HeaderTST::clean_up()
{
switch (union_selection) {
case ALT_anyHdr:
  delete field_anyHdr;
  break;
case ALT_beaconHdr:
  delete field_beaconHdr;
  break;
case ALT_geoUnicastHdr:
  delete field_geoUnicastHdr;
  break;
case ALT_geoAnycastHdr:
  delete field_geoAnycastHdr;
  break;
case ALT_geoBroadcastHdr:
  delete field_geoBroadcastHdr;
  break;
case ALT_tsbHdr:
  delete field_tsbHdr;
  break;
case ALT_lsHdr:
  delete field_lsHdr;
  break;
case ALT_saHdr:
  delete field_saHdr;
  break;
case ALT_reserved:
  delete field_reserved;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void HeaderTST::log() const
{
switch (union_selection) {
case ALT_anyHdr:
TTCN_Logger::log_event_str("{ anyHdr := ");
field_anyHdr->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_beaconHdr:
TTCN_Logger::log_event_str("{ beaconHdr := ");
field_beaconHdr->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_geoUnicastHdr:
TTCN_Logger::log_event_str("{ geoUnicastHdr := ");
field_geoUnicastHdr->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_geoAnycastHdr:
TTCN_Logger::log_event_str("{ geoAnycastHdr := ");
field_geoAnycastHdr->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_geoBroadcastHdr:
TTCN_Logger::log_event_str("{ geoBroadcastHdr := ");
field_geoBroadcastHdr->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_tsbHdr:
TTCN_Logger::log_event_str("{ tsbHdr := ");
field_tsbHdr->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_lsHdr:
TTCN_Logger::log_event_str("{ lsHdr := ");
field_lsHdr->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_saHdr:
TTCN_Logger::log_event_str("{ saHdr := ");
field_saHdr->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_reserved:
TTCN_Logger::log_event_str("{ reserved := ");
field_reserved->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void HeaderTST::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsGeoNetworking_TypesAndValues.HeaderTST'");
    }
    if (strcmp("anyHdr", param_field) == 0) {
      anyHdr().set_param(param);
      return;
    } else if (strcmp("beaconHdr", param_field) == 0) {
      beaconHdr().set_param(param);
      return;
    } else if (strcmp("geoUnicastHdr", param_field) == 0) {
      geoUnicastHdr().set_param(param);
      return;
    } else if (strcmp("geoAnycastHdr", param_field) == 0) {
      geoAnycastHdr().set_param(param);
      return;
    } else if (strcmp("geoBroadcastHdr", param_field) == 0) {
      geoBroadcastHdr().set_param(param);
      return;
    } else if (strcmp("tsbHdr", param_field) == 0) {
      tsbHdr().set_param(param);
      return;
    } else if (strcmp("lsHdr", param_field) == 0) {
      lsHdr().set_param(param);
      return;
    } else if (strcmp("saHdr", param_field) == 0) {
      saHdr().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsGeoNetworking_TypesAndValues.HeaderTST'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "anyHdr")) {
    anyHdr().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "beaconHdr")) {
    beaconHdr().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "geoUnicastHdr")) {
    geoUnicastHdr().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "geoAnycastHdr")) {
    geoAnycastHdr().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "geoBroadcastHdr")) {
    geoBroadcastHdr().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "tsbHdr")) {
    tsbHdr().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "lsHdr")) {
    lsHdr().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "saHdr")) {
    saHdr().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "reserved")) {
    reserved().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsGeoNetworking_TypesAndValues.HeaderTST.", mp_last->get_id()->get_name());
}

Module_Param* HeaderTST::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsGeoNetworking_TypesAndValues.HeaderTST'");
    }
    if (strcmp("anyHdr", param_field) == 0) {
      return anyHdr().get_param(param_name);
    } else if (strcmp("beaconHdr", param_field) == 0) {
      return beaconHdr().get_param(param_name);
    } else if (strcmp("geoUnicastHdr", param_field) == 0) {
      return geoUnicastHdr().get_param(param_name);
    } else if (strcmp("geoAnycastHdr", param_field) == 0) {
      return geoAnycastHdr().get_param(param_name);
    } else if (strcmp("geoBroadcastHdr", param_field) == 0) {
      return geoBroadcastHdr().get_param(param_name);
    } else if (strcmp("tsbHdr", param_field) == 0) {
      return tsbHdr().get_param(param_name);
    } else if (strcmp("lsHdr", param_field) == 0) {
      return lsHdr().get_param(param_name);
    } else if (strcmp("saHdr", param_field) == 0) {
      return saHdr().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `HeaderTST'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_anyHdr:
    mp_field = field_anyHdr->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("anyHdr")));
    break;
  case ALT_beaconHdr:
    mp_field = field_beaconHdr->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("beaconHdr")));
    break;
  case ALT_geoUnicastHdr:
    mp_field = field_geoUnicastHdr->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("geoUnicastHdr")));
    break;
  case ALT_geoAnycastHdr:
    mp_field = field_geoAnycastHdr->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("geoAnycastHdr")));
    break;
  case ALT_geoBroadcastHdr:
    mp_field = field_geoBroadcastHdr->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("geoBroadcastHdr")));
    break;
  case ALT_tsbHdr:
    mp_field = field_tsbHdr->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("tsbHdr")));
    break;
  case ALT_lsHdr:
    mp_field = field_lsHdr->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("lsHdr")));
    break;
  case ALT_saHdr:
    mp_field = field_saHdr->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("saHdr")));
    break;
  case ALT_reserved:
    mp_field = field_reserved->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("reserved")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void HeaderTST::set_implicit_omit()
{
switch (union_selection) {
case ALT_anyHdr:
field_anyHdr->set_implicit_omit(); break;
case ALT_beaconHdr:
field_beaconHdr->set_implicit_omit(); break;
case ALT_geoUnicastHdr:
field_geoUnicastHdr->set_implicit_omit(); break;
case ALT_geoAnycastHdr:
field_geoAnycastHdr->set_implicit_omit(); break;
case ALT_geoBroadcastHdr:
field_geoBroadcastHdr->set_implicit_omit(); break;
case ALT_tsbHdr:
field_tsbHdr->set_implicit_omit(); break;
case ALT_lsHdr:
field_lsHdr->set_implicit_omit(); break;
case ALT_saHdr:
field_saHdr->set_implicit_omit(); break;
case ALT_reserved:
field_reserved->set_implicit_omit(); break;
default: break;
}
}

void HeaderTST::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_anyHdr:
field_anyHdr->encode_text(text_buf);
break;
case ALT_beaconHdr:
field_beaconHdr->encode_text(text_buf);
break;
case ALT_geoUnicastHdr:
field_geoUnicastHdr->encode_text(text_buf);
break;
case ALT_geoAnycastHdr:
field_geoAnycastHdr->encode_text(text_buf);
break;
case ALT_geoBroadcastHdr:
field_geoBroadcastHdr->encode_text(text_buf);
break;
case ALT_tsbHdr:
field_tsbHdr->encode_text(text_buf);
break;
case ALT_lsHdr:
field_lsHdr->encode_text(text_buf);
break;
case ALT_saHdr:
field_saHdr->encode_text(text_buf);
break;
case ALT_reserved:
field_reserved->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
}
}

void HeaderTST::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_anyHdr:
anyHdr().decode_text(text_buf);
break;
case ALT_beaconHdr:
beaconHdr().decode_text(text_buf);
break;
case ALT_geoUnicastHdr:
geoUnicastHdr().decode_text(text_buf);
break;
case ALT_geoAnycastHdr:
geoAnycastHdr().decode_text(text_buf);
break;
case ALT_geoBroadcastHdr:
geoBroadcastHdr().decode_text(text_buf);
break;
case ALT_tsbHdr:
tsbHdr().decode_text(text_buf);
break;
case ALT_lsHdr:
lsHdr().decode_text(text_buf);
break;
case ALT_saHdr:
saHdr().decode_text(text_buf);
break;
case ALT_reserved:
reserved().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
}
}

void HeaderTST::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void HeaderTST::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int HeaderTST::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = anyHdr().RAW_decode(AnyHeaderType_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = beaconHdr().RAW_decode(BeaconHeaderType_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 2:
      decoded_length = geoUnicastHdr().RAW_decode(GeoUnicastHeaderType_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 3:
      decoded_length = geoAnycastHdr().RAW_decode(GeoAnycastHeaderType_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 4:
      decoded_length = geoBroadcastHdr().RAW_decode(GeoBroadcastHeaderType_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 5:
      decoded_length = tsbHdr().RAW_decode(TsbHeaderType_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 6:
      decoded_length = lsHdr().RAW_decode(LsHeaderType_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 7:
      decoded_length = saHdr().RAW_decode(SaHeaderType_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 8:
      decoded_length = reserved().RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = anyHdr().RAW_decode(AnyHeaderType_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = beaconHdr().RAW_decode(BeaconHeaderType_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = geoUnicastHdr().RAW_decode(GeoUnicastHeaderType_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = geoAnycastHdr().RAW_decode(GeoAnycastHeaderType_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = geoBroadcastHdr().RAW_decode(GeoBroadcastHeaderType_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = tsbHdr().RAW_decode(TsbHeaderType_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = lsHdr().RAW_decode(LsHeaderType_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = saHdr().RAW_decode(SaHeaderType_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = reserved().RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int HeaderTST::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 9;  myleaf.body.node.nodes = init_nodes_of_enc_tree(9);
  memset(myleaf.body.node.nodes, 0, 9 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_anyHdr:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, AnyHeaderType_descr_.raw);
    encoded_length = field_anyHdr->RAW_encode(AnyHeaderType_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &AnyHeaderType_descr_;
    break;
  case ALT_beaconHdr:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, BeaconHeaderType_descr_.raw);
    encoded_length = field_beaconHdr->RAW_encode(BeaconHeaderType_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &BeaconHeaderType_descr_;
    break;
  case ALT_geoUnicastHdr:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, GeoUnicastHeaderType_descr_.raw);
    encoded_length = field_geoUnicastHdr->RAW_encode(GeoUnicastHeaderType_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &GeoUnicastHeaderType_descr_;
    break;
  case ALT_geoAnycastHdr:
    myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 3, GeoAnycastHeaderType_descr_.raw);
    encoded_length = field_geoAnycastHdr->RAW_encode(GeoAnycastHeaderType_descr_, *myleaf.body.node.nodes[3]);
    myleaf.body.node.nodes[3]->coding_descr = &GeoAnycastHeaderType_descr_;
    break;
  case ALT_geoBroadcastHdr:
    myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 4, GeoBroadcastHeaderType_descr_.raw);
    encoded_length = field_geoBroadcastHdr->RAW_encode(GeoBroadcastHeaderType_descr_, *myleaf.body.node.nodes[4]);
    myleaf.body.node.nodes[4]->coding_descr = &GeoBroadcastHeaderType_descr_;
    break;
  case ALT_tsbHdr:
    myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 5, TsbHeaderType_descr_.raw);
    encoded_length = field_tsbHdr->RAW_encode(TsbHeaderType_descr_, *myleaf.body.node.nodes[5]);
    myleaf.body.node.nodes[5]->coding_descr = &TsbHeaderType_descr_;
    break;
  case ALT_lsHdr:
    myleaf.body.node.nodes[6] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 6, LsHeaderType_descr_.raw);
    encoded_length = field_lsHdr->RAW_encode(LsHeaderType_descr_, *myleaf.body.node.nodes[6]);
    myleaf.body.node.nodes[6]->coding_descr = &LsHeaderType_descr_;
    break;
  case ALT_saHdr:
    myleaf.body.node.nodes[7] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 7, SaHeaderType_descr_.raw);
    encoded_length = field_saHdr->RAW_encode(SaHeaderType_descr_, *myleaf.body.node.nodes[7]);
    myleaf.body.node.nodes[7]->coding_descr = &SaHeaderType_descr_;
    break;
  case ALT_reserved:
    myleaf.body.node.nodes[8] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 8, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
    encoded_length = field_reserved->RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[8]);
    myleaf.body.node.nodes[8]->coding_descr = &LibCommon__BasicTypesAndValues::UInt8_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int HeaderTST::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_anyHdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "anyHdr");
    enc_len += field_anyHdr->JSON_encode(AnyHeaderType_descr_, p_tok);
    break;
  case ALT_beaconHdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "beaconHdr");
    enc_len += field_beaconHdr->JSON_encode(BeaconHeaderType_descr_, p_tok);
    break;
  case ALT_geoUnicastHdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoUnicastHdr");
    enc_len += field_geoUnicastHdr->JSON_encode(GeoUnicastHeaderType_descr_, p_tok);
    break;
  case ALT_geoAnycastHdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoAnycastHdr");
    enc_len += field_geoAnycastHdr->JSON_encode(GeoAnycastHeaderType_descr_, p_tok);
    break;
  case ALT_geoBroadcastHdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoBroadcastHdr");
    enc_len += field_geoBroadcastHdr->JSON_encode(GeoBroadcastHeaderType_descr_, p_tok);
    break;
  case ALT_tsbHdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "tsbHdr");
    enc_len += field_tsbHdr->JSON_encode(TsbHeaderType_descr_, p_tok);
    break;
  case ALT_lsHdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lsHdr");
    enc_len += field_lsHdr->JSON_encode(LsHeaderType_descr_, p_tok);
    break;
  case ALT_saHdr:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "saHdr");
    enc_len += field_saHdr->JSON_encode(SaHeaderType_descr_, p_tok);
    break;
  case ALT_reserved:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved->JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int HeaderTST::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "anyHdr", name_len)) {
      int ret_val = anyHdr().JSON_decode(AnyHeaderType_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "anyHdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "beaconHdr", name_len)) {
      int ret_val = beaconHdr().JSON_decode(BeaconHeaderType_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "beaconHdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "geoUnicastHdr", name_len)) {
      int ret_val = geoUnicastHdr().JSON_decode(GeoUnicastHeaderType_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoUnicastHdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "geoAnycastHdr", name_len)) {
      int ret_val = geoAnycastHdr().JSON_decode(GeoAnycastHeaderType_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoAnycastHdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "geoBroadcastHdr", name_len)) {
      int ret_val = geoBroadcastHdr().JSON_decode(GeoBroadcastHeaderType_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoBroadcastHdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "tsbHdr", name_len)) {
      int ret_val = tsbHdr().JSON_decode(TsbHeaderType_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "tsbHdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "lsHdr", name_len)) {
      int ret_val = lsHdr().JSON_decode(LsHeaderType_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lsHdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "saHdr", name_len)) {
      int ret_val = saHdr().JSON_decode(SaHeaderType_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "saHdr");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "reserved", name_len)) {
      int ret_val = reserved().JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void HeaderTST_template::copy_value(const HeaderTST& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case HeaderTST::ALT_anyHdr:
single_value.field_anyHdr = new AnyHeaderType_template(other_value.anyHdr());
break;
case HeaderTST::ALT_beaconHdr:
single_value.field_beaconHdr = new BeaconHeaderType_template(other_value.beaconHdr());
break;
case HeaderTST::ALT_geoUnicastHdr:
single_value.field_geoUnicastHdr = new GeoUnicastHeaderType_template(other_value.geoUnicastHdr());
break;
case HeaderTST::ALT_geoAnycastHdr:
single_value.field_geoAnycastHdr = new GeoAnycastHeaderType_template(other_value.geoAnycastHdr());
break;
case HeaderTST::ALT_geoBroadcastHdr:
single_value.field_geoBroadcastHdr = new GeoBroadcastHeaderType_template(other_value.geoBroadcastHdr());
break;
case HeaderTST::ALT_tsbHdr:
single_value.field_tsbHdr = new TsbHeaderType_template(other_value.tsbHdr());
break;
case HeaderTST::ALT_lsHdr:
single_value.field_lsHdr = new LsHeaderType_template(other_value.lsHdr());
break;
case HeaderTST::ALT_saHdr:
single_value.field_saHdr = new SaHeaderType_template(other_value.saHdr());
break;
case HeaderTST::ALT_reserved:
single_value.field_reserved = new INTEGER_template(other_value.reserved());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
}
set_selection(SPECIFIC_VALUE);
}

void HeaderTST_template::copy_template(const HeaderTST_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case HeaderTST::ALT_anyHdr:
single_value.field_anyHdr = new AnyHeaderType_template(*other_value.single_value.field_anyHdr);
break;
case HeaderTST::ALT_beaconHdr:
single_value.field_beaconHdr = new BeaconHeaderType_template(*other_value.single_value.field_beaconHdr);
break;
case HeaderTST::ALT_geoUnicastHdr:
single_value.field_geoUnicastHdr = new GeoUnicastHeaderType_template(*other_value.single_value.field_geoUnicastHdr);
break;
case HeaderTST::ALT_geoAnycastHdr:
single_value.field_geoAnycastHdr = new GeoAnycastHeaderType_template(*other_value.single_value.field_geoAnycastHdr);
break;
case HeaderTST::ALT_geoBroadcastHdr:
single_value.field_geoBroadcastHdr = new GeoBroadcastHeaderType_template(*other_value.single_value.field_geoBroadcastHdr);
break;
case HeaderTST::ALT_tsbHdr:
single_value.field_tsbHdr = new TsbHeaderType_template(*other_value.single_value.field_tsbHdr);
break;
case HeaderTST::ALT_lsHdr:
single_value.field_lsHdr = new LsHeaderType_template(*other_value.single_value.field_lsHdr);
break;
case HeaderTST::ALT_saHdr:
single_value.field_saHdr = new SaHeaderType_template(*other_value.single_value.field_saHdr);
break;
case HeaderTST::ALT_reserved:
single_value.field_reserved = new INTEGER_template(*other_value.single_value.field_reserved);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new HeaderTST_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
}
set_selection(other_value);
}

HeaderTST_template::HeaderTST_template()
{
}

HeaderTST_template::HeaderTST_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

HeaderTST_template::HeaderTST_template(const HeaderTST& other_value)
{
copy_value(other_value);
}

HeaderTST_template::HeaderTST_template(const OPTIONAL<HeaderTST>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const HeaderTST&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST from an unbound optional field.");
}
}

HeaderTST_template::HeaderTST_template(const HeaderTST_template& other_value)
: Base_Template(){
copy_template(other_value);
}

HeaderTST_template::~HeaderTST_template()
{
clean_up();
}

void HeaderTST_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case HeaderTST::ALT_anyHdr:
delete single_value.field_anyHdr;
break;
case HeaderTST::ALT_beaconHdr:
delete single_value.field_beaconHdr;
break;
case HeaderTST::ALT_geoUnicastHdr:
delete single_value.field_geoUnicastHdr;
break;
case HeaderTST::ALT_geoAnycastHdr:
delete single_value.field_geoAnycastHdr;
break;
case HeaderTST::ALT_geoBroadcastHdr:
delete single_value.field_geoBroadcastHdr;
break;
case HeaderTST::ALT_tsbHdr:
delete single_value.field_tsbHdr;
break;
case HeaderTST::ALT_lsHdr:
delete single_value.field_lsHdr;
break;
case HeaderTST::ALT_saHdr:
delete single_value.field_saHdr;
break;
case HeaderTST::ALT_reserved:
delete single_value.field_reserved;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

HeaderTST_template& HeaderTST_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

HeaderTST_template& HeaderTST_template::operator=(const HeaderTST& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

HeaderTST_template& HeaderTST_template::operator=(const OPTIONAL<HeaderTST>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const HeaderTST&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
}
return *this;
}

HeaderTST_template& HeaderTST_template::operator=(const HeaderTST_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean HeaderTST_template::match(const HeaderTST& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
HeaderTST::union_selection_type value_selection = other_value.get_selection();
if (value_selection == HeaderTST::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case HeaderTST::ALT_anyHdr:
return single_value.field_anyHdr->match(other_value.anyHdr(), legacy);
case HeaderTST::ALT_beaconHdr:
return single_value.field_beaconHdr->match(other_value.beaconHdr(), legacy);
case HeaderTST::ALT_geoUnicastHdr:
return single_value.field_geoUnicastHdr->match(other_value.geoUnicastHdr(), legacy);
case HeaderTST::ALT_geoAnycastHdr:
return single_value.field_geoAnycastHdr->match(other_value.geoAnycastHdr(), legacy);
case HeaderTST::ALT_geoBroadcastHdr:
return single_value.field_geoBroadcastHdr->match(other_value.geoBroadcastHdr(), legacy);
case HeaderTST::ALT_tsbHdr:
return single_value.field_tsbHdr->match(other_value.tsbHdr(), legacy);
case HeaderTST::ALT_lsHdr:
return single_value.field_lsHdr->match(other_value.lsHdr(), legacy);
case HeaderTST::ALT_saHdr:
return single_value.field_saHdr->match(other_value.saHdr(), legacy);
case HeaderTST::ALT_reserved:
return single_value.field_reserved->match(other_value.reserved(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
}
return FALSE;
}

boolean HeaderTST_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case HeaderTST::ALT_anyHdr:
return single_value.field_anyHdr->is_value();
case HeaderTST::ALT_beaconHdr:
return single_value.field_beaconHdr->is_value();
case HeaderTST::ALT_geoUnicastHdr:
return single_value.field_geoUnicastHdr->is_value();
case HeaderTST::ALT_geoAnycastHdr:
return single_value.field_geoAnycastHdr->is_value();
case HeaderTST::ALT_geoBroadcastHdr:
return single_value.field_geoBroadcastHdr->is_value();
case HeaderTST::ALT_tsbHdr:
return single_value.field_tsbHdr->is_value();
case HeaderTST::ALT_lsHdr:
return single_value.field_lsHdr->is_value();
case HeaderTST::ALT_saHdr:
return single_value.field_saHdr->is_value();
case HeaderTST::ALT_reserved:
return single_value.field_reserved->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
}
}

HeaderTST HeaderTST_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
HeaderTST ret_val;
switch (single_value.union_selection) {
case HeaderTST::ALT_anyHdr:
ret_val.anyHdr() = single_value.field_anyHdr->valueof();
break;
case HeaderTST::ALT_beaconHdr:
ret_val.beaconHdr() = single_value.field_beaconHdr->valueof();
break;
case HeaderTST::ALT_geoUnicastHdr:
ret_val.geoUnicastHdr() = single_value.field_geoUnicastHdr->valueof();
break;
case HeaderTST::ALT_geoAnycastHdr:
ret_val.geoAnycastHdr() = single_value.field_geoAnycastHdr->valueof();
break;
case HeaderTST::ALT_geoBroadcastHdr:
ret_val.geoBroadcastHdr() = single_value.field_geoBroadcastHdr->valueof();
break;
case HeaderTST::ALT_tsbHdr:
ret_val.tsbHdr() = single_value.field_tsbHdr->valueof();
break;
case HeaderTST::ALT_lsHdr:
ret_val.lsHdr() = single_value.field_lsHdr->valueof();
break;
case HeaderTST::ALT_saHdr:
ret_val.saHdr() = single_value.field_saHdr->valueof();
break;
case HeaderTST::ALT_reserved:
ret_val.reserved() = single_value.field_reserved->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
}
return ret_val;
}

HeaderTST_template& HeaderTST_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return value_list.list_value[list_index];
}
void HeaderTST_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new HeaderTST_template[list_length];
}

AnyHeaderType_template& HeaderTST_template::anyHdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderTST::ALT_anyHdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_anyHdr = new AnyHeaderType_template(ANY_VALUE);
else single_value.field_anyHdr = new AnyHeaderType_template;
single_value.union_selection = HeaderTST::ALT_anyHdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_anyHdr;
}

const AnyHeaderType_template& HeaderTST_template::anyHdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field anyHdr in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
if (single_value.union_selection != HeaderTST::ALT_anyHdr) TTCN_error("Accessing non-selected field anyHdr in a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *single_value.field_anyHdr;
}

BeaconHeaderType_template& HeaderTST_template::beaconHdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderTST::ALT_beaconHdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_beaconHdr = new BeaconHeaderType_template(ANY_VALUE);
else single_value.field_beaconHdr = new BeaconHeaderType_template;
single_value.union_selection = HeaderTST::ALT_beaconHdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_beaconHdr;
}

const BeaconHeaderType_template& HeaderTST_template::beaconHdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field beaconHdr in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
if (single_value.union_selection != HeaderTST::ALT_beaconHdr) TTCN_error("Accessing non-selected field beaconHdr in a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *single_value.field_beaconHdr;
}

GeoUnicastHeaderType_template& HeaderTST_template::geoUnicastHdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderTST::ALT_geoUnicastHdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_geoUnicastHdr = new GeoUnicastHeaderType_template(ANY_VALUE);
else single_value.field_geoUnicastHdr = new GeoUnicastHeaderType_template;
single_value.union_selection = HeaderTST::ALT_geoUnicastHdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_geoUnicastHdr;
}

const GeoUnicastHeaderType_template& HeaderTST_template::geoUnicastHdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field geoUnicastHdr in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
if (single_value.union_selection != HeaderTST::ALT_geoUnicastHdr) TTCN_error("Accessing non-selected field geoUnicastHdr in a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *single_value.field_geoUnicastHdr;
}

GeoAnycastHeaderType_template& HeaderTST_template::geoAnycastHdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderTST::ALT_geoAnycastHdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_geoAnycastHdr = new GeoAnycastHeaderType_template(ANY_VALUE);
else single_value.field_geoAnycastHdr = new GeoAnycastHeaderType_template;
single_value.union_selection = HeaderTST::ALT_geoAnycastHdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_geoAnycastHdr;
}

const GeoAnycastHeaderType_template& HeaderTST_template::geoAnycastHdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field geoAnycastHdr in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
if (single_value.union_selection != HeaderTST::ALT_geoAnycastHdr) TTCN_error("Accessing non-selected field geoAnycastHdr in a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *single_value.field_geoAnycastHdr;
}

GeoBroadcastHeaderType_template& HeaderTST_template::geoBroadcastHdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderTST::ALT_geoBroadcastHdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_geoBroadcastHdr = new GeoBroadcastHeaderType_template(ANY_VALUE);
else single_value.field_geoBroadcastHdr = new GeoBroadcastHeaderType_template;
single_value.union_selection = HeaderTST::ALT_geoBroadcastHdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_geoBroadcastHdr;
}

const GeoBroadcastHeaderType_template& HeaderTST_template::geoBroadcastHdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field geoBroadcastHdr in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
if (single_value.union_selection != HeaderTST::ALT_geoBroadcastHdr) TTCN_error("Accessing non-selected field geoBroadcastHdr in a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *single_value.field_geoBroadcastHdr;
}

TsbHeaderType_template& HeaderTST_template::tsbHdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderTST::ALT_tsbHdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_tsbHdr = new TsbHeaderType_template(ANY_VALUE);
else single_value.field_tsbHdr = new TsbHeaderType_template;
single_value.union_selection = HeaderTST::ALT_tsbHdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_tsbHdr;
}

const TsbHeaderType_template& HeaderTST_template::tsbHdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field tsbHdr in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
if (single_value.union_selection != HeaderTST::ALT_tsbHdr) TTCN_error("Accessing non-selected field tsbHdr in a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *single_value.field_tsbHdr;
}

LsHeaderType_template& HeaderTST_template::lsHdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderTST::ALT_lsHdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_lsHdr = new LsHeaderType_template(ANY_VALUE);
else single_value.field_lsHdr = new LsHeaderType_template;
single_value.union_selection = HeaderTST::ALT_lsHdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_lsHdr;
}

const LsHeaderType_template& HeaderTST_template::lsHdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field lsHdr in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
if (single_value.union_selection != HeaderTST::ALT_lsHdr) TTCN_error("Accessing non-selected field lsHdr in a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *single_value.field_lsHdr;
}

SaHeaderType_template& HeaderTST_template::saHdr()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderTST::ALT_saHdr) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_saHdr = new SaHeaderType_template(ANY_VALUE);
else single_value.field_saHdr = new SaHeaderType_template;
single_value.union_selection = HeaderTST::ALT_saHdr;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_saHdr;
}

const SaHeaderType_template& HeaderTST_template::saHdr() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field saHdr in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
if (single_value.union_selection != HeaderTST::ALT_saHdr) TTCN_error("Accessing non-selected field saHdr in a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *single_value.field_saHdr;
}

INTEGER_template& HeaderTST_template::reserved()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderTST::ALT_reserved) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_reserved = new INTEGER_template(ANY_VALUE);
else single_value.field_reserved = new INTEGER_template;
single_value.union_selection = HeaderTST::ALT_reserved;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_reserved;
}

const INTEGER_template& HeaderTST_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field reserved in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
if (single_value.union_selection != HeaderTST::ALT_reserved) TTCN_error("Accessing non-selected field reserved in a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return *single_value.field_reserved;
}

boolean HeaderTST_template::ischosen(HeaderTST::union_selection_type checked_selection) const
{
if (checked_selection == HeaderTST::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == HeaderTST::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST");
}
return FALSE;
}

void HeaderTST_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case HeaderTST::ALT_anyHdr:
TTCN_Logger::log_event_str("{ anyHdr := ");
single_value.field_anyHdr->log();
TTCN_Logger::log_event_str(" }");
break;
case HeaderTST::ALT_beaconHdr:
TTCN_Logger::log_event_str("{ beaconHdr := ");
single_value.field_beaconHdr->log();
TTCN_Logger::log_event_str(" }");
break;
case HeaderTST::ALT_geoUnicastHdr:
TTCN_Logger::log_event_str("{ geoUnicastHdr := ");
single_value.field_geoUnicastHdr->log();
TTCN_Logger::log_event_str(" }");
break;
case HeaderTST::ALT_geoAnycastHdr:
TTCN_Logger::log_event_str("{ geoAnycastHdr := ");
single_value.field_geoAnycastHdr->log();
TTCN_Logger::log_event_str(" }");
break;
case HeaderTST::ALT_geoBroadcastHdr:
TTCN_Logger::log_event_str("{ geoBroadcastHdr := ");
single_value.field_geoBroadcastHdr->log();
TTCN_Logger::log_event_str(" }");
break;
case HeaderTST::ALT_tsbHdr:
TTCN_Logger::log_event_str("{ tsbHdr := ");
single_value.field_tsbHdr->log();
TTCN_Logger::log_event_str(" }");
break;
case HeaderTST::ALT_lsHdr:
TTCN_Logger::log_event_str("{ lsHdr := ");
single_value.field_lsHdr->log();
TTCN_Logger::log_event_str(" }");
break;
case HeaderTST::ALT_saHdr:
TTCN_Logger::log_event_str("{ saHdr := ");
single_value.field_saHdr->log();
TTCN_Logger::log_event_str(" }");
break;
case HeaderTST::ALT_reserved:
TTCN_Logger::log_event_str("{ reserved := ");
single_value.field_reserved->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void HeaderTST_template::log_match(const HeaderTST& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case HeaderTST::ALT_anyHdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".anyHdr");
single_value.field_anyHdr->log_match(match_value.anyHdr(), legacy);
} else {
TTCN_Logger::log_event_str("{ anyHdr := ");
single_value.field_anyHdr->log_match(match_value.anyHdr(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HeaderTST::ALT_beaconHdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".beaconHdr");
single_value.field_beaconHdr->log_match(match_value.beaconHdr(), legacy);
} else {
TTCN_Logger::log_event_str("{ beaconHdr := ");
single_value.field_beaconHdr->log_match(match_value.beaconHdr(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HeaderTST::ALT_geoUnicastHdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".geoUnicastHdr");
single_value.field_geoUnicastHdr->log_match(match_value.geoUnicastHdr(), legacy);
} else {
TTCN_Logger::log_event_str("{ geoUnicastHdr := ");
single_value.field_geoUnicastHdr->log_match(match_value.geoUnicastHdr(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HeaderTST::ALT_geoAnycastHdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".geoAnycastHdr");
single_value.field_geoAnycastHdr->log_match(match_value.geoAnycastHdr(), legacy);
} else {
TTCN_Logger::log_event_str("{ geoAnycastHdr := ");
single_value.field_geoAnycastHdr->log_match(match_value.geoAnycastHdr(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HeaderTST::ALT_geoBroadcastHdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".geoBroadcastHdr");
single_value.field_geoBroadcastHdr->log_match(match_value.geoBroadcastHdr(), legacy);
} else {
TTCN_Logger::log_event_str("{ geoBroadcastHdr := ");
single_value.field_geoBroadcastHdr->log_match(match_value.geoBroadcastHdr(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HeaderTST::ALT_tsbHdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".tsbHdr");
single_value.field_tsbHdr->log_match(match_value.tsbHdr(), legacy);
} else {
TTCN_Logger::log_event_str("{ tsbHdr := ");
single_value.field_tsbHdr->log_match(match_value.tsbHdr(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HeaderTST::ALT_lsHdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".lsHdr");
single_value.field_lsHdr->log_match(match_value.lsHdr(), legacy);
} else {
TTCN_Logger::log_event_str("{ lsHdr := ");
single_value.field_lsHdr->log_match(match_value.lsHdr(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HeaderTST::ALT_saHdr:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".saHdr");
single_value.field_saHdr->log_match(match_value.saHdr(), legacy);
} else {
TTCN_Logger::log_event_str("{ saHdr := ");
single_value.field_saHdr->log_match(match_value.saHdr(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HeaderTST::ALT_reserved:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".reserved");
single_value.field_reserved->log_match(match_value.reserved(), legacy);
} else {
TTCN_Logger::log_event_str("{ reserved := ");
single_value.field_reserved->log_match(match_value.reserved(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void HeaderTST_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case HeaderTST::ALT_anyHdr:
single_value.field_anyHdr->encode_text(text_buf);
break;
case HeaderTST::ALT_beaconHdr:
single_value.field_beaconHdr->encode_text(text_buf);
break;
case HeaderTST::ALT_geoUnicastHdr:
single_value.field_geoUnicastHdr->encode_text(text_buf);
break;
case HeaderTST::ALT_geoAnycastHdr:
single_value.field_geoAnycastHdr->encode_text(text_buf);
break;
case HeaderTST::ALT_geoBroadcastHdr:
single_value.field_geoBroadcastHdr->encode_text(text_buf);
break;
case HeaderTST::ALT_tsbHdr:
single_value.field_tsbHdr->encode_text(text_buf);
break;
case HeaderTST::ALT_lsHdr:
single_value.field_lsHdr->encode_text(text_buf);
break;
case HeaderTST::ALT_saHdr:
single_value.field_saHdr->encode_text(text_buf);
break;
case HeaderTST::ALT_reserved:
single_value.field_reserved->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
}
}

void HeaderTST_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = HeaderTST::UNBOUND_VALUE;
HeaderTST::union_selection_type new_selection = (HeaderTST::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case HeaderTST::ALT_anyHdr:
single_value.field_anyHdr = new AnyHeaderType_template;
single_value.field_anyHdr->decode_text(text_buf);
break;
case HeaderTST::ALT_beaconHdr:
single_value.field_beaconHdr = new BeaconHeaderType_template;
single_value.field_beaconHdr->decode_text(text_buf);
break;
case HeaderTST::ALT_geoUnicastHdr:
single_value.field_geoUnicastHdr = new GeoUnicastHeaderType_template;
single_value.field_geoUnicastHdr->decode_text(text_buf);
break;
case HeaderTST::ALT_geoAnycastHdr:
single_value.field_geoAnycastHdr = new GeoAnycastHeaderType_template;
single_value.field_geoAnycastHdr->decode_text(text_buf);
break;
case HeaderTST::ALT_geoBroadcastHdr:
single_value.field_geoBroadcastHdr = new GeoBroadcastHeaderType_template;
single_value.field_geoBroadcastHdr->decode_text(text_buf);
break;
case HeaderTST::ALT_tsbHdr:
single_value.field_tsbHdr = new TsbHeaderType_template;
single_value.field_tsbHdr->decode_text(text_buf);
break;
case HeaderTST::ALT_lsHdr:
single_value.field_lsHdr = new LsHeaderType_template;
single_value.field_lsHdr->decode_text(text_buf);
break;
case HeaderTST::ALT_saHdr:
single_value.field_saHdr = new SaHeaderType_template;
single_value.field_saHdr->decode_text(text_buf);
break;
case HeaderTST::ALT_reserved:
single_value.field_reserved = new INTEGER_template;
single_value.field_reserved->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new HeaderTST_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
}
}

boolean HeaderTST_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean HeaderTST_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void HeaderTST_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsGeoNetworking_TypesAndValues.HeaderTST'");
    }
    if (strcmp("anyHdr", param_field) == 0) {
      anyHdr().set_param(param);
      return;
    } else if (strcmp("beaconHdr", param_field) == 0) {
      beaconHdr().set_param(param);
      return;
    } else if (strcmp("geoUnicastHdr", param_field) == 0) {
      geoUnicastHdr().set_param(param);
      return;
    } else if (strcmp("geoAnycastHdr", param_field) == 0) {
      geoAnycastHdr().set_param(param);
      return;
    } else if (strcmp("geoBroadcastHdr", param_field) == 0) {
      geoBroadcastHdr().set_param(param);
      return;
    } else if (strcmp("tsbHdr", param_field) == 0) {
      tsbHdr().set_param(param);
      return;
    } else if (strcmp("lsHdr", param_field) == 0) {
      lsHdr().set_param(param);
      return;
    } else if (strcmp("saHdr", param_field) == 0) {
      saHdr().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsGeoNetworking_TypesAndValues.HeaderTST'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    HeaderTST_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsGeoNetworking_TypesAndValues.HeaderTST");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "anyHdr")) {
      anyHdr().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "beaconHdr")) {
      beaconHdr().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "geoUnicastHdr")) {
      geoUnicastHdr().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "geoAnycastHdr")) {
      geoAnycastHdr().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "geoBroadcastHdr")) {
      geoBroadcastHdr().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "tsbHdr")) {
      tsbHdr().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "lsHdr")) {
      lsHdr().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "saHdr")) {
      saHdr().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "reserved")) {
      reserved().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsGeoNetworking_TypesAndValues.HeaderTST.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsGeoNetworking_TypesAndValues.HeaderTST");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* HeaderTST_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsGeoNetworking_TypesAndValues.HeaderTST'");
    }
    if (strcmp("anyHdr", param_field) == 0) {
      return anyHdr().get_param(param_name);
    } else if (strcmp("beaconHdr", param_field) == 0) {
      return beaconHdr().get_param(param_name);
    } else if (strcmp("geoUnicastHdr", param_field) == 0) {
      return geoUnicastHdr().get_param(param_name);
    } else if (strcmp("geoAnycastHdr", param_field) == 0) {
      return geoAnycastHdr().get_param(param_name);
    } else if (strcmp("geoBroadcastHdr", param_field) == 0) {
      return geoBroadcastHdr().get_param(param_name);
    } else if (strcmp("tsbHdr", param_field) == 0) {
      return tsbHdr().get_param(param_name);
    } else if (strcmp("lsHdr", param_field) == 0) {
      return lsHdr().get_param(param_name);
    } else if (strcmp("saHdr", param_field) == 0) {
      return saHdr().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `HeaderTST'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case HeaderTST::ALT_anyHdr:
      mp_field = single_value.field_anyHdr->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("anyHdr")));
      break;
    case HeaderTST::ALT_beaconHdr:
      mp_field = single_value.field_beaconHdr->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("beaconHdr")));
      break;
    case HeaderTST::ALT_geoUnicastHdr:
      mp_field = single_value.field_geoUnicastHdr->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("geoUnicastHdr")));
      break;
    case HeaderTST::ALT_geoAnycastHdr:
      mp_field = single_value.field_geoAnycastHdr->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("geoAnycastHdr")));
      break;
    case HeaderTST::ALT_geoBroadcastHdr:
      mp_field = single_value.field_geoBroadcastHdr->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("geoBroadcastHdr")));
      break;
    case HeaderTST::ALT_tsbHdr:
      mp_field = single_value.field_tsbHdr->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("tsbHdr")));
      break;
    case HeaderTST::ALT_lsHdr:
      mp_field = single_value.field_lsHdr->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("lsHdr")));
      break;
    case HeaderTST::ALT_saHdr:
      mp_field = single_value.field_saHdr->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("saHdr")));
      break;
    case HeaderTST::ALT_reserved:
      mp_field = single_value.field_reserved->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("reserved")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void HeaderTST_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case HeaderTST::ALT_anyHdr:
single_value.field_anyHdr->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.HeaderTST");
return;
case HeaderTST::ALT_beaconHdr:
single_value.field_beaconHdr->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.HeaderTST");
return;
case HeaderTST::ALT_geoUnicastHdr:
single_value.field_geoUnicastHdr->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.HeaderTST");
return;
case HeaderTST::ALT_geoAnycastHdr:
single_value.field_geoAnycastHdr->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.HeaderTST");
return;
case HeaderTST::ALT_geoBroadcastHdr:
single_value.field_geoBroadcastHdr->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.HeaderTST");
return;
case HeaderTST::ALT_tsbHdr:
single_value.field_tsbHdr->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.HeaderTST");
return;
case HeaderTST::ALT_lsHdr:
single_value.field_lsHdr->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.HeaderTST");
return;
case HeaderTST::ALT_saHdr:
single_value.field_saHdr->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.HeaderTST");
return;
case HeaderTST::ALT_reserved:
single_value.field_reserved->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.HeaderTST");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsGeoNetworking_TypesAndValues.HeaderTST.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.HeaderTST");
}

HeaderType::HeaderType()
{
enum_value = UNBOUND_VALUE;
}

HeaderType::HeaderType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

HeaderType::HeaderType(enum_type other_value)
{
enum_value = other_value;
}

HeaderType::HeaderType(const HeaderType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
enum_value = other_value.enum_value;
}

HeaderType& HeaderType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

HeaderType& HeaderType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

HeaderType& HeaderType::operator=(const HeaderType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
enum_value = other_value.enum_value;
return *this;
}

boolean HeaderType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
return enum_value == other_value;
}

boolean HeaderType::operator==(const HeaderType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
return enum_value == other_value.enum_value;
}

boolean HeaderType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
return enum_value < other_value;
}

boolean HeaderType::operator<(const HeaderType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
return enum_value < other_value.enum_value;
}

boolean HeaderType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
return enum_value > other_value;
}

boolean HeaderType::operator>(const HeaderType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
return enum_value > other_value.enum_value;
}

const char *HeaderType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__any: return "e_any";
case e__beacon: return "e_beacon";
case e__geoUnicast: return "e_geoUnicast";
case e__geoAnycast: return "e_geoAnycast";
case e__geoBroadcast: return "e_geoBroadcast";
case e__topologicallyScopedBroadcast: return "e_topologicallyScopedBroadcast";
case e__locationService: return "e_locationService";
case e__serviceAnnouncement: return "e_serviceAnnouncement";
case e__reserved: return "e_reserved";
default: return "<unknown>";
}
}

HeaderType::enum_type HeaderType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_any")) return e__any;
else if (!strcmp(str_par, "e_beacon")) return e__beacon;
else if (!strcmp(str_par, "e_geoUnicast")) return e__geoUnicast;
else if (!strcmp(str_par, "e_geoAnycast")) return e__geoAnycast;
else if (!strcmp(str_par, "e_geoBroadcast")) return e__geoBroadcast;
else if (!strcmp(str_par, "e_topologicallyScopedBroadcast")) return e__topologicallyScopedBroadcast;
else if (!strcmp(str_par, "e_locationService")) return e__locationService;
else if (!strcmp(str_par, "e_serviceAnnouncement")) return e__serviceAnnouncement;
else if (!strcmp(str_par, "e_reserved")) return e__reserved;
else return UNKNOWN_VALUE;
}

boolean HeaderType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
return TRUE;
default:
return FALSE;
}
}

int HeaderType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int HeaderType::enum2int(const HeaderType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void HeaderType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.", int_val);
enum_value = (enum_type)int_val;
}

HeaderType::operator HeaderType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
return enum_value;
}

void HeaderType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void HeaderType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsGeoNetworking_TypesAndValues.HeaderType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
  }
}

Module_Param* HeaderType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void HeaderType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
text_buf.push_int(enum_value);
}

void HeaderType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.", enum_value);
}

void HeaderType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void HeaderType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int HeaderType::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 4, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int HeaderType::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 4);
}

int HeaderType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int HeaderType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void HeaderType_template::copy_template(const HeaderType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new HeaderType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
}
}

HeaderType_template::HeaderType_template()
{
}

HeaderType_template::HeaderType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

HeaderType_template::HeaderType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!HeaderType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType with unknown numeric value %d.", other_value);
single_value = (HeaderType::enum_type)other_value;
}

HeaderType_template::HeaderType_template(HeaderType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

HeaderType_template::HeaderType_template(const HeaderType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == HeaderType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
single_value = other_value.enum_value;
}

HeaderType_template::HeaderType_template(const OPTIONAL<HeaderType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (HeaderType::enum_type)(const HeaderType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType from an unbound optional field.");
}
}

HeaderType_template::HeaderType_template(const HeaderType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

HeaderType_template::~HeaderType_template()
{
clean_up();
}

boolean HeaderType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean HeaderType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != HeaderType::UNBOUND_VALUE;
}

void HeaderType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

HeaderType_template& HeaderType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

HeaderType_template& HeaderType_template::operator=(int other_value)
{
if (!HeaderType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (HeaderType::enum_type)other_value;
return *this;
}

HeaderType_template& HeaderType_template::operator=(HeaderType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

HeaderType_template& HeaderType_template::operator=(const HeaderType& other_value)
{
if (other_value.enum_value == HeaderType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

HeaderType_template& HeaderType_template::operator=(const OPTIONAL<HeaderType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (HeaderType::enum_type)(const HeaderType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
}
return *this;
}

HeaderType_template& HeaderType_template::operator=(const HeaderType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean HeaderType_template::match(HeaderType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
}
return FALSE;
}

boolean HeaderType_template::match(const HeaderType& other_value, boolean) const
{
if (other_value.enum_value == HeaderType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType with an unbound value.");
return match(other_value.enum_value);
}

HeaderType::enum_type HeaderType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
return single_value;
}

void HeaderType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new HeaderType_template[list_length];
}

HeaderType_template& HeaderType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
return value_list.list_value[list_index];
}

void HeaderType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(HeaderType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void HeaderType_template::log_match(const HeaderType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void HeaderType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
}
}

void HeaderType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (HeaderType::enum_type)text_buf.pull_int().get_val();
if (!HeaderType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new HeaderType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
}
}

boolean HeaderType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean HeaderType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void HeaderType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    HeaderType::enum_type enum_val = (enum_name != NULL) ? HeaderType::str_to_enum(enum_name) : HeaderType::UNKNOWN_VALUE;
    if (HeaderType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    HeaderType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    HeaderType::enum_type enum_val = HeaderType::str_to_enum(mp->get_enumerated());
    if (!HeaderType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.HeaderType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsGeoNetworking_TypesAndValues.HeaderType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* HeaderType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(HeaderType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void HeaderType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.HeaderType");
}

AnyHeaderType::AnyHeaderType()
{
  bound_flag = FALSE;
}

AnyHeaderType::AnyHeaderType(const HeaderType& par_headerType,
    const INTEGER& par_headerSubType)
  :   field_headerType(par_headerType),
  field_headerSubType(par_headerSubType)
{
  bound_flag = TRUE;
}

AnyHeaderType::AnyHeaderType(const AnyHeaderType& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType.");
bound_flag = TRUE;
if (other_value.headerType().is_bound()) field_headerType = other_value.headerType();
else field_headerType.clean_up();
if (other_value.headerSubType().is_bound()) field_headerSubType = other_value.headerSubType();
else field_headerSubType.clean_up();
}

void AnyHeaderType::clean_up()
{
field_headerType.clean_up();
field_headerSubType.clean_up();
bound_flag = FALSE;
}

AnyHeaderType& AnyHeaderType::operator=(const AnyHeaderType& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType.");
  bound_flag = TRUE;
  if (other_value.headerType().is_bound()) field_headerType = other_value.headerType();
  else field_headerType.clean_up();
  if (other_value.headerSubType().is_bound()) field_headerSubType = other_value.headerSubType();
  else field_headerSubType.clean_up();
}
return *this;
}

boolean AnyHeaderType::operator==(const AnyHeaderType& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_headerType==other_value.field_headerType
  && field_headerSubType==other_value.field_headerSubType;
}

boolean AnyHeaderType::is_bound() const
{
if (bound_flag) return TRUE;
if(field_headerType.is_bound()) return TRUE;
if(field_headerSubType.is_bound()) return TRUE;
return FALSE;
}
boolean AnyHeaderType::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_headerType.is_value()) return FALSE;
if(!field_headerSubType.is_value()) return FALSE;
return TRUE;
}
int AnyHeaderType::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType");
  return 2;
}

void AnyHeaderType::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ headerType := ");
field_headerType.log();
TTCN_Logger::log_event_str(", headerSubType := ");
field_headerSubType.log();
TTCN_Logger::log_event_str(" }");
}

void AnyHeaderType::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.AnyHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      headerType().set_param(param);
      return;
    } else if (strcmp("headerSubType", param_field) == 0) {
      headerSubType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AnyHeaderType'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headerType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerSubType().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.AnyHeaderType");
  }
}

Module_Param* AnyHeaderType::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.AnyHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      return headerType().get_param(param_name);
    } else if (strcmp("headerSubType", param_field) == 0) {
      return headerSubType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AnyHeaderType'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_headerType = field_headerType.get_param(param_name);
  mp_field_headerType->set_id(new Module_Param_FieldName(mcopystr("headerType")));
  mp->add_elem(mp_field_headerType);
  Module_Param* mp_field_headerSubType = field_headerSubType.get_param(param_name);
  mp_field_headerSubType->set_id(new Module_Param_FieldName(mcopystr("headerSubType")));
  mp->add_elem(mp_field_headerSubType);
  return mp;
  }

void AnyHeaderType::set_implicit_omit()
{
if (headerType().is_bound()) headerType().set_implicit_omit();
if (headerSubType().is_bound()) headerSubType().set_implicit_omit();
}

void AnyHeaderType::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType.");
field_headerType.encode_text(text_buf);
field_headerSubType.encode_text(text_buf);
}

void AnyHeaderType::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_headerType.decode_text(text_buf);
field_headerSubType.decode_text(text_buf);
}

void AnyHeaderType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AnyHeaderType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AnyHeaderType::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_headerType.RAW_decode(AnyHeaderType_headerType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_headerSubType.RAW_decode(AnyHeaderType_headerSubType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int AnyHeaderType::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, AnyHeaderType_headerType_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, AnyHeaderType_headerSubType_descr_.raw);
  encoded_length += field_headerType.RAW_encode(AnyHeaderType_headerType_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_headerSubType.RAW_encode(AnyHeaderType_headerSubType_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int AnyHeaderType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerType");
    enc_len += field_headerType.JSON_encode(AnyHeaderType_headerType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerSubType");
    enc_len += field_headerSubType.JSON_encode(AnyHeaderType_headerSubType_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AnyHeaderType::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "headerType", name_len)) {
         int ret_val = field_headerType.JSON_decode(AnyHeaderType_headerType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "headerSubType", name_len)) {
         int ret_val = field_headerSubType.JSON_decode(AnyHeaderType_headerSubType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerSubType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_headerType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerType");
    return JSON_ERROR_FATAL;
  }
if (!field_headerSubType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerSubType");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct AnyHeaderType_template::single_value_struct {
HeaderType_template field_headerType;
INTEGER_template field_headerSubType;
};

void AnyHeaderType_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_headerType = ANY_VALUE;
single_value->field_headerSubType = ANY_VALUE;
}
}
}

void AnyHeaderType_template::copy_value(const AnyHeaderType& other_value)
{
single_value = new single_value_struct;
if (other_value.headerType().is_bound()) {
  single_value->field_headerType = other_value.headerType();
} else {
  single_value->field_headerType.clean_up();
}
if (other_value.headerSubType().is_bound()) {
  single_value->field_headerSubType = other_value.headerSubType();
} else {
  single_value->field_headerSubType.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void AnyHeaderType_template::copy_template(const AnyHeaderType_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.headerType().get_selection()) {
single_value->field_headerType = other_value.headerType();
} else {
single_value->field_headerType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.headerSubType().get_selection()) {
single_value->field_headerSubType = other_value.headerSubType();
} else {
single_value->field_headerSubType.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AnyHeaderType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType.");
break;
}
set_selection(other_value);
}

AnyHeaderType_template::AnyHeaderType_template()
{
}

AnyHeaderType_template::AnyHeaderType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AnyHeaderType_template::AnyHeaderType_template(const AnyHeaderType& other_value)
{
copy_value(other_value);
}

AnyHeaderType_template::AnyHeaderType_template(const OPTIONAL<AnyHeaderType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AnyHeaderType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType from an unbound optional field.");
}
}

AnyHeaderType_template::AnyHeaderType_template(const AnyHeaderType_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

AnyHeaderType_template::~AnyHeaderType_template()
{
clean_up();
}

AnyHeaderType_template& AnyHeaderType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AnyHeaderType_template& AnyHeaderType_template::operator=(const AnyHeaderType& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AnyHeaderType_template& AnyHeaderType_template::operator=(const OPTIONAL<AnyHeaderType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AnyHeaderType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType.");
}
return *this;
}

AnyHeaderType_template& AnyHeaderType_template::operator=(const AnyHeaderType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AnyHeaderType_template::match(const AnyHeaderType& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.headerType().is_bound()) return FALSE;
if(!single_value->field_headerType.match(other_value.headerType(), legacy))return FALSE;
if(!other_value.headerSubType().is_bound()) return FALSE;
if(!single_value->field_headerSubType.match(other_value.headerSubType(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType.");
}
return FALSE;
}

boolean AnyHeaderType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_headerType.is_bound()) return TRUE;
if (single_value->field_headerSubType.is_bound()) return TRUE;
return FALSE;
}

boolean AnyHeaderType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_headerType.is_value()) return FALSE;
if (!single_value->field_headerSubType.is_value()) return FALSE;
return TRUE;
}

void AnyHeaderType_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AnyHeaderType AnyHeaderType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType.");
AnyHeaderType ret_val;
if (single_value->field_headerType.is_bound()) {
ret_val.headerType() = single_value->field_headerType.valueof();
}
if (single_value->field_headerSubType.is_bound()) {
ret_val.headerSubType() = single_value->field_headerSubType.valueof();
}
return ret_val;
}

void AnyHeaderType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AnyHeaderType_template[list_length];
}

AnyHeaderType_template& AnyHeaderType_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType.");
return value_list.list_value[list_index];
}

HeaderType_template& AnyHeaderType_template::headerType()
{
set_specific();
return single_value->field_headerType;
}

const HeaderType_template& AnyHeaderType_template::headerType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType.");
return single_value->field_headerType;
}

INTEGER_template& AnyHeaderType_template::headerSubType()
{
set_specific();
return single_value->field_headerSubType;
}

const INTEGER_template& AnyHeaderType_template::headerSubType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerSubType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType.");
return single_value->field_headerSubType;
}

int AnyHeaderType_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType.");
  }
  return 0;
}

void AnyHeaderType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ headerType := ");
single_value->field_headerType.log();
TTCN_Logger::log_event_str(", headerSubType := ");
single_value->field_headerSubType.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AnyHeaderType_template::log_match(const AnyHeaderType& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_headerType.match(match_value.headerType(), legacy)){
TTCN_Logger::log_logmatch_info(".headerType");
single_value->field_headerType.log_match(match_value.headerType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_headerSubType.match(match_value.headerSubType(), legacy)){
TTCN_Logger::log_logmatch_info(".headerSubType");
single_value->field_headerSubType.log_match(match_value.headerSubType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ headerType := ");
single_value->field_headerType.log_match(match_value.headerType(), legacy);
TTCN_Logger::log_event_str(", headerSubType := ");
single_value->field_headerSubType.log_match(match_value.headerSubType(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AnyHeaderType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_headerType.encode_text(text_buf);
single_value->field_headerSubType.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType.");
}
}

void AnyHeaderType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_headerType.decode_text(text_buf);
single_value->field_headerSubType.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AnyHeaderType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType.");
}
}

void AnyHeaderType_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.AnyHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      headerType().set_param(param);
      return;
    } else if (strcmp("headerSubType", param_field) == 0) {
      headerSubType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.AnyHeaderType'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AnyHeaderType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headerType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerSubType().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.AnyHeaderType: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.AnyHeaderType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AnyHeaderType_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.AnyHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      return headerType().get_param(param_name);
    } else if (strcmp("headerSubType", param_field) == 0) {
      return headerSubType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AnyHeaderType'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_headerType = single_value->field_headerType.get_param(param_name);
    mp_field_headerType->set_id(new Module_Param_FieldName(mcopystr("headerType")));
    mp->add_elem(mp_field_headerType);
    Module_Param* mp_field_headerSubType = single_value->field_headerSubType.get_param(param_name);
    mp_field_headerSubType->set_id(new Module_Param_FieldName(mcopystr("headerSubType")));
    mp->add_elem(mp_field_headerSubType);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AnyHeaderType_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_headerType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AnyHeaderType");
single_value->field_headerSubType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AnyHeaderType");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AnyHeaderType");
}

boolean AnyHeaderType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AnyHeaderType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

BeaconHeaderType::BeaconHeaderType()
{
  bound_flag = FALSE;
}

BeaconHeaderType::BeaconHeaderType(const HeaderType& par_headerType,
    const INTEGER& par_headerSubType)
  :   field_headerType(par_headerType),
  field_headerSubType(par_headerSubType)
{
  bound_flag = TRUE;
}

BeaconHeaderType::BeaconHeaderType(const BeaconHeaderType& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.");
bound_flag = TRUE;
if (other_value.headerType().is_bound()) field_headerType = other_value.headerType();
else field_headerType.clean_up();
if (other_value.headerSubType().is_bound()) field_headerSubType = other_value.headerSubType();
else field_headerSubType.clean_up();
}

void BeaconHeaderType::clean_up()
{
field_headerType.clean_up();
field_headerSubType.clean_up();
bound_flag = FALSE;
}

BeaconHeaderType& BeaconHeaderType::operator=(const BeaconHeaderType& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.");
  bound_flag = TRUE;
  if (other_value.headerType().is_bound()) field_headerType = other_value.headerType();
  else field_headerType.clean_up();
  if (other_value.headerSubType().is_bound()) field_headerSubType = other_value.headerSubType();
  else field_headerSubType.clean_up();
}
return *this;
}

boolean BeaconHeaderType::operator==(const BeaconHeaderType& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_headerType==other_value.field_headerType
  && field_headerSubType==other_value.field_headerSubType;
}

boolean BeaconHeaderType::is_bound() const
{
if (bound_flag) return TRUE;
if(field_headerType.is_bound()) return TRUE;
if(field_headerSubType.is_bound()) return TRUE;
return FALSE;
}
boolean BeaconHeaderType::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_headerType.is_value()) return FALSE;
if(!field_headerSubType.is_value()) return FALSE;
return TRUE;
}
int BeaconHeaderType::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType");
  return 2;
}

void BeaconHeaderType::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ headerType := ");
field_headerType.log();
TTCN_Logger::log_event_str(", headerSubType := ");
field_headerSubType.log();
TTCN_Logger::log_event_str(" }");
}

void BeaconHeaderType::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.BeaconHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      headerType().set_param(param);
      return;
    } else if (strcmp("headerSubType", param_field) == 0) {
      headerSubType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.BeaconHeaderType'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headerType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerSubType().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.BeaconHeaderType");
  }
}

Module_Param* BeaconHeaderType::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.BeaconHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      return headerType().get_param(param_name);
    } else if (strcmp("headerSubType", param_field) == 0) {
      return headerSubType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.BeaconHeaderType'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_headerType = field_headerType.get_param(param_name);
  mp_field_headerType->set_id(new Module_Param_FieldName(mcopystr("headerType")));
  mp->add_elem(mp_field_headerType);
  Module_Param* mp_field_headerSubType = field_headerSubType.get_param(param_name);
  mp_field_headerSubType->set_id(new Module_Param_FieldName(mcopystr("headerSubType")));
  mp->add_elem(mp_field_headerSubType);
  return mp;
  }

void BeaconHeaderType::set_implicit_omit()
{
if (headerType().is_bound()) headerType().set_implicit_omit();
if (headerSubType().is_bound()) headerSubType().set_implicit_omit();
}

void BeaconHeaderType::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.");
field_headerType.encode_text(text_buf);
field_headerSubType.encode_text(text_buf);
}

void BeaconHeaderType::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_headerType.decode_text(text_buf);
field_headerSubType.decode_text(text_buf);
}

void BeaconHeaderType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void BeaconHeaderType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int BeaconHeaderType::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_headerType.RAW_decode(BeaconHeaderType_headerType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_headerSubType.RAW_decode(BeaconHeaderType_headerSubType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int BeaconHeaderType::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, BeaconHeaderType_headerType_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, BeaconHeaderType_headerSubType_descr_.raw);
  encoded_length += field_headerType.RAW_encode(BeaconHeaderType_headerType_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_headerSubType.RAW_encode(BeaconHeaderType_headerSubType_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int BeaconHeaderType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerType");
    enc_len += field_headerType.JSON_encode(BeaconHeaderType_headerType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerSubType");
    enc_len += field_headerSubType.JSON_encode(BeaconHeaderType_headerSubType_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int BeaconHeaderType::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "headerType", name_len)) {
         int ret_val = field_headerType.JSON_decode(BeaconHeaderType_headerType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "headerSubType", name_len)) {
         int ret_val = field_headerSubType.JSON_decode(BeaconHeaderType_headerSubType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerSubType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_headerType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerType");
    return JSON_ERROR_FATAL;
  }
if (!field_headerSubType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerSubType");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct BeaconHeaderType_template::single_value_struct {
HeaderType_template field_headerType;
INTEGER_template field_headerSubType;
};

void BeaconHeaderType_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_headerType = ANY_VALUE;
single_value->field_headerSubType = ANY_VALUE;
}
}
}

void BeaconHeaderType_template::copy_value(const BeaconHeaderType& other_value)
{
single_value = new single_value_struct;
if (other_value.headerType().is_bound()) {
  single_value->field_headerType = other_value.headerType();
} else {
  single_value->field_headerType.clean_up();
}
if (other_value.headerSubType().is_bound()) {
  single_value->field_headerSubType = other_value.headerSubType();
} else {
  single_value->field_headerSubType.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void BeaconHeaderType_template::copy_template(const BeaconHeaderType_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.headerType().get_selection()) {
single_value->field_headerType = other_value.headerType();
} else {
single_value->field_headerType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.headerSubType().get_selection()) {
single_value->field_headerSubType = other_value.headerSubType();
} else {
single_value->field_headerSubType.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new BeaconHeaderType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.");
break;
}
set_selection(other_value);
}

BeaconHeaderType_template::BeaconHeaderType_template()
{
}

BeaconHeaderType_template::BeaconHeaderType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

BeaconHeaderType_template::BeaconHeaderType_template(const BeaconHeaderType& other_value)
{
copy_value(other_value);
}

BeaconHeaderType_template::BeaconHeaderType_template(const OPTIONAL<BeaconHeaderType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BeaconHeaderType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType from an unbound optional field.");
}
}

BeaconHeaderType_template::BeaconHeaderType_template(const BeaconHeaderType_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

BeaconHeaderType_template::~BeaconHeaderType_template()
{
clean_up();
}

BeaconHeaderType_template& BeaconHeaderType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BeaconHeaderType_template& BeaconHeaderType_template::operator=(const BeaconHeaderType& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

BeaconHeaderType_template& BeaconHeaderType_template::operator=(const OPTIONAL<BeaconHeaderType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BeaconHeaderType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.");
}
return *this;
}

BeaconHeaderType_template& BeaconHeaderType_template::operator=(const BeaconHeaderType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean BeaconHeaderType_template::match(const BeaconHeaderType& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.headerType().is_bound()) return FALSE;
if(!single_value->field_headerType.match(other_value.headerType(), legacy))return FALSE;
if(!other_value.headerSubType().is_bound()) return FALSE;
if(!single_value->field_headerSubType.match(other_value.headerSubType(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.");
}
return FALSE;
}

boolean BeaconHeaderType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_headerType.is_bound()) return TRUE;
if (single_value->field_headerSubType.is_bound()) return TRUE;
return FALSE;
}

boolean BeaconHeaderType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_headerType.is_value()) return FALSE;
if (!single_value->field_headerSubType.is_value()) return FALSE;
return TRUE;
}

void BeaconHeaderType_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

BeaconHeaderType BeaconHeaderType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.");
BeaconHeaderType ret_val;
if (single_value->field_headerType.is_bound()) {
ret_val.headerType() = single_value->field_headerType.valueof();
}
if (single_value->field_headerSubType.is_bound()) {
ret_val.headerSubType() = single_value->field_headerSubType.valueof();
}
return ret_val;
}

void BeaconHeaderType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new BeaconHeaderType_template[list_length];
}

BeaconHeaderType_template& BeaconHeaderType_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.");
return value_list.list_value[list_index];
}

HeaderType_template& BeaconHeaderType_template::headerType()
{
set_specific();
return single_value->field_headerType;
}

const HeaderType_template& BeaconHeaderType_template::headerType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.");
return single_value->field_headerType;
}

INTEGER_template& BeaconHeaderType_template::headerSubType()
{
set_specific();
return single_value->field_headerSubType;
}

const INTEGER_template& BeaconHeaderType_template::headerSubType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerSubType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.");
return single_value->field_headerSubType;
}

int BeaconHeaderType_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.");
  }
  return 0;
}

void BeaconHeaderType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ headerType := ");
single_value->field_headerType.log();
TTCN_Logger::log_event_str(", headerSubType := ");
single_value->field_headerSubType.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void BeaconHeaderType_template::log_match(const BeaconHeaderType& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_headerType.match(match_value.headerType(), legacy)){
TTCN_Logger::log_logmatch_info(".headerType");
single_value->field_headerType.log_match(match_value.headerType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_headerSubType.match(match_value.headerSubType(), legacy)){
TTCN_Logger::log_logmatch_info(".headerSubType");
single_value->field_headerSubType.log_match(match_value.headerSubType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ headerType := ");
single_value->field_headerType.log_match(match_value.headerType(), legacy);
TTCN_Logger::log_event_str(", headerSubType := ");
single_value->field_headerSubType.log_match(match_value.headerSubType(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void BeaconHeaderType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_headerType.encode_text(text_buf);
single_value->field_headerSubType.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.");
}
}

void BeaconHeaderType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_headerType.decode_text(text_buf);
single_value->field_headerSubType.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new BeaconHeaderType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType.");
}
}

void BeaconHeaderType_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.BeaconHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      headerType().set_param(param);
      return;
    } else if (strcmp("headerSubType", param_field) == 0) {
      headerSubType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.BeaconHeaderType'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    BeaconHeaderType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headerType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerSubType().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.BeaconHeaderType: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.BeaconHeaderType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* BeaconHeaderType_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.BeaconHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      return headerType().get_param(param_name);
    } else if (strcmp("headerSubType", param_field) == 0) {
      return headerSubType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.BeaconHeaderType'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_headerType = single_value->field_headerType.get_param(param_name);
    mp_field_headerType->set_id(new Module_Param_FieldName(mcopystr("headerType")));
    mp->add_elem(mp_field_headerType);
    Module_Param* mp_field_headerSubType = single_value->field_headerSubType.get_param(param_name);
    mp_field_headerSubType->set_id(new Module_Param_FieldName(mcopystr("headerSubType")));
    mp->add_elem(mp_field_headerSubType);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void BeaconHeaderType_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_headerType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.BeaconHeaderType");
single_value->field_headerSubType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.BeaconHeaderType");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.BeaconHeaderType");
}

boolean BeaconHeaderType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean BeaconHeaderType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

GeoUnicastHeaderType::GeoUnicastHeaderType()
{
  bound_flag = FALSE;
}

GeoUnicastHeaderType::GeoUnicastHeaderType(const HeaderType& par_headerType,
    const INTEGER& par_headerSubType)
  :   field_headerType(par_headerType),
  field_headerSubType(par_headerSubType)
{
  bound_flag = TRUE;
}

GeoUnicastHeaderType::GeoUnicastHeaderType(const GeoUnicastHeaderType& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.");
bound_flag = TRUE;
if (other_value.headerType().is_bound()) field_headerType = other_value.headerType();
else field_headerType.clean_up();
if (other_value.headerSubType().is_bound()) field_headerSubType = other_value.headerSubType();
else field_headerSubType.clean_up();
}

void GeoUnicastHeaderType::clean_up()
{
field_headerType.clean_up();
field_headerSubType.clean_up();
bound_flag = FALSE;
}

GeoUnicastHeaderType& GeoUnicastHeaderType::operator=(const GeoUnicastHeaderType& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.");
  bound_flag = TRUE;
  if (other_value.headerType().is_bound()) field_headerType = other_value.headerType();
  else field_headerType.clean_up();
  if (other_value.headerSubType().is_bound()) field_headerSubType = other_value.headerSubType();
  else field_headerSubType.clean_up();
}
return *this;
}

boolean GeoUnicastHeaderType::operator==(const GeoUnicastHeaderType& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_headerType==other_value.field_headerType
  && field_headerSubType==other_value.field_headerSubType;
}

boolean GeoUnicastHeaderType::is_bound() const
{
if (bound_flag) return TRUE;
if(field_headerType.is_bound()) return TRUE;
if(field_headerSubType.is_bound()) return TRUE;
return FALSE;
}
boolean GeoUnicastHeaderType::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_headerType.is_value()) return FALSE;
if(!field_headerSubType.is_value()) return FALSE;
return TRUE;
}
int GeoUnicastHeaderType::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType");
  return 2;
}

void GeoUnicastHeaderType::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ headerType := ");
field_headerType.log();
TTCN_Logger::log_event_str(", headerSubType := ");
field_headerSubType.log();
TTCN_Logger::log_event_str(" }");
}

void GeoUnicastHeaderType::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      headerType().set_param(param);
      return;
    } else if (strcmp("headerSubType", param_field) == 0) {
      headerSubType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headerType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerSubType().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType");
  }
}

Module_Param* GeoUnicastHeaderType::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      return headerType().get_param(param_name);
    } else if (strcmp("headerSubType", param_field) == 0) {
      return headerSubType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_headerType = field_headerType.get_param(param_name);
  mp_field_headerType->set_id(new Module_Param_FieldName(mcopystr("headerType")));
  mp->add_elem(mp_field_headerType);
  Module_Param* mp_field_headerSubType = field_headerSubType.get_param(param_name);
  mp_field_headerSubType->set_id(new Module_Param_FieldName(mcopystr("headerSubType")));
  mp->add_elem(mp_field_headerSubType);
  return mp;
  }

void GeoUnicastHeaderType::set_implicit_omit()
{
if (headerType().is_bound()) headerType().set_implicit_omit();
if (headerSubType().is_bound()) headerSubType().set_implicit_omit();
}

void GeoUnicastHeaderType::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.");
field_headerType.encode_text(text_buf);
field_headerSubType.encode_text(text_buf);
}

void GeoUnicastHeaderType::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_headerType.decode_text(text_buf);
field_headerSubType.decode_text(text_buf);
}

void GeoUnicastHeaderType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GeoUnicastHeaderType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GeoUnicastHeaderType::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_headerType.RAW_decode(GeoUnicastHeaderType_headerType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_headerSubType.RAW_decode(GeoUnicastHeaderType_headerSubType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GeoUnicastHeaderType::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, GeoUnicastHeaderType_headerType_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, GeoUnicastHeaderType_headerSubType_descr_.raw);
  encoded_length += field_headerType.RAW_encode(GeoUnicastHeaderType_headerType_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_headerSubType.RAW_encode(GeoUnicastHeaderType_headerSubType_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int GeoUnicastHeaderType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerType");
    enc_len += field_headerType.JSON_encode(GeoUnicastHeaderType_headerType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerSubType");
    enc_len += field_headerSubType.JSON_encode(GeoUnicastHeaderType_headerSubType_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GeoUnicastHeaderType::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "headerType", name_len)) {
         int ret_val = field_headerType.JSON_decode(GeoUnicastHeaderType_headerType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "headerSubType", name_len)) {
         int ret_val = field_headerSubType.JSON_decode(GeoUnicastHeaderType_headerSubType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerSubType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_headerType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerType");
    return JSON_ERROR_FATAL;
  }
if (!field_headerSubType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerSubType");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GeoUnicastHeaderType_template::single_value_struct {
HeaderType_template field_headerType;
INTEGER_template field_headerSubType;
};

void GeoUnicastHeaderType_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_headerType = ANY_VALUE;
single_value->field_headerSubType = ANY_VALUE;
}
}
}

void GeoUnicastHeaderType_template::copy_value(const GeoUnicastHeaderType& other_value)
{
single_value = new single_value_struct;
if (other_value.headerType().is_bound()) {
  single_value->field_headerType = other_value.headerType();
} else {
  single_value->field_headerType.clean_up();
}
if (other_value.headerSubType().is_bound()) {
  single_value->field_headerSubType = other_value.headerSubType();
} else {
  single_value->field_headerSubType.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GeoUnicastHeaderType_template::copy_template(const GeoUnicastHeaderType_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.headerType().get_selection()) {
single_value->field_headerType = other_value.headerType();
} else {
single_value->field_headerType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.headerSubType().get_selection()) {
single_value->field_headerSubType = other_value.headerSubType();
} else {
single_value->field_headerSubType.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GeoUnicastHeaderType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.");
break;
}
set_selection(other_value);
}

GeoUnicastHeaderType_template::GeoUnicastHeaderType_template()
{
}

GeoUnicastHeaderType_template::GeoUnicastHeaderType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GeoUnicastHeaderType_template::GeoUnicastHeaderType_template(const GeoUnicastHeaderType& other_value)
{
copy_value(other_value);
}

GeoUnicastHeaderType_template::GeoUnicastHeaderType_template(const OPTIONAL<GeoUnicastHeaderType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoUnicastHeaderType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType from an unbound optional field.");
}
}

GeoUnicastHeaderType_template::GeoUnicastHeaderType_template(const GeoUnicastHeaderType_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GeoUnicastHeaderType_template::~GeoUnicastHeaderType_template()
{
clean_up();
}

GeoUnicastHeaderType_template& GeoUnicastHeaderType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GeoUnicastHeaderType_template& GeoUnicastHeaderType_template::operator=(const GeoUnicastHeaderType& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GeoUnicastHeaderType_template& GeoUnicastHeaderType_template::operator=(const OPTIONAL<GeoUnicastHeaderType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoUnicastHeaderType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.");
}
return *this;
}

GeoUnicastHeaderType_template& GeoUnicastHeaderType_template::operator=(const GeoUnicastHeaderType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GeoUnicastHeaderType_template::match(const GeoUnicastHeaderType& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.headerType().is_bound()) return FALSE;
if(!single_value->field_headerType.match(other_value.headerType(), legacy))return FALSE;
if(!other_value.headerSubType().is_bound()) return FALSE;
if(!single_value->field_headerSubType.match(other_value.headerSubType(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.");
}
return FALSE;
}

boolean GeoUnicastHeaderType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_headerType.is_bound()) return TRUE;
if (single_value->field_headerSubType.is_bound()) return TRUE;
return FALSE;
}

boolean GeoUnicastHeaderType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_headerType.is_value()) return FALSE;
if (!single_value->field_headerSubType.is_value()) return FALSE;
return TRUE;
}

void GeoUnicastHeaderType_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GeoUnicastHeaderType GeoUnicastHeaderType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.");
GeoUnicastHeaderType ret_val;
if (single_value->field_headerType.is_bound()) {
ret_val.headerType() = single_value->field_headerType.valueof();
}
if (single_value->field_headerSubType.is_bound()) {
ret_val.headerSubType() = single_value->field_headerSubType.valueof();
}
return ret_val;
}

void GeoUnicastHeaderType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GeoUnicastHeaderType_template[list_length];
}

GeoUnicastHeaderType_template& GeoUnicastHeaderType_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.");
return value_list.list_value[list_index];
}

HeaderType_template& GeoUnicastHeaderType_template::headerType()
{
set_specific();
return single_value->field_headerType;
}

const HeaderType_template& GeoUnicastHeaderType_template::headerType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.");
return single_value->field_headerType;
}

INTEGER_template& GeoUnicastHeaderType_template::headerSubType()
{
set_specific();
return single_value->field_headerSubType;
}

const INTEGER_template& GeoUnicastHeaderType_template::headerSubType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerSubType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.");
return single_value->field_headerSubType;
}

int GeoUnicastHeaderType_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.");
  }
  return 0;
}

void GeoUnicastHeaderType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ headerType := ");
single_value->field_headerType.log();
TTCN_Logger::log_event_str(", headerSubType := ");
single_value->field_headerSubType.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GeoUnicastHeaderType_template::log_match(const GeoUnicastHeaderType& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_headerType.match(match_value.headerType(), legacy)){
TTCN_Logger::log_logmatch_info(".headerType");
single_value->field_headerType.log_match(match_value.headerType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_headerSubType.match(match_value.headerSubType(), legacy)){
TTCN_Logger::log_logmatch_info(".headerSubType");
single_value->field_headerSubType.log_match(match_value.headerSubType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ headerType := ");
single_value->field_headerType.log_match(match_value.headerType(), legacy);
TTCN_Logger::log_event_str(", headerSubType := ");
single_value->field_headerSubType.log_match(match_value.headerSubType(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GeoUnicastHeaderType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_headerType.encode_text(text_buf);
single_value->field_headerSubType.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.");
}
}

void GeoUnicastHeaderType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_headerType.decode_text(text_buf);
single_value->field_headerSubType.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GeoUnicastHeaderType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType.");
}
}

void GeoUnicastHeaderType_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      headerType().set_param(param);
      return;
    } else if (strcmp("headerSubType", param_field) == 0) {
      headerSubType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GeoUnicastHeaderType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headerType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerSubType().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GeoUnicastHeaderType_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      return headerType().get_param(param_name);
    } else if (strcmp("headerSubType", param_field) == 0) {
      return headerSubType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_headerType = single_value->field_headerType.get_param(param_name);
    mp_field_headerType->set_id(new Module_Param_FieldName(mcopystr("headerType")));
    mp->add_elem(mp_field_headerType);
    Module_Param* mp_field_headerSubType = single_value->field_headerSubType.get_param(param_name);
    mp_field_headerSubType->set_id(new Module_Param_FieldName(mcopystr("headerSubType")));
    mp->add_elem(mp_field_headerSubType);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GeoUnicastHeaderType_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_headerType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType");
single_value->field_headerSubType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeaderType");
}

boolean GeoUnicastHeaderType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GeoUnicastHeaderType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

GeoAnycastHeaderType::GeoAnycastHeaderType()
{
  bound_flag = FALSE;
}

GeoAnycastHeaderType::GeoAnycastHeaderType(const HeaderType& par_headerType,
    const HeaderSubTypeGeoAnycast& par_headerSubType)
  :   field_headerType(par_headerType),
  field_headerSubType(par_headerSubType)
{
  bound_flag = TRUE;
}

GeoAnycastHeaderType::GeoAnycastHeaderType(const GeoAnycastHeaderType& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.");
bound_flag = TRUE;
if (other_value.headerType().is_bound()) field_headerType = other_value.headerType();
else field_headerType.clean_up();
if (other_value.headerSubType().is_bound()) field_headerSubType = other_value.headerSubType();
else field_headerSubType.clean_up();
}

void GeoAnycastHeaderType::clean_up()
{
field_headerType.clean_up();
field_headerSubType.clean_up();
bound_flag = FALSE;
}

GeoAnycastHeaderType& GeoAnycastHeaderType::operator=(const GeoAnycastHeaderType& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.");
  bound_flag = TRUE;
  if (other_value.headerType().is_bound()) field_headerType = other_value.headerType();
  else field_headerType.clean_up();
  if (other_value.headerSubType().is_bound()) field_headerSubType = other_value.headerSubType();
  else field_headerSubType.clean_up();
}
return *this;
}

boolean GeoAnycastHeaderType::operator==(const GeoAnycastHeaderType& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_headerType==other_value.field_headerType
  && field_headerSubType==other_value.field_headerSubType;
}

boolean GeoAnycastHeaderType::is_bound() const
{
if (bound_flag) return TRUE;
if(field_headerType.is_bound()) return TRUE;
if(field_headerSubType.is_bound()) return TRUE;
return FALSE;
}
boolean GeoAnycastHeaderType::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_headerType.is_value()) return FALSE;
if(!field_headerSubType.is_value()) return FALSE;
return TRUE;
}
int GeoAnycastHeaderType::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType");
  return 2;
}

void GeoAnycastHeaderType::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ headerType := ");
field_headerType.log();
TTCN_Logger::log_event_str(", headerSubType := ");
field_headerSubType.log();
TTCN_Logger::log_event_str(" }");
}

void GeoAnycastHeaderType::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      headerType().set_param(param);
      return;
    } else if (strcmp("headerSubType", param_field) == 0) {
      headerSubType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headerType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerSubType().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType");
  }
}

Module_Param* GeoAnycastHeaderType::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      return headerType().get_param(param_name);
    } else if (strcmp("headerSubType", param_field) == 0) {
      return headerSubType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_headerType = field_headerType.get_param(param_name);
  mp_field_headerType->set_id(new Module_Param_FieldName(mcopystr("headerType")));
  mp->add_elem(mp_field_headerType);
  Module_Param* mp_field_headerSubType = field_headerSubType.get_param(param_name);
  mp_field_headerSubType->set_id(new Module_Param_FieldName(mcopystr("headerSubType")));
  mp->add_elem(mp_field_headerSubType);
  return mp;
  }

void GeoAnycastHeaderType::set_implicit_omit()
{
if (headerType().is_bound()) headerType().set_implicit_omit();
if (headerSubType().is_bound()) headerSubType().set_implicit_omit();
}

void GeoAnycastHeaderType::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.");
field_headerType.encode_text(text_buf);
field_headerSubType.encode_text(text_buf);
}

void GeoAnycastHeaderType::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_headerType.decode_text(text_buf);
field_headerSubType.decode_text(text_buf);
}

void GeoAnycastHeaderType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GeoAnycastHeaderType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GeoAnycastHeaderType::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_headerType.RAW_decode(GeoAnycastHeaderType_headerType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_headerSubType.RAW_decode(GeoAnycastHeaderType_headerSubType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GeoAnycastHeaderType::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, GeoAnycastHeaderType_headerType_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, GeoAnycastHeaderType_headerSubType_descr_.raw);
  encoded_length += field_headerType.RAW_encode(GeoAnycastHeaderType_headerType_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_headerSubType.RAW_encode(GeoAnycastHeaderType_headerSubType_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int GeoAnycastHeaderType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerType");
    enc_len += field_headerType.JSON_encode(GeoAnycastHeaderType_headerType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerSubType");
    enc_len += field_headerSubType.JSON_encode(GeoAnycastHeaderType_headerSubType_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GeoAnycastHeaderType::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "headerType", name_len)) {
         int ret_val = field_headerType.JSON_decode(GeoAnycastHeaderType_headerType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "headerSubType", name_len)) {
         int ret_val = field_headerSubType.JSON_decode(GeoAnycastHeaderType_headerSubType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerSubType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_headerType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerType");
    return JSON_ERROR_FATAL;
  }
if (!field_headerSubType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerSubType");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GeoAnycastHeaderType_template::single_value_struct {
HeaderType_template field_headerType;
HeaderSubTypeGeoAnycast_template field_headerSubType;
};

void GeoAnycastHeaderType_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_headerType = ANY_VALUE;
single_value->field_headerSubType = ANY_VALUE;
}
}
}

void GeoAnycastHeaderType_template::copy_value(const GeoAnycastHeaderType& other_value)
{
single_value = new single_value_struct;
if (other_value.headerType().is_bound()) {
  single_value->field_headerType = other_value.headerType();
} else {
  single_value->field_headerType.clean_up();
}
if (other_value.headerSubType().is_bound()) {
  single_value->field_headerSubType = other_value.headerSubType();
} else {
  single_value->field_headerSubType.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GeoAnycastHeaderType_template::copy_template(const GeoAnycastHeaderType_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.headerType().get_selection()) {
single_value->field_headerType = other_value.headerType();
} else {
single_value->field_headerType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.headerSubType().get_selection()) {
single_value->field_headerSubType = other_value.headerSubType();
} else {
single_value->field_headerSubType.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GeoAnycastHeaderType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.");
break;
}
set_selection(other_value);
}

GeoAnycastHeaderType_template::GeoAnycastHeaderType_template()
{
}

GeoAnycastHeaderType_template::GeoAnycastHeaderType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GeoAnycastHeaderType_template::GeoAnycastHeaderType_template(const GeoAnycastHeaderType& other_value)
{
copy_value(other_value);
}

GeoAnycastHeaderType_template::GeoAnycastHeaderType_template(const OPTIONAL<GeoAnycastHeaderType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoAnycastHeaderType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType from an unbound optional field.");
}
}

GeoAnycastHeaderType_template::GeoAnycastHeaderType_template(const GeoAnycastHeaderType_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GeoAnycastHeaderType_template::~GeoAnycastHeaderType_template()
{
clean_up();
}

GeoAnycastHeaderType_template& GeoAnycastHeaderType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GeoAnycastHeaderType_template& GeoAnycastHeaderType_template::operator=(const GeoAnycastHeaderType& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GeoAnycastHeaderType_template& GeoAnycastHeaderType_template::operator=(const OPTIONAL<GeoAnycastHeaderType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoAnycastHeaderType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.");
}
return *this;
}

GeoAnycastHeaderType_template& GeoAnycastHeaderType_template::operator=(const GeoAnycastHeaderType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GeoAnycastHeaderType_template::match(const GeoAnycastHeaderType& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.headerType().is_bound()) return FALSE;
if(!single_value->field_headerType.match(other_value.headerType(), legacy))return FALSE;
if(!other_value.headerSubType().is_bound()) return FALSE;
if(!single_value->field_headerSubType.match(other_value.headerSubType(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.");
}
return FALSE;
}

boolean GeoAnycastHeaderType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_headerType.is_bound()) return TRUE;
if (single_value->field_headerSubType.is_bound()) return TRUE;
return FALSE;
}

boolean GeoAnycastHeaderType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_headerType.is_value()) return FALSE;
if (!single_value->field_headerSubType.is_value()) return FALSE;
return TRUE;
}

void GeoAnycastHeaderType_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GeoAnycastHeaderType GeoAnycastHeaderType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.");
GeoAnycastHeaderType ret_val;
if (single_value->field_headerType.is_bound()) {
ret_val.headerType() = single_value->field_headerType.valueof();
}
if (single_value->field_headerSubType.is_bound()) {
ret_val.headerSubType() = single_value->field_headerSubType.valueof();
}
return ret_val;
}

void GeoAnycastHeaderType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GeoAnycastHeaderType_template[list_length];
}

GeoAnycastHeaderType_template& GeoAnycastHeaderType_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.");
return value_list.list_value[list_index];
}

HeaderType_template& GeoAnycastHeaderType_template::headerType()
{
set_specific();
return single_value->field_headerType;
}

const HeaderType_template& GeoAnycastHeaderType_template::headerType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.");
return single_value->field_headerType;
}

HeaderSubTypeGeoAnycast_template& GeoAnycastHeaderType_template::headerSubType()
{
set_specific();
return single_value->field_headerSubType;
}

const HeaderSubTypeGeoAnycast_template& GeoAnycastHeaderType_template::headerSubType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerSubType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.");
return single_value->field_headerSubType;
}

int GeoAnycastHeaderType_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.");
  }
  return 0;
}

void GeoAnycastHeaderType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ headerType := ");
single_value->field_headerType.log();
TTCN_Logger::log_event_str(", headerSubType := ");
single_value->field_headerSubType.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GeoAnycastHeaderType_template::log_match(const GeoAnycastHeaderType& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_headerType.match(match_value.headerType(), legacy)){
TTCN_Logger::log_logmatch_info(".headerType");
single_value->field_headerType.log_match(match_value.headerType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_headerSubType.match(match_value.headerSubType(), legacy)){
TTCN_Logger::log_logmatch_info(".headerSubType");
single_value->field_headerSubType.log_match(match_value.headerSubType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ headerType := ");
single_value->field_headerType.log_match(match_value.headerType(), legacy);
TTCN_Logger::log_event_str(", headerSubType := ");
single_value->field_headerSubType.log_match(match_value.headerSubType(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GeoAnycastHeaderType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_headerType.encode_text(text_buf);
single_value->field_headerSubType.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.");
}
}

void GeoAnycastHeaderType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_headerType.decode_text(text_buf);
single_value->field_headerSubType.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GeoAnycastHeaderType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType.");
}
}

void GeoAnycastHeaderType_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      headerType().set_param(param);
      return;
    } else if (strcmp("headerSubType", param_field) == 0) {
      headerSubType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GeoAnycastHeaderType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headerType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerSubType().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GeoAnycastHeaderType_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      return headerType().get_param(param_name);
    } else if (strcmp("headerSubType", param_field) == 0) {
      return headerSubType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_headerType = single_value->field_headerType.get_param(param_name);
    mp_field_headerType->set_id(new Module_Param_FieldName(mcopystr("headerType")));
    mp->add_elem(mp_field_headerType);
    Module_Param* mp_field_headerSubType = single_value->field_headerSubType.get_param(param_name);
    mp_field_headerSubType->set_id(new Module_Param_FieldName(mcopystr("headerSubType")));
    mp->add_elem(mp_field_headerSubType);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GeoAnycastHeaderType_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_headerType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType");
single_value->field_headerSubType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeaderType");
}

boolean GeoAnycastHeaderType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GeoAnycastHeaderType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

GeoBroadcastHeaderType::GeoBroadcastHeaderType()
{
  bound_flag = FALSE;
}

GeoBroadcastHeaderType::GeoBroadcastHeaderType(const HeaderType& par_headerType,
    const HeaderSubTypeGeoBroadcast& par_headerSubType)
  :   field_headerType(par_headerType),
  field_headerSubType(par_headerSubType)
{
  bound_flag = TRUE;
}

GeoBroadcastHeaderType::GeoBroadcastHeaderType(const GeoBroadcastHeaderType& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.");
bound_flag = TRUE;
if (other_value.headerType().is_bound()) field_headerType = other_value.headerType();
else field_headerType.clean_up();
if (other_value.headerSubType().is_bound()) field_headerSubType = other_value.headerSubType();
else field_headerSubType.clean_up();
}

void GeoBroadcastHeaderType::clean_up()
{
field_headerType.clean_up();
field_headerSubType.clean_up();
bound_flag = FALSE;
}

GeoBroadcastHeaderType& GeoBroadcastHeaderType::operator=(const GeoBroadcastHeaderType& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.");
  bound_flag = TRUE;
  if (other_value.headerType().is_bound()) field_headerType = other_value.headerType();
  else field_headerType.clean_up();
  if (other_value.headerSubType().is_bound()) field_headerSubType = other_value.headerSubType();
  else field_headerSubType.clean_up();
}
return *this;
}

boolean GeoBroadcastHeaderType::operator==(const GeoBroadcastHeaderType& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_headerType==other_value.field_headerType
  && field_headerSubType==other_value.field_headerSubType;
}

boolean GeoBroadcastHeaderType::is_bound() const
{
if (bound_flag) return TRUE;
if(field_headerType.is_bound()) return TRUE;
if(field_headerSubType.is_bound()) return TRUE;
return FALSE;
}
boolean GeoBroadcastHeaderType::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_headerType.is_value()) return FALSE;
if(!field_headerSubType.is_value()) return FALSE;
return TRUE;
}
int GeoBroadcastHeaderType::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType");
  return 2;
}

void GeoBroadcastHeaderType::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ headerType := ");
field_headerType.log();
TTCN_Logger::log_event_str(", headerSubType := ");
field_headerSubType.log();
TTCN_Logger::log_event_str(" }");
}

void GeoBroadcastHeaderType::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      headerType().set_param(param);
      return;
    } else if (strcmp("headerSubType", param_field) == 0) {
      headerSubType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headerType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerSubType().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType");
  }
}

Module_Param* GeoBroadcastHeaderType::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      return headerType().get_param(param_name);
    } else if (strcmp("headerSubType", param_field) == 0) {
      return headerSubType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_headerType = field_headerType.get_param(param_name);
  mp_field_headerType->set_id(new Module_Param_FieldName(mcopystr("headerType")));
  mp->add_elem(mp_field_headerType);
  Module_Param* mp_field_headerSubType = field_headerSubType.get_param(param_name);
  mp_field_headerSubType->set_id(new Module_Param_FieldName(mcopystr("headerSubType")));
  mp->add_elem(mp_field_headerSubType);
  return mp;
  }

void GeoBroadcastHeaderType::set_implicit_omit()
{
if (headerType().is_bound()) headerType().set_implicit_omit();
if (headerSubType().is_bound()) headerSubType().set_implicit_omit();
}

void GeoBroadcastHeaderType::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.");
field_headerType.encode_text(text_buf);
field_headerSubType.encode_text(text_buf);
}

void GeoBroadcastHeaderType::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_headerType.decode_text(text_buf);
field_headerSubType.decode_text(text_buf);
}

void GeoBroadcastHeaderType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GeoBroadcastHeaderType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GeoBroadcastHeaderType::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_headerType.RAW_decode(GeoBroadcastHeaderType_headerType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_headerSubType.RAW_decode(GeoBroadcastHeaderType_headerSubType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GeoBroadcastHeaderType::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, GeoBroadcastHeaderType_headerType_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, GeoBroadcastHeaderType_headerSubType_descr_.raw);
  encoded_length += field_headerType.RAW_encode(GeoBroadcastHeaderType_headerType_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_headerSubType.RAW_encode(GeoBroadcastHeaderType_headerSubType_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int GeoBroadcastHeaderType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerType");
    enc_len += field_headerType.JSON_encode(GeoBroadcastHeaderType_headerType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerSubType");
    enc_len += field_headerSubType.JSON_encode(GeoBroadcastHeaderType_headerSubType_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GeoBroadcastHeaderType::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "headerType", name_len)) {
         int ret_val = field_headerType.JSON_decode(GeoBroadcastHeaderType_headerType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "headerSubType", name_len)) {
         int ret_val = field_headerSubType.JSON_decode(GeoBroadcastHeaderType_headerSubType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerSubType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_headerType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerType");
    return JSON_ERROR_FATAL;
  }
if (!field_headerSubType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerSubType");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GeoBroadcastHeaderType_template::single_value_struct {
HeaderType_template field_headerType;
HeaderSubTypeGeoBroadcast_template field_headerSubType;
};

void GeoBroadcastHeaderType_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_headerType = ANY_VALUE;
single_value->field_headerSubType = ANY_VALUE;
}
}
}

void GeoBroadcastHeaderType_template::copy_value(const GeoBroadcastHeaderType& other_value)
{
single_value = new single_value_struct;
if (other_value.headerType().is_bound()) {
  single_value->field_headerType = other_value.headerType();
} else {
  single_value->field_headerType.clean_up();
}
if (other_value.headerSubType().is_bound()) {
  single_value->field_headerSubType = other_value.headerSubType();
} else {
  single_value->field_headerSubType.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GeoBroadcastHeaderType_template::copy_template(const GeoBroadcastHeaderType_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.headerType().get_selection()) {
single_value->field_headerType = other_value.headerType();
} else {
single_value->field_headerType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.headerSubType().get_selection()) {
single_value->field_headerSubType = other_value.headerSubType();
} else {
single_value->field_headerSubType.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GeoBroadcastHeaderType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.");
break;
}
set_selection(other_value);
}

GeoBroadcastHeaderType_template::GeoBroadcastHeaderType_template()
{
}

GeoBroadcastHeaderType_template::GeoBroadcastHeaderType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GeoBroadcastHeaderType_template::GeoBroadcastHeaderType_template(const GeoBroadcastHeaderType& other_value)
{
copy_value(other_value);
}

GeoBroadcastHeaderType_template::GeoBroadcastHeaderType_template(const OPTIONAL<GeoBroadcastHeaderType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoBroadcastHeaderType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType from an unbound optional field.");
}
}

GeoBroadcastHeaderType_template::GeoBroadcastHeaderType_template(const GeoBroadcastHeaderType_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GeoBroadcastHeaderType_template::~GeoBroadcastHeaderType_template()
{
clean_up();
}

GeoBroadcastHeaderType_template& GeoBroadcastHeaderType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GeoBroadcastHeaderType_template& GeoBroadcastHeaderType_template::operator=(const GeoBroadcastHeaderType& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GeoBroadcastHeaderType_template& GeoBroadcastHeaderType_template::operator=(const OPTIONAL<GeoBroadcastHeaderType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoBroadcastHeaderType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.");
}
return *this;
}

GeoBroadcastHeaderType_template& GeoBroadcastHeaderType_template::operator=(const GeoBroadcastHeaderType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GeoBroadcastHeaderType_template::match(const GeoBroadcastHeaderType& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.headerType().is_bound()) return FALSE;
if(!single_value->field_headerType.match(other_value.headerType(), legacy))return FALSE;
if(!other_value.headerSubType().is_bound()) return FALSE;
if(!single_value->field_headerSubType.match(other_value.headerSubType(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.");
}
return FALSE;
}

boolean GeoBroadcastHeaderType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_headerType.is_bound()) return TRUE;
if (single_value->field_headerSubType.is_bound()) return TRUE;
return FALSE;
}

boolean GeoBroadcastHeaderType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_headerType.is_value()) return FALSE;
if (!single_value->field_headerSubType.is_value()) return FALSE;
return TRUE;
}

void GeoBroadcastHeaderType_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GeoBroadcastHeaderType GeoBroadcastHeaderType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.");
GeoBroadcastHeaderType ret_val;
if (single_value->field_headerType.is_bound()) {
ret_val.headerType() = single_value->field_headerType.valueof();
}
if (single_value->field_headerSubType.is_bound()) {
ret_val.headerSubType() = single_value->field_headerSubType.valueof();
}
return ret_val;
}

void GeoBroadcastHeaderType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GeoBroadcastHeaderType_template[list_length];
}

GeoBroadcastHeaderType_template& GeoBroadcastHeaderType_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.");
return value_list.list_value[list_index];
}

HeaderType_template& GeoBroadcastHeaderType_template::headerType()
{
set_specific();
return single_value->field_headerType;
}

const HeaderType_template& GeoBroadcastHeaderType_template::headerType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.");
return single_value->field_headerType;
}

HeaderSubTypeGeoBroadcast_template& GeoBroadcastHeaderType_template::headerSubType()
{
set_specific();
return single_value->field_headerSubType;
}

const HeaderSubTypeGeoBroadcast_template& GeoBroadcastHeaderType_template::headerSubType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerSubType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.");
return single_value->field_headerSubType;
}

int GeoBroadcastHeaderType_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.");
  }
  return 0;
}

void GeoBroadcastHeaderType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ headerType := ");
single_value->field_headerType.log();
TTCN_Logger::log_event_str(", headerSubType := ");
single_value->field_headerSubType.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GeoBroadcastHeaderType_template::log_match(const GeoBroadcastHeaderType& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_headerType.match(match_value.headerType(), legacy)){
TTCN_Logger::log_logmatch_info(".headerType");
single_value->field_headerType.log_match(match_value.headerType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_headerSubType.match(match_value.headerSubType(), legacy)){
TTCN_Logger::log_logmatch_info(".headerSubType");
single_value->field_headerSubType.log_match(match_value.headerSubType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ headerType := ");
single_value->field_headerType.log_match(match_value.headerType(), legacy);
TTCN_Logger::log_event_str(", headerSubType := ");
single_value->field_headerSubType.log_match(match_value.headerSubType(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GeoBroadcastHeaderType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_headerType.encode_text(text_buf);
single_value->field_headerSubType.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.");
}
}

void GeoBroadcastHeaderType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_headerType.decode_text(text_buf);
single_value->field_headerSubType.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GeoBroadcastHeaderType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType.");
}
}

void GeoBroadcastHeaderType_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      headerType().set_param(param);
      return;
    } else if (strcmp("headerSubType", param_field) == 0) {
      headerSubType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GeoBroadcastHeaderType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headerType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerSubType().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GeoBroadcastHeaderType_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      return headerType().get_param(param_name);
    } else if (strcmp("headerSubType", param_field) == 0) {
      return headerSubType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_headerType = single_value->field_headerType.get_param(param_name);
    mp_field_headerType->set_id(new Module_Param_FieldName(mcopystr("headerType")));
    mp->add_elem(mp_field_headerType);
    Module_Param* mp_field_headerSubType = single_value->field_headerSubType.get_param(param_name);
    mp_field_headerSubType->set_id(new Module_Param_FieldName(mcopystr("headerSubType")));
    mp->add_elem(mp_field_headerSubType);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GeoBroadcastHeaderType_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_headerType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType");
single_value->field_headerSubType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastHeaderType");
}

boolean GeoBroadcastHeaderType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GeoBroadcastHeaderType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

HeaderSubTypeTSB::HeaderSubTypeTSB()
{
enum_value = UNBOUND_VALUE;
}

HeaderSubTypeTSB::HeaderSubTypeTSB(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

HeaderSubTypeTSB::HeaderSubTypeTSB(enum_type other_value)
{
enum_value = other_value;
}

HeaderSubTypeTSB::HeaderSubTypeTSB(const HeaderSubTypeTSB& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
enum_value = other_value.enum_value;
}

HeaderSubTypeTSB& HeaderSubTypeTSB::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

HeaderSubTypeTSB& HeaderSubTypeTSB::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

HeaderSubTypeTSB& HeaderSubTypeTSB::operator=(const HeaderSubTypeTSB& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
enum_value = other_value.enum_value;
return *this;
}

boolean HeaderSubTypeTSB::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
return enum_value == other_value;
}

boolean HeaderSubTypeTSB::operator==(const HeaderSubTypeTSB& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
return enum_value == other_value.enum_value;
}

boolean HeaderSubTypeTSB::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
return enum_value < other_value;
}

boolean HeaderSubTypeTSB::operator<(const HeaderSubTypeTSB& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
return enum_value < other_value.enum_value;
}

boolean HeaderSubTypeTSB::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
return enum_value > other_value;
}

boolean HeaderSubTypeTSB::operator>(const HeaderSubTypeTSB& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
return enum_value > other_value.enum_value;
}

const char *HeaderSubTypeTSB::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__singleHop: return "e_singleHop";
case e__multiHop: return "e_multiHop";
case e__reserved: return "e_reserved";
default: return "<unknown>";
}
}

HeaderSubTypeTSB::enum_type HeaderSubTypeTSB::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_singleHop")) return e__singleHop;
else if (!strcmp(str_par, "e_multiHop")) return e__multiHop;
else if (!strcmp(str_par, "e_reserved")) return e__reserved;
else return UNKNOWN_VALUE;
}

boolean HeaderSubTypeTSB::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
return TRUE;
default:
return FALSE;
}
}

int HeaderSubTypeTSB::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int HeaderSubTypeTSB::enum2int(const HeaderSubTypeTSB& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void HeaderSubTypeTSB::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.", int_val);
enum_value = (enum_type)int_val;
}

HeaderSubTypeTSB::operator HeaderSubTypeTSB::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
return enum_value;
}

void HeaderSubTypeTSB::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void HeaderSubTypeTSB::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
  }
}

Module_Param* HeaderSubTypeTSB::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void HeaderSubTypeTSB::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
text_buf.push_int(enum_value);
}

void HeaderSubTypeTSB::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.", enum_value);
}

void HeaderSubTypeTSB::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void HeaderSubTypeTSB::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int HeaderSubTypeTSB::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 2, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int HeaderSubTypeTSB::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 2);
}

int HeaderSubTypeTSB::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int HeaderSubTypeTSB::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void HeaderSubTypeTSB_template::copy_template(const HeaderSubTypeTSB_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new HeaderSubTypeTSB_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
}
}

HeaderSubTypeTSB_template::HeaderSubTypeTSB_template()
{
}

HeaderSubTypeTSB_template::HeaderSubTypeTSB_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

HeaderSubTypeTSB_template::HeaderSubTypeTSB_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!HeaderSubTypeTSB::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB with unknown numeric value %d.", other_value);
single_value = (HeaderSubTypeTSB::enum_type)other_value;
}

HeaderSubTypeTSB_template::HeaderSubTypeTSB_template(HeaderSubTypeTSB::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

HeaderSubTypeTSB_template::HeaderSubTypeTSB_template(const HeaderSubTypeTSB& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == HeaderSubTypeTSB::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
single_value = other_value.enum_value;
}

HeaderSubTypeTSB_template::HeaderSubTypeTSB_template(const OPTIONAL<HeaderSubTypeTSB>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (HeaderSubTypeTSB::enum_type)(const HeaderSubTypeTSB&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB from an unbound optional field.");
}
}

HeaderSubTypeTSB_template::HeaderSubTypeTSB_template(const HeaderSubTypeTSB_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

HeaderSubTypeTSB_template::~HeaderSubTypeTSB_template()
{
clean_up();
}

boolean HeaderSubTypeTSB_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean HeaderSubTypeTSB_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != HeaderSubTypeTSB::UNBOUND_VALUE;
}

void HeaderSubTypeTSB_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

HeaderSubTypeTSB_template& HeaderSubTypeTSB_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

HeaderSubTypeTSB_template& HeaderSubTypeTSB_template::operator=(int other_value)
{
if (!HeaderSubTypeTSB::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (HeaderSubTypeTSB::enum_type)other_value;
return *this;
}

HeaderSubTypeTSB_template& HeaderSubTypeTSB_template::operator=(HeaderSubTypeTSB::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

HeaderSubTypeTSB_template& HeaderSubTypeTSB_template::operator=(const HeaderSubTypeTSB& other_value)
{
if (other_value.enum_value == HeaderSubTypeTSB::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

HeaderSubTypeTSB_template& HeaderSubTypeTSB_template::operator=(const OPTIONAL<HeaderSubTypeTSB>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (HeaderSubTypeTSB::enum_type)(const HeaderSubTypeTSB&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
}
return *this;
}

HeaderSubTypeTSB_template& HeaderSubTypeTSB_template::operator=(const HeaderSubTypeTSB_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean HeaderSubTypeTSB_template::match(HeaderSubTypeTSB::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
}
return FALSE;
}

boolean HeaderSubTypeTSB_template::match(const HeaderSubTypeTSB& other_value, boolean) const
{
if (other_value.enum_value == HeaderSubTypeTSB::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB with an unbound value.");
return match(other_value.enum_value);
}

HeaderSubTypeTSB::enum_type HeaderSubTypeTSB_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
return single_value;
}

void HeaderSubTypeTSB_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new HeaderSubTypeTSB_template[list_length];
}

HeaderSubTypeTSB_template& HeaderSubTypeTSB_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
return value_list.list_value[list_index];
}

void HeaderSubTypeTSB_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(HeaderSubTypeTSB::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void HeaderSubTypeTSB_template::log_match(const HeaderSubTypeTSB& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void HeaderSubTypeTSB_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
}
}

void HeaderSubTypeTSB_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (HeaderSubTypeTSB::enum_type)text_buf.pull_int().get_val();
if (!HeaderSubTypeTSB::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new HeaderSubTypeTSB_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
}
}

boolean HeaderSubTypeTSB_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean HeaderSubTypeTSB_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void HeaderSubTypeTSB_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    HeaderSubTypeTSB::enum_type enum_val = (enum_name != NULL) ? HeaderSubTypeTSB::str_to_enum(enum_name) : HeaderSubTypeTSB::UNKNOWN_VALUE;
    if (HeaderSubTypeTSB::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    HeaderSubTypeTSB_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    HeaderSubTypeTSB::enum_type enum_val = HeaderSubTypeTSB::str_to_enum(mp->get_enumerated());
    if (!HeaderSubTypeTSB::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* HeaderSubTypeTSB_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(HeaderSubTypeTSB::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void HeaderSubTypeTSB_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeTSB");
}

TsbHeaderType::TsbHeaderType()
{
  bound_flag = FALSE;
}

TsbHeaderType::TsbHeaderType(const HeaderType& par_headerType,
    const HeaderSubTypeTSB& par_headerSubType)
  :   field_headerType(par_headerType),
  field_headerSubType(par_headerSubType)
{
  bound_flag = TRUE;
}

TsbHeaderType::TsbHeaderType(const TsbHeaderType& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType.");
bound_flag = TRUE;
if (other_value.headerType().is_bound()) field_headerType = other_value.headerType();
else field_headerType.clean_up();
if (other_value.headerSubType().is_bound()) field_headerSubType = other_value.headerSubType();
else field_headerSubType.clean_up();
}

void TsbHeaderType::clean_up()
{
field_headerType.clean_up();
field_headerSubType.clean_up();
bound_flag = FALSE;
}

TsbHeaderType& TsbHeaderType::operator=(const TsbHeaderType& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType.");
  bound_flag = TRUE;
  if (other_value.headerType().is_bound()) field_headerType = other_value.headerType();
  else field_headerType.clean_up();
  if (other_value.headerSubType().is_bound()) field_headerSubType = other_value.headerSubType();
  else field_headerSubType.clean_up();
}
return *this;
}

boolean TsbHeaderType::operator==(const TsbHeaderType& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_headerType==other_value.field_headerType
  && field_headerSubType==other_value.field_headerSubType;
}

boolean TsbHeaderType::is_bound() const
{
if (bound_flag) return TRUE;
if(field_headerType.is_bound()) return TRUE;
if(field_headerSubType.is_bound()) return TRUE;
return FALSE;
}
boolean TsbHeaderType::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_headerType.is_value()) return FALSE;
if(!field_headerSubType.is_value()) return FALSE;
return TRUE;
}
int TsbHeaderType::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType");
  return 2;
}

void TsbHeaderType::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ headerType := ");
field_headerType.log();
TTCN_Logger::log_event_str(", headerSubType := ");
field_headerSubType.log();
TTCN_Logger::log_event_str(" }");
}

void TsbHeaderType::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.TsbHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      headerType().set_param(param);
      return;
    } else if (strcmp("headerSubType", param_field) == 0) {
      headerSubType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.TsbHeaderType'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headerType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerSubType().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.TsbHeaderType");
  }
}

Module_Param* TsbHeaderType::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.TsbHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      return headerType().get_param(param_name);
    } else if (strcmp("headerSubType", param_field) == 0) {
      return headerSubType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.TsbHeaderType'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_headerType = field_headerType.get_param(param_name);
  mp_field_headerType->set_id(new Module_Param_FieldName(mcopystr("headerType")));
  mp->add_elem(mp_field_headerType);
  Module_Param* mp_field_headerSubType = field_headerSubType.get_param(param_name);
  mp_field_headerSubType->set_id(new Module_Param_FieldName(mcopystr("headerSubType")));
  mp->add_elem(mp_field_headerSubType);
  return mp;
  }

void TsbHeaderType::set_implicit_omit()
{
if (headerType().is_bound()) headerType().set_implicit_omit();
if (headerSubType().is_bound()) headerSubType().set_implicit_omit();
}

void TsbHeaderType::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType.");
field_headerType.encode_text(text_buf);
field_headerSubType.encode_text(text_buf);
}

void TsbHeaderType::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_headerType.decode_text(text_buf);
field_headerSubType.decode_text(text_buf);
}

void TsbHeaderType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void TsbHeaderType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int TsbHeaderType::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_headerType.RAW_decode(TsbHeaderType_headerType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_headerSubType.RAW_decode(TsbHeaderType_headerSubType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int TsbHeaderType::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, TsbHeaderType_headerType_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, TsbHeaderType_headerSubType_descr_.raw);
  encoded_length += field_headerType.RAW_encode(TsbHeaderType_headerType_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_headerSubType.RAW_encode(TsbHeaderType_headerSubType_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int TsbHeaderType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerType");
    enc_len += field_headerType.JSON_encode(TsbHeaderType_headerType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerSubType");
    enc_len += field_headerSubType.JSON_encode(TsbHeaderType_headerSubType_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int TsbHeaderType::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "headerType", name_len)) {
         int ret_val = field_headerType.JSON_decode(TsbHeaderType_headerType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "headerSubType", name_len)) {
         int ret_val = field_headerSubType.JSON_decode(TsbHeaderType_headerSubType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerSubType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_headerType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerType");
    return JSON_ERROR_FATAL;
  }
if (!field_headerSubType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerSubType");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct TsbHeaderType_template::single_value_struct {
HeaderType_template field_headerType;
HeaderSubTypeTSB_template field_headerSubType;
};

void TsbHeaderType_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_headerType = ANY_VALUE;
single_value->field_headerSubType = ANY_VALUE;
}
}
}

void TsbHeaderType_template::copy_value(const TsbHeaderType& other_value)
{
single_value = new single_value_struct;
if (other_value.headerType().is_bound()) {
  single_value->field_headerType = other_value.headerType();
} else {
  single_value->field_headerType.clean_up();
}
if (other_value.headerSubType().is_bound()) {
  single_value->field_headerSubType = other_value.headerSubType();
} else {
  single_value->field_headerSubType.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void TsbHeaderType_template::copy_template(const TsbHeaderType_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.headerType().get_selection()) {
single_value->field_headerType = other_value.headerType();
} else {
single_value->field_headerType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.headerSubType().get_selection()) {
single_value->field_headerSubType = other_value.headerSubType();
} else {
single_value->field_headerSubType.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TsbHeaderType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType.");
break;
}
set_selection(other_value);
}

TsbHeaderType_template::TsbHeaderType_template()
{
}

TsbHeaderType_template::TsbHeaderType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

TsbHeaderType_template::TsbHeaderType_template(const TsbHeaderType& other_value)
{
copy_value(other_value);
}

TsbHeaderType_template::TsbHeaderType_template(const OPTIONAL<TsbHeaderType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TsbHeaderType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType from an unbound optional field.");
}
}

TsbHeaderType_template::TsbHeaderType_template(const TsbHeaderType_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

TsbHeaderType_template::~TsbHeaderType_template()
{
clean_up();
}

TsbHeaderType_template& TsbHeaderType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TsbHeaderType_template& TsbHeaderType_template::operator=(const TsbHeaderType& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

TsbHeaderType_template& TsbHeaderType_template::operator=(const OPTIONAL<TsbHeaderType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TsbHeaderType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType.");
}
return *this;
}

TsbHeaderType_template& TsbHeaderType_template::operator=(const TsbHeaderType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean TsbHeaderType_template::match(const TsbHeaderType& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.headerType().is_bound()) return FALSE;
if(!single_value->field_headerType.match(other_value.headerType(), legacy))return FALSE;
if(!other_value.headerSubType().is_bound()) return FALSE;
if(!single_value->field_headerSubType.match(other_value.headerSubType(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType.");
}
return FALSE;
}

boolean TsbHeaderType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_headerType.is_bound()) return TRUE;
if (single_value->field_headerSubType.is_bound()) return TRUE;
return FALSE;
}

boolean TsbHeaderType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_headerType.is_value()) return FALSE;
if (!single_value->field_headerSubType.is_value()) return FALSE;
return TRUE;
}

void TsbHeaderType_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

TsbHeaderType TsbHeaderType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType.");
TsbHeaderType ret_val;
if (single_value->field_headerType.is_bound()) {
ret_val.headerType() = single_value->field_headerType.valueof();
}
if (single_value->field_headerSubType.is_bound()) {
ret_val.headerSubType() = single_value->field_headerSubType.valueof();
}
return ret_val;
}

void TsbHeaderType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new TsbHeaderType_template[list_length];
}

TsbHeaderType_template& TsbHeaderType_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType.");
return value_list.list_value[list_index];
}

HeaderType_template& TsbHeaderType_template::headerType()
{
set_specific();
return single_value->field_headerType;
}

const HeaderType_template& TsbHeaderType_template::headerType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType.");
return single_value->field_headerType;
}

HeaderSubTypeTSB_template& TsbHeaderType_template::headerSubType()
{
set_specific();
return single_value->field_headerSubType;
}

const HeaderSubTypeTSB_template& TsbHeaderType_template::headerSubType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerSubType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType.");
return single_value->field_headerSubType;
}

int TsbHeaderType_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType.");
  }
  return 0;
}

void TsbHeaderType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ headerType := ");
single_value->field_headerType.log();
TTCN_Logger::log_event_str(", headerSubType := ");
single_value->field_headerSubType.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void TsbHeaderType_template::log_match(const TsbHeaderType& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_headerType.match(match_value.headerType(), legacy)){
TTCN_Logger::log_logmatch_info(".headerType");
single_value->field_headerType.log_match(match_value.headerType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_headerSubType.match(match_value.headerSubType(), legacy)){
TTCN_Logger::log_logmatch_info(".headerSubType");
single_value->field_headerSubType.log_match(match_value.headerSubType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ headerType := ");
single_value->field_headerType.log_match(match_value.headerType(), legacy);
TTCN_Logger::log_event_str(", headerSubType := ");
single_value->field_headerSubType.log_match(match_value.headerSubType(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void TsbHeaderType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_headerType.encode_text(text_buf);
single_value->field_headerSubType.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType.");
}
}

void TsbHeaderType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_headerType.decode_text(text_buf);
single_value->field_headerSubType.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TsbHeaderType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType.");
}
}

void TsbHeaderType_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.TsbHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      headerType().set_param(param);
      return;
    } else if (strcmp("headerSubType", param_field) == 0) {
      headerSubType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.TsbHeaderType'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TsbHeaderType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headerType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerSubType().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.TsbHeaderType: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.TsbHeaderType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* TsbHeaderType_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.TsbHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      return headerType().get_param(param_name);
    } else if (strcmp("headerSubType", param_field) == 0) {
      return headerSubType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.TsbHeaderType'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_headerType = single_value->field_headerType.get_param(param_name);
    mp_field_headerType->set_id(new Module_Param_FieldName(mcopystr("headerType")));
    mp->add_elem(mp_field_headerType);
    Module_Param* mp_field_headerSubType = single_value->field_headerSubType.get_param(param_name);
    mp_field_headerSubType->set_id(new Module_Param_FieldName(mcopystr("headerSubType")));
    mp->add_elem(mp_field_headerSubType);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void TsbHeaderType_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_headerType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.TsbHeaderType");
single_value->field_headerSubType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.TsbHeaderType");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.TsbHeaderType");
}

boolean TsbHeaderType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TsbHeaderType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

HeaderSubTypeLs::HeaderSubTypeLs()
{
enum_value = UNBOUND_VALUE;
}

HeaderSubTypeLs::HeaderSubTypeLs(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

HeaderSubTypeLs::HeaderSubTypeLs(enum_type other_value)
{
enum_value = other_value;
}

HeaderSubTypeLs::HeaderSubTypeLs(const HeaderSubTypeLs& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
enum_value = other_value.enum_value;
}

HeaderSubTypeLs& HeaderSubTypeLs::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

HeaderSubTypeLs& HeaderSubTypeLs::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

HeaderSubTypeLs& HeaderSubTypeLs::operator=(const HeaderSubTypeLs& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
enum_value = other_value.enum_value;
return *this;
}

boolean HeaderSubTypeLs::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
return enum_value == other_value;
}

boolean HeaderSubTypeLs::operator==(const HeaderSubTypeLs& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
return enum_value == other_value.enum_value;
}

boolean HeaderSubTypeLs::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
return enum_value < other_value;
}

boolean HeaderSubTypeLs::operator<(const HeaderSubTypeLs& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
return enum_value < other_value.enum_value;
}

boolean HeaderSubTypeLs::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
return enum_value > other_value;
}

boolean HeaderSubTypeLs::operator>(const HeaderSubTypeLs& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
return enum_value > other_value.enum_value;
}

const char *HeaderSubTypeLs::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__lsRequest: return "e_lsRequest";
case e__lsReply: return "e_lsReply";
case e__reserved: return "e_reserved";
default: return "<unknown>";
}
}

HeaderSubTypeLs::enum_type HeaderSubTypeLs::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_lsRequest")) return e__lsRequest;
else if (!strcmp(str_par, "e_lsReply")) return e__lsReply;
else if (!strcmp(str_par, "e_reserved")) return e__reserved;
else return UNKNOWN_VALUE;
}

boolean HeaderSubTypeLs::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
return TRUE;
default:
return FALSE;
}
}

int HeaderSubTypeLs::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int HeaderSubTypeLs::enum2int(const HeaderSubTypeLs& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void HeaderSubTypeLs::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.", int_val);
enum_value = (enum_type)int_val;
}

HeaderSubTypeLs::operator HeaderSubTypeLs::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
return enum_value;
}

void HeaderSubTypeLs::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void HeaderSubTypeLs::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
  }
}

Module_Param* HeaderSubTypeLs::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void HeaderSubTypeLs::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
text_buf.push_int(enum_value);
}

void HeaderSubTypeLs::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.", enum_value);
}

void HeaderSubTypeLs::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void HeaderSubTypeLs::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int HeaderSubTypeLs::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 2, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int HeaderSubTypeLs::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 2);
}

int HeaderSubTypeLs::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int HeaderSubTypeLs::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void HeaderSubTypeLs_template::copy_template(const HeaderSubTypeLs_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new HeaderSubTypeLs_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
}
}

HeaderSubTypeLs_template::HeaderSubTypeLs_template()
{
}

HeaderSubTypeLs_template::HeaderSubTypeLs_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

HeaderSubTypeLs_template::HeaderSubTypeLs_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!HeaderSubTypeLs::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs with unknown numeric value %d.", other_value);
single_value = (HeaderSubTypeLs::enum_type)other_value;
}

HeaderSubTypeLs_template::HeaderSubTypeLs_template(HeaderSubTypeLs::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

HeaderSubTypeLs_template::HeaderSubTypeLs_template(const HeaderSubTypeLs& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == HeaderSubTypeLs::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
single_value = other_value.enum_value;
}

HeaderSubTypeLs_template::HeaderSubTypeLs_template(const OPTIONAL<HeaderSubTypeLs>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (HeaderSubTypeLs::enum_type)(const HeaderSubTypeLs&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs from an unbound optional field.");
}
}

HeaderSubTypeLs_template::HeaderSubTypeLs_template(const HeaderSubTypeLs_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

HeaderSubTypeLs_template::~HeaderSubTypeLs_template()
{
clean_up();
}

boolean HeaderSubTypeLs_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean HeaderSubTypeLs_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != HeaderSubTypeLs::UNBOUND_VALUE;
}

void HeaderSubTypeLs_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

HeaderSubTypeLs_template& HeaderSubTypeLs_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

HeaderSubTypeLs_template& HeaderSubTypeLs_template::operator=(int other_value)
{
if (!HeaderSubTypeLs::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (HeaderSubTypeLs::enum_type)other_value;
return *this;
}

HeaderSubTypeLs_template& HeaderSubTypeLs_template::operator=(HeaderSubTypeLs::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

HeaderSubTypeLs_template& HeaderSubTypeLs_template::operator=(const HeaderSubTypeLs& other_value)
{
if (other_value.enum_value == HeaderSubTypeLs::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

HeaderSubTypeLs_template& HeaderSubTypeLs_template::operator=(const OPTIONAL<HeaderSubTypeLs>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (HeaderSubTypeLs::enum_type)(const HeaderSubTypeLs&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
}
return *this;
}

HeaderSubTypeLs_template& HeaderSubTypeLs_template::operator=(const HeaderSubTypeLs_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean HeaderSubTypeLs_template::match(HeaderSubTypeLs::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
}
return FALSE;
}

boolean HeaderSubTypeLs_template::match(const HeaderSubTypeLs& other_value, boolean) const
{
if (other_value.enum_value == HeaderSubTypeLs::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs with an unbound value.");
return match(other_value.enum_value);
}

HeaderSubTypeLs::enum_type HeaderSubTypeLs_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
return single_value;
}

void HeaderSubTypeLs_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new HeaderSubTypeLs_template[list_length];
}

HeaderSubTypeLs_template& HeaderSubTypeLs_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
return value_list.list_value[list_index];
}

void HeaderSubTypeLs_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(HeaderSubTypeLs::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void HeaderSubTypeLs_template::log_match(const HeaderSubTypeLs& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void HeaderSubTypeLs_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
}
}

void HeaderSubTypeLs_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (HeaderSubTypeLs::enum_type)text_buf.pull_int().get_val();
if (!HeaderSubTypeLs::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new HeaderSubTypeLs_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
}
}

boolean HeaderSubTypeLs_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean HeaderSubTypeLs_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void HeaderSubTypeLs_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    HeaderSubTypeLs::enum_type enum_val = (enum_name != NULL) ? HeaderSubTypeLs::str_to_enum(enum_name) : HeaderSubTypeLs::UNKNOWN_VALUE;
    if (HeaderSubTypeLs::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    HeaderSubTypeLs_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    HeaderSubTypeLs::enum_type enum_val = HeaderSubTypeLs::str_to_enum(mp->get_enumerated());
    if (!HeaderSubTypeLs::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* HeaderSubTypeLs_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(HeaderSubTypeLs::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void HeaderSubTypeLs_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeLs");
}

LsHeaderType::LsHeaderType()
{
  bound_flag = FALSE;
}

LsHeaderType::LsHeaderType(const HeaderType& par_headerType,
    const HeaderSubTypeLs& par_headerSubType)
  :   field_headerType(par_headerType),
  field_headerSubType(par_headerSubType)
{
  bound_flag = TRUE;
}

LsHeaderType::LsHeaderType(const LsHeaderType& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType.");
bound_flag = TRUE;
if (other_value.headerType().is_bound()) field_headerType = other_value.headerType();
else field_headerType.clean_up();
if (other_value.headerSubType().is_bound()) field_headerSubType = other_value.headerSubType();
else field_headerSubType.clean_up();
}

void LsHeaderType::clean_up()
{
field_headerType.clean_up();
field_headerSubType.clean_up();
bound_flag = FALSE;
}

LsHeaderType& LsHeaderType::operator=(const LsHeaderType& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType.");
  bound_flag = TRUE;
  if (other_value.headerType().is_bound()) field_headerType = other_value.headerType();
  else field_headerType.clean_up();
  if (other_value.headerSubType().is_bound()) field_headerSubType = other_value.headerSubType();
  else field_headerSubType.clean_up();
}
return *this;
}

boolean LsHeaderType::operator==(const LsHeaderType& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_headerType==other_value.field_headerType
  && field_headerSubType==other_value.field_headerSubType;
}

boolean LsHeaderType::is_bound() const
{
if (bound_flag) return TRUE;
if(field_headerType.is_bound()) return TRUE;
if(field_headerSubType.is_bound()) return TRUE;
return FALSE;
}
boolean LsHeaderType::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_headerType.is_value()) return FALSE;
if(!field_headerSubType.is_value()) return FALSE;
return TRUE;
}
int LsHeaderType::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType");
  return 2;
}

void LsHeaderType::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ headerType := ");
field_headerType.log();
TTCN_Logger::log_event_str(", headerSubType := ");
field_headerSubType.log();
TTCN_Logger::log_event_str(" }");
}

void LsHeaderType::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.LsHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      headerType().set_param(param);
      return;
    } else if (strcmp("headerSubType", param_field) == 0) {
      headerSubType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.LsHeaderType'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headerType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerSubType().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.LsHeaderType: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.LsHeaderType");
  }
}

Module_Param* LsHeaderType::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.LsHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      return headerType().get_param(param_name);
    } else if (strcmp("headerSubType", param_field) == 0) {
      return headerSubType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.LsHeaderType'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_headerType = field_headerType.get_param(param_name);
  mp_field_headerType->set_id(new Module_Param_FieldName(mcopystr("headerType")));
  mp->add_elem(mp_field_headerType);
  Module_Param* mp_field_headerSubType = field_headerSubType.get_param(param_name);
  mp_field_headerSubType->set_id(new Module_Param_FieldName(mcopystr("headerSubType")));
  mp->add_elem(mp_field_headerSubType);
  return mp;
  }

void LsHeaderType::set_implicit_omit()
{
if (headerType().is_bound()) headerType().set_implicit_omit();
if (headerSubType().is_bound()) headerSubType().set_implicit_omit();
}

void LsHeaderType::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType.");
field_headerType.encode_text(text_buf);
field_headerSubType.encode_text(text_buf);
}

void LsHeaderType::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_headerType.decode_text(text_buf);
field_headerSubType.decode_text(text_buf);
}

void LsHeaderType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void LsHeaderType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int LsHeaderType::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_headerType.RAW_decode(LsHeaderType_headerType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_headerSubType.RAW_decode(LsHeaderType_headerSubType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int LsHeaderType::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LsHeaderType_headerType_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LsHeaderType_headerSubType_descr_.raw);
  encoded_length += field_headerType.RAW_encode(LsHeaderType_headerType_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_headerSubType.RAW_encode(LsHeaderType_headerSubType_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int LsHeaderType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerType");
    enc_len += field_headerType.JSON_encode(LsHeaderType_headerType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerSubType");
    enc_len += field_headerSubType.JSON_encode(LsHeaderType_headerSubType_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int LsHeaderType::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "headerType", name_len)) {
         int ret_val = field_headerType.JSON_decode(LsHeaderType_headerType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "headerSubType", name_len)) {
         int ret_val = field_headerSubType.JSON_decode(LsHeaderType_headerSubType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerSubType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_headerType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerType");
    return JSON_ERROR_FATAL;
  }
if (!field_headerSubType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerSubType");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct LsHeaderType_template::single_value_struct {
HeaderType_template field_headerType;
HeaderSubTypeLs_template field_headerSubType;
};

void LsHeaderType_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_headerType = ANY_VALUE;
single_value->field_headerSubType = ANY_VALUE;
}
}
}

void LsHeaderType_template::copy_value(const LsHeaderType& other_value)
{
single_value = new single_value_struct;
if (other_value.headerType().is_bound()) {
  single_value->field_headerType = other_value.headerType();
} else {
  single_value->field_headerType.clean_up();
}
if (other_value.headerSubType().is_bound()) {
  single_value->field_headerSubType = other_value.headerSubType();
} else {
  single_value->field_headerSubType.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void LsHeaderType_template::copy_template(const LsHeaderType_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.headerType().get_selection()) {
single_value->field_headerType = other_value.headerType();
} else {
single_value->field_headerType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.headerSubType().get_selection()) {
single_value->field_headerSubType = other_value.headerSubType();
} else {
single_value->field_headerSubType.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new LsHeaderType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType.");
break;
}
set_selection(other_value);
}

LsHeaderType_template::LsHeaderType_template()
{
}

LsHeaderType_template::LsHeaderType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

LsHeaderType_template::LsHeaderType_template(const LsHeaderType& other_value)
{
copy_value(other_value);
}

LsHeaderType_template::LsHeaderType_template(const OPTIONAL<LsHeaderType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LsHeaderType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType from an unbound optional field.");
}
}

LsHeaderType_template::LsHeaderType_template(const LsHeaderType_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

LsHeaderType_template::~LsHeaderType_template()
{
clean_up();
}

LsHeaderType_template& LsHeaderType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

LsHeaderType_template& LsHeaderType_template::operator=(const LsHeaderType& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

LsHeaderType_template& LsHeaderType_template::operator=(const OPTIONAL<LsHeaderType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LsHeaderType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType.");
}
return *this;
}

LsHeaderType_template& LsHeaderType_template::operator=(const LsHeaderType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean LsHeaderType_template::match(const LsHeaderType& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.headerType().is_bound()) return FALSE;
if(!single_value->field_headerType.match(other_value.headerType(), legacy))return FALSE;
if(!other_value.headerSubType().is_bound()) return FALSE;
if(!single_value->field_headerSubType.match(other_value.headerSubType(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType.");
}
return FALSE;
}

boolean LsHeaderType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_headerType.is_bound()) return TRUE;
if (single_value->field_headerSubType.is_bound()) return TRUE;
return FALSE;
}

boolean LsHeaderType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_headerType.is_value()) return FALSE;
if (!single_value->field_headerSubType.is_value()) return FALSE;
return TRUE;
}

void LsHeaderType_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

LsHeaderType LsHeaderType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType.");
LsHeaderType ret_val;
if (single_value->field_headerType.is_bound()) {
ret_val.headerType() = single_value->field_headerType.valueof();
}
if (single_value->field_headerSubType.is_bound()) {
ret_val.headerSubType() = single_value->field_headerSubType.valueof();
}
return ret_val;
}

void LsHeaderType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new LsHeaderType_template[list_length];
}

LsHeaderType_template& LsHeaderType_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType.");
return value_list.list_value[list_index];
}

HeaderType_template& LsHeaderType_template::headerType()
{
set_specific();
return single_value->field_headerType;
}

const HeaderType_template& LsHeaderType_template::headerType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType.");
return single_value->field_headerType;
}

HeaderSubTypeLs_template& LsHeaderType_template::headerSubType()
{
set_specific();
return single_value->field_headerSubType;
}

const HeaderSubTypeLs_template& LsHeaderType_template::headerSubType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerSubType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType.");
return single_value->field_headerSubType;
}

int LsHeaderType_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType.");
  }
  return 0;
}

void LsHeaderType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ headerType := ");
single_value->field_headerType.log();
TTCN_Logger::log_event_str(", headerSubType := ");
single_value->field_headerSubType.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void LsHeaderType_template::log_match(const LsHeaderType& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_headerType.match(match_value.headerType(), legacy)){
TTCN_Logger::log_logmatch_info(".headerType");
single_value->field_headerType.log_match(match_value.headerType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_headerSubType.match(match_value.headerSubType(), legacy)){
TTCN_Logger::log_logmatch_info(".headerSubType");
single_value->field_headerSubType.log_match(match_value.headerSubType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ headerType := ");
single_value->field_headerType.log_match(match_value.headerType(), legacy);
TTCN_Logger::log_event_str(", headerSubType := ");
single_value->field_headerSubType.log_match(match_value.headerSubType(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void LsHeaderType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_headerType.encode_text(text_buf);
single_value->field_headerSubType.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType.");
}
}

void LsHeaderType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_headerType.decode_text(text_buf);
single_value->field_headerSubType.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new LsHeaderType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType.");
}
}

void LsHeaderType_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.LsHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      headerType().set_param(param);
      return;
    } else if (strcmp("headerSubType", param_field) == 0) {
      headerSubType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.LsHeaderType'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    LsHeaderType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.LsHeaderType has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headerType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerSubType().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.LsHeaderType: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.LsHeaderType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* LsHeaderType_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.LsHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      return headerType().get_param(param_name);
    } else if (strcmp("headerSubType", param_field) == 0) {
      return headerSubType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.LsHeaderType'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_headerType = single_value->field_headerType.get_param(param_name);
    mp_field_headerType->set_id(new Module_Param_FieldName(mcopystr("headerType")));
    mp->add_elem(mp_field_headerType);
    Module_Param* mp_field_headerSubType = single_value->field_headerSubType.get_param(param_name);
    mp_field_headerSubType->set_id(new Module_Param_FieldName(mcopystr("headerSubType")));
    mp->add_elem(mp_field_headerSubType);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void LsHeaderType_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_headerType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LsHeaderType");
single_value->field_headerSubType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LsHeaderType");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LsHeaderType");
}

boolean LsHeaderType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean LsHeaderType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

HeaderSubTypeSa::HeaderSubTypeSa()
{
enum_value = UNBOUND_VALUE;
}

HeaderSubTypeSa::HeaderSubTypeSa(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

HeaderSubTypeSa::HeaderSubTypeSa(enum_type other_value)
{
enum_value = other_value;
}

HeaderSubTypeSa::HeaderSubTypeSa(const HeaderSubTypeSa& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
enum_value = other_value.enum_value;
}

HeaderSubTypeSa& HeaderSubTypeSa::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

HeaderSubTypeSa& HeaderSubTypeSa::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

HeaderSubTypeSa& HeaderSubTypeSa::operator=(const HeaderSubTypeSa& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
enum_value = other_value.enum_value;
return *this;
}

boolean HeaderSubTypeSa::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
return enum_value == other_value;
}

boolean HeaderSubTypeSa::operator==(const HeaderSubTypeSa& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
return enum_value == other_value.enum_value;
}

boolean HeaderSubTypeSa::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
return enum_value < other_value;
}

boolean HeaderSubTypeSa::operator<(const HeaderSubTypeSa& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
return enum_value < other_value.enum_value;
}

boolean HeaderSubTypeSa::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
return enum_value > other_value;
}

boolean HeaderSubTypeSa::operator>(const HeaderSubTypeSa& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
return enum_value > other_value.enum_value;
}

const char *HeaderSubTypeSa::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__sa: return "e_sa";
case e__saEos: return "e_saEos";
case e__reserved: return "e_reserved";
default: return "<unknown>";
}
}

HeaderSubTypeSa::enum_type HeaderSubTypeSa::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_sa")) return e__sa;
else if (!strcmp(str_par, "e_saEos")) return e__saEos;
else if (!strcmp(str_par, "e_reserved")) return e__reserved;
else return UNKNOWN_VALUE;
}

boolean HeaderSubTypeSa::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
return TRUE;
default:
return FALSE;
}
}

int HeaderSubTypeSa::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int HeaderSubTypeSa::enum2int(const HeaderSubTypeSa& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void HeaderSubTypeSa::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.", int_val);
enum_value = (enum_type)int_val;
}

HeaderSubTypeSa::operator HeaderSubTypeSa::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
return enum_value;
}

void HeaderSubTypeSa::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void HeaderSubTypeSa::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
  }
}

Module_Param* HeaderSubTypeSa::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void HeaderSubTypeSa::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
text_buf.push_int(enum_value);
}

void HeaderSubTypeSa::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.", enum_value);
}

void HeaderSubTypeSa::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void HeaderSubTypeSa::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int HeaderSubTypeSa::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 2, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int HeaderSubTypeSa::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 2);
}

int HeaderSubTypeSa::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int HeaderSubTypeSa::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void HeaderSubTypeSa_template::copy_template(const HeaderSubTypeSa_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new HeaderSubTypeSa_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
}
}

HeaderSubTypeSa_template::HeaderSubTypeSa_template()
{
}

HeaderSubTypeSa_template::HeaderSubTypeSa_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

HeaderSubTypeSa_template::HeaderSubTypeSa_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!HeaderSubTypeSa::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa with unknown numeric value %d.", other_value);
single_value = (HeaderSubTypeSa::enum_type)other_value;
}

HeaderSubTypeSa_template::HeaderSubTypeSa_template(HeaderSubTypeSa::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

HeaderSubTypeSa_template::HeaderSubTypeSa_template(const HeaderSubTypeSa& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == HeaderSubTypeSa::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
single_value = other_value.enum_value;
}

HeaderSubTypeSa_template::HeaderSubTypeSa_template(const OPTIONAL<HeaderSubTypeSa>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (HeaderSubTypeSa::enum_type)(const HeaderSubTypeSa&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa from an unbound optional field.");
}
}

HeaderSubTypeSa_template::HeaderSubTypeSa_template(const HeaderSubTypeSa_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

HeaderSubTypeSa_template::~HeaderSubTypeSa_template()
{
clean_up();
}

boolean HeaderSubTypeSa_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean HeaderSubTypeSa_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != HeaderSubTypeSa::UNBOUND_VALUE;
}

void HeaderSubTypeSa_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

HeaderSubTypeSa_template& HeaderSubTypeSa_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

HeaderSubTypeSa_template& HeaderSubTypeSa_template::operator=(int other_value)
{
if (!HeaderSubTypeSa::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (HeaderSubTypeSa::enum_type)other_value;
return *this;
}

HeaderSubTypeSa_template& HeaderSubTypeSa_template::operator=(HeaderSubTypeSa::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

HeaderSubTypeSa_template& HeaderSubTypeSa_template::operator=(const HeaderSubTypeSa& other_value)
{
if (other_value.enum_value == HeaderSubTypeSa::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

HeaderSubTypeSa_template& HeaderSubTypeSa_template::operator=(const OPTIONAL<HeaderSubTypeSa>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (HeaderSubTypeSa::enum_type)(const HeaderSubTypeSa&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
}
return *this;
}

HeaderSubTypeSa_template& HeaderSubTypeSa_template::operator=(const HeaderSubTypeSa_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean HeaderSubTypeSa_template::match(HeaderSubTypeSa::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
}
return FALSE;
}

boolean HeaderSubTypeSa_template::match(const HeaderSubTypeSa& other_value, boolean) const
{
if (other_value.enum_value == HeaderSubTypeSa::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa with an unbound value.");
return match(other_value.enum_value);
}

HeaderSubTypeSa::enum_type HeaderSubTypeSa_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
return single_value;
}

void HeaderSubTypeSa_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new HeaderSubTypeSa_template[list_length];
}

HeaderSubTypeSa_template& HeaderSubTypeSa_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
return value_list.list_value[list_index];
}

void HeaderSubTypeSa_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(HeaderSubTypeSa::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void HeaderSubTypeSa_template::log_match(const HeaderSubTypeSa& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void HeaderSubTypeSa_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
}
}

void HeaderSubTypeSa_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (HeaderSubTypeSa::enum_type)text_buf.pull_int().get_val();
if (!HeaderSubTypeSa::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new HeaderSubTypeSa_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
}
}

boolean HeaderSubTypeSa_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean HeaderSubTypeSa_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void HeaderSubTypeSa_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    HeaderSubTypeSa::enum_type enum_val = (enum_name != NULL) ? HeaderSubTypeSa::str_to_enum(enum_name) : HeaderSubTypeSa::UNKNOWN_VALUE;
    if (HeaderSubTypeSa::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    HeaderSubTypeSa_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    HeaderSubTypeSa::enum_type enum_val = HeaderSubTypeSa::str_to_enum(mp->get_enumerated());
    if (!HeaderSubTypeSa::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* HeaderSubTypeSa_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(HeaderSubTypeSa::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void HeaderSubTypeSa_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.HeaderSubTypeSa");
}

SaHeaderType::SaHeaderType()
{
  bound_flag = FALSE;
}

SaHeaderType::SaHeaderType(const HeaderType& par_headerType,
    const HeaderSubTypeSa& par_headerSubType)
  :   field_headerType(par_headerType),
  field_headerSubType(par_headerSubType)
{
  bound_flag = TRUE;
}

SaHeaderType::SaHeaderType(const SaHeaderType& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType.");
bound_flag = TRUE;
if (other_value.headerType().is_bound()) field_headerType = other_value.headerType();
else field_headerType.clean_up();
if (other_value.headerSubType().is_bound()) field_headerSubType = other_value.headerSubType();
else field_headerSubType.clean_up();
}

void SaHeaderType::clean_up()
{
field_headerType.clean_up();
field_headerSubType.clean_up();
bound_flag = FALSE;
}

SaHeaderType& SaHeaderType::operator=(const SaHeaderType& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType.");
  bound_flag = TRUE;
  if (other_value.headerType().is_bound()) field_headerType = other_value.headerType();
  else field_headerType.clean_up();
  if (other_value.headerSubType().is_bound()) field_headerSubType = other_value.headerSubType();
  else field_headerSubType.clean_up();
}
return *this;
}

boolean SaHeaderType::operator==(const SaHeaderType& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_headerType==other_value.field_headerType
  && field_headerSubType==other_value.field_headerSubType;
}

boolean SaHeaderType::is_bound() const
{
if (bound_flag) return TRUE;
if(field_headerType.is_bound()) return TRUE;
if(field_headerSubType.is_bound()) return TRUE;
return FALSE;
}
boolean SaHeaderType::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_headerType.is_value()) return FALSE;
if(!field_headerSubType.is_value()) return FALSE;
return TRUE;
}
int SaHeaderType::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType");
  return 2;
}

void SaHeaderType::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ headerType := ");
field_headerType.log();
TTCN_Logger::log_event_str(", headerSubType := ");
field_headerSubType.log();
TTCN_Logger::log_event_str(" }");
}

void SaHeaderType::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.SaHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      headerType().set_param(param);
      return;
    } else if (strcmp("headerSubType", param_field) == 0) {
      headerSubType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.SaHeaderType'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headerType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerSubType().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.SaHeaderType: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.SaHeaderType");
  }
}

Module_Param* SaHeaderType::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.SaHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      return headerType().get_param(param_name);
    } else if (strcmp("headerSubType", param_field) == 0) {
      return headerSubType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.SaHeaderType'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_headerType = field_headerType.get_param(param_name);
  mp_field_headerType->set_id(new Module_Param_FieldName(mcopystr("headerType")));
  mp->add_elem(mp_field_headerType);
  Module_Param* mp_field_headerSubType = field_headerSubType.get_param(param_name);
  mp_field_headerSubType->set_id(new Module_Param_FieldName(mcopystr("headerSubType")));
  mp->add_elem(mp_field_headerSubType);
  return mp;
  }

void SaHeaderType::set_implicit_omit()
{
if (headerType().is_bound()) headerType().set_implicit_omit();
if (headerSubType().is_bound()) headerSubType().set_implicit_omit();
}

void SaHeaderType::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType.");
field_headerType.encode_text(text_buf);
field_headerSubType.encode_text(text_buf);
}

void SaHeaderType::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_headerType.decode_text(text_buf);
field_headerSubType.decode_text(text_buf);
}

void SaHeaderType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SaHeaderType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SaHeaderType::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_headerType.RAW_decode(SaHeaderType_headerType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_headerSubType.RAW_decode(SaHeaderType_headerSubType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int SaHeaderType::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, SaHeaderType_headerType_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, SaHeaderType_headerSubType_descr_.raw);
  encoded_length += field_headerType.RAW_encode(SaHeaderType_headerType_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_headerSubType.RAW_encode(SaHeaderType_headerSubType_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int SaHeaderType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerType");
    enc_len += field_headerType.JSON_encode(SaHeaderType_headerType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerSubType");
    enc_len += field_headerSubType.JSON_encode(SaHeaderType_headerSubType_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SaHeaderType::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "headerType", name_len)) {
         int ret_val = field_headerType.JSON_decode(SaHeaderType_headerType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "headerSubType", name_len)) {
         int ret_val = field_headerSubType.JSON_decode(SaHeaderType_headerSubType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerSubType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_headerType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerType");
    return JSON_ERROR_FATAL;
  }
if (!field_headerSubType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerSubType");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct SaHeaderType_template::single_value_struct {
HeaderType_template field_headerType;
HeaderSubTypeSa_template field_headerSubType;
};

void SaHeaderType_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_headerType = ANY_VALUE;
single_value->field_headerSubType = ANY_VALUE;
}
}
}

void SaHeaderType_template::copy_value(const SaHeaderType& other_value)
{
single_value = new single_value_struct;
if (other_value.headerType().is_bound()) {
  single_value->field_headerType = other_value.headerType();
} else {
  single_value->field_headerType.clean_up();
}
if (other_value.headerSubType().is_bound()) {
  single_value->field_headerSubType = other_value.headerSubType();
} else {
  single_value->field_headerSubType.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SaHeaderType_template::copy_template(const SaHeaderType_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.headerType().get_selection()) {
single_value->field_headerType = other_value.headerType();
} else {
single_value->field_headerType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.headerSubType().get_selection()) {
single_value->field_headerSubType = other_value.headerSubType();
} else {
single_value->field_headerSubType.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SaHeaderType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType.");
break;
}
set_selection(other_value);
}

SaHeaderType_template::SaHeaderType_template()
{
}

SaHeaderType_template::SaHeaderType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SaHeaderType_template::SaHeaderType_template(const SaHeaderType& other_value)
{
copy_value(other_value);
}

SaHeaderType_template::SaHeaderType_template(const OPTIONAL<SaHeaderType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SaHeaderType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType from an unbound optional field.");
}
}

SaHeaderType_template::SaHeaderType_template(const SaHeaderType_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SaHeaderType_template::~SaHeaderType_template()
{
clean_up();
}

SaHeaderType_template& SaHeaderType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SaHeaderType_template& SaHeaderType_template::operator=(const SaHeaderType& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SaHeaderType_template& SaHeaderType_template::operator=(const OPTIONAL<SaHeaderType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SaHeaderType&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType.");
}
return *this;
}

SaHeaderType_template& SaHeaderType_template::operator=(const SaHeaderType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SaHeaderType_template::match(const SaHeaderType& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.headerType().is_bound()) return FALSE;
if(!single_value->field_headerType.match(other_value.headerType(), legacy))return FALSE;
if(!other_value.headerSubType().is_bound()) return FALSE;
if(!single_value->field_headerSubType.match(other_value.headerSubType(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType.");
}
return FALSE;
}

boolean SaHeaderType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_headerType.is_bound()) return TRUE;
if (single_value->field_headerSubType.is_bound()) return TRUE;
return FALSE;
}

boolean SaHeaderType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_headerType.is_value()) return FALSE;
if (!single_value->field_headerSubType.is_value()) return FALSE;
return TRUE;
}

void SaHeaderType_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SaHeaderType SaHeaderType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType.");
SaHeaderType ret_val;
if (single_value->field_headerType.is_bound()) {
ret_val.headerType() = single_value->field_headerType.valueof();
}
if (single_value->field_headerSubType.is_bound()) {
ret_val.headerSubType() = single_value->field_headerSubType.valueof();
}
return ret_val;
}

void SaHeaderType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SaHeaderType_template[list_length];
}

SaHeaderType_template& SaHeaderType_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType.");
return value_list.list_value[list_index];
}

HeaderType_template& SaHeaderType_template::headerType()
{
set_specific();
return single_value->field_headerType;
}

const HeaderType_template& SaHeaderType_template::headerType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType.");
return single_value->field_headerType;
}

HeaderSubTypeSa_template& SaHeaderType_template::headerSubType()
{
set_specific();
return single_value->field_headerSubType;
}

const HeaderSubTypeSa_template& SaHeaderType_template::headerSubType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerSubType of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType.");
return single_value->field_headerSubType;
}

int SaHeaderType_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType.");
  }
  return 0;
}

void SaHeaderType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ headerType := ");
single_value->field_headerType.log();
TTCN_Logger::log_event_str(", headerSubType := ");
single_value->field_headerSubType.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SaHeaderType_template::log_match(const SaHeaderType& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_headerType.match(match_value.headerType(), legacy)){
TTCN_Logger::log_logmatch_info(".headerType");
single_value->field_headerType.log_match(match_value.headerType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_headerSubType.match(match_value.headerSubType(), legacy)){
TTCN_Logger::log_logmatch_info(".headerSubType");
single_value->field_headerSubType.log_match(match_value.headerSubType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ headerType := ");
single_value->field_headerType.log_match(match_value.headerType(), legacy);
TTCN_Logger::log_event_str(", headerSubType := ");
single_value->field_headerSubType.log_match(match_value.headerSubType(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SaHeaderType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_headerType.encode_text(text_buf);
single_value->field_headerSubType.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType.");
}
}

void SaHeaderType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_headerType.decode_text(text_buf);
single_value->field_headerSubType.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SaHeaderType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType.");
}
}

void SaHeaderType_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.SaHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      headerType().set_param(param);
      return;
    } else if (strcmp("headerSubType", param_field) == 0) {
      headerSubType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.SaHeaderType'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SaHeaderType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.SaHeaderType has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) headerType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerSubType().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerSubType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerSubType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.SaHeaderType: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.SaHeaderType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SaHeaderType_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.SaHeaderType'");
    }
    if (strcmp("headerType", param_field) == 0) {
      return headerType().get_param(param_name);
    } else if (strcmp("headerSubType", param_field) == 0) {
      return headerSubType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.SaHeaderType'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_headerType = single_value->field_headerType.get_param(param_name);
    mp_field_headerType->set_id(new Module_Param_FieldName(mcopystr("headerType")));
    mp->add_elem(mp_field_headerType);
    Module_Param* mp_field_headerSubType = single_value->field_headerSubType.get_param(param_name);
    mp_field_headerSubType->set_id(new Module_Param_FieldName(mcopystr("headerSubType")));
    mp->add_elem(mp_field_headerSubType);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SaHeaderType_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_headerType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.SaHeaderType");
single_value->field_headerSubType.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.SaHeaderType");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.SaHeaderType");
}

boolean SaHeaderType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SaHeaderType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SCF::SCF()
{
enum_value = UNBOUND_VALUE;
}

SCF::SCF(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

SCF::SCF(enum_type other_value)
{
enum_value = other_value;
}

SCF::SCF(const SCF& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
enum_value = other_value.enum_value;
}

SCF& SCF::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

SCF& SCF::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

SCF& SCF::operator=(const SCF& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
enum_value = other_value.enum_value;
return *this;
}

boolean SCF::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
return enum_value == other_value;
}

boolean SCF::operator==(const SCF& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
return enum_value == other_value.enum_value;
}

boolean SCF::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
return enum_value < other_value;
}

boolean SCF::operator<(const SCF& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
return enum_value < other_value.enum_value;
}

boolean SCF::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
return enum_value > other_value;
}

boolean SCF::operator>(const SCF& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
return enum_value > other_value.enum_value;
}

const char *SCF::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__scfDisabled: return "e_scfDisabled";
case e__scfEnable: return "e_scfEnable";
default: return "<unknown>";
}
}

SCF::enum_type SCF::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_scfDisabled")) return e__scfDisabled;
else if (!strcmp(str_par, "e_scfEnable")) return e__scfEnable;
else return UNKNOWN_VALUE;
}

boolean SCF::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
return TRUE;
default:
return FALSE;
}
}

int SCF::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int SCF::enum2int(const SCF& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void SCF::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.", int_val);
enum_value = (enum_type)int_val;
}

SCF::operator SCF::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
return enum_value;
}

void SCF::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void SCF::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsGeoNetworking_TypesAndValues.SCF");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.SCF.");
  }
}

Module_Param* SCF::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void SCF::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
text_buf.push_int(enum_value);
}

void SCF::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.", enum_value);
}

void SCF::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SCF::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SCF::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 2, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int SCF::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 2);
}

int SCF::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int SCF::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void SCF_template::copy_template(const SCF_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SCF_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
}
}

SCF_template::SCF_template()
{
}

SCF_template::SCF_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SCF_template::SCF_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!SCF::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF with unknown numeric value %d.", other_value);
single_value = (SCF::enum_type)other_value;
}

SCF_template::SCF_template(SCF::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

SCF_template::SCF_template(const SCF& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == SCF::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
single_value = other_value.enum_value;
}

SCF_template::SCF_template(const OPTIONAL<SCF>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SCF::enum_type)(const SCF&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF from an unbound optional field.");
}
}

SCF_template::SCF_template(const SCF_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

SCF_template::~SCF_template()
{
clean_up();
}

boolean SCF_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean SCF_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != SCF::UNBOUND_VALUE;
}

void SCF_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

SCF_template& SCF_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SCF_template& SCF_template::operator=(int other_value)
{
if (!SCF::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (SCF::enum_type)other_value;
return *this;
}

SCF_template& SCF_template::operator=(SCF::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

SCF_template& SCF_template::operator=(const SCF& other_value)
{
if (other_value.enum_value == SCF::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

SCF_template& SCF_template::operator=(const OPTIONAL<SCF>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SCF::enum_type)(const SCF&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
}
return *this;
}

SCF_template& SCF_template::operator=(const SCF_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SCF_template::match(SCF::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
}
return FALSE;
}

boolean SCF_template::match(const SCF& other_value, boolean) const
{
if (other_value.enum_value == SCF::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF with an unbound value.");
return match(other_value.enum_value);
}

SCF::enum_type SCF_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
return single_value;
}

void SCF_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SCF_template[list_length];
}

SCF_template& SCF_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
return value_list.list_value[list_index];
}

void SCF_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(SCF::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SCF_template::log_match(const SCF& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void SCF_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
}
}

void SCF_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (SCF::enum_type)text_buf.pull_int().get_val();
if (!SCF::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SCF_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.SCF.");
}
}

boolean SCF_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SCF_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SCF_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    SCF::enum_type enum_val = (enum_name != NULL) ? SCF::str_to_enum(enum_name) : SCF::UNKNOWN_VALUE;
    if (SCF::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SCF_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    SCF::enum_type enum_val = SCF::str_to_enum(mp->get_enumerated());
    if (!SCF::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.SCF.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsGeoNetworking_TypesAndValues.SCF");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SCF_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(SCF::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SCF_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.SCF");
}

ChannelOffload::ChannelOffload()
{
enum_value = UNBOUND_VALUE;
}

ChannelOffload::ChannelOffload(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

ChannelOffload::ChannelOffload(enum_type other_value)
{
enum_value = other_value;
}

ChannelOffload::ChannelOffload(const ChannelOffload& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
enum_value = other_value.enum_value;
}

ChannelOffload& ChannelOffload::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

ChannelOffload& ChannelOffload::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

ChannelOffload& ChannelOffload::operator=(const ChannelOffload& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
enum_value = other_value.enum_value;
return *this;
}

boolean ChannelOffload::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
return enum_value == other_value;
}

boolean ChannelOffload::operator==(const ChannelOffload& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
return enum_value == other_value.enum_value;
}

boolean ChannelOffload::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
return enum_value < other_value;
}

boolean ChannelOffload::operator<(const ChannelOffload& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
return enum_value < other_value.enum_value;
}

boolean ChannelOffload::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
return enum_value > other_value;
}

boolean ChannelOffload::operator>(const ChannelOffload& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
return enum_value > other_value.enum_value;
}

const char *ChannelOffload::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__choffDisabled: return "e_choffDisabled";
case e__choffEnable: return "e_choffEnable";
default: return "<unknown>";
}
}

ChannelOffload::enum_type ChannelOffload::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_choffDisabled")) return e__choffDisabled;
else if (!strcmp(str_par, "e_choffEnable")) return e__choffEnable;
else return UNKNOWN_VALUE;
}

boolean ChannelOffload::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
return TRUE;
default:
return FALSE;
}
}

int ChannelOffload::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int ChannelOffload::enum2int(const ChannelOffload& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void ChannelOffload::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.", int_val);
enum_value = (enum_type)int_val;
}

ChannelOffload::operator ChannelOffload::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
return enum_value;
}

void ChannelOffload::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void ChannelOffload::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsGeoNetworking_TypesAndValues.ChannelOffload");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
  }
}

Module_Param* ChannelOffload::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void ChannelOffload::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
text_buf.push_int(enum_value);
}

void ChannelOffload::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.", enum_value);
}

void ChannelOffload::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ChannelOffload::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ChannelOffload::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 2, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int ChannelOffload::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 2);
}

int ChannelOffload::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int ChannelOffload::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void ChannelOffload_template::copy_template(const ChannelOffload_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ChannelOffload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
}
}

ChannelOffload_template::ChannelOffload_template()
{
}

ChannelOffload_template::ChannelOffload_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ChannelOffload_template::ChannelOffload_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!ChannelOffload::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload with unknown numeric value %d.", other_value);
single_value = (ChannelOffload::enum_type)other_value;
}

ChannelOffload_template::ChannelOffload_template(ChannelOffload::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

ChannelOffload_template::ChannelOffload_template(const ChannelOffload& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == ChannelOffload::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
single_value = other_value.enum_value;
}

ChannelOffload_template::ChannelOffload_template(const OPTIONAL<ChannelOffload>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (ChannelOffload::enum_type)(const ChannelOffload&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload from an unbound optional field.");
}
}

ChannelOffload_template::ChannelOffload_template(const ChannelOffload_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

ChannelOffload_template::~ChannelOffload_template()
{
clean_up();
}

boolean ChannelOffload_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean ChannelOffload_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != ChannelOffload::UNBOUND_VALUE;
}

void ChannelOffload_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

ChannelOffload_template& ChannelOffload_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ChannelOffload_template& ChannelOffload_template::operator=(int other_value)
{
if (!ChannelOffload::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (ChannelOffload::enum_type)other_value;
return *this;
}

ChannelOffload_template& ChannelOffload_template::operator=(ChannelOffload::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

ChannelOffload_template& ChannelOffload_template::operator=(const ChannelOffload& other_value)
{
if (other_value.enum_value == ChannelOffload::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

ChannelOffload_template& ChannelOffload_template::operator=(const OPTIONAL<ChannelOffload>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (ChannelOffload::enum_type)(const ChannelOffload&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
}
return *this;
}

ChannelOffload_template& ChannelOffload_template::operator=(const ChannelOffload_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ChannelOffload_template::match(ChannelOffload::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
}
return FALSE;
}

boolean ChannelOffload_template::match(const ChannelOffload& other_value, boolean) const
{
if (other_value.enum_value == ChannelOffload::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload with an unbound value.");
return match(other_value.enum_value);
}

ChannelOffload::enum_type ChannelOffload_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
return single_value;
}

void ChannelOffload_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ChannelOffload_template[list_length];
}

ChannelOffload_template& ChannelOffload_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
return value_list.list_value[list_index];
}

void ChannelOffload_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(ChannelOffload::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ChannelOffload_template::log_match(const ChannelOffload& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void ChannelOffload_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
}
}

void ChannelOffload_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (ChannelOffload::enum_type)text_buf.pull_int().get_val();
if (!ChannelOffload::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ChannelOffload_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
}
}

boolean ChannelOffload_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ChannelOffload_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ChannelOffload_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    ChannelOffload::enum_type enum_val = (enum_name != NULL) ? ChannelOffload::str_to_enum(enum_name) : ChannelOffload::UNKNOWN_VALUE;
    if (ChannelOffload::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ChannelOffload_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    ChannelOffload::enum_type enum_val = ChannelOffload::str_to_enum(mp->get_enumerated());
    if (!ChannelOffload::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.ChannelOffload.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsGeoNetworking_TypesAndValues.ChannelOffload");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ChannelOffload_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(ChannelOffload::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ChannelOffload_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.ChannelOffload");
}

TrafficClass::TrafficClass()
{
  bound_flag = FALSE;
}

TrafficClass::TrafficClass(const SCF& par_scf,
    const ChannelOffload& par_channelOffload,
    const INTEGER& par_tcId)
  :   field_scf(par_scf),
  field_channelOffload(par_channelOffload),
  field_tcId(par_tcId)
{
  bound_flag = TRUE;
}

TrafficClass::TrafficClass(const TrafficClass& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.TrafficClass.");
bound_flag = TRUE;
if (other_value.scf().is_bound()) field_scf = other_value.scf();
else field_scf.clean_up();
if (other_value.channelOffload().is_bound()) field_channelOffload = other_value.channelOffload();
else field_channelOffload.clean_up();
if (other_value.tcId().is_bound()) field_tcId = other_value.tcId();
else field_tcId.clean_up();
}

void TrafficClass::clean_up()
{
field_scf.clean_up();
field_channelOffload.clean_up();
field_tcId.clean_up();
bound_flag = FALSE;
}

TrafficClass& TrafficClass::operator=(const TrafficClass& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.TrafficClass.");
  bound_flag = TRUE;
  if (other_value.scf().is_bound()) field_scf = other_value.scf();
  else field_scf.clean_up();
  if (other_value.channelOffload().is_bound()) field_channelOffload = other_value.channelOffload();
  else field_channelOffload.clean_up();
  if (other_value.tcId().is_bound()) field_tcId = other_value.tcId();
  else field_tcId.clean_up();
}
return *this;
}

boolean TrafficClass::operator==(const TrafficClass& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_scf==other_value.field_scf
  && field_channelOffload==other_value.field_channelOffload
  && field_tcId==other_value.field_tcId;
}

boolean TrafficClass::is_bound() const
{
if (bound_flag) return TRUE;
if(field_scf.is_bound()) return TRUE;
if(field_channelOffload.is_bound()) return TRUE;
if(field_tcId.is_bound()) return TRUE;
return FALSE;
}
boolean TrafficClass::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_scf.is_value()) return FALSE;
if(!field_channelOffload.is_value()) return FALSE;
if(!field_tcId.is_value()) return FALSE;
return TRUE;
}
int TrafficClass::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.TrafficClass");
  return 3;
}

void TrafficClass::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ scf := ");
field_scf.log();
TTCN_Logger::log_event_str(", channelOffload := ");
field_channelOffload.log();
TTCN_Logger::log_event_str(", tcId := ");
field_tcId.log();
TTCN_Logger::log_event_str(" }");
}

void TrafficClass::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.TrafficClass'");
    }
    if (strcmp("scf", param_field) == 0) {
      scf().set_param(param);
      return;
    } else if (strcmp("channelOffload", param_field) == 0) {
      channelOffload().set_param(param);
      return;
    } else if (strcmp("tcId", param_field) == 0) {
      tcId().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.TrafficClass'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.TrafficClass has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) scf().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) channelOffload().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) tcId().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "scf")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          scf().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "channelOffload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          channelOffload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tcId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tcId().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.TrafficClass: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.TrafficClass");
  }
}

Module_Param* TrafficClass::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.TrafficClass'");
    }
    if (strcmp("scf", param_field) == 0) {
      return scf().get_param(param_name);
    } else if (strcmp("channelOffload", param_field) == 0) {
      return channelOffload().get_param(param_name);
    } else if (strcmp("tcId", param_field) == 0) {
      return tcId().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.TrafficClass'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_scf = field_scf.get_param(param_name);
  mp_field_scf->set_id(new Module_Param_FieldName(mcopystr("scf")));
  mp->add_elem(mp_field_scf);
  Module_Param* mp_field_channelOffload = field_channelOffload.get_param(param_name);
  mp_field_channelOffload->set_id(new Module_Param_FieldName(mcopystr("channelOffload")));
  mp->add_elem(mp_field_channelOffload);
  Module_Param* mp_field_tcId = field_tcId.get_param(param_name);
  mp_field_tcId->set_id(new Module_Param_FieldName(mcopystr("tcId")));
  mp->add_elem(mp_field_tcId);
  return mp;
  }

void TrafficClass::set_implicit_omit()
{
if (scf().is_bound()) scf().set_implicit_omit();
if (channelOffload().is_bound()) channelOffload().set_implicit_omit();
if (tcId().is_bound()) tcId().set_implicit_omit();
}

void TrafficClass::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.TrafficClass.");
field_scf.encode_text(text_buf);
field_channelOffload.encode_text(text_buf);
field_tcId.encode_text(text_buf);
}

void TrafficClass::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_scf.decode_text(text_buf);
field_channelOffload.decode_text(text_buf);
field_tcId.decode_text(text_buf);
}

void TrafficClass::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void TrafficClass::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int TrafficClass::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_scf.RAW_decode(SCF_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_channelOffload.RAW_decode(ChannelOffload_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_tcId.RAW_decode(TcId_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int TrafficClass::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, SCF_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, ChannelOffload_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, TcId_descr_.raw);
  encoded_length += field_scf.RAW_encode(SCF_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_channelOffload.RAW_encode(ChannelOffload_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_tcId.RAW_encode(TcId_descr_, *myleaf.body.node.nodes[2]);
  return myleaf.length = encoded_length;
}

int TrafficClass::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.TrafficClass.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "scf");
    enc_len += field_scf.JSON_encode(SCF_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "channelOffload");
    enc_len += field_channelOffload.JSON_encode(ChannelOffload_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "tcId");
    enc_len += field_tcId.JSON_encode(TcId_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int TrafficClass::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (3 == name_len && 0 == strncmp(fld_name, "scf", name_len)) {
         int ret_val = field_scf.JSON_decode(SCF_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "scf");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "channelOffload", name_len)) {
         int ret_val = field_channelOffload.JSON_decode(ChannelOffload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "channelOffload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (4 == name_len && 0 == strncmp(fld_name, "tcId", name_len)) {
         int ret_val = field_tcId.JSON_decode(TcId_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "tcId");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_scf.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "scf");
    return JSON_ERROR_FATAL;
  }
if (!field_channelOffload.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "channelOffload");
    return JSON_ERROR_FATAL;
  }
if (!field_tcId.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "tcId");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct TrafficClass_template::single_value_struct {
SCF_template field_scf;
ChannelOffload_template field_channelOffload;
INTEGER_template field_tcId;
};

void TrafficClass_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_scf = ANY_VALUE;
single_value->field_channelOffload = ANY_VALUE;
single_value->field_tcId = ANY_VALUE;
}
}
}

void TrafficClass_template::copy_value(const TrafficClass& other_value)
{
single_value = new single_value_struct;
if (other_value.scf().is_bound()) {
  single_value->field_scf = other_value.scf();
} else {
  single_value->field_scf.clean_up();
}
if (other_value.channelOffload().is_bound()) {
  single_value->field_channelOffload = other_value.channelOffload();
} else {
  single_value->field_channelOffload.clean_up();
}
if (other_value.tcId().is_bound()) {
  single_value->field_tcId = other_value.tcId();
} else {
  single_value->field_tcId.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void TrafficClass_template::copy_template(const TrafficClass_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.scf().get_selection()) {
single_value->field_scf = other_value.scf();
} else {
single_value->field_scf.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.channelOffload().get_selection()) {
single_value->field_channelOffload = other_value.channelOffload();
} else {
single_value->field_channelOffload.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.tcId().get_selection()) {
single_value->field_tcId = other_value.tcId();
} else {
single_value->field_tcId.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TrafficClass_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass.");
break;
}
set_selection(other_value);
}

TrafficClass_template::TrafficClass_template()
{
}

TrafficClass_template::TrafficClass_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

TrafficClass_template::TrafficClass_template(const TrafficClass& other_value)
{
copy_value(other_value);
}

TrafficClass_template::TrafficClass_template(const OPTIONAL<TrafficClass>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TrafficClass&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass from an unbound optional field.");
}
}

TrafficClass_template::TrafficClass_template(const TrafficClass_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

TrafficClass_template::~TrafficClass_template()
{
clean_up();
}

TrafficClass_template& TrafficClass_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TrafficClass_template& TrafficClass_template::operator=(const TrafficClass& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

TrafficClass_template& TrafficClass_template::operator=(const OPTIONAL<TrafficClass>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TrafficClass&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass.");
}
return *this;
}

TrafficClass_template& TrafficClass_template::operator=(const TrafficClass_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean TrafficClass_template::match(const TrafficClass& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.scf().is_bound()) return FALSE;
if(!single_value->field_scf.match(other_value.scf(), legacy))return FALSE;
if(!other_value.channelOffload().is_bound()) return FALSE;
if(!single_value->field_channelOffload.match(other_value.channelOffload(), legacy))return FALSE;
if(!other_value.tcId().is_bound()) return FALSE;
if(!single_value->field_tcId.match(other_value.tcId(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass.");
}
return FALSE;
}

boolean TrafficClass_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_scf.is_bound()) return TRUE;
if (single_value->field_channelOffload.is_bound()) return TRUE;
if (single_value->field_tcId.is_bound()) return TRUE;
return FALSE;
}

boolean TrafficClass_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_scf.is_value()) return FALSE;
if (!single_value->field_channelOffload.is_value()) return FALSE;
if (!single_value->field_tcId.is_value()) return FALSE;
return TRUE;
}

void TrafficClass_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

TrafficClass TrafficClass_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass.");
TrafficClass ret_val;
if (single_value->field_scf.is_bound()) {
ret_val.scf() = single_value->field_scf.valueof();
}
if (single_value->field_channelOffload.is_bound()) {
ret_val.channelOffload() = single_value->field_channelOffload.valueof();
}
if (single_value->field_tcId.is_bound()) {
ret_val.tcId() = single_value->field_tcId.valueof();
}
return ret_val;
}

void TrafficClass_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new TrafficClass_template[list_length];
}

TrafficClass_template& TrafficClass_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass.");
return value_list.list_value[list_index];
}

SCF_template& TrafficClass_template::scf()
{
set_specific();
return single_value->field_scf;
}

const SCF_template& TrafficClass_template::scf() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field scf of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass.");
return single_value->field_scf;
}

ChannelOffload_template& TrafficClass_template::channelOffload()
{
set_specific();
return single_value->field_channelOffload;
}

const ChannelOffload_template& TrafficClass_template::channelOffload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field channelOffload of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass.");
return single_value->field_channelOffload;
}

INTEGER_template& TrafficClass_template::tcId()
{
set_specific();
return single_value->field_tcId;
}

const INTEGER_template& TrafficClass_template::tcId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field tcId of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass.");
return single_value->field_tcId;
}

int TrafficClass_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass.");
  }
  return 0;
}

void TrafficClass_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ scf := ");
single_value->field_scf.log();
TTCN_Logger::log_event_str(", channelOffload := ");
single_value->field_channelOffload.log();
TTCN_Logger::log_event_str(", tcId := ");
single_value->field_tcId.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void TrafficClass_template::log_match(const TrafficClass& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_scf.match(match_value.scf(), legacy)){
TTCN_Logger::log_logmatch_info(".scf");
single_value->field_scf.log_match(match_value.scf(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_channelOffload.match(match_value.channelOffload(), legacy)){
TTCN_Logger::log_logmatch_info(".channelOffload");
single_value->field_channelOffload.log_match(match_value.channelOffload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_tcId.match(match_value.tcId(), legacy)){
TTCN_Logger::log_logmatch_info(".tcId");
single_value->field_tcId.log_match(match_value.tcId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ scf := ");
single_value->field_scf.log_match(match_value.scf(), legacy);
TTCN_Logger::log_event_str(", channelOffload := ");
single_value->field_channelOffload.log_match(match_value.channelOffload(), legacy);
TTCN_Logger::log_event_str(", tcId := ");
single_value->field_tcId.log_match(match_value.tcId(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void TrafficClass_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_scf.encode_text(text_buf);
single_value->field_channelOffload.encode_text(text_buf);
single_value->field_tcId.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass.");
}
}

void TrafficClass_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_scf.decode_text(text_buf);
single_value->field_channelOffload.decode_text(text_buf);
single_value->field_tcId.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TrafficClass_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass.");
}
}

void TrafficClass_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.TrafficClass'");
    }
    if (strcmp("scf", param_field) == 0) {
      scf().set_param(param);
      return;
    } else if (strcmp("channelOffload", param_field) == 0) {
      channelOffload().set_param(param);
      return;
    } else if (strcmp("tcId", param_field) == 0) {
      tcId().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.TrafficClass'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TrafficClass_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.TrafficClass has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) scf().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) channelOffload().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) tcId().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "scf")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          scf().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "channelOffload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          channelOffload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "tcId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          tcId().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.TrafficClass: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.TrafficClass");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* TrafficClass_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.TrafficClass'");
    }
    if (strcmp("scf", param_field) == 0) {
      return scf().get_param(param_name);
    } else if (strcmp("channelOffload", param_field) == 0) {
      return channelOffload().get_param(param_name);
    } else if (strcmp("tcId", param_field) == 0) {
      return tcId().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.TrafficClass'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_scf = single_value->field_scf.get_param(param_name);
    mp_field_scf->set_id(new Module_Param_FieldName(mcopystr("scf")));
    mp->add_elem(mp_field_scf);
    Module_Param* mp_field_channelOffload = single_value->field_channelOffload.get_param(param_name);
    mp_field_channelOffload->set_id(new Module_Param_FieldName(mcopystr("channelOffload")));
    mp->add_elem(mp_field_channelOffload);
    Module_Param* mp_field_tcId = single_value->field_tcId.get_param(param_name);
    mp_field_tcId->set_id(new Module_Param_FieldName(mcopystr("tcId")));
    mp->add_elem(mp_field_tcId);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void TrafficClass_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_scf.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.TrafficClass");
single_value->field_channelOffload.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.TrafficClass");
single_value->field_tcId.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.TrafficClass");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.TrafficClass");
}

boolean TrafficClass_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TrafficClass_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

CommonHeader::CommonHeader()
{
  bound_flag = FALSE;
}

CommonHeader::CommonHeader(const NextHeader& par_nextHeader,
    const INTEGER& par_reserved,
    const HeaderTST& par_headerTST,
    const TrafficClass& par_trafficClass,
    const BITSTRING& par_flags,
    const INTEGER& par_plLength,
    const INTEGER& par_maxHopLimit,
    const INTEGER& par_reserved2)
  :   field_nextHeader(par_nextHeader),
  field_reserved(par_reserved),
  field_headerTST(par_headerTST),
  field_trafficClass(par_trafficClass),
  field_flags(par_flags),
  field_plLength(par_plLength),
  field_maxHopLimit(par_maxHopLimit),
  field_reserved2(par_reserved2)
{
  bound_flag = TRUE;
}

CommonHeader::CommonHeader(const CommonHeader& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
bound_flag = TRUE;
if (other_value.nextHeader().is_bound()) field_nextHeader = other_value.nextHeader();
else field_nextHeader.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
if (other_value.headerTST().is_bound()) field_headerTST = other_value.headerTST();
else field_headerTST.clean_up();
if (other_value.trafficClass().is_bound()) field_trafficClass = other_value.trafficClass();
else field_trafficClass.clean_up();
if (other_value.flags().is_bound()) field_flags = other_value.flags();
else field_flags.clean_up();
if (other_value.plLength().is_bound()) field_plLength = other_value.plLength();
else field_plLength.clean_up();
if (other_value.maxHopLimit().is_bound()) field_maxHopLimit = other_value.maxHopLimit();
else field_maxHopLimit.clean_up();
if (other_value.reserved2().is_bound()) field_reserved2 = other_value.reserved2();
else field_reserved2.clean_up();
}

void CommonHeader::clean_up()
{
field_nextHeader.clean_up();
field_reserved.clean_up();
field_headerTST.clean_up();
field_trafficClass.clean_up();
field_flags.clean_up();
field_plLength.clean_up();
field_maxHopLimit.clean_up();
field_reserved2.clean_up();
bound_flag = FALSE;
}

CommonHeader& CommonHeader::operator=(const CommonHeader& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
  bound_flag = TRUE;
  if (other_value.nextHeader().is_bound()) field_nextHeader = other_value.nextHeader();
  else field_nextHeader.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
  if (other_value.headerTST().is_bound()) field_headerTST = other_value.headerTST();
  else field_headerTST.clean_up();
  if (other_value.trafficClass().is_bound()) field_trafficClass = other_value.trafficClass();
  else field_trafficClass.clean_up();
  if (other_value.flags().is_bound()) field_flags = other_value.flags();
  else field_flags.clean_up();
  if (other_value.plLength().is_bound()) field_plLength = other_value.plLength();
  else field_plLength.clean_up();
  if (other_value.maxHopLimit().is_bound()) field_maxHopLimit = other_value.maxHopLimit();
  else field_maxHopLimit.clean_up();
  if (other_value.reserved2().is_bound()) field_reserved2 = other_value.reserved2();
  else field_reserved2.clean_up();
}
return *this;
}

boolean CommonHeader::operator==(const CommonHeader& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_nextHeader==other_value.field_nextHeader
  && field_reserved==other_value.field_reserved
  && field_headerTST==other_value.field_headerTST
  && field_trafficClass==other_value.field_trafficClass
  && field_flags==other_value.field_flags
  && field_plLength==other_value.field_plLength
  && field_maxHopLimit==other_value.field_maxHopLimit
  && field_reserved2==other_value.field_reserved2;
}

boolean CommonHeader::is_bound() const
{
if (bound_flag) return TRUE;
if(field_nextHeader.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
if(field_headerTST.is_bound()) return TRUE;
if(field_trafficClass.is_bound()) return TRUE;
if(field_flags.is_bound()) return TRUE;
if(field_plLength.is_bound()) return TRUE;
if(field_maxHopLimit.is_bound()) return TRUE;
if(field_reserved2.is_bound()) return TRUE;
return FALSE;
}
boolean CommonHeader::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_nextHeader.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
if(!field_headerTST.is_value()) return FALSE;
if(!field_trafficClass.is_value()) return FALSE;
if(!field_flags.is_value()) return FALSE;
if(!field_plLength.is_value()) return FALSE;
if(!field_maxHopLimit.is_value()) return FALSE;
if(!field_reserved2.is_value()) return FALSE;
return TRUE;
}
int CommonHeader::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.CommonHeader");
  return 8;
}

void CommonHeader::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ nextHeader := ");
field_nextHeader.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(", headerTST := ");
field_headerTST.log();
TTCN_Logger::log_event_str(", trafficClass := ");
field_trafficClass.log();
TTCN_Logger::log_event_str(", flags := ");
field_flags.log();
TTCN_Logger::log_event_str(", plLength := ");
field_plLength.log();
TTCN_Logger::log_event_str(", maxHopLimit := ");
field_maxHopLimit.log();
TTCN_Logger::log_event_str(", reserved2 := ");
field_reserved2.log();
TTCN_Logger::log_event_str(" }");
}

void CommonHeader::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.CommonHeader'");
    }
    if (strcmp("nextHeader", param_field) == 0) {
      nextHeader().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("headerTST", param_field) == 0) {
      headerTST().set_param(param);
      return;
    } else if (strcmp("trafficClass", param_field) == 0) {
      trafficClass().set_param(param);
      return;
    } else if (strcmp("flags", param_field) == 0) {
      flags().set_param(param);
      return;
    } else if (strcmp("plLength", param_field) == 0) {
      plLength().set_param(param);
      return;
    } else if (strcmp("maxHopLimit", param_field) == 0) {
      maxHopLimit().set_param(param);
      return;
    } else if (strcmp("reserved2", param_field) == 0) {
      reserved2().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.CommonHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (8<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.CommonHeader has 8 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) nextHeader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) headerTST().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) trafficClass().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) flags().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) plLength().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) maxHopLimit().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) reserved2().set_param(*mp->get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerTST")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerTST().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "flags")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          flags().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "plLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          plLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "maxHopLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          maxHopLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved2().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.CommonHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.CommonHeader");
  }
}

Module_Param* CommonHeader::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.CommonHeader'");
    }
    if (strcmp("nextHeader", param_field) == 0) {
      return nextHeader().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("headerTST", param_field) == 0) {
      return headerTST().get_param(param_name);
    } else if (strcmp("trafficClass", param_field) == 0) {
      return trafficClass().get_param(param_name);
    } else if (strcmp("flags", param_field) == 0) {
      return flags().get_param(param_name);
    } else if (strcmp("plLength", param_field) == 0) {
      return plLength().get_param(param_name);
    } else if (strcmp("maxHopLimit", param_field) == 0) {
      return maxHopLimit().get_param(param_name);
    } else if (strcmp("reserved2", param_field) == 0) {
      return reserved2().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.CommonHeader'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_nextHeader = field_nextHeader.get_param(param_name);
  mp_field_nextHeader->set_id(new Module_Param_FieldName(mcopystr("nextHeader")));
  mp->add_elem(mp_field_nextHeader);
  Module_Param* mp_field_reserved = field_reserved.get_param(param_name);
  mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
  mp->add_elem(mp_field_reserved);
  Module_Param* mp_field_headerTST = field_headerTST.get_param(param_name);
  mp_field_headerTST->set_id(new Module_Param_FieldName(mcopystr("headerTST")));
  mp->add_elem(mp_field_headerTST);
  Module_Param* mp_field_trafficClass = field_trafficClass.get_param(param_name);
  mp_field_trafficClass->set_id(new Module_Param_FieldName(mcopystr("trafficClass")));
  mp->add_elem(mp_field_trafficClass);
  Module_Param* mp_field_flags = field_flags.get_param(param_name);
  mp_field_flags->set_id(new Module_Param_FieldName(mcopystr("flags")));
  mp->add_elem(mp_field_flags);
  Module_Param* mp_field_plLength = field_plLength.get_param(param_name);
  mp_field_plLength->set_id(new Module_Param_FieldName(mcopystr("plLength")));
  mp->add_elem(mp_field_plLength);
  Module_Param* mp_field_maxHopLimit = field_maxHopLimit.get_param(param_name);
  mp_field_maxHopLimit->set_id(new Module_Param_FieldName(mcopystr("maxHopLimit")));
  mp->add_elem(mp_field_maxHopLimit);
  Module_Param* mp_field_reserved2 = field_reserved2.get_param(param_name);
  mp_field_reserved2->set_id(new Module_Param_FieldName(mcopystr("reserved2")));
  mp->add_elem(mp_field_reserved2);
  return mp;
  }

void CommonHeader::set_implicit_omit()
{
if (nextHeader().is_bound()) nextHeader().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
if (headerTST().is_bound()) headerTST().set_implicit_omit();
if (trafficClass().is_bound()) trafficClass().set_implicit_omit();
if (flags().is_bound()) flags().set_implicit_omit();
if (plLength().is_bound()) plLength().set_implicit_omit();
if (maxHopLimit().is_bound()) maxHopLimit().set_implicit_omit();
if (reserved2().is_bound()) reserved2().set_implicit_omit();
}

void CommonHeader::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
field_nextHeader.encode_text(text_buf);
field_reserved.encode_text(text_buf);
field_headerTST.encode_text(text_buf);
field_trafficClass.encode_text(text_buf);
field_flags.encode_text(text_buf);
field_plLength.encode_text(text_buf);
field_maxHopLimit.encode_text(text_buf);
field_reserved2.encode_text(text_buf);
}

void CommonHeader::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_nextHeader.decode_text(text_buf);
field_reserved.decode_text(text_buf);
field_headerTST.decode_text(text_buf);
field_trafficClass.decode_text(text_buf);
field_flags.decode_text(text_buf);
field_plLength.decode_text(text_buf);
field_maxHopLimit.decode_text(text_buf);
field_reserved2.decode_text(text_buf);
}

void CommonHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void CommonHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int CommonHeader::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_nextHeader.RAW_decode(CommonHeader_nextHeader_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved.RAW_decode(CommonHeader_reserved_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_headerTST.RAW_decode(CommonHeader_headerTST_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_trafficClass.RAW_decode(CommonHeader_trafficClass_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_flags.RAW_decode(CommonHeader_flags_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_plLength.RAW_decode(CommonHeader_plLength_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_maxHopLimit.RAW_decode(CommonHeader_maxHopLimit_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved2.RAW_decode(CommonHeader_reserved2_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int CommonHeader::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 8;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(8);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, CommonHeader_nextHeader_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, CommonHeader_reserved_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, CommonHeader_headerTST_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, CommonHeader_trafficClass_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, CommonHeader_flags_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, CommonHeader_plLength_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, CommonHeader_maxHopLimit_descr_.raw);
  myleaf.body.node.nodes[7] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 7, CommonHeader_reserved2_descr_.raw);
  encoded_length += field_nextHeader.RAW_encode(CommonHeader_nextHeader_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_reserved.RAW_encode(CommonHeader_reserved_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_headerTST.RAW_encode(CommonHeader_headerTST_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_trafficClass.RAW_encode(CommonHeader_trafficClass_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_flags.RAW_encode(CommonHeader_flags_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_plLength.RAW_encode(CommonHeader_plLength_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_maxHopLimit.RAW_encode(CommonHeader_maxHopLimit_descr_, *myleaf.body.node.nodes[6]);
  encoded_length += field_reserved2.RAW_encode(CommonHeader_reserved2_descr_, *myleaf.body.node.nodes[7]);
  return myleaf.length = encoded_length;
}

int CommonHeader::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "nextHeader");
    enc_len += field_nextHeader.JSON_encode(CommonHeader_nextHeader_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(CommonHeader_reserved_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerTST");
    enc_len += field_headerTST.JSON_encode(CommonHeader_headerTST_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "trafficClass");
    enc_len += field_trafficClass.JSON_encode(CommonHeader_trafficClass_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "flags");
    enc_len += field_flags.JSON_encode(CommonHeader_flags_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "plLength");
    enc_len += field_plLength.JSON_encode(CommonHeader_plLength_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "maxHopLimit");
    enc_len += field_maxHopLimit.JSON_encode(CommonHeader_maxHopLimit_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved2");
    enc_len += field_reserved2.JSON_encode(CommonHeader_reserved2_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int CommonHeader::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "nextHeader", name_len)) {
         int ret_val = field_nextHeader.JSON_decode(CommonHeader_nextHeader_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "nextHeader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
         int ret_val = field_reserved.JSON_decode(CommonHeader_reserved_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "headerTST", name_len)) {
         int ret_val = field_headerTST.JSON_decode(CommonHeader_headerTST_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerTST");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "trafficClass", name_len)) {
         int ret_val = field_trafficClass.JSON_decode(CommonHeader_trafficClass_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "trafficClass");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (5 == name_len && 0 == strncmp(fld_name, "flags", name_len)) {
         int ret_val = field_flags.JSON_decode(CommonHeader_flags_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "flags");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "plLength", name_len)) {
         int ret_val = field_plLength.JSON_decode(CommonHeader_plLength_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "plLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "maxHopLimit", name_len)) {
         int ret_val = field_maxHopLimit.JSON_decode(CommonHeader_maxHopLimit_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "maxHopLimit");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "reserved2", name_len)) {
         int ret_val = field_reserved2.JSON_decode(CommonHeader_reserved2_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved2");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_nextHeader.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "nextHeader");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }
if (!field_headerTST.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerTST");
    return JSON_ERROR_FATAL;
  }
if (!field_trafficClass.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "trafficClass");
    return JSON_ERROR_FATAL;
  }
if (!field_flags.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "flags");
    return JSON_ERROR_FATAL;
  }
if (!field_plLength.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "plLength");
    return JSON_ERROR_FATAL;
  }
if (!field_maxHopLimit.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "maxHopLimit");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved2.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved2");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct CommonHeader_template::single_value_struct {
NextHeader_template field_nextHeader;
INTEGER_template field_reserved;
HeaderTST_template field_headerTST;
TrafficClass_template field_trafficClass;
BITSTRING_template field_flags;
INTEGER_template field_plLength;
INTEGER_template field_maxHopLimit;
INTEGER_template field_reserved2;
};

void CommonHeader_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_nextHeader = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
single_value->field_headerTST = ANY_VALUE;
single_value->field_trafficClass = ANY_VALUE;
single_value->field_flags = ANY_VALUE;
single_value->field_plLength = ANY_VALUE;
single_value->field_maxHopLimit = ANY_VALUE;
single_value->field_reserved2 = ANY_VALUE;
}
}
}

void CommonHeader_template::copy_value(const CommonHeader& other_value)
{
single_value = new single_value_struct;
if (other_value.nextHeader().is_bound()) {
  single_value->field_nextHeader = other_value.nextHeader();
} else {
  single_value->field_nextHeader.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
if (other_value.headerTST().is_bound()) {
  single_value->field_headerTST = other_value.headerTST();
} else {
  single_value->field_headerTST.clean_up();
}
if (other_value.trafficClass().is_bound()) {
  single_value->field_trafficClass = other_value.trafficClass();
} else {
  single_value->field_trafficClass.clean_up();
}
if (other_value.flags().is_bound()) {
  single_value->field_flags = other_value.flags();
} else {
  single_value->field_flags.clean_up();
}
if (other_value.plLength().is_bound()) {
  single_value->field_plLength = other_value.plLength();
} else {
  single_value->field_plLength.clean_up();
}
if (other_value.maxHopLimit().is_bound()) {
  single_value->field_maxHopLimit = other_value.maxHopLimit();
} else {
  single_value->field_maxHopLimit.clean_up();
}
if (other_value.reserved2().is_bound()) {
  single_value->field_reserved2 = other_value.reserved2();
} else {
  single_value->field_reserved2.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void CommonHeader_template::copy_template(const CommonHeader_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.nextHeader().get_selection()) {
single_value->field_nextHeader = other_value.nextHeader();
} else {
single_value->field_nextHeader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.headerTST().get_selection()) {
single_value->field_headerTST = other_value.headerTST();
} else {
single_value->field_headerTST.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trafficClass().get_selection()) {
single_value->field_trafficClass = other_value.trafficClass();
} else {
single_value->field_trafficClass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.flags().get_selection()) {
single_value->field_flags = other_value.flags();
} else {
single_value->field_flags.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.plLength().get_selection()) {
single_value->field_plLength = other_value.plLength();
} else {
single_value->field_plLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.maxHopLimit().get_selection()) {
single_value->field_maxHopLimit = other_value.maxHopLimit();
} else {
single_value->field_maxHopLimit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved2().get_selection()) {
single_value->field_reserved2 = other_value.reserved2();
} else {
single_value->field_reserved2.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CommonHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
break;
}
set_selection(other_value);
}

CommonHeader_template::CommonHeader_template()
{
}

CommonHeader_template::CommonHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

CommonHeader_template::CommonHeader_template(const CommonHeader& other_value)
{
copy_value(other_value);
}

CommonHeader_template::CommonHeader_template(const OPTIONAL<CommonHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CommonHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader from an unbound optional field.");
}
}

CommonHeader_template::CommonHeader_template(const CommonHeader_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

CommonHeader_template::~CommonHeader_template()
{
clean_up();
}

CommonHeader_template& CommonHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CommonHeader_template& CommonHeader_template::operator=(const CommonHeader& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

CommonHeader_template& CommonHeader_template::operator=(const OPTIONAL<CommonHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CommonHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
}
return *this;
}

CommonHeader_template& CommonHeader_template::operator=(const CommonHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean CommonHeader_template::match(const CommonHeader& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.nextHeader().is_bound()) return FALSE;
if(!single_value->field_nextHeader.match(other_value.nextHeader(), legacy))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved(), legacy))return FALSE;
if(!other_value.headerTST().is_bound()) return FALSE;
if(!single_value->field_headerTST.match(other_value.headerTST(), legacy))return FALSE;
if(!other_value.trafficClass().is_bound()) return FALSE;
if(!single_value->field_trafficClass.match(other_value.trafficClass(), legacy))return FALSE;
if(!other_value.flags().is_bound()) return FALSE;
if(!single_value->field_flags.match(other_value.flags(), legacy))return FALSE;
if(!other_value.plLength().is_bound()) return FALSE;
if(!single_value->field_plLength.match(other_value.plLength(), legacy))return FALSE;
if(!other_value.maxHopLimit().is_bound()) return FALSE;
if(!single_value->field_maxHopLimit.match(other_value.maxHopLimit(), legacy))return FALSE;
if(!other_value.reserved2().is_bound()) return FALSE;
if(!single_value->field_reserved2.match(other_value.reserved2(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
}
return FALSE;
}

boolean CommonHeader_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_nextHeader.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
if (single_value->field_headerTST.is_bound()) return TRUE;
if (single_value->field_trafficClass.is_bound()) return TRUE;
if (single_value->field_flags.is_bound()) return TRUE;
if (single_value->field_plLength.is_bound()) return TRUE;
if (single_value->field_maxHopLimit.is_bound()) return TRUE;
if (single_value->field_reserved2.is_bound()) return TRUE;
return FALSE;
}

boolean CommonHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_nextHeader.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
if (!single_value->field_headerTST.is_value()) return FALSE;
if (!single_value->field_trafficClass.is_value()) return FALSE;
if (!single_value->field_flags.is_value()) return FALSE;
if (!single_value->field_plLength.is_value()) return FALSE;
if (!single_value->field_maxHopLimit.is_value()) return FALSE;
if (!single_value->field_reserved2.is_value()) return FALSE;
return TRUE;
}

void CommonHeader_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

CommonHeader CommonHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
CommonHeader ret_val;
if (single_value->field_nextHeader.is_bound()) {
ret_val.nextHeader() = single_value->field_nextHeader.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
if (single_value->field_headerTST.is_bound()) {
ret_val.headerTST() = single_value->field_headerTST.valueof();
}
if (single_value->field_trafficClass.is_bound()) {
ret_val.trafficClass() = single_value->field_trafficClass.valueof();
}
if (single_value->field_flags.is_bound()) {
ret_val.flags() = single_value->field_flags.valueof();
}
if (single_value->field_plLength.is_bound()) {
ret_val.plLength() = single_value->field_plLength.valueof();
}
if (single_value->field_maxHopLimit.is_bound()) {
ret_val.maxHopLimit() = single_value->field_maxHopLimit.valueof();
}
if (single_value->field_reserved2.is_bound()) {
ret_val.reserved2() = single_value->field_reserved2.valueof();
}
return ret_val;
}

void CommonHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new CommonHeader_template[list_length];
}

CommonHeader_template& CommonHeader_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
return value_list.list_value[list_index];
}

NextHeader_template& CommonHeader_template::nextHeader()
{
set_specific();
return single_value->field_nextHeader;
}

const NextHeader_template& CommonHeader_template::nextHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field nextHeader of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
return single_value->field_nextHeader;
}

INTEGER_template& CommonHeader_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const INTEGER_template& CommonHeader_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
return single_value->field_reserved;
}

HeaderTST_template& CommonHeader_template::headerTST()
{
set_specific();
return single_value->field_headerTST;
}

const HeaderTST_template& CommonHeader_template::headerTST() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerTST of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
return single_value->field_headerTST;
}

TrafficClass_template& CommonHeader_template::trafficClass()
{
set_specific();
return single_value->field_trafficClass;
}

const TrafficClass_template& CommonHeader_template::trafficClass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trafficClass of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
return single_value->field_trafficClass;
}

BITSTRING_template& CommonHeader_template::flags()
{
set_specific();
return single_value->field_flags;
}

const BITSTRING_template& CommonHeader_template::flags() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field flags of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
return single_value->field_flags;
}

INTEGER_template& CommonHeader_template::plLength()
{
set_specific();
return single_value->field_plLength;
}

const INTEGER_template& CommonHeader_template::plLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field plLength of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
return single_value->field_plLength;
}

INTEGER_template& CommonHeader_template::maxHopLimit()
{
set_specific();
return single_value->field_maxHopLimit;
}

const INTEGER_template& CommonHeader_template::maxHopLimit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field maxHopLimit of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
return single_value->field_maxHopLimit;
}

INTEGER_template& CommonHeader_template::reserved2()
{
set_specific();
return single_value->field_reserved2;
}

const INTEGER_template& CommonHeader_template::reserved2() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved2 of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
return single_value->field_reserved2;
}

int CommonHeader_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 8;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
  }
  return 0;
}

void CommonHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ nextHeader := ");
single_value->field_nextHeader.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(", headerTST := ");
single_value->field_headerTST.log();
TTCN_Logger::log_event_str(", trafficClass := ");
single_value->field_trafficClass.log();
TTCN_Logger::log_event_str(", flags := ");
single_value->field_flags.log();
TTCN_Logger::log_event_str(", plLength := ");
single_value->field_plLength.log();
TTCN_Logger::log_event_str(", maxHopLimit := ");
single_value->field_maxHopLimit.log();
TTCN_Logger::log_event_str(", reserved2 := ");
single_value->field_reserved2.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void CommonHeader_template::log_match(const CommonHeader& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_nextHeader.match(match_value.nextHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".nextHeader");
single_value->field_nextHeader.log_match(match_value.nextHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_headerTST.match(match_value.headerTST(), legacy)){
TTCN_Logger::log_logmatch_info(".headerTST");
single_value->field_headerTST.log_match(match_value.headerTST(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_trafficClass.match(match_value.trafficClass(), legacy)){
TTCN_Logger::log_logmatch_info(".trafficClass");
single_value->field_trafficClass.log_match(match_value.trafficClass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_flags.match(match_value.flags(), legacy)){
TTCN_Logger::log_logmatch_info(".flags");
single_value->field_flags.log_match(match_value.flags(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_plLength.match(match_value.plLength(), legacy)){
TTCN_Logger::log_logmatch_info(".plLength");
single_value->field_plLength.log_match(match_value.plLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_maxHopLimit.match(match_value.maxHopLimit(), legacy)){
TTCN_Logger::log_logmatch_info(".maxHopLimit");
single_value->field_maxHopLimit.log_match(match_value.maxHopLimit(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved2.match(match_value.reserved2(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved2");
single_value->field_reserved2.log_match(match_value.reserved2(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ nextHeader := ");
single_value->field_nextHeader.log_match(match_value.nextHeader(), legacy);
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::log_event_str(", headerTST := ");
single_value->field_headerTST.log_match(match_value.headerTST(), legacy);
TTCN_Logger::log_event_str(", trafficClass := ");
single_value->field_trafficClass.log_match(match_value.trafficClass(), legacy);
TTCN_Logger::log_event_str(", flags := ");
single_value->field_flags.log_match(match_value.flags(), legacy);
TTCN_Logger::log_event_str(", plLength := ");
single_value->field_plLength.log_match(match_value.plLength(), legacy);
TTCN_Logger::log_event_str(", maxHopLimit := ");
single_value->field_maxHopLimit.log_match(match_value.maxHopLimit(), legacy);
TTCN_Logger::log_event_str(", reserved2 := ");
single_value->field_reserved2.log_match(match_value.reserved2(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void CommonHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_nextHeader.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
single_value->field_headerTST.encode_text(text_buf);
single_value->field_trafficClass.encode_text(text_buf);
single_value->field_flags.encode_text(text_buf);
single_value->field_plLength.encode_text(text_buf);
single_value->field_maxHopLimit.encode_text(text_buf);
single_value->field_reserved2.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
}
}

void CommonHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_nextHeader.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
single_value->field_headerTST.decode_text(text_buf);
single_value->field_trafficClass.decode_text(text_buf);
single_value->field_flags.decode_text(text_buf);
single_value->field_plLength.decode_text(text_buf);
single_value->field_maxHopLimit.decode_text(text_buf);
single_value->field_reserved2.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CommonHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader.");
}
}

void CommonHeader_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.CommonHeader'");
    }
    if (strcmp("nextHeader", param_field) == 0) {
      nextHeader().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("headerTST", param_field) == 0) {
      headerTST().set_param(param);
      return;
    } else if (strcmp("trafficClass", param_field) == 0) {
      trafficClass().set_param(param);
      return;
    } else if (strcmp("flags", param_field) == 0) {
      flags().set_param(param);
      return;
    } else if (strcmp("plLength", param_field) == 0) {
      plLength().set_param(param);
      return;
    } else if (strcmp("maxHopLimit", param_field) == 0) {
      maxHopLimit().set_param(param);
      return;
    } else if (strcmp("reserved2", param_field) == 0) {
      reserved2().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.CommonHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CommonHeader_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (8<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.CommonHeader has 8 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) nextHeader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) headerTST().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) trafficClass().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) flags().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) plLength().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) maxHopLimit().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) reserved2().set_param(*mp->get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerTST")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerTST().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "flags")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          flags().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "plLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          plLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "maxHopLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          maxHopLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved2().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.CommonHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.CommonHeader");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* CommonHeader_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.CommonHeader'");
    }
    if (strcmp("nextHeader", param_field) == 0) {
      return nextHeader().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("headerTST", param_field) == 0) {
      return headerTST().get_param(param_name);
    } else if (strcmp("trafficClass", param_field) == 0) {
      return trafficClass().get_param(param_name);
    } else if (strcmp("flags", param_field) == 0) {
      return flags().get_param(param_name);
    } else if (strcmp("plLength", param_field) == 0) {
      return plLength().get_param(param_name);
    } else if (strcmp("maxHopLimit", param_field) == 0) {
      return maxHopLimit().get_param(param_name);
    } else if (strcmp("reserved2", param_field) == 0) {
      return reserved2().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.CommonHeader'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_nextHeader = single_value->field_nextHeader.get_param(param_name);
    mp_field_nextHeader->set_id(new Module_Param_FieldName(mcopystr("nextHeader")));
    mp->add_elem(mp_field_nextHeader);
    Module_Param* mp_field_reserved = single_value->field_reserved.get_param(param_name);
    mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
    mp->add_elem(mp_field_reserved);
    Module_Param* mp_field_headerTST = single_value->field_headerTST.get_param(param_name);
    mp_field_headerTST->set_id(new Module_Param_FieldName(mcopystr("headerTST")));
    mp->add_elem(mp_field_headerTST);
    Module_Param* mp_field_trafficClass = single_value->field_trafficClass.get_param(param_name);
    mp_field_trafficClass->set_id(new Module_Param_FieldName(mcopystr("trafficClass")));
    mp->add_elem(mp_field_trafficClass);
    Module_Param* mp_field_flags = single_value->field_flags.get_param(param_name);
    mp_field_flags->set_id(new Module_Param_FieldName(mcopystr("flags")));
    mp->add_elem(mp_field_flags);
    Module_Param* mp_field_plLength = single_value->field_plLength.get_param(param_name);
    mp_field_plLength->set_id(new Module_Param_FieldName(mcopystr("plLength")));
    mp->add_elem(mp_field_plLength);
    Module_Param* mp_field_maxHopLimit = single_value->field_maxHopLimit.get_param(param_name);
    mp_field_maxHopLimit->set_id(new Module_Param_FieldName(mcopystr("maxHopLimit")));
    mp->add_elem(mp_field_maxHopLimit);
    Module_Param* mp_field_reserved2 = single_value->field_reserved2.get_param(param_name);
    mp_field_reserved2->set_id(new Module_Param_FieldName(mcopystr("reserved2")));
    mp->add_elem(mp_field_reserved2);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void CommonHeader_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_nextHeader.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.CommonHeader");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.CommonHeader");
single_value->field_headerTST.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.CommonHeader");
single_value->field_trafficClass.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.CommonHeader");
single_value->field_flags.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.CommonHeader");
single_value->field_plLength.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.CommonHeader");
single_value->field_maxHopLimit.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.CommonHeader");
single_value->field_reserved2.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.CommonHeader");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.CommonHeader");
}

boolean CommonHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CommonHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

GnNonSecuredPacket::GnNonSecuredPacket()
{
  bound_flag = FALSE;
}

GnNonSecuredPacket::GnNonSecuredPacket(const CommonHeader& par_commonHeader,
    const OPTIONAL<ExtendedHeader>& par_extendedHeader,
    const OPTIONAL<Payload>& par_payload)
  :   field_commonHeader(par_commonHeader),
  field_extendedHeader(par_extendedHeader),
  field_payload(par_payload)
{
  bound_flag = TRUE;
}

GnNonSecuredPacket::GnNonSecuredPacket(const GnNonSecuredPacket& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket.");
bound_flag = TRUE;
if (other_value.commonHeader().is_bound()) field_commonHeader = other_value.commonHeader();
else field_commonHeader.clean_up();
if (other_value.extendedHeader().is_bound()) field_extendedHeader = other_value.extendedHeader();
else field_extendedHeader.clean_up();
if (other_value.payload().is_bound()) field_payload = other_value.payload();
else field_payload.clean_up();
}

void GnNonSecuredPacket::clean_up()
{
field_commonHeader.clean_up();
field_extendedHeader.clean_up();
field_payload.clean_up();
bound_flag = FALSE;
}

GnNonSecuredPacket& GnNonSecuredPacket::operator=(const GnNonSecuredPacket& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket.");
  bound_flag = TRUE;
  if (other_value.commonHeader().is_bound()) field_commonHeader = other_value.commonHeader();
  else field_commonHeader.clean_up();
  if (other_value.extendedHeader().is_bound()) field_extendedHeader = other_value.extendedHeader();
  else field_extendedHeader.clean_up();
  if (other_value.payload().is_bound()) field_payload = other_value.payload();
  else field_payload.clean_up();
}
return *this;
}

boolean GnNonSecuredPacket::operator==(const GnNonSecuredPacket& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_commonHeader==other_value.field_commonHeader
  && field_extendedHeader==other_value.field_extendedHeader
  && field_payload==other_value.field_payload;
}

boolean GnNonSecuredPacket::is_bound() const
{
if (bound_flag) return TRUE;
if(field_commonHeader.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_extendedHeader.get_selection() || field_extendedHeader.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_payload.get_selection() || field_payload.is_bound()) return TRUE;
return FALSE;
}
boolean GnNonSecuredPacket::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_commonHeader.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_extendedHeader.get_selection() && !field_extendedHeader.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_payload.get_selection() && !field_payload.is_value()) return FALSE;
return TRUE;
}
int GnNonSecuredPacket::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket");
  int ret_val = 1;
  if (field_extendedHeader.ispresent()) ret_val++;
  if (field_payload.ispresent()) ret_val++;
  return ret_val;
}

void GnNonSecuredPacket::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ commonHeader := ");
field_commonHeader.log();
TTCN_Logger::log_event_str(", extendedHeader := ");
field_extendedHeader.log();
TTCN_Logger::log_event_str(", payload := ");
field_payload.log();
TTCN_Logger::log_event_str(" }");
}

void GnNonSecuredPacket::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket'");
    }
    if (strcmp("commonHeader", param_field) == 0) {
      commonHeader().set_param(param);
      return;
    } else if (strcmp("extendedHeader", param_field) == 0) {
      extendedHeader().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) commonHeader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) extendedHeader().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "commonHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          commonHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "extendedHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          extendedHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket");
  }
}

Module_Param* GnNonSecuredPacket::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket'");
    }
    if (strcmp("commonHeader", param_field) == 0) {
      return commonHeader().get_param(param_name);
    } else if (strcmp("extendedHeader", param_field) == 0) {
      return extendedHeader().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_commonHeader = field_commonHeader.get_param(param_name);
  mp_field_commonHeader->set_id(new Module_Param_FieldName(mcopystr("commonHeader")));
  mp->add_elem(mp_field_commonHeader);
  Module_Param* mp_field_extendedHeader = field_extendedHeader.get_param(param_name);
  mp_field_extendedHeader->set_id(new Module_Param_FieldName(mcopystr("extendedHeader")));
  mp->add_elem(mp_field_extendedHeader);
  Module_Param* mp_field_payload = field_payload.get_param(param_name);
  mp_field_payload->set_id(new Module_Param_FieldName(mcopystr("payload")));
  mp->add_elem(mp_field_payload);
  return mp;
  }

void GnNonSecuredPacket::set_implicit_omit()
{
if (commonHeader().is_bound()) commonHeader().set_implicit_omit();
if (!extendedHeader().is_bound()) extendedHeader() = OMIT_VALUE;
else extendedHeader().set_implicit_omit();
if (!payload().is_bound()) payload() = OMIT_VALUE;
else payload().set_implicit_omit();
}

void GnNonSecuredPacket::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket.");
field_commonHeader.encode_text(text_buf);
field_extendedHeader.encode_text(text_buf);
field_payload.encode_text(text_buf);
}

void GnNonSecuredPacket::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_commonHeader.decode_text(text_buf);
field_extendedHeader.decode_text(text_buf);
field_payload.decode_text(text_buf);
}

void GnNonSecuredPacket::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GnNonSecuredPacket::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GnNonSecuredPacket::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_commonHeader.RAW_decode(CommonHeader_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_extendedHeader().RAW_decode(ExtendedHeader_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_extendedHeader = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_extendedHeader=OMIT_VALUE;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_payload().RAW_decode(Payload_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_payload = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_payload=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GnNonSecuredPacket::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, CommonHeader_descr_.raw);
  if (field_extendedHeader.ispresent()) {
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, ExtendedHeader_descr_.raw);
  }
  else myleaf.body.node.nodes[1] = NULL;
  if (field_payload.ispresent()) {
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, Payload_descr_.raw);
  }
  else myleaf.body.node.nodes[2] = NULL;
  encoded_length += field_commonHeader.RAW_encode(CommonHeader_descr_, *myleaf.body.node.nodes[0]);
  if (field_extendedHeader.ispresent()) {
  encoded_length += field_extendedHeader().RAW_encode(ExtendedHeader_descr_, *myleaf.body.node.nodes[1]);
  }
  if (field_payload.ispresent()) {
  encoded_length += field_payload().RAW_encode(Payload_descr_, *myleaf.body.node.nodes[2]);
  }
  return myleaf.length = encoded_length;
}

int GnNonSecuredPacket::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "commonHeader");
    enc_len += field_commonHeader.JSON_encode(CommonHeader_descr_, p_tok);
  }

  if (field_extendedHeader.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "extendedHeader");
    enc_len += field_extendedHeader.JSON_encode(ExtendedHeader_descr_, p_tok);
  }

  if (field_payload.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payload");
    enc_len += field_payload.JSON_encode(Payload_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GnNonSecuredPacket::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "commonHeader", name_len)) {
         int ret_val = field_commonHeader.JSON_decode(CommonHeader_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "commonHeader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "extendedHeader", name_len)) {
         int ret_val = field_extendedHeader.JSON_decode(ExtendedHeader_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "extendedHeader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "payload", name_len)) {
         int ret_val = field_payload.JSON_decode(Payload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "payload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_commonHeader.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "commonHeader");
    return JSON_ERROR_FATAL;
  }
if (!field_extendedHeader.is_bound()) {
    field_extendedHeader = OMIT_VALUE;
  }
if (!field_payload.is_bound()) {
    field_payload = OMIT_VALUE;
  }

  return dec_len;
}

struct GnNonSecuredPacket_template::single_value_struct {
CommonHeader_template field_commonHeader;
ExtendedHeader_template field_extendedHeader;
Payload_template field_payload;
};

void GnNonSecuredPacket_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_commonHeader = ANY_VALUE;
single_value->field_extendedHeader = ANY_OR_OMIT;
single_value->field_payload = ANY_OR_OMIT;
}
}
}

void GnNonSecuredPacket_template::copy_value(const GnNonSecuredPacket& other_value)
{
single_value = new single_value_struct;
if (other_value.commonHeader().is_bound()) {
  single_value->field_commonHeader = other_value.commonHeader();
} else {
  single_value->field_commonHeader.clean_up();
}
if (other_value.extendedHeader().is_bound()) {
  if (other_value.extendedHeader().ispresent()) single_value->field_extendedHeader = other_value.extendedHeader()();
  else single_value->field_extendedHeader = OMIT_VALUE;
} else {
  single_value->field_extendedHeader.clean_up();
}
if (other_value.payload().is_bound()) {
  if (other_value.payload().ispresent()) single_value->field_payload = other_value.payload()();
  else single_value->field_payload = OMIT_VALUE;
} else {
  single_value->field_payload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GnNonSecuredPacket_template::copy_template(const GnNonSecuredPacket_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.commonHeader().get_selection()) {
single_value->field_commonHeader = other_value.commonHeader();
} else {
single_value->field_commonHeader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.extendedHeader().get_selection()) {
single_value->field_extendedHeader = other_value.extendedHeader();
} else {
single_value->field_extendedHeader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload().get_selection()) {
single_value->field_payload = other_value.payload();
} else {
single_value->field_payload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GnNonSecuredPacket_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket.");
break;
}
set_selection(other_value);
}

GnNonSecuredPacket_template::GnNonSecuredPacket_template()
{
}

GnNonSecuredPacket_template::GnNonSecuredPacket_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GnNonSecuredPacket_template::GnNonSecuredPacket_template(const GnNonSecuredPacket& other_value)
{
copy_value(other_value);
}

GnNonSecuredPacket_template::GnNonSecuredPacket_template(const OPTIONAL<GnNonSecuredPacket>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GnNonSecuredPacket&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket from an unbound optional field.");
}
}

GnNonSecuredPacket_template::GnNonSecuredPacket_template(const GnNonSecuredPacket_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GnNonSecuredPacket_template::~GnNonSecuredPacket_template()
{
clean_up();
}

GnNonSecuredPacket_template& GnNonSecuredPacket_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GnNonSecuredPacket_template& GnNonSecuredPacket_template::operator=(const GnNonSecuredPacket& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GnNonSecuredPacket_template& GnNonSecuredPacket_template::operator=(const OPTIONAL<GnNonSecuredPacket>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GnNonSecuredPacket&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket.");
}
return *this;
}

GnNonSecuredPacket_template& GnNonSecuredPacket_template::operator=(const GnNonSecuredPacket_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GnNonSecuredPacket_template::match(const GnNonSecuredPacket& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.commonHeader().is_bound()) return FALSE;
if(!single_value->field_commonHeader.match(other_value.commonHeader(), legacy))return FALSE;
if(!other_value.extendedHeader().is_bound()) return FALSE;
if((other_value.extendedHeader().ispresent() ? !single_value->field_extendedHeader.match((const ExtendedHeader&)other_value.extendedHeader(), legacy) : !single_value->field_extendedHeader.match_omit(legacy)))return FALSE;
if(!other_value.payload().is_bound()) return FALSE;
if((other_value.payload().ispresent() ? !single_value->field_payload.match((const Payload&)other_value.payload(), legacy) : !single_value->field_payload.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket.");
}
return FALSE;
}

boolean GnNonSecuredPacket_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_commonHeader.is_bound()) return TRUE;
if (single_value->field_extendedHeader.is_omit() || single_value->field_extendedHeader.is_bound()) return TRUE;
if (single_value->field_payload.is_omit() || single_value->field_payload.is_bound()) return TRUE;
return FALSE;
}

boolean GnNonSecuredPacket_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_commonHeader.is_value()) return FALSE;
if (!single_value->field_extendedHeader.is_omit() && !single_value->field_extendedHeader.is_value()) return FALSE;
if (!single_value->field_payload.is_omit() && !single_value->field_payload.is_value()) return FALSE;
return TRUE;
}

void GnNonSecuredPacket_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GnNonSecuredPacket GnNonSecuredPacket_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket.");
GnNonSecuredPacket ret_val;
if (single_value->field_commonHeader.is_bound()) {
ret_val.commonHeader() = single_value->field_commonHeader.valueof();
}
if (single_value->field_extendedHeader.is_omit()) ret_val.extendedHeader() = OMIT_VALUE;
else if (single_value->field_extendedHeader.is_bound()) {
ret_val.extendedHeader() = single_value->field_extendedHeader.valueof();
}
if (single_value->field_payload.is_omit()) ret_val.payload() = OMIT_VALUE;
else if (single_value->field_payload.is_bound()) {
ret_val.payload() = single_value->field_payload.valueof();
}
return ret_val;
}

void GnNonSecuredPacket_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GnNonSecuredPacket_template[list_length];
}

GnNonSecuredPacket_template& GnNonSecuredPacket_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket.");
return value_list.list_value[list_index];
}

CommonHeader_template& GnNonSecuredPacket_template::commonHeader()
{
set_specific();
return single_value->field_commonHeader;
}

const CommonHeader_template& GnNonSecuredPacket_template::commonHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field commonHeader of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket.");
return single_value->field_commonHeader;
}

ExtendedHeader_template& GnNonSecuredPacket_template::extendedHeader()
{
set_specific();
return single_value->field_extendedHeader;
}

const ExtendedHeader_template& GnNonSecuredPacket_template::extendedHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field extendedHeader of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket.");
return single_value->field_extendedHeader;
}

Payload_template& GnNonSecuredPacket_template::payload()
{
set_specific();
return single_value->field_payload;
}

const Payload_template& GnNonSecuredPacket_template::payload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket.");
return single_value->field_payload;
}

int GnNonSecuredPacket_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_extendedHeader.is_present()) ret_val++;
      if (single_value->field_payload.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket.");
  }
  return 0;
}

void GnNonSecuredPacket_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ commonHeader := ");
single_value->field_commonHeader.log();
TTCN_Logger::log_event_str(", extendedHeader := ");
single_value->field_extendedHeader.log();
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GnNonSecuredPacket_template::log_match(const GnNonSecuredPacket& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_commonHeader.match(match_value.commonHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".commonHeader");
single_value->field_commonHeader.log_match(match_value.commonHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.extendedHeader().ispresent()){
if(!single_value->field_extendedHeader.match(match_value.extendedHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".extendedHeader");
single_value->field_extendedHeader.log_match(match_value.extendedHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_extendedHeader.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".extendedHeader := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_extendedHeader.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.payload().ispresent()){
if(!single_value->field_payload.match(match_value.payload(), legacy)){
TTCN_Logger::log_logmatch_info(".payload");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_payload.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".payload := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_payload.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ commonHeader := ");
single_value->field_commonHeader.log_match(match_value.commonHeader(), legacy);
TTCN_Logger::log_event_str(", extendedHeader := ");
if (match_value.extendedHeader().ispresent()) single_value->field_extendedHeader.log_match(match_value.extendedHeader(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_extendedHeader.log();
if (single_value->field_extendedHeader.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", payload := ");
if (match_value.payload().ispresent()) single_value->field_payload.log_match(match_value.payload(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_payload.log();
if (single_value->field_payload.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GnNonSecuredPacket_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_commonHeader.encode_text(text_buf);
single_value->field_extendedHeader.encode_text(text_buf);
single_value->field_payload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket.");
}
}

void GnNonSecuredPacket_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_commonHeader.decode_text(text_buf);
single_value->field_extendedHeader.decode_text(text_buf);
single_value->field_payload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GnNonSecuredPacket_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket.");
}
}

void GnNonSecuredPacket_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket'");
    }
    if (strcmp("commonHeader", param_field) == 0) {
      commonHeader().set_param(param);
      return;
    } else if (strcmp("extendedHeader", param_field) == 0) {
      extendedHeader().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GnNonSecuredPacket_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) commonHeader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) extendedHeader().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "commonHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          commonHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "extendedHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          extendedHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GnNonSecuredPacket_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket'");
    }
    if (strcmp("commonHeader", param_field) == 0) {
      return commonHeader().get_param(param_name);
    } else if (strcmp("extendedHeader", param_field) == 0) {
      return extendedHeader().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_commonHeader = single_value->field_commonHeader.get_param(param_name);
    mp_field_commonHeader->set_id(new Module_Param_FieldName(mcopystr("commonHeader")));
    mp->add_elem(mp_field_commonHeader);
    Module_Param* mp_field_extendedHeader = single_value->field_extendedHeader.get_param(param_name);
    mp_field_extendedHeader->set_id(new Module_Param_FieldName(mcopystr("extendedHeader")));
    mp->add_elem(mp_field_extendedHeader);
    Module_Param* mp_field_payload = single_value->field_payload.get_param(param_name);
    mp_field_payload->set_id(new Module_Param_FieldName(mcopystr("payload")));
    mp->add_elem(mp_field_payload);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GnNonSecuredPacket_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_commonHeader.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket");
single_value->field_extendedHeader.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket");
single_value->field_payload.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GnNonSecuredPacket");
}

boolean GnNonSecuredPacket_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GnNonSecuredPacket_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ExtendedHeader::copy_value(const ExtendedHeader& other_value)
{
switch (other_value.union_selection) {
case ALT_geoUnicastHeader:
field_geoUnicastHeader = new GeoUnicastHeader(*other_value.field_geoUnicastHeader);
break;
case ALT_tsbHeader:
field_tsbHeader = new TSBHeader(*other_value.field_tsbHeader);
break;
case ALT_shbHeader:
field_shbHeader = new SHBHeader(*other_value.field_shbHeader);
break;
case ALT_geoBroadcastHeader:
field_geoBroadcastHeader = new GeoAnycastHeader(*other_value.field_geoBroadcastHeader);
break;
case ALT_geoAnycastHeader:
field_geoAnycastHeader = new GeoAnycastHeader(*other_value.field_geoAnycastHeader);
break;
case ALT_beaconHeader:
field_beaconHeader = new BeaconHeader(*other_value.field_beaconHeader);
break;
case ALT_lsRequestHeader:
field_lsRequestHeader = new LSRequestHeader(*other_value.field_lsRequestHeader);
break;
case ALT_lsReplyHeader:
field_lsReplyHeader = new LSReplyHeader(*other_value.field_lsReplyHeader);
break;
case ALT_anyHeader:
field_anyHeader = new AnyHeader(*other_value.field_anyHeader);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
}
union_selection = other_value.union_selection;
}

ExtendedHeader::ExtendedHeader()
{
union_selection = UNBOUND_VALUE;
}

ExtendedHeader::ExtendedHeader(const ExtendedHeader& other_value)
: Base_Type(){
copy_value(other_value);
}

ExtendedHeader::~ExtendedHeader()
{
clean_up();
}

ExtendedHeader& ExtendedHeader::operator=(const ExtendedHeader& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean ExtendedHeader::operator==(const ExtendedHeader& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_geoUnicastHeader:
return *field_geoUnicastHeader == *other_value.field_geoUnicastHeader;
case ALT_tsbHeader:
return *field_tsbHeader == *other_value.field_tsbHeader;
case ALT_shbHeader:
return *field_shbHeader == *other_value.field_shbHeader;
case ALT_geoBroadcastHeader:
return *field_geoBroadcastHeader == *other_value.field_geoBroadcastHeader;
case ALT_geoAnycastHeader:
return *field_geoAnycastHeader == *other_value.field_geoAnycastHeader;
case ALT_beaconHeader:
return *field_beaconHeader == *other_value.field_beaconHeader;
case ALT_lsRequestHeader:
return *field_lsRequestHeader == *other_value.field_lsRequestHeader;
case ALT_lsReplyHeader:
return *field_lsReplyHeader == *other_value.field_lsReplyHeader;
case ALT_anyHeader:
return *field_anyHeader == *other_value.field_anyHeader;
default:
return FALSE;
}
}

GeoUnicastHeader& ExtendedHeader::geoUnicastHeader()
{
if (union_selection != ALT_geoUnicastHeader) {
clean_up();
field_geoUnicastHeader = new GeoUnicastHeader;
union_selection = ALT_geoUnicastHeader;
}
return *field_geoUnicastHeader;
}

const GeoUnicastHeader& ExtendedHeader::geoUnicastHeader() const
{
if (union_selection != ALT_geoUnicastHeader) TTCN_error("Using non-selected field geoUnicastHeader in a value of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *field_geoUnicastHeader;
}

TSBHeader& ExtendedHeader::tsbHeader()
{
if (union_selection != ALT_tsbHeader) {
clean_up();
field_tsbHeader = new TSBHeader;
union_selection = ALT_tsbHeader;
}
return *field_tsbHeader;
}

const TSBHeader& ExtendedHeader::tsbHeader() const
{
if (union_selection != ALT_tsbHeader) TTCN_error("Using non-selected field tsbHeader in a value of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *field_tsbHeader;
}

SHBHeader& ExtendedHeader::shbHeader()
{
if (union_selection != ALT_shbHeader) {
clean_up();
field_shbHeader = new SHBHeader;
union_selection = ALT_shbHeader;
}
return *field_shbHeader;
}

const SHBHeader& ExtendedHeader::shbHeader() const
{
if (union_selection != ALT_shbHeader) TTCN_error("Using non-selected field shbHeader in a value of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *field_shbHeader;
}

GeoAnycastHeader& ExtendedHeader::geoBroadcastHeader()
{
if (union_selection != ALT_geoBroadcastHeader) {
clean_up();
field_geoBroadcastHeader = new GeoAnycastHeader;
union_selection = ALT_geoBroadcastHeader;
}
return *field_geoBroadcastHeader;
}

const GeoAnycastHeader& ExtendedHeader::geoBroadcastHeader() const
{
if (union_selection != ALT_geoBroadcastHeader) TTCN_error("Using non-selected field geoBroadcastHeader in a value of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *field_geoBroadcastHeader;
}

GeoAnycastHeader& ExtendedHeader::geoAnycastHeader()
{
if (union_selection != ALT_geoAnycastHeader) {
clean_up();
field_geoAnycastHeader = new GeoAnycastHeader;
union_selection = ALT_geoAnycastHeader;
}
return *field_geoAnycastHeader;
}

const GeoAnycastHeader& ExtendedHeader::geoAnycastHeader() const
{
if (union_selection != ALT_geoAnycastHeader) TTCN_error("Using non-selected field geoAnycastHeader in a value of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *field_geoAnycastHeader;
}

BeaconHeader& ExtendedHeader::beaconHeader()
{
if (union_selection != ALT_beaconHeader) {
clean_up();
field_beaconHeader = new BeaconHeader;
union_selection = ALT_beaconHeader;
}
return *field_beaconHeader;
}

const BeaconHeader& ExtendedHeader::beaconHeader() const
{
if (union_selection != ALT_beaconHeader) TTCN_error("Using non-selected field beaconHeader in a value of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *field_beaconHeader;
}

LSRequestHeader& ExtendedHeader::lsRequestHeader()
{
if (union_selection != ALT_lsRequestHeader) {
clean_up();
field_lsRequestHeader = new LSRequestHeader;
union_selection = ALT_lsRequestHeader;
}
return *field_lsRequestHeader;
}

const LSRequestHeader& ExtendedHeader::lsRequestHeader() const
{
if (union_selection != ALT_lsRequestHeader) TTCN_error("Using non-selected field lsRequestHeader in a value of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *field_lsRequestHeader;
}

LSReplyHeader& ExtendedHeader::lsReplyHeader()
{
if (union_selection != ALT_lsReplyHeader) {
clean_up();
field_lsReplyHeader = new LSReplyHeader;
union_selection = ALT_lsReplyHeader;
}
return *field_lsReplyHeader;
}

const LSReplyHeader& ExtendedHeader::lsReplyHeader() const
{
if (union_selection != ALT_lsReplyHeader) TTCN_error("Using non-selected field lsReplyHeader in a value of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *field_lsReplyHeader;
}

AnyHeader& ExtendedHeader::anyHeader()
{
if (union_selection != ALT_anyHeader) {
clean_up();
field_anyHeader = new AnyHeader;
union_selection = ALT_anyHeader;
}
return *field_anyHeader;
}

const AnyHeader& ExtendedHeader::anyHeader() const
{
if (union_selection != ALT_anyHeader) TTCN_error("Using non-selected field anyHeader in a value of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *field_anyHeader;
}

boolean ExtendedHeader::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return union_selection == checked_selection;
}

boolean ExtendedHeader::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean ExtendedHeader::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_geoUnicastHeader: return field_geoUnicastHeader->is_value();
case ALT_tsbHeader: return field_tsbHeader->is_value();
case ALT_shbHeader: return field_shbHeader->is_value();
case ALT_geoBroadcastHeader: return field_geoBroadcastHeader->is_value();
case ALT_geoAnycastHeader: return field_geoAnycastHeader->is_value();
case ALT_beaconHeader: return field_beaconHeader->is_value();
case ALT_lsRequestHeader: return field_lsRequestHeader->is_value();
case ALT_lsReplyHeader: return field_lsReplyHeader->is_value();
case ALT_anyHeader: return field_anyHeader->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void ExtendedHeader::clean_up()
{
switch (union_selection) {
case ALT_geoUnicastHeader:
  delete field_geoUnicastHeader;
  break;
case ALT_tsbHeader:
  delete field_tsbHeader;
  break;
case ALT_shbHeader:
  delete field_shbHeader;
  break;
case ALT_geoBroadcastHeader:
  delete field_geoBroadcastHeader;
  break;
case ALT_geoAnycastHeader:
  delete field_geoAnycastHeader;
  break;
case ALT_beaconHeader:
  delete field_beaconHeader;
  break;
case ALT_lsRequestHeader:
  delete field_lsRequestHeader;
  break;
case ALT_lsReplyHeader:
  delete field_lsReplyHeader;
  break;
case ALT_anyHeader:
  delete field_anyHeader;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void ExtendedHeader::log() const
{
switch (union_selection) {
case ALT_geoUnicastHeader:
TTCN_Logger::log_event_str("{ geoUnicastHeader := ");
field_geoUnicastHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_tsbHeader:
TTCN_Logger::log_event_str("{ tsbHeader := ");
field_tsbHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_shbHeader:
TTCN_Logger::log_event_str("{ shbHeader := ");
field_shbHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_geoBroadcastHeader:
TTCN_Logger::log_event_str("{ geoBroadcastHeader := ");
field_geoBroadcastHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_geoAnycastHeader:
TTCN_Logger::log_event_str("{ geoAnycastHeader := ");
field_geoAnycastHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_beaconHeader:
TTCN_Logger::log_event_str("{ beaconHeader := ");
field_beaconHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_lsRequestHeader:
TTCN_Logger::log_event_str("{ lsRequestHeader := ");
field_lsRequestHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_lsReplyHeader:
TTCN_Logger::log_event_str("{ lsReplyHeader := ");
field_lsReplyHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_anyHeader:
TTCN_Logger::log_event_str("{ anyHeader := ");
field_anyHeader->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void ExtendedHeader::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsGeoNetworking_TypesAndValues.ExtendedHeader'");
    }
    if (strcmp("geoUnicastHeader", param_field) == 0) {
      geoUnicastHeader().set_param(param);
      return;
    } else if (strcmp("tsbHeader", param_field) == 0) {
      tsbHeader().set_param(param);
      return;
    } else if (strcmp("shbHeader", param_field) == 0) {
      shbHeader().set_param(param);
      return;
    } else if (strcmp("geoBroadcastHeader", param_field) == 0) {
      geoBroadcastHeader().set_param(param);
      return;
    } else if (strcmp("geoAnycastHeader", param_field) == 0) {
      geoAnycastHeader().set_param(param);
      return;
    } else if (strcmp("beaconHeader", param_field) == 0) {
      beaconHeader().set_param(param);
      return;
    } else if (strcmp("lsRequestHeader", param_field) == 0) {
      lsRequestHeader().set_param(param);
      return;
    } else if (strcmp("lsReplyHeader", param_field) == 0) {
      lsReplyHeader().set_param(param);
      return;
    } else if (strcmp("anyHeader", param_field) == 0) {
      anyHeader().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsGeoNetworking_TypesAndValues.ExtendedHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "geoUnicastHeader")) {
    geoUnicastHeader().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "tsbHeader")) {
    tsbHeader().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "shbHeader")) {
    shbHeader().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "geoBroadcastHeader")) {
    geoBroadcastHeader().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "geoAnycastHeader")) {
    geoAnycastHeader().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "beaconHeader")) {
    beaconHeader().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "lsRequestHeader")) {
    lsRequestHeader().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "lsReplyHeader")) {
    lsReplyHeader().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "anyHeader")) {
    anyHeader().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.", mp_last->get_id()->get_name());
}

Module_Param* ExtendedHeader::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsGeoNetworking_TypesAndValues.ExtendedHeader'");
    }
    if (strcmp("geoUnicastHeader", param_field) == 0) {
      return geoUnicastHeader().get_param(param_name);
    } else if (strcmp("tsbHeader", param_field) == 0) {
      return tsbHeader().get_param(param_name);
    } else if (strcmp("shbHeader", param_field) == 0) {
      return shbHeader().get_param(param_name);
    } else if (strcmp("geoBroadcastHeader", param_field) == 0) {
      return geoBroadcastHeader().get_param(param_name);
    } else if (strcmp("geoAnycastHeader", param_field) == 0) {
      return geoAnycastHeader().get_param(param_name);
    } else if (strcmp("beaconHeader", param_field) == 0) {
      return beaconHeader().get_param(param_name);
    } else if (strcmp("lsRequestHeader", param_field) == 0) {
      return lsRequestHeader().get_param(param_name);
    } else if (strcmp("lsReplyHeader", param_field) == 0) {
      return lsReplyHeader().get_param(param_name);
    } else if (strcmp("anyHeader", param_field) == 0) {
      return anyHeader().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `ExtendedHeader'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_geoUnicastHeader:
    mp_field = field_geoUnicastHeader->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("geoUnicastHeader")));
    break;
  case ALT_tsbHeader:
    mp_field = field_tsbHeader->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("tsbHeader")));
    break;
  case ALT_shbHeader:
    mp_field = field_shbHeader->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("shbHeader")));
    break;
  case ALT_geoBroadcastHeader:
    mp_field = field_geoBroadcastHeader->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("geoBroadcastHeader")));
    break;
  case ALT_geoAnycastHeader:
    mp_field = field_geoAnycastHeader->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("geoAnycastHeader")));
    break;
  case ALT_beaconHeader:
    mp_field = field_beaconHeader->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("beaconHeader")));
    break;
  case ALT_lsRequestHeader:
    mp_field = field_lsRequestHeader->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("lsRequestHeader")));
    break;
  case ALT_lsReplyHeader:
    mp_field = field_lsReplyHeader->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("lsReplyHeader")));
    break;
  case ALT_anyHeader:
    mp_field = field_anyHeader->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("anyHeader")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void ExtendedHeader::set_implicit_omit()
{
switch (union_selection) {
case ALT_geoUnicastHeader:
field_geoUnicastHeader->set_implicit_omit(); break;
case ALT_tsbHeader:
field_tsbHeader->set_implicit_omit(); break;
case ALT_shbHeader:
field_shbHeader->set_implicit_omit(); break;
case ALT_geoBroadcastHeader:
field_geoBroadcastHeader->set_implicit_omit(); break;
case ALT_geoAnycastHeader:
field_geoAnycastHeader->set_implicit_omit(); break;
case ALT_beaconHeader:
field_beaconHeader->set_implicit_omit(); break;
case ALT_lsRequestHeader:
field_lsRequestHeader->set_implicit_omit(); break;
case ALT_lsReplyHeader:
field_lsReplyHeader->set_implicit_omit(); break;
case ALT_anyHeader:
field_anyHeader->set_implicit_omit(); break;
default: break;
}
}

void ExtendedHeader::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_geoUnicastHeader:
field_geoUnicastHeader->encode_text(text_buf);
break;
case ALT_tsbHeader:
field_tsbHeader->encode_text(text_buf);
break;
case ALT_shbHeader:
field_shbHeader->encode_text(text_buf);
break;
case ALT_geoBroadcastHeader:
field_geoBroadcastHeader->encode_text(text_buf);
break;
case ALT_geoAnycastHeader:
field_geoAnycastHeader->encode_text(text_buf);
break;
case ALT_beaconHeader:
field_beaconHeader->encode_text(text_buf);
break;
case ALT_lsRequestHeader:
field_lsRequestHeader->encode_text(text_buf);
break;
case ALT_lsReplyHeader:
field_lsReplyHeader->encode_text(text_buf);
break;
case ALT_anyHeader:
field_anyHeader->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
}
}

void ExtendedHeader::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_geoUnicastHeader:
geoUnicastHeader().decode_text(text_buf);
break;
case ALT_tsbHeader:
tsbHeader().decode_text(text_buf);
break;
case ALT_shbHeader:
shbHeader().decode_text(text_buf);
break;
case ALT_geoBroadcastHeader:
geoBroadcastHeader().decode_text(text_buf);
break;
case ALT_geoAnycastHeader:
geoAnycastHeader().decode_text(text_buf);
break;
case ALT_beaconHeader:
beaconHeader().decode_text(text_buf);
break;
case ALT_lsRequestHeader:
lsRequestHeader().decode_text(text_buf);
break;
case ALT_lsReplyHeader:
lsReplyHeader().decode_text(text_buf);
break;
case ALT_anyHeader:
anyHeader().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
}
}

void ExtendedHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ExtendedHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ExtendedHeader::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = geoUnicastHeader().RAW_decode(GeoUnicastHeader_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = tsbHeader().RAW_decode(TSBHeader_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 2:
      decoded_length = shbHeader().RAW_decode(SHBHeader_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 3:
      decoded_length = geoBroadcastHeader().RAW_decode(GeoBroadcastHeader_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 4:
      decoded_length = geoAnycastHeader().RAW_decode(GeoAnycastHeader_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 5:
      decoded_length = beaconHeader().RAW_decode(BeaconHeader_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 6:
      decoded_length = lsRequestHeader().RAW_decode(LSRequestHeader_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 7:
      decoded_length = lsReplyHeader().RAW_decode(LSReplyHeader_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 8:
      decoded_length = anyHeader().RAW_decode(AnyHeader_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = geoUnicastHeader().RAW_decode(GeoUnicastHeader_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = tsbHeader().RAW_decode(TSBHeader_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = shbHeader().RAW_decode(SHBHeader_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = geoBroadcastHeader().RAW_decode(GeoBroadcastHeader_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = geoAnycastHeader().RAW_decode(GeoAnycastHeader_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = beaconHeader().RAW_decode(BeaconHeader_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = lsRequestHeader().RAW_decode(LSRequestHeader_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = lsReplyHeader().RAW_decode(LSReplyHeader_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = anyHeader().RAW_decode(AnyHeader_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int ExtendedHeader::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 9;  myleaf.body.node.nodes = init_nodes_of_enc_tree(9);
  memset(myleaf.body.node.nodes, 0, 9 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_geoUnicastHeader:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, GeoUnicastHeader_descr_.raw);
    encoded_length = field_geoUnicastHeader->RAW_encode(GeoUnicastHeader_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &GeoUnicastHeader_descr_;
    break;
  case ALT_tsbHeader:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, TSBHeader_descr_.raw);
    encoded_length = field_tsbHeader->RAW_encode(TSBHeader_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &TSBHeader_descr_;
    break;
  case ALT_shbHeader:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, SHBHeader_descr_.raw);
    encoded_length = field_shbHeader->RAW_encode(SHBHeader_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &SHBHeader_descr_;
    break;
  case ALT_geoBroadcastHeader:
    myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 3, GeoBroadcastHeader_descr_.raw);
    encoded_length = field_geoBroadcastHeader->RAW_encode(GeoBroadcastHeader_descr_, *myleaf.body.node.nodes[3]);
    myleaf.body.node.nodes[3]->coding_descr = &GeoBroadcastHeader_descr_;
    break;
  case ALT_geoAnycastHeader:
    myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 4, GeoAnycastHeader_descr_.raw);
    encoded_length = field_geoAnycastHeader->RAW_encode(GeoAnycastHeader_descr_, *myleaf.body.node.nodes[4]);
    myleaf.body.node.nodes[4]->coding_descr = &GeoAnycastHeader_descr_;
    break;
  case ALT_beaconHeader:
    myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 5, BeaconHeader_descr_.raw);
    encoded_length = field_beaconHeader->RAW_encode(BeaconHeader_descr_, *myleaf.body.node.nodes[5]);
    myleaf.body.node.nodes[5]->coding_descr = &BeaconHeader_descr_;
    break;
  case ALT_lsRequestHeader:
    myleaf.body.node.nodes[6] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 6, LSRequestHeader_descr_.raw);
    encoded_length = field_lsRequestHeader->RAW_encode(LSRequestHeader_descr_, *myleaf.body.node.nodes[6]);
    myleaf.body.node.nodes[6]->coding_descr = &LSRequestHeader_descr_;
    break;
  case ALT_lsReplyHeader:
    myleaf.body.node.nodes[7] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 7, LSReplyHeader_descr_.raw);
    encoded_length = field_lsReplyHeader->RAW_encode(LSReplyHeader_descr_, *myleaf.body.node.nodes[7]);
    myleaf.body.node.nodes[7]->coding_descr = &LSReplyHeader_descr_;
    break;
  case ALT_anyHeader:
    myleaf.body.node.nodes[8] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 8, AnyHeader_descr_.raw);
    encoded_length = field_anyHeader->RAW_encode(AnyHeader_descr_, *myleaf.body.node.nodes[8]);
    myleaf.body.node.nodes[8]->coding_descr = &AnyHeader_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int ExtendedHeader::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_geoUnicastHeader:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoUnicastHeader");
    enc_len += field_geoUnicastHeader->JSON_encode(GeoUnicastHeader_descr_, p_tok);
    break;
  case ALT_tsbHeader:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "tsbHeader");
    enc_len += field_tsbHeader->JSON_encode(TSBHeader_descr_, p_tok);
    break;
  case ALT_shbHeader:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "shbHeader");
    enc_len += field_shbHeader->JSON_encode(SHBHeader_descr_, p_tok);
    break;
  case ALT_geoBroadcastHeader:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoBroadcastHeader");
    enc_len += field_geoBroadcastHeader->JSON_encode(GeoBroadcastHeader_descr_, p_tok);
    break;
  case ALT_geoAnycastHeader:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoAnycastHeader");
    enc_len += field_geoAnycastHeader->JSON_encode(GeoAnycastHeader_descr_, p_tok);
    break;
  case ALT_beaconHeader:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "beaconHeader");
    enc_len += field_beaconHeader->JSON_encode(BeaconHeader_descr_, p_tok);
    break;
  case ALT_lsRequestHeader:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lsRequestHeader");
    enc_len += field_lsRequestHeader->JSON_encode(LSRequestHeader_descr_, p_tok);
    break;
  case ALT_lsReplyHeader:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lsReplyHeader");
    enc_len += field_lsReplyHeader->JSON_encode(LSReplyHeader_descr_, p_tok);
    break;
  case ALT_anyHeader:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "anyHeader");
    enc_len += field_anyHeader->JSON_encode(AnyHeader_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ExtendedHeader::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "geoUnicastHeader", name_len)) {
      int ret_val = geoUnicastHeader().JSON_decode(GeoUnicastHeader_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoUnicastHeader");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "tsbHeader", name_len)) {
      int ret_val = tsbHeader().JSON_decode(TSBHeader_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "tsbHeader");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "shbHeader", name_len)) {
      int ret_val = shbHeader().JSON_decode(SHBHeader_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "shbHeader");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "geoBroadcastHeader", name_len)) {
      int ret_val = geoBroadcastHeader().JSON_decode(GeoBroadcastHeader_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoBroadcastHeader");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "geoAnycastHeader", name_len)) {
      int ret_val = geoAnycastHeader().JSON_decode(GeoAnycastHeader_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoAnycastHeader");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "beaconHeader", name_len)) {
      int ret_val = beaconHeader().JSON_decode(BeaconHeader_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "beaconHeader");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "lsRequestHeader", name_len)) {
      int ret_val = lsRequestHeader().JSON_decode(LSRequestHeader_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lsRequestHeader");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "lsReplyHeader", name_len)) {
      int ret_val = lsReplyHeader().JSON_decode(LSReplyHeader_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lsReplyHeader");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "anyHeader", name_len)) {
      int ret_val = anyHeader().JSON_decode(AnyHeader_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "anyHeader");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void ExtendedHeader_template::copy_value(const ExtendedHeader& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case ExtendedHeader::ALT_geoUnicastHeader:
single_value.field_geoUnicastHeader = new GeoUnicastHeader_template(other_value.geoUnicastHeader());
break;
case ExtendedHeader::ALT_tsbHeader:
single_value.field_tsbHeader = new TSBHeader_template(other_value.tsbHeader());
break;
case ExtendedHeader::ALT_shbHeader:
single_value.field_shbHeader = new SHBHeader_template(other_value.shbHeader());
break;
case ExtendedHeader::ALT_geoBroadcastHeader:
single_value.field_geoBroadcastHeader = new GeoAnycastHeader_template(other_value.geoBroadcastHeader());
break;
case ExtendedHeader::ALT_geoAnycastHeader:
single_value.field_geoAnycastHeader = new GeoAnycastHeader_template(other_value.geoAnycastHeader());
break;
case ExtendedHeader::ALT_beaconHeader:
single_value.field_beaconHeader = new BeaconHeader_template(other_value.beaconHeader());
break;
case ExtendedHeader::ALT_lsRequestHeader:
single_value.field_lsRequestHeader = new LSRequestHeader_template(other_value.lsRequestHeader());
break;
case ExtendedHeader::ALT_lsReplyHeader:
single_value.field_lsReplyHeader = new LSReplyHeader_template(other_value.lsReplyHeader());
break;
case ExtendedHeader::ALT_anyHeader:
single_value.field_anyHeader = new AnyHeader_template(other_value.anyHeader());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
}
set_selection(SPECIFIC_VALUE);
}

void ExtendedHeader_template::copy_template(const ExtendedHeader_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case ExtendedHeader::ALT_geoUnicastHeader:
single_value.field_geoUnicastHeader = new GeoUnicastHeader_template(*other_value.single_value.field_geoUnicastHeader);
break;
case ExtendedHeader::ALT_tsbHeader:
single_value.field_tsbHeader = new TSBHeader_template(*other_value.single_value.field_tsbHeader);
break;
case ExtendedHeader::ALT_shbHeader:
single_value.field_shbHeader = new SHBHeader_template(*other_value.single_value.field_shbHeader);
break;
case ExtendedHeader::ALT_geoBroadcastHeader:
single_value.field_geoBroadcastHeader = new GeoAnycastHeader_template(*other_value.single_value.field_geoBroadcastHeader);
break;
case ExtendedHeader::ALT_geoAnycastHeader:
single_value.field_geoAnycastHeader = new GeoAnycastHeader_template(*other_value.single_value.field_geoAnycastHeader);
break;
case ExtendedHeader::ALT_beaconHeader:
single_value.field_beaconHeader = new BeaconHeader_template(*other_value.single_value.field_beaconHeader);
break;
case ExtendedHeader::ALT_lsRequestHeader:
single_value.field_lsRequestHeader = new LSRequestHeader_template(*other_value.single_value.field_lsRequestHeader);
break;
case ExtendedHeader::ALT_lsReplyHeader:
single_value.field_lsReplyHeader = new LSReplyHeader_template(*other_value.single_value.field_lsReplyHeader);
break;
case ExtendedHeader::ALT_anyHeader:
single_value.field_anyHeader = new AnyHeader_template(*other_value.single_value.field_anyHeader);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ExtendedHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
}
set_selection(other_value);
}

ExtendedHeader_template::ExtendedHeader_template()
{
}

ExtendedHeader_template::ExtendedHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ExtendedHeader_template::ExtendedHeader_template(const ExtendedHeader& other_value)
{
copy_value(other_value);
}

ExtendedHeader_template::ExtendedHeader_template(const OPTIONAL<ExtendedHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtendedHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader from an unbound optional field.");
}
}

ExtendedHeader_template::ExtendedHeader_template(const ExtendedHeader_template& other_value)
: Base_Template(){
copy_template(other_value);
}

ExtendedHeader_template::~ExtendedHeader_template()
{
clean_up();
}

void ExtendedHeader_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ExtendedHeader::ALT_geoUnicastHeader:
delete single_value.field_geoUnicastHeader;
break;
case ExtendedHeader::ALT_tsbHeader:
delete single_value.field_tsbHeader;
break;
case ExtendedHeader::ALT_shbHeader:
delete single_value.field_shbHeader;
break;
case ExtendedHeader::ALT_geoBroadcastHeader:
delete single_value.field_geoBroadcastHeader;
break;
case ExtendedHeader::ALT_geoAnycastHeader:
delete single_value.field_geoAnycastHeader;
break;
case ExtendedHeader::ALT_beaconHeader:
delete single_value.field_beaconHeader;
break;
case ExtendedHeader::ALT_lsRequestHeader:
delete single_value.field_lsRequestHeader;
break;
case ExtendedHeader::ALT_lsReplyHeader:
delete single_value.field_lsReplyHeader;
break;
case ExtendedHeader::ALT_anyHeader:
delete single_value.field_anyHeader;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ExtendedHeader_template& ExtendedHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ExtendedHeader_template& ExtendedHeader_template::operator=(const ExtendedHeader& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ExtendedHeader_template& ExtendedHeader_template::operator=(const OPTIONAL<ExtendedHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ExtendedHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
}
return *this;
}

ExtendedHeader_template& ExtendedHeader_template::operator=(const ExtendedHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ExtendedHeader_template::match(const ExtendedHeader& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
ExtendedHeader::union_selection_type value_selection = other_value.get_selection();
if (value_selection == ExtendedHeader::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case ExtendedHeader::ALT_geoUnicastHeader:
return single_value.field_geoUnicastHeader->match(other_value.geoUnicastHeader(), legacy);
case ExtendedHeader::ALT_tsbHeader:
return single_value.field_tsbHeader->match(other_value.tsbHeader(), legacy);
case ExtendedHeader::ALT_shbHeader:
return single_value.field_shbHeader->match(other_value.shbHeader(), legacy);
case ExtendedHeader::ALT_geoBroadcastHeader:
return single_value.field_geoBroadcastHeader->match(other_value.geoBroadcastHeader(), legacy);
case ExtendedHeader::ALT_geoAnycastHeader:
return single_value.field_geoAnycastHeader->match(other_value.geoAnycastHeader(), legacy);
case ExtendedHeader::ALT_beaconHeader:
return single_value.field_beaconHeader->match(other_value.beaconHeader(), legacy);
case ExtendedHeader::ALT_lsRequestHeader:
return single_value.field_lsRequestHeader->match(other_value.lsRequestHeader(), legacy);
case ExtendedHeader::ALT_lsReplyHeader:
return single_value.field_lsReplyHeader->match(other_value.lsReplyHeader(), legacy);
case ExtendedHeader::ALT_anyHeader:
return single_value.field_anyHeader->match(other_value.anyHeader(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
}
return FALSE;
}

boolean ExtendedHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case ExtendedHeader::ALT_geoUnicastHeader:
return single_value.field_geoUnicastHeader->is_value();
case ExtendedHeader::ALT_tsbHeader:
return single_value.field_tsbHeader->is_value();
case ExtendedHeader::ALT_shbHeader:
return single_value.field_shbHeader->is_value();
case ExtendedHeader::ALT_geoBroadcastHeader:
return single_value.field_geoBroadcastHeader->is_value();
case ExtendedHeader::ALT_geoAnycastHeader:
return single_value.field_geoAnycastHeader->is_value();
case ExtendedHeader::ALT_beaconHeader:
return single_value.field_beaconHeader->is_value();
case ExtendedHeader::ALT_lsRequestHeader:
return single_value.field_lsRequestHeader->is_value();
case ExtendedHeader::ALT_lsReplyHeader:
return single_value.field_lsReplyHeader->is_value();
case ExtendedHeader::ALT_anyHeader:
return single_value.field_anyHeader->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
}
}

ExtendedHeader ExtendedHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
ExtendedHeader ret_val;
switch (single_value.union_selection) {
case ExtendedHeader::ALT_geoUnicastHeader:
ret_val.geoUnicastHeader() = single_value.field_geoUnicastHeader->valueof();
break;
case ExtendedHeader::ALT_tsbHeader:
ret_val.tsbHeader() = single_value.field_tsbHeader->valueof();
break;
case ExtendedHeader::ALT_shbHeader:
ret_val.shbHeader() = single_value.field_shbHeader->valueof();
break;
case ExtendedHeader::ALT_geoBroadcastHeader:
ret_val.geoBroadcastHeader() = single_value.field_geoBroadcastHeader->valueof();
break;
case ExtendedHeader::ALT_geoAnycastHeader:
ret_val.geoAnycastHeader() = single_value.field_geoAnycastHeader->valueof();
break;
case ExtendedHeader::ALT_beaconHeader:
ret_val.beaconHeader() = single_value.field_beaconHeader->valueof();
break;
case ExtendedHeader::ALT_lsRequestHeader:
ret_val.lsRequestHeader() = single_value.field_lsRequestHeader->valueof();
break;
case ExtendedHeader::ALT_lsReplyHeader:
ret_val.lsReplyHeader() = single_value.field_lsReplyHeader->valueof();
break;
case ExtendedHeader::ALT_anyHeader:
ret_val.anyHeader() = single_value.field_anyHeader->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
}
return ret_val;
}

ExtendedHeader_template& ExtendedHeader_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return value_list.list_value[list_index];
}
void ExtendedHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ExtendedHeader_template[list_length];
}

GeoUnicastHeader_template& ExtendedHeader_template::geoUnicastHeader()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtendedHeader::ALT_geoUnicastHeader) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_geoUnicastHeader = new GeoUnicastHeader_template(ANY_VALUE);
else single_value.field_geoUnicastHeader = new GeoUnicastHeader_template;
single_value.union_selection = ExtendedHeader::ALT_geoUnicastHeader;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_geoUnicastHeader;
}

const GeoUnicastHeader_template& ExtendedHeader_template::geoUnicastHeader() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field geoUnicastHeader in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
if (single_value.union_selection != ExtendedHeader::ALT_geoUnicastHeader) TTCN_error("Accessing non-selected field geoUnicastHeader in a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *single_value.field_geoUnicastHeader;
}

TSBHeader_template& ExtendedHeader_template::tsbHeader()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtendedHeader::ALT_tsbHeader) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_tsbHeader = new TSBHeader_template(ANY_VALUE);
else single_value.field_tsbHeader = new TSBHeader_template;
single_value.union_selection = ExtendedHeader::ALT_tsbHeader;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_tsbHeader;
}

const TSBHeader_template& ExtendedHeader_template::tsbHeader() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field tsbHeader in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
if (single_value.union_selection != ExtendedHeader::ALT_tsbHeader) TTCN_error("Accessing non-selected field tsbHeader in a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *single_value.field_tsbHeader;
}

SHBHeader_template& ExtendedHeader_template::shbHeader()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtendedHeader::ALT_shbHeader) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_shbHeader = new SHBHeader_template(ANY_VALUE);
else single_value.field_shbHeader = new SHBHeader_template;
single_value.union_selection = ExtendedHeader::ALT_shbHeader;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_shbHeader;
}

const SHBHeader_template& ExtendedHeader_template::shbHeader() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field shbHeader in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
if (single_value.union_selection != ExtendedHeader::ALT_shbHeader) TTCN_error("Accessing non-selected field shbHeader in a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *single_value.field_shbHeader;
}

GeoAnycastHeader_template& ExtendedHeader_template::geoBroadcastHeader()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtendedHeader::ALT_geoBroadcastHeader) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_geoBroadcastHeader = new GeoAnycastHeader_template(ANY_VALUE);
else single_value.field_geoBroadcastHeader = new GeoAnycastHeader_template;
single_value.union_selection = ExtendedHeader::ALT_geoBroadcastHeader;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_geoBroadcastHeader;
}

const GeoAnycastHeader_template& ExtendedHeader_template::geoBroadcastHeader() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field geoBroadcastHeader in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
if (single_value.union_selection != ExtendedHeader::ALT_geoBroadcastHeader) TTCN_error("Accessing non-selected field geoBroadcastHeader in a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *single_value.field_geoBroadcastHeader;
}

GeoAnycastHeader_template& ExtendedHeader_template::geoAnycastHeader()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtendedHeader::ALT_geoAnycastHeader) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_geoAnycastHeader = new GeoAnycastHeader_template(ANY_VALUE);
else single_value.field_geoAnycastHeader = new GeoAnycastHeader_template;
single_value.union_selection = ExtendedHeader::ALT_geoAnycastHeader;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_geoAnycastHeader;
}

const GeoAnycastHeader_template& ExtendedHeader_template::geoAnycastHeader() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field geoAnycastHeader in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
if (single_value.union_selection != ExtendedHeader::ALT_geoAnycastHeader) TTCN_error("Accessing non-selected field geoAnycastHeader in a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *single_value.field_geoAnycastHeader;
}

BeaconHeader_template& ExtendedHeader_template::beaconHeader()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtendedHeader::ALT_beaconHeader) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_beaconHeader = new BeaconHeader_template(ANY_VALUE);
else single_value.field_beaconHeader = new BeaconHeader_template;
single_value.union_selection = ExtendedHeader::ALT_beaconHeader;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_beaconHeader;
}

const BeaconHeader_template& ExtendedHeader_template::beaconHeader() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field beaconHeader in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
if (single_value.union_selection != ExtendedHeader::ALT_beaconHeader) TTCN_error("Accessing non-selected field beaconHeader in a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *single_value.field_beaconHeader;
}

LSRequestHeader_template& ExtendedHeader_template::lsRequestHeader()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtendedHeader::ALT_lsRequestHeader) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_lsRequestHeader = new LSRequestHeader_template(ANY_VALUE);
else single_value.field_lsRequestHeader = new LSRequestHeader_template;
single_value.union_selection = ExtendedHeader::ALT_lsRequestHeader;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_lsRequestHeader;
}

const LSRequestHeader_template& ExtendedHeader_template::lsRequestHeader() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field lsRequestHeader in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
if (single_value.union_selection != ExtendedHeader::ALT_lsRequestHeader) TTCN_error("Accessing non-selected field lsRequestHeader in a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *single_value.field_lsRequestHeader;
}

LSReplyHeader_template& ExtendedHeader_template::lsReplyHeader()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtendedHeader::ALT_lsReplyHeader) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_lsReplyHeader = new LSReplyHeader_template(ANY_VALUE);
else single_value.field_lsReplyHeader = new LSReplyHeader_template;
single_value.union_selection = ExtendedHeader::ALT_lsReplyHeader;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_lsReplyHeader;
}

const LSReplyHeader_template& ExtendedHeader_template::lsReplyHeader() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field lsReplyHeader in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
if (single_value.union_selection != ExtendedHeader::ALT_lsReplyHeader) TTCN_error("Accessing non-selected field lsReplyHeader in a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *single_value.field_lsReplyHeader;
}

AnyHeader_template& ExtendedHeader_template::anyHeader()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ExtendedHeader::ALT_anyHeader) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_anyHeader = new AnyHeader_template(ANY_VALUE);
else single_value.field_anyHeader = new AnyHeader_template;
single_value.union_selection = ExtendedHeader::ALT_anyHeader;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_anyHeader;
}

const AnyHeader_template& ExtendedHeader_template::anyHeader() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field anyHeader in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
if (single_value.union_selection != ExtendedHeader::ALT_anyHeader) TTCN_error("Accessing non-selected field anyHeader in a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return *single_value.field_anyHeader;
}

boolean ExtendedHeader_template::ischosen(ExtendedHeader::union_selection_type checked_selection) const
{
if (checked_selection == ExtendedHeader::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == ExtendedHeader::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader");
}
return FALSE;
}

void ExtendedHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ExtendedHeader::ALT_geoUnicastHeader:
TTCN_Logger::log_event_str("{ geoUnicastHeader := ");
single_value.field_geoUnicastHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtendedHeader::ALT_tsbHeader:
TTCN_Logger::log_event_str("{ tsbHeader := ");
single_value.field_tsbHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtendedHeader::ALT_shbHeader:
TTCN_Logger::log_event_str("{ shbHeader := ");
single_value.field_shbHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtendedHeader::ALT_geoBroadcastHeader:
TTCN_Logger::log_event_str("{ geoBroadcastHeader := ");
single_value.field_geoBroadcastHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtendedHeader::ALT_geoAnycastHeader:
TTCN_Logger::log_event_str("{ geoAnycastHeader := ");
single_value.field_geoAnycastHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtendedHeader::ALT_beaconHeader:
TTCN_Logger::log_event_str("{ beaconHeader := ");
single_value.field_beaconHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtendedHeader::ALT_lsRequestHeader:
TTCN_Logger::log_event_str("{ lsRequestHeader := ");
single_value.field_lsRequestHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtendedHeader::ALT_lsReplyHeader:
TTCN_Logger::log_event_str("{ lsReplyHeader := ");
single_value.field_lsReplyHeader->log();
TTCN_Logger::log_event_str(" }");
break;
case ExtendedHeader::ALT_anyHeader:
TTCN_Logger::log_event_str("{ anyHeader := ");
single_value.field_anyHeader->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ExtendedHeader_template::log_match(const ExtendedHeader& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case ExtendedHeader::ALT_geoUnicastHeader:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".geoUnicastHeader");
single_value.field_geoUnicastHeader->log_match(match_value.geoUnicastHeader(), legacy);
} else {
TTCN_Logger::log_event_str("{ geoUnicastHeader := ");
single_value.field_geoUnicastHeader->log_match(match_value.geoUnicastHeader(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtendedHeader::ALT_tsbHeader:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".tsbHeader");
single_value.field_tsbHeader->log_match(match_value.tsbHeader(), legacy);
} else {
TTCN_Logger::log_event_str("{ tsbHeader := ");
single_value.field_tsbHeader->log_match(match_value.tsbHeader(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtendedHeader::ALT_shbHeader:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".shbHeader");
single_value.field_shbHeader->log_match(match_value.shbHeader(), legacy);
} else {
TTCN_Logger::log_event_str("{ shbHeader := ");
single_value.field_shbHeader->log_match(match_value.shbHeader(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtendedHeader::ALT_geoBroadcastHeader:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".geoBroadcastHeader");
single_value.field_geoBroadcastHeader->log_match(match_value.geoBroadcastHeader(), legacy);
} else {
TTCN_Logger::log_event_str("{ geoBroadcastHeader := ");
single_value.field_geoBroadcastHeader->log_match(match_value.geoBroadcastHeader(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtendedHeader::ALT_geoAnycastHeader:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".geoAnycastHeader");
single_value.field_geoAnycastHeader->log_match(match_value.geoAnycastHeader(), legacy);
} else {
TTCN_Logger::log_event_str("{ geoAnycastHeader := ");
single_value.field_geoAnycastHeader->log_match(match_value.geoAnycastHeader(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtendedHeader::ALT_beaconHeader:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".beaconHeader");
single_value.field_beaconHeader->log_match(match_value.beaconHeader(), legacy);
} else {
TTCN_Logger::log_event_str("{ beaconHeader := ");
single_value.field_beaconHeader->log_match(match_value.beaconHeader(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtendedHeader::ALT_lsRequestHeader:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".lsRequestHeader");
single_value.field_lsRequestHeader->log_match(match_value.lsRequestHeader(), legacy);
} else {
TTCN_Logger::log_event_str("{ lsRequestHeader := ");
single_value.field_lsRequestHeader->log_match(match_value.lsRequestHeader(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtendedHeader::ALT_lsReplyHeader:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".lsReplyHeader");
single_value.field_lsReplyHeader->log_match(match_value.lsReplyHeader(), legacy);
} else {
TTCN_Logger::log_event_str("{ lsReplyHeader := ");
single_value.field_lsReplyHeader->log_match(match_value.lsReplyHeader(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ExtendedHeader::ALT_anyHeader:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".anyHeader");
single_value.field_anyHeader->log_match(match_value.anyHeader(), legacy);
} else {
TTCN_Logger::log_event_str("{ anyHeader := ");
single_value.field_anyHeader->log_match(match_value.anyHeader(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ExtendedHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case ExtendedHeader::ALT_geoUnicastHeader:
single_value.field_geoUnicastHeader->encode_text(text_buf);
break;
case ExtendedHeader::ALT_tsbHeader:
single_value.field_tsbHeader->encode_text(text_buf);
break;
case ExtendedHeader::ALT_shbHeader:
single_value.field_shbHeader->encode_text(text_buf);
break;
case ExtendedHeader::ALT_geoBroadcastHeader:
single_value.field_geoBroadcastHeader->encode_text(text_buf);
break;
case ExtendedHeader::ALT_geoAnycastHeader:
single_value.field_geoAnycastHeader->encode_text(text_buf);
break;
case ExtendedHeader::ALT_beaconHeader:
single_value.field_beaconHeader->encode_text(text_buf);
break;
case ExtendedHeader::ALT_lsRequestHeader:
single_value.field_lsRequestHeader->encode_text(text_buf);
break;
case ExtendedHeader::ALT_lsReplyHeader:
single_value.field_lsReplyHeader->encode_text(text_buf);
break;
case ExtendedHeader::ALT_anyHeader:
single_value.field_anyHeader->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
}
}

void ExtendedHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = ExtendedHeader::UNBOUND_VALUE;
ExtendedHeader::union_selection_type new_selection = (ExtendedHeader::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case ExtendedHeader::ALT_geoUnicastHeader:
single_value.field_geoUnicastHeader = new GeoUnicastHeader_template;
single_value.field_geoUnicastHeader->decode_text(text_buf);
break;
case ExtendedHeader::ALT_tsbHeader:
single_value.field_tsbHeader = new TSBHeader_template;
single_value.field_tsbHeader->decode_text(text_buf);
break;
case ExtendedHeader::ALT_shbHeader:
single_value.field_shbHeader = new SHBHeader_template;
single_value.field_shbHeader->decode_text(text_buf);
break;
case ExtendedHeader::ALT_geoBroadcastHeader:
single_value.field_geoBroadcastHeader = new GeoAnycastHeader_template;
single_value.field_geoBroadcastHeader->decode_text(text_buf);
break;
case ExtendedHeader::ALT_geoAnycastHeader:
single_value.field_geoAnycastHeader = new GeoAnycastHeader_template;
single_value.field_geoAnycastHeader->decode_text(text_buf);
break;
case ExtendedHeader::ALT_beaconHeader:
single_value.field_beaconHeader = new BeaconHeader_template;
single_value.field_beaconHeader->decode_text(text_buf);
break;
case ExtendedHeader::ALT_lsRequestHeader:
single_value.field_lsRequestHeader = new LSRequestHeader_template;
single_value.field_lsRequestHeader->decode_text(text_buf);
break;
case ExtendedHeader::ALT_lsReplyHeader:
single_value.field_lsReplyHeader = new LSReplyHeader_template;
single_value.field_lsReplyHeader->decode_text(text_buf);
break;
case ExtendedHeader::ALT_anyHeader:
single_value.field_anyHeader = new AnyHeader_template;
single_value.field_anyHeader->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ExtendedHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
}
}

boolean ExtendedHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ExtendedHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ExtendedHeader_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsGeoNetworking_TypesAndValues.ExtendedHeader'");
    }
    if (strcmp("geoUnicastHeader", param_field) == 0) {
      geoUnicastHeader().set_param(param);
      return;
    } else if (strcmp("tsbHeader", param_field) == 0) {
      tsbHeader().set_param(param);
      return;
    } else if (strcmp("shbHeader", param_field) == 0) {
      shbHeader().set_param(param);
      return;
    } else if (strcmp("geoBroadcastHeader", param_field) == 0) {
      geoBroadcastHeader().set_param(param);
      return;
    } else if (strcmp("geoAnycastHeader", param_field) == 0) {
      geoAnycastHeader().set_param(param);
      return;
    } else if (strcmp("beaconHeader", param_field) == 0) {
      beaconHeader().set_param(param);
      return;
    } else if (strcmp("lsRequestHeader", param_field) == 0) {
      lsRequestHeader().set_param(param);
      return;
    } else if (strcmp("lsReplyHeader", param_field) == 0) {
      lsReplyHeader().set_param(param);
      return;
    } else if (strcmp("anyHeader", param_field) == 0) {
      anyHeader().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsGeoNetworking_TypesAndValues.ExtendedHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ExtendedHeader_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsGeoNetworking_TypesAndValues.ExtendedHeader");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "geoUnicastHeader")) {
      geoUnicastHeader().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "tsbHeader")) {
      tsbHeader().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "shbHeader")) {
      shbHeader().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "geoBroadcastHeader")) {
      geoBroadcastHeader().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "geoAnycastHeader")) {
      geoAnycastHeader().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "beaconHeader")) {
      beaconHeader().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "lsRequestHeader")) {
      lsRequestHeader().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "lsReplyHeader")) {
      lsReplyHeader().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "anyHeader")) {
      anyHeader().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsGeoNetworking_TypesAndValues.ExtendedHeader");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ExtendedHeader_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsGeoNetworking_TypesAndValues.ExtendedHeader'");
    }
    if (strcmp("geoUnicastHeader", param_field) == 0) {
      return geoUnicastHeader().get_param(param_name);
    } else if (strcmp("tsbHeader", param_field) == 0) {
      return tsbHeader().get_param(param_name);
    } else if (strcmp("shbHeader", param_field) == 0) {
      return shbHeader().get_param(param_name);
    } else if (strcmp("geoBroadcastHeader", param_field) == 0) {
      return geoBroadcastHeader().get_param(param_name);
    } else if (strcmp("geoAnycastHeader", param_field) == 0) {
      return geoAnycastHeader().get_param(param_name);
    } else if (strcmp("beaconHeader", param_field) == 0) {
      return beaconHeader().get_param(param_name);
    } else if (strcmp("lsRequestHeader", param_field) == 0) {
      return lsRequestHeader().get_param(param_name);
    } else if (strcmp("lsReplyHeader", param_field) == 0) {
      return lsReplyHeader().get_param(param_name);
    } else if (strcmp("anyHeader", param_field) == 0) {
      return anyHeader().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `ExtendedHeader'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case ExtendedHeader::ALT_geoUnicastHeader:
      mp_field = single_value.field_geoUnicastHeader->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("geoUnicastHeader")));
      break;
    case ExtendedHeader::ALT_tsbHeader:
      mp_field = single_value.field_tsbHeader->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("tsbHeader")));
      break;
    case ExtendedHeader::ALT_shbHeader:
      mp_field = single_value.field_shbHeader->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("shbHeader")));
      break;
    case ExtendedHeader::ALT_geoBroadcastHeader:
      mp_field = single_value.field_geoBroadcastHeader->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("geoBroadcastHeader")));
      break;
    case ExtendedHeader::ALT_geoAnycastHeader:
      mp_field = single_value.field_geoAnycastHeader->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("geoAnycastHeader")));
      break;
    case ExtendedHeader::ALT_beaconHeader:
      mp_field = single_value.field_beaconHeader->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("beaconHeader")));
      break;
    case ExtendedHeader::ALT_lsRequestHeader:
      mp_field = single_value.field_lsRequestHeader->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("lsRequestHeader")));
      break;
    case ExtendedHeader::ALT_lsReplyHeader:
      mp_field = single_value.field_lsReplyHeader->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("lsReplyHeader")));
      break;
    case ExtendedHeader::ALT_anyHeader:
      mp_field = single_value.field_anyHeader->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("anyHeader")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ExtendedHeader_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case ExtendedHeader::ALT_geoUnicastHeader:
single_value.field_geoUnicastHeader->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.ExtendedHeader");
return;
case ExtendedHeader::ALT_tsbHeader:
single_value.field_tsbHeader->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.ExtendedHeader");
return;
case ExtendedHeader::ALT_shbHeader:
single_value.field_shbHeader->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.ExtendedHeader");
return;
case ExtendedHeader::ALT_geoBroadcastHeader:
single_value.field_geoBroadcastHeader->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.ExtendedHeader");
return;
case ExtendedHeader::ALT_geoAnycastHeader:
single_value.field_geoAnycastHeader->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.ExtendedHeader");
return;
case ExtendedHeader::ALT_beaconHeader:
single_value.field_beaconHeader->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.ExtendedHeader");
return;
case ExtendedHeader::ALT_lsRequestHeader:
single_value.field_lsRequestHeader->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.ExtendedHeader");
return;
case ExtendedHeader::ALT_lsReplyHeader:
single_value.field_lsReplyHeader->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.ExtendedHeader");
return;
case ExtendedHeader::ALT_anyHeader:
single_value.field_anyHeader->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.ExtendedHeader");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsGeoNetworking_TypesAndValues.ExtendedHeader.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.ExtendedHeader");
}

ShortPosVector::ShortPosVector()
{
  bound_flag = FALSE;
}

ShortPosVector::ShortPosVector(const GN__Address& par_gnAddr,
    const INTEGER& par_timestamp,
    const INTEGER& par_latitude,
    const INTEGER& par_longitude)
  :   field_gnAddr(par_gnAddr),
  field_timestamp(par_timestamp),
  field_latitude(par_latitude),
  field_longitude(par_longitude)
{
  bound_flag = TRUE;
}

ShortPosVector::ShortPosVector(const ShortPosVector& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
bound_flag = TRUE;
if (other_value.gnAddr().is_bound()) field_gnAddr = other_value.gnAddr();
else field_gnAddr.clean_up();
if (other_value.timestamp().is_bound()) field_timestamp = other_value.timestamp();
else field_timestamp.clean_up();
if (other_value.latitude().is_bound()) field_latitude = other_value.latitude();
else field_latitude.clean_up();
if (other_value.longitude().is_bound()) field_longitude = other_value.longitude();
else field_longitude.clean_up();
}

void ShortPosVector::clean_up()
{
field_gnAddr.clean_up();
field_timestamp.clean_up();
field_latitude.clean_up();
field_longitude.clean_up();
bound_flag = FALSE;
}

ShortPosVector& ShortPosVector::operator=(const ShortPosVector& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
  bound_flag = TRUE;
  if (other_value.gnAddr().is_bound()) field_gnAddr = other_value.gnAddr();
  else field_gnAddr.clean_up();
  if (other_value.timestamp().is_bound()) field_timestamp = other_value.timestamp();
  else field_timestamp.clean_up();
  if (other_value.latitude().is_bound()) field_latitude = other_value.latitude();
  else field_latitude.clean_up();
  if (other_value.longitude().is_bound()) field_longitude = other_value.longitude();
  else field_longitude.clean_up();
}
return *this;
}

boolean ShortPosVector::operator==(const ShortPosVector& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_gnAddr==other_value.field_gnAddr
  && field_timestamp==other_value.field_timestamp
  && field_latitude==other_value.field_latitude
  && field_longitude==other_value.field_longitude;
}

boolean ShortPosVector::is_bound() const
{
if (bound_flag) return TRUE;
if(field_gnAddr.is_bound()) return TRUE;
if(field_timestamp.is_bound()) return TRUE;
if(field_latitude.is_bound()) return TRUE;
if(field_longitude.is_bound()) return TRUE;
return FALSE;
}
boolean ShortPosVector::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_gnAddr.is_value()) return FALSE;
if(!field_timestamp.is_value()) return FALSE;
if(!field_latitude.is_value()) return FALSE;
if(!field_longitude.is_value()) return FALSE;
return TRUE;
}
int ShortPosVector::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector");
  return 4;
}

void ShortPosVector::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ gnAddr := ");
field_gnAddr.log();
TTCN_Logger::log_event_str(", timestamp := ");
field_timestamp.log();
TTCN_Logger::log_event_str(", latitude := ");
field_latitude.log();
TTCN_Logger::log_event_str(", longitude := ");
field_longitude.log();
TTCN_Logger::log_event_str(" }");
}

void ShortPosVector::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.ShortPosVector'");
    }
    if (strcmp("gnAddr", param_field) == 0) {
      gnAddr().set_param(param);
      return;
    } else if (strcmp("timestamp", param_field) == 0) {
      timestamp().set_param(param);
      return;
    } else if (strcmp("latitude", param_field) == 0) {
      latitude().set_param(param);
      return;
    } else if (strcmp("longitude", param_field) == 0) {
      longitude().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.ShortPosVector'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) gnAddr().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) timestamp().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) latitude().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) longitude().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnAddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnAddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "timestamp")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          timestamp().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "latitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          latitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "longitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          longitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.ShortPosVector: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.ShortPosVector");
  }
}

Module_Param* ShortPosVector::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.ShortPosVector'");
    }
    if (strcmp("gnAddr", param_field) == 0) {
      return gnAddr().get_param(param_name);
    } else if (strcmp("timestamp", param_field) == 0) {
      return timestamp().get_param(param_name);
    } else if (strcmp("latitude", param_field) == 0) {
      return latitude().get_param(param_name);
    } else if (strcmp("longitude", param_field) == 0) {
      return longitude().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.ShortPosVector'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_gnAddr = field_gnAddr.get_param(param_name);
  mp_field_gnAddr->set_id(new Module_Param_FieldName(mcopystr("gnAddr")));
  mp->add_elem(mp_field_gnAddr);
  Module_Param* mp_field_timestamp = field_timestamp.get_param(param_name);
  mp_field_timestamp->set_id(new Module_Param_FieldName(mcopystr("timestamp")));
  mp->add_elem(mp_field_timestamp);
  Module_Param* mp_field_latitude = field_latitude.get_param(param_name);
  mp_field_latitude->set_id(new Module_Param_FieldName(mcopystr("latitude")));
  mp->add_elem(mp_field_latitude);
  Module_Param* mp_field_longitude = field_longitude.get_param(param_name);
  mp_field_longitude->set_id(new Module_Param_FieldName(mcopystr("longitude")));
  mp->add_elem(mp_field_longitude);
  return mp;
  }

void ShortPosVector::set_implicit_omit()
{
if (gnAddr().is_bound()) gnAddr().set_implicit_omit();
if (timestamp().is_bound()) timestamp().set_implicit_omit();
if (latitude().is_bound()) latitude().set_implicit_omit();
if (longitude().is_bound()) longitude().set_implicit_omit();
}

void ShortPosVector::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
field_gnAddr.encode_text(text_buf);
field_timestamp.encode_text(text_buf);
field_latitude.encode_text(text_buf);
field_longitude.encode_text(text_buf);
}

void ShortPosVector::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_gnAddr.decode_text(text_buf);
field_timestamp.decode_text(text_buf);
field_latitude.decode_text(text_buf);
field_longitude.decode_text(text_buf);
}

void ShortPosVector::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ShortPosVector::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ShortPosVector::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_gnAddr.RAW_decode(GN__Address_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_timestamp.RAW_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_latitude.RAW_decode(LibCommon__BasicTypesAndValues::Int32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_longitude.RAW_decode(LibCommon__BasicTypesAndValues::Int32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ShortPosVector::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 4;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(4);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, GN__Address_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt32_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__BasicTypesAndValues::Int32_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, LibCommon__BasicTypesAndValues::Int32_descr_.raw);
  encoded_length += field_gnAddr.RAW_encode(GN__Address_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_timestamp.RAW_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_latitude.RAW_encode(LibCommon__BasicTypesAndValues::Int32_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_longitude.RAW_encode(LibCommon__BasicTypesAndValues::Int32_descr_, *myleaf.body.node.nodes[3]);
  return myleaf.length = encoded_length;
}

int ShortPosVector::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnAddr");
    enc_len += field_gnAddr.JSON_encode(GN__Address_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "timestamp");
    enc_len += field_timestamp.JSON_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "latitude");
    enc_len += field_latitude.JSON_encode(LibCommon__BasicTypesAndValues::Int32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "longitude");
    enc_len += field_longitude.JSON_encode(LibCommon__BasicTypesAndValues::Int32_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ShortPosVector::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (6 == name_len && 0 == strncmp(fld_name, "gnAddr", name_len)) {
         int ret_val = field_gnAddr.JSON_decode(GN__Address_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnAddr");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "timestamp", name_len)) {
         int ret_val = field_timestamp.JSON_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "timestamp");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "latitude", name_len)) {
         int ret_val = field_latitude.JSON_decode(LibCommon__BasicTypesAndValues::Int32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "latitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "longitude", name_len)) {
         int ret_val = field_longitude.JSON_decode(LibCommon__BasicTypesAndValues::Int32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "longitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_gnAddr.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnAddr");
    return JSON_ERROR_FATAL;
  }
if (!field_timestamp.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "timestamp");
    return JSON_ERROR_FATAL;
  }
if (!field_latitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "latitude");
    return JSON_ERROR_FATAL;
  }
if (!field_longitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "longitude");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ShortPosVector_template::single_value_struct {
GN__Address_template field_gnAddr;
INTEGER_template field_timestamp;
INTEGER_template field_latitude;
INTEGER_template field_longitude;
};

void ShortPosVector_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_gnAddr = ANY_VALUE;
single_value->field_timestamp = ANY_VALUE;
single_value->field_latitude = ANY_VALUE;
single_value->field_longitude = ANY_VALUE;
}
}
}

void ShortPosVector_template::copy_value(const ShortPosVector& other_value)
{
single_value = new single_value_struct;
if (other_value.gnAddr().is_bound()) {
  single_value->field_gnAddr = other_value.gnAddr();
} else {
  single_value->field_gnAddr.clean_up();
}
if (other_value.timestamp().is_bound()) {
  single_value->field_timestamp = other_value.timestamp();
} else {
  single_value->field_timestamp.clean_up();
}
if (other_value.latitude().is_bound()) {
  single_value->field_latitude = other_value.latitude();
} else {
  single_value->field_latitude.clean_up();
}
if (other_value.longitude().is_bound()) {
  single_value->field_longitude = other_value.longitude();
} else {
  single_value->field_longitude.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ShortPosVector_template::copy_template(const ShortPosVector_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.gnAddr().get_selection()) {
single_value->field_gnAddr = other_value.gnAddr();
} else {
single_value->field_gnAddr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.timestamp().get_selection()) {
single_value->field_timestamp = other_value.timestamp();
} else {
single_value->field_timestamp.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.latitude().get_selection()) {
single_value->field_latitude = other_value.latitude();
} else {
single_value->field_latitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.longitude().get_selection()) {
single_value->field_longitude = other_value.longitude();
} else {
single_value->field_longitude.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ShortPosVector_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
break;
}
set_selection(other_value);
}

ShortPosVector_template::ShortPosVector_template()
{
}

ShortPosVector_template::ShortPosVector_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ShortPosVector_template::ShortPosVector_template(const ShortPosVector& other_value)
{
copy_value(other_value);
}

ShortPosVector_template::ShortPosVector_template(const OPTIONAL<ShortPosVector>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ShortPosVector&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector from an unbound optional field.");
}
}

ShortPosVector_template::ShortPosVector_template(const ShortPosVector_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ShortPosVector_template::~ShortPosVector_template()
{
clean_up();
}

ShortPosVector_template& ShortPosVector_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ShortPosVector_template& ShortPosVector_template::operator=(const ShortPosVector& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ShortPosVector_template& ShortPosVector_template::operator=(const OPTIONAL<ShortPosVector>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ShortPosVector&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
}
return *this;
}

ShortPosVector_template& ShortPosVector_template::operator=(const ShortPosVector_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ShortPosVector_template::match(const ShortPosVector& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.gnAddr().is_bound()) return FALSE;
if(!single_value->field_gnAddr.match(other_value.gnAddr(), legacy))return FALSE;
if(!other_value.timestamp().is_bound()) return FALSE;
if(!single_value->field_timestamp.match(other_value.timestamp(), legacy))return FALSE;
if(!other_value.latitude().is_bound()) return FALSE;
if(!single_value->field_latitude.match(other_value.latitude(), legacy))return FALSE;
if(!other_value.longitude().is_bound()) return FALSE;
if(!single_value->field_longitude.match(other_value.longitude(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
}
return FALSE;
}

boolean ShortPosVector_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_gnAddr.is_bound()) return TRUE;
if (single_value->field_timestamp.is_bound()) return TRUE;
if (single_value->field_latitude.is_bound()) return TRUE;
if (single_value->field_longitude.is_bound()) return TRUE;
return FALSE;
}

boolean ShortPosVector_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_gnAddr.is_value()) return FALSE;
if (!single_value->field_timestamp.is_value()) return FALSE;
if (!single_value->field_latitude.is_value()) return FALSE;
if (!single_value->field_longitude.is_value()) return FALSE;
return TRUE;
}

void ShortPosVector_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ShortPosVector ShortPosVector_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
ShortPosVector ret_val;
if (single_value->field_gnAddr.is_bound()) {
ret_val.gnAddr() = single_value->field_gnAddr.valueof();
}
if (single_value->field_timestamp.is_bound()) {
ret_val.timestamp() = single_value->field_timestamp.valueof();
}
if (single_value->field_latitude.is_bound()) {
ret_val.latitude() = single_value->field_latitude.valueof();
}
if (single_value->field_longitude.is_bound()) {
ret_val.longitude() = single_value->field_longitude.valueof();
}
return ret_val;
}

void ShortPosVector_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ShortPosVector_template[list_length];
}

ShortPosVector_template& ShortPosVector_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
return value_list.list_value[list_index];
}

GN__Address_template& ShortPosVector_template::gnAddr()
{
set_specific();
return single_value->field_gnAddr;
}

const GN__Address_template& ShortPosVector_template::gnAddr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnAddr of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
return single_value->field_gnAddr;
}

INTEGER_template& ShortPosVector_template::timestamp()
{
set_specific();
return single_value->field_timestamp;
}

const INTEGER_template& ShortPosVector_template::timestamp() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field timestamp of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
return single_value->field_timestamp;
}

INTEGER_template& ShortPosVector_template::latitude()
{
set_specific();
return single_value->field_latitude;
}

const INTEGER_template& ShortPosVector_template::latitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field latitude of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
return single_value->field_latitude;
}

INTEGER_template& ShortPosVector_template::longitude()
{
set_specific();
return single_value->field_longitude;
}

const INTEGER_template& ShortPosVector_template::longitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field longitude of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
return single_value->field_longitude;
}

int ShortPosVector_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 4;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
  }
  return 0;
}

void ShortPosVector_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ gnAddr := ");
single_value->field_gnAddr.log();
TTCN_Logger::log_event_str(", timestamp := ");
single_value->field_timestamp.log();
TTCN_Logger::log_event_str(", latitude := ");
single_value->field_latitude.log();
TTCN_Logger::log_event_str(", longitude := ");
single_value->field_longitude.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ShortPosVector_template::log_match(const ShortPosVector& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_gnAddr.match(match_value.gnAddr(), legacy)){
TTCN_Logger::log_logmatch_info(".gnAddr");
single_value->field_gnAddr.log_match(match_value.gnAddr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_timestamp.match(match_value.timestamp(), legacy)){
TTCN_Logger::log_logmatch_info(".timestamp");
single_value->field_timestamp.log_match(match_value.timestamp(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_latitude.match(match_value.latitude(), legacy)){
TTCN_Logger::log_logmatch_info(".latitude");
single_value->field_latitude.log_match(match_value.latitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_longitude.match(match_value.longitude(), legacy)){
TTCN_Logger::log_logmatch_info(".longitude");
single_value->field_longitude.log_match(match_value.longitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ gnAddr := ");
single_value->field_gnAddr.log_match(match_value.gnAddr(), legacy);
TTCN_Logger::log_event_str(", timestamp := ");
single_value->field_timestamp.log_match(match_value.timestamp(), legacy);
TTCN_Logger::log_event_str(", latitude := ");
single_value->field_latitude.log_match(match_value.latitude(), legacy);
TTCN_Logger::log_event_str(", longitude := ");
single_value->field_longitude.log_match(match_value.longitude(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ShortPosVector_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_gnAddr.encode_text(text_buf);
single_value->field_timestamp.encode_text(text_buf);
single_value->field_latitude.encode_text(text_buf);
single_value->field_longitude.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
}
}

void ShortPosVector_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_gnAddr.decode_text(text_buf);
single_value->field_timestamp.decode_text(text_buf);
single_value->field_latitude.decode_text(text_buf);
single_value->field_longitude.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ShortPosVector_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector.");
}
}

void ShortPosVector_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.ShortPosVector'");
    }
    if (strcmp("gnAddr", param_field) == 0) {
      gnAddr().set_param(param);
      return;
    } else if (strcmp("timestamp", param_field) == 0) {
      timestamp().set_param(param);
      return;
    } else if (strcmp("latitude", param_field) == 0) {
      latitude().set_param(param);
      return;
    } else if (strcmp("longitude", param_field) == 0) {
      longitude().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.ShortPosVector'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ShortPosVector_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.ShortPosVector has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) gnAddr().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) timestamp().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) latitude().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) longitude().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnAddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnAddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "timestamp")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          timestamp().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "latitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          latitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "longitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          longitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.ShortPosVector: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.ShortPosVector");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ShortPosVector_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.ShortPosVector'");
    }
    if (strcmp("gnAddr", param_field) == 0) {
      return gnAddr().get_param(param_name);
    } else if (strcmp("timestamp", param_field) == 0) {
      return timestamp().get_param(param_name);
    } else if (strcmp("latitude", param_field) == 0) {
      return latitude().get_param(param_name);
    } else if (strcmp("longitude", param_field) == 0) {
      return longitude().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.ShortPosVector'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_gnAddr = single_value->field_gnAddr.get_param(param_name);
    mp_field_gnAddr->set_id(new Module_Param_FieldName(mcopystr("gnAddr")));
    mp->add_elem(mp_field_gnAddr);
    Module_Param* mp_field_timestamp = single_value->field_timestamp.get_param(param_name);
    mp_field_timestamp->set_id(new Module_Param_FieldName(mcopystr("timestamp")));
    mp->add_elem(mp_field_timestamp);
    Module_Param* mp_field_latitude = single_value->field_latitude.get_param(param_name);
    mp_field_latitude->set_id(new Module_Param_FieldName(mcopystr("latitude")));
    mp->add_elem(mp_field_latitude);
    Module_Param* mp_field_longitude = single_value->field_longitude.get_param(param_name);
    mp_field_longitude->set_id(new Module_Param_FieldName(mcopystr("longitude")));
    mp->add_elem(mp_field_longitude);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ShortPosVector_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_gnAddr.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.ShortPosVector");
single_value->field_timestamp.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.ShortPosVector");
single_value->field_latitude.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.ShortPosVector");
single_value->field_longitude.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.ShortPosVector");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.ShortPosVector");
}

boolean ShortPosVector_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ShortPosVector_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

GeoUnicastHeader::GeoUnicastHeader()
{
  bound_flag = FALSE;
}

GeoUnicastHeader::GeoUnicastHeader(const INTEGER& par_seqNumber,
    const INTEGER& par_reserved,
    const LongPosVector& par_srcPosVector,
    const ShortPosVector& par_dstPosVector)
  :   field_seqNumber(par_seqNumber),
  field_reserved(par_reserved),
  field_srcPosVector(par_srcPosVector),
  field_dstPosVector(par_dstPosVector)
{
  bound_flag = TRUE;
}

GeoUnicastHeader::GeoUnicastHeader(const GeoUnicastHeader& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
bound_flag = TRUE;
if (other_value.seqNumber().is_bound()) field_seqNumber = other_value.seqNumber();
else field_seqNumber.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
if (other_value.srcPosVector().is_bound()) field_srcPosVector = other_value.srcPosVector();
else field_srcPosVector.clean_up();
if (other_value.dstPosVector().is_bound()) field_dstPosVector = other_value.dstPosVector();
else field_dstPosVector.clean_up();
}

void GeoUnicastHeader::clean_up()
{
field_seqNumber.clean_up();
field_reserved.clean_up();
field_srcPosVector.clean_up();
field_dstPosVector.clean_up();
bound_flag = FALSE;
}

GeoUnicastHeader& GeoUnicastHeader::operator=(const GeoUnicastHeader& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
  bound_flag = TRUE;
  if (other_value.seqNumber().is_bound()) field_seqNumber = other_value.seqNumber();
  else field_seqNumber.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
  if (other_value.srcPosVector().is_bound()) field_srcPosVector = other_value.srcPosVector();
  else field_srcPosVector.clean_up();
  if (other_value.dstPosVector().is_bound()) field_dstPosVector = other_value.dstPosVector();
  else field_dstPosVector.clean_up();
}
return *this;
}

boolean GeoUnicastHeader::operator==(const GeoUnicastHeader& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_seqNumber==other_value.field_seqNumber
  && field_reserved==other_value.field_reserved
  && field_srcPosVector==other_value.field_srcPosVector
  && field_dstPosVector==other_value.field_dstPosVector;
}

boolean GeoUnicastHeader::is_bound() const
{
if (bound_flag) return TRUE;
if(field_seqNumber.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
if(field_srcPosVector.is_bound()) return TRUE;
if(field_dstPosVector.is_bound()) return TRUE;
return FALSE;
}
boolean GeoUnicastHeader::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_seqNumber.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
if(!field_srcPosVector.is_value()) return FALSE;
if(!field_dstPosVector.is_value()) return FALSE;
return TRUE;
}
int GeoUnicastHeader::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader");
  return 4;
}

void GeoUnicastHeader::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ seqNumber := ");
field_seqNumber.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(", srcPosVector := ");
field_srcPosVector.log();
TTCN_Logger::log_event_str(", dstPosVector := ");
field_dstPosVector.log();
TTCN_Logger::log_event_str(" }");
}

void GeoUnicastHeader::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      seqNumber().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("srcPosVector", param_field) == 0) {
      srcPosVector().set_param(param);
      return;
    } else if (strcmp("dstPosVector", param_field) == 0) {
      dstPosVector().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) seqNumber().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) srcPosVector().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) dstPosVector().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "seqNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          seqNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dstPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dstPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader");
  }
}

Module_Param* GeoUnicastHeader::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      return seqNumber().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("srcPosVector", param_field) == 0) {
      return srcPosVector().get_param(param_name);
    } else if (strcmp("dstPosVector", param_field) == 0) {
      return dstPosVector().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_seqNumber = field_seqNumber.get_param(param_name);
  mp_field_seqNumber->set_id(new Module_Param_FieldName(mcopystr("seqNumber")));
  mp->add_elem(mp_field_seqNumber);
  Module_Param* mp_field_reserved = field_reserved.get_param(param_name);
  mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
  mp->add_elem(mp_field_reserved);
  Module_Param* mp_field_srcPosVector = field_srcPosVector.get_param(param_name);
  mp_field_srcPosVector->set_id(new Module_Param_FieldName(mcopystr("srcPosVector")));
  mp->add_elem(mp_field_srcPosVector);
  Module_Param* mp_field_dstPosVector = field_dstPosVector.get_param(param_name);
  mp_field_dstPosVector->set_id(new Module_Param_FieldName(mcopystr("dstPosVector")));
  mp->add_elem(mp_field_dstPosVector);
  return mp;
  }

void GeoUnicastHeader::set_implicit_omit()
{
if (seqNumber().is_bound()) seqNumber().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
if (srcPosVector().is_bound()) srcPosVector().set_implicit_omit();
if (dstPosVector().is_bound()) dstPosVector().set_implicit_omit();
}

void GeoUnicastHeader::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
field_seqNumber.encode_text(text_buf);
field_reserved.encode_text(text_buf);
field_srcPosVector.encode_text(text_buf);
field_dstPosVector.encode_text(text_buf);
}

void GeoUnicastHeader::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_seqNumber.decode_text(text_buf);
field_reserved.decode_text(text_buf);
field_srcPosVector.decode_text(text_buf);
field_dstPosVector.decode_text(text_buf);
}

void GeoUnicastHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GeoUnicastHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GeoUnicastHeader::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_seqNumber.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_srcPosVector.RAW_decode(LongPosVector_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_dstPosVector.RAW_decode(ShortPosVector_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GeoUnicastHeader::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 4;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(4);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LongPosVector_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, ShortPosVector_descr_.raw);
  encoded_length += field_seqNumber.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_reserved.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_srcPosVector.RAW_encode(LongPosVector_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_dstPosVector.RAW_encode(ShortPosVector_descr_, *myleaf.body.node.nodes[3]);
  return myleaf.length = encoded_length;
}

int GeoUnicastHeader::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "seqNumber");
    enc_len += field_seqNumber.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "srcPosVector");
    enc_len += field_srcPosVector.JSON_encode(LongPosVector_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "dstPosVector");
    enc_len += field_dstPosVector.JSON_encode(ShortPosVector_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GeoUnicastHeader::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (9 == name_len && 0 == strncmp(fld_name, "seqNumber", name_len)) {
         int ret_val = field_seqNumber.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "seqNumber");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
         int ret_val = field_reserved.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "srcPosVector", name_len)) {
         int ret_val = field_srcPosVector.JSON_decode(LongPosVector_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "srcPosVector");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "dstPosVector", name_len)) {
         int ret_val = field_dstPosVector.JSON_decode(ShortPosVector_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "dstPosVector");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_seqNumber.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "seqNumber");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }
if (!field_srcPosVector.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "srcPosVector");
    return JSON_ERROR_FATAL;
  }
if (!field_dstPosVector.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "dstPosVector");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GeoUnicastHeader_template::single_value_struct {
INTEGER_template field_seqNumber;
INTEGER_template field_reserved;
LongPosVector_template field_srcPosVector;
ShortPosVector_template field_dstPosVector;
};

void GeoUnicastHeader_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_seqNumber = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
single_value->field_srcPosVector = ANY_VALUE;
single_value->field_dstPosVector = ANY_VALUE;
}
}
}

void GeoUnicastHeader_template::copy_value(const GeoUnicastHeader& other_value)
{
single_value = new single_value_struct;
if (other_value.seqNumber().is_bound()) {
  single_value->field_seqNumber = other_value.seqNumber();
} else {
  single_value->field_seqNumber.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
if (other_value.srcPosVector().is_bound()) {
  single_value->field_srcPosVector = other_value.srcPosVector();
} else {
  single_value->field_srcPosVector.clean_up();
}
if (other_value.dstPosVector().is_bound()) {
  single_value->field_dstPosVector = other_value.dstPosVector();
} else {
  single_value->field_dstPosVector.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GeoUnicastHeader_template::copy_template(const GeoUnicastHeader_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.seqNumber().get_selection()) {
single_value->field_seqNumber = other_value.seqNumber();
} else {
single_value->field_seqNumber.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.srcPosVector().get_selection()) {
single_value->field_srcPosVector = other_value.srcPosVector();
} else {
single_value->field_srcPosVector.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.dstPosVector().get_selection()) {
single_value->field_dstPosVector = other_value.dstPosVector();
} else {
single_value->field_dstPosVector.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GeoUnicastHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
break;
}
set_selection(other_value);
}

GeoUnicastHeader_template::GeoUnicastHeader_template()
{
}

GeoUnicastHeader_template::GeoUnicastHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GeoUnicastHeader_template::GeoUnicastHeader_template(const GeoUnicastHeader& other_value)
{
copy_value(other_value);
}

GeoUnicastHeader_template::GeoUnicastHeader_template(const OPTIONAL<GeoUnicastHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoUnicastHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader from an unbound optional field.");
}
}

GeoUnicastHeader_template::GeoUnicastHeader_template(const GeoUnicastHeader_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GeoUnicastHeader_template::~GeoUnicastHeader_template()
{
clean_up();
}

GeoUnicastHeader_template& GeoUnicastHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GeoUnicastHeader_template& GeoUnicastHeader_template::operator=(const GeoUnicastHeader& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GeoUnicastHeader_template& GeoUnicastHeader_template::operator=(const OPTIONAL<GeoUnicastHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoUnicastHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
}
return *this;
}

GeoUnicastHeader_template& GeoUnicastHeader_template::operator=(const GeoUnicastHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GeoUnicastHeader_template::match(const GeoUnicastHeader& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.seqNumber().is_bound()) return FALSE;
if(!single_value->field_seqNumber.match(other_value.seqNumber(), legacy))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved(), legacy))return FALSE;
if(!other_value.srcPosVector().is_bound()) return FALSE;
if(!single_value->field_srcPosVector.match(other_value.srcPosVector(), legacy))return FALSE;
if(!other_value.dstPosVector().is_bound()) return FALSE;
if(!single_value->field_dstPosVector.match(other_value.dstPosVector(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
}
return FALSE;
}

boolean GeoUnicastHeader_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_seqNumber.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
if (single_value->field_srcPosVector.is_bound()) return TRUE;
if (single_value->field_dstPosVector.is_bound()) return TRUE;
return FALSE;
}

boolean GeoUnicastHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_seqNumber.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
if (!single_value->field_srcPosVector.is_value()) return FALSE;
if (!single_value->field_dstPosVector.is_value()) return FALSE;
return TRUE;
}

void GeoUnicastHeader_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GeoUnicastHeader GeoUnicastHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
GeoUnicastHeader ret_val;
if (single_value->field_seqNumber.is_bound()) {
ret_val.seqNumber() = single_value->field_seqNumber.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
if (single_value->field_srcPosVector.is_bound()) {
ret_val.srcPosVector() = single_value->field_srcPosVector.valueof();
}
if (single_value->field_dstPosVector.is_bound()) {
ret_val.dstPosVector() = single_value->field_dstPosVector.valueof();
}
return ret_val;
}

void GeoUnicastHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GeoUnicastHeader_template[list_length];
}

GeoUnicastHeader_template& GeoUnicastHeader_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
return value_list.list_value[list_index];
}

INTEGER_template& GeoUnicastHeader_template::seqNumber()
{
set_specific();
return single_value->field_seqNumber;
}

const INTEGER_template& GeoUnicastHeader_template::seqNumber() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field seqNumber of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
return single_value->field_seqNumber;
}

INTEGER_template& GeoUnicastHeader_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const INTEGER_template& GeoUnicastHeader_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
return single_value->field_reserved;
}

LongPosVector_template& GeoUnicastHeader_template::srcPosVector()
{
set_specific();
return single_value->field_srcPosVector;
}

const LongPosVector_template& GeoUnicastHeader_template::srcPosVector() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field srcPosVector of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
return single_value->field_srcPosVector;
}

ShortPosVector_template& GeoUnicastHeader_template::dstPosVector()
{
set_specific();
return single_value->field_dstPosVector;
}

const ShortPosVector_template& GeoUnicastHeader_template::dstPosVector() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field dstPosVector of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
return single_value->field_dstPosVector;
}

int GeoUnicastHeader_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 4;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
  }
  return 0;
}

void GeoUnicastHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ seqNumber := ");
single_value->field_seqNumber.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(", srcPosVector := ");
single_value->field_srcPosVector.log();
TTCN_Logger::log_event_str(", dstPosVector := ");
single_value->field_dstPosVector.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GeoUnicastHeader_template::log_match(const GeoUnicastHeader& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_seqNumber.match(match_value.seqNumber(), legacy)){
TTCN_Logger::log_logmatch_info(".seqNumber");
single_value->field_seqNumber.log_match(match_value.seqNumber(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_srcPosVector.match(match_value.srcPosVector(), legacy)){
TTCN_Logger::log_logmatch_info(".srcPosVector");
single_value->field_srcPosVector.log_match(match_value.srcPosVector(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_dstPosVector.match(match_value.dstPosVector(), legacy)){
TTCN_Logger::log_logmatch_info(".dstPosVector");
single_value->field_dstPosVector.log_match(match_value.dstPosVector(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ seqNumber := ");
single_value->field_seqNumber.log_match(match_value.seqNumber(), legacy);
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::log_event_str(", srcPosVector := ");
single_value->field_srcPosVector.log_match(match_value.srcPosVector(), legacy);
TTCN_Logger::log_event_str(", dstPosVector := ");
single_value->field_dstPosVector.log_match(match_value.dstPosVector(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GeoUnicastHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_seqNumber.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
single_value->field_srcPosVector.encode_text(text_buf);
single_value->field_dstPosVector.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
}
}

void GeoUnicastHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_seqNumber.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
single_value->field_srcPosVector.decode_text(text_buf);
single_value->field_dstPosVector.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GeoUnicastHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader.");
}
}

void GeoUnicastHeader_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      seqNumber().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("srcPosVector", param_field) == 0) {
      srcPosVector().set_param(param);
      return;
    } else if (strcmp("dstPosVector", param_field) == 0) {
      dstPosVector().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GeoUnicastHeader_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) seqNumber().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) srcPosVector().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) dstPosVector().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "seqNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          seqNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dstPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dstPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GeoUnicastHeader_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      return seqNumber().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("srcPosVector", param_field) == 0) {
      return srcPosVector().get_param(param_name);
    } else if (strcmp("dstPosVector", param_field) == 0) {
      return dstPosVector().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_seqNumber = single_value->field_seqNumber.get_param(param_name);
    mp_field_seqNumber->set_id(new Module_Param_FieldName(mcopystr("seqNumber")));
    mp->add_elem(mp_field_seqNumber);
    Module_Param* mp_field_reserved = single_value->field_reserved.get_param(param_name);
    mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
    mp->add_elem(mp_field_reserved);
    Module_Param* mp_field_srcPosVector = single_value->field_srcPosVector.get_param(param_name);
    mp_field_srcPosVector->set_id(new Module_Param_FieldName(mcopystr("srcPosVector")));
    mp->add_elem(mp_field_srcPosVector);
    Module_Param* mp_field_dstPosVector = single_value->field_dstPosVector.get_param(param_name);
    mp_field_dstPosVector->set_id(new Module_Param_FieldName(mcopystr("dstPosVector")));
    mp->add_elem(mp_field_dstPosVector);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GeoUnicastHeader_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_seqNumber.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader");
single_value->field_srcPosVector.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader");
single_value->field_dstPosVector.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoUnicastHeader");
}

boolean GeoUnicastHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GeoUnicastHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

TSBHeader::TSBHeader()
{
  bound_flag = FALSE;
}

TSBHeader::TSBHeader(const INTEGER& par_seqNumber,
    const INTEGER& par_reserved,
    const LongPosVector& par_srcPosVector)
  :   field_seqNumber(par_seqNumber),
  field_reserved(par_reserved),
  field_srcPosVector(par_srcPosVector)
{
  bound_flag = TRUE;
}

TSBHeader::TSBHeader(const TSBHeader& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.TSBHeader.");
bound_flag = TRUE;
if (other_value.seqNumber().is_bound()) field_seqNumber = other_value.seqNumber();
else field_seqNumber.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
if (other_value.srcPosVector().is_bound()) field_srcPosVector = other_value.srcPosVector();
else field_srcPosVector.clean_up();
}

void TSBHeader::clean_up()
{
field_seqNumber.clean_up();
field_reserved.clean_up();
field_srcPosVector.clean_up();
bound_flag = FALSE;
}

TSBHeader& TSBHeader::operator=(const TSBHeader& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.TSBHeader.");
  bound_flag = TRUE;
  if (other_value.seqNumber().is_bound()) field_seqNumber = other_value.seqNumber();
  else field_seqNumber.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
  if (other_value.srcPosVector().is_bound()) field_srcPosVector = other_value.srcPosVector();
  else field_srcPosVector.clean_up();
}
return *this;
}

boolean TSBHeader::operator==(const TSBHeader& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_seqNumber==other_value.field_seqNumber
  && field_reserved==other_value.field_reserved
  && field_srcPosVector==other_value.field_srcPosVector;
}

boolean TSBHeader::is_bound() const
{
if (bound_flag) return TRUE;
if(field_seqNumber.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
if(field_srcPosVector.is_bound()) return TRUE;
return FALSE;
}
boolean TSBHeader::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_seqNumber.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
if(!field_srcPosVector.is_value()) return FALSE;
return TRUE;
}
int TSBHeader::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.TSBHeader");
  return 3;
}

void TSBHeader::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ seqNumber := ");
field_seqNumber.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(", srcPosVector := ");
field_srcPosVector.log();
TTCN_Logger::log_event_str(" }");
}

void TSBHeader::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.TSBHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      seqNumber().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("srcPosVector", param_field) == 0) {
      srcPosVector().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.TSBHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.TSBHeader has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) seqNumber().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) srcPosVector().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "seqNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          seqNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.TSBHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.TSBHeader");
  }
}

Module_Param* TSBHeader::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.TSBHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      return seqNumber().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("srcPosVector", param_field) == 0) {
      return srcPosVector().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.TSBHeader'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_seqNumber = field_seqNumber.get_param(param_name);
  mp_field_seqNumber->set_id(new Module_Param_FieldName(mcopystr("seqNumber")));
  mp->add_elem(mp_field_seqNumber);
  Module_Param* mp_field_reserved = field_reserved.get_param(param_name);
  mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
  mp->add_elem(mp_field_reserved);
  Module_Param* mp_field_srcPosVector = field_srcPosVector.get_param(param_name);
  mp_field_srcPosVector->set_id(new Module_Param_FieldName(mcopystr("srcPosVector")));
  mp->add_elem(mp_field_srcPosVector);
  return mp;
  }

void TSBHeader::set_implicit_omit()
{
if (seqNumber().is_bound()) seqNumber().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
if (srcPosVector().is_bound()) srcPosVector().set_implicit_omit();
}

void TSBHeader::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.TSBHeader.");
field_seqNumber.encode_text(text_buf);
field_reserved.encode_text(text_buf);
field_srcPosVector.encode_text(text_buf);
}

void TSBHeader::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_seqNumber.decode_text(text_buf);
field_reserved.decode_text(text_buf);
field_srcPosVector.decode_text(text_buf);
}

void TSBHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void TSBHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int TSBHeader::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_seqNumber.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_srcPosVector.RAW_decode(LongPosVector_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int TSBHeader::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LongPosVector_descr_.raw);
  encoded_length += field_seqNumber.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_reserved.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_srcPosVector.RAW_encode(LongPosVector_descr_, *myleaf.body.node.nodes[2]);
  return myleaf.length = encoded_length;
}

int TSBHeader::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.TSBHeader.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "seqNumber");
    enc_len += field_seqNumber.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "srcPosVector");
    enc_len += field_srcPosVector.JSON_encode(LongPosVector_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int TSBHeader::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (9 == name_len && 0 == strncmp(fld_name, "seqNumber", name_len)) {
         int ret_val = field_seqNumber.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "seqNumber");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
         int ret_val = field_reserved.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "srcPosVector", name_len)) {
         int ret_val = field_srcPosVector.JSON_decode(LongPosVector_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "srcPosVector");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_seqNumber.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "seqNumber");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }
if (!field_srcPosVector.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "srcPosVector");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct TSBHeader_template::single_value_struct {
INTEGER_template field_seqNumber;
INTEGER_template field_reserved;
LongPosVector_template field_srcPosVector;
};

void TSBHeader_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_seqNumber = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
single_value->field_srcPosVector = ANY_VALUE;
}
}
}

void TSBHeader_template::copy_value(const TSBHeader& other_value)
{
single_value = new single_value_struct;
if (other_value.seqNumber().is_bound()) {
  single_value->field_seqNumber = other_value.seqNumber();
} else {
  single_value->field_seqNumber.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
if (other_value.srcPosVector().is_bound()) {
  single_value->field_srcPosVector = other_value.srcPosVector();
} else {
  single_value->field_srcPosVector.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void TSBHeader_template::copy_template(const TSBHeader_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.seqNumber().get_selection()) {
single_value->field_seqNumber = other_value.seqNumber();
} else {
single_value->field_seqNumber.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.srcPosVector().get_selection()) {
single_value->field_srcPosVector = other_value.srcPosVector();
} else {
single_value->field_srcPosVector.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TSBHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader.");
break;
}
set_selection(other_value);
}

TSBHeader_template::TSBHeader_template()
{
}

TSBHeader_template::TSBHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

TSBHeader_template::TSBHeader_template(const TSBHeader& other_value)
{
copy_value(other_value);
}

TSBHeader_template::TSBHeader_template(const OPTIONAL<TSBHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TSBHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader from an unbound optional field.");
}
}

TSBHeader_template::TSBHeader_template(const TSBHeader_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

TSBHeader_template::~TSBHeader_template()
{
clean_up();
}

TSBHeader_template& TSBHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TSBHeader_template& TSBHeader_template::operator=(const TSBHeader& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

TSBHeader_template& TSBHeader_template::operator=(const OPTIONAL<TSBHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TSBHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader.");
}
return *this;
}

TSBHeader_template& TSBHeader_template::operator=(const TSBHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean TSBHeader_template::match(const TSBHeader& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.seqNumber().is_bound()) return FALSE;
if(!single_value->field_seqNumber.match(other_value.seqNumber(), legacy))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved(), legacy))return FALSE;
if(!other_value.srcPosVector().is_bound()) return FALSE;
if(!single_value->field_srcPosVector.match(other_value.srcPosVector(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader.");
}
return FALSE;
}

boolean TSBHeader_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_seqNumber.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
if (single_value->field_srcPosVector.is_bound()) return TRUE;
return FALSE;
}

boolean TSBHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_seqNumber.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
if (!single_value->field_srcPosVector.is_value()) return FALSE;
return TRUE;
}

void TSBHeader_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

TSBHeader TSBHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader.");
TSBHeader ret_val;
if (single_value->field_seqNumber.is_bound()) {
ret_val.seqNumber() = single_value->field_seqNumber.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
if (single_value->field_srcPosVector.is_bound()) {
ret_val.srcPosVector() = single_value->field_srcPosVector.valueof();
}
return ret_val;
}

void TSBHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new TSBHeader_template[list_length];
}

TSBHeader_template& TSBHeader_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader.");
return value_list.list_value[list_index];
}

INTEGER_template& TSBHeader_template::seqNumber()
{
set_specific();
return single_value->field_seqNumber;
}

const INTEGER_template& TSBHeader_template::seqNumber() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field seqNumber of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader.");
return single_value->field_seqNumber;
}

INTEGER_template& TSBHeader_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const INTEGER_template& TSBHeader_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader.");
return single_value->field_reserved;
}

LongPosVector_template& TSBHeader_template::srcPosVector()
{
set_specific();
return single_value->field_srcPosVector;
}

const LongPosVector_template& TSBHeader_template::srcPosVector() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field srcPosVector of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader.");
return single_value->field_srcPosVector;
}

int TSBHeader_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader.");
  }
  return 0;
}

void TSBHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ seqNumber := ");
single_value->field_seqNumber.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(", srcPosVector := ");
single_value->field_srcPosVector.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void TSBHeader_template::log_match(const TSBHeader& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_seqNumber.match(match_value.seqNumber(), legacy)){
TTCN_Logger::log_logmatch_info(".seqNumber");
single_value->field_seqNumber.log_match(match_value.seqNumber(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_srcPosVector.match(match_value.srcPosVector(), legacy)){
TTCN_Logger::log_logmatch_info(".srcPosVector");
single_value->field_srcPosVector.log_match(match_value.srcPosVector(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ seqNumber := ");
single_value->field_seqNumber.log_match(match_value.seqNumber(), legacy);
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::log_event_str(", srcPosVector := ");
single_value->field_srcPosVector.log_match(match_value.srcPosVector(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void TSBHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_seqNumber.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
single_value->field_srcPosVector.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader.");
}
}

void TSBHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_seqNumber.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
single_value->field_srcPosVector.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TSBHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader.");
}
}

void TSBHeader_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.TSBHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      seqNumber().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("srcPosVector", param_field) == 0) {
      srcPosVector().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.TSBHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TSBHeader_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.TSBHeader has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) seqNumber().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) srcPosVector().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "seqNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          seqNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.TSBHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.TSBHeader");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* TSBHeader_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.TSBHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      return seqNumber().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("srcPosVector", param_field) == 0) {
      return srcPosVector().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.TSBHeader'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_seqNumber = single_value->field_seqNumber.get_param(param_name);
    mp_field_seqNumber->set_id(new Module_Param_FieldName(mcopystr("seqNumber")));
    mp->add_elem(mp_field_seqNumber);
    Module_Param* mp_field_reserved = single_value->field_reserved.get_param(param_name);
    mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
    mp->add_elem(mp_field_reserved);
    Module_Param* mp_field_srcPosVector = single_value->field_srcPosVector.get_param(param_name);
    mp_field_srcPosVector->set_id(new Module_Param_FieldName(mcopystr("srcPosVector")));
    mp->add_elem(mp_field_srcPosVector);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void TSBHeader_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_seqNumber.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.TSBHeader");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.TSBHeader");
single_value->field_srcPosVector.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.TSBHeader");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.TSBHeader");
}

boolean TSBHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TSBHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SHBHeader::SHBHeader()
{
  bound_flag = FALSE;
}

SHBHeader::SHBHeader(const LongPosVector& par_srcPosVector,
    const INTEGER& par_reserved)
  :   field_srcPosVector(par_srcPosVector),
  field_reserved(par_reserved)
{
  bound_flag = TRUE;
}

SHBHeader::SHBHeader(const SHBHeader& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.SHBHeader.");
bound_flag = TRUE;
if (other_value.srcPosVector().is_bound()) field_srcPosVector = other_value.srcPosVector();
else field_srcPosVector.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
}

void SHBHeader::clean_up()
{
field_srcPosVector.clean_up();
field_reserved.clean_up();
bound_flag = FALSE;
}

SHBHeader& SHBHeader::operator=(const SHBHeader& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.SHBHeader.");
  bound_flag = TRUE;
  if (other_value.srcPosVector().is_bound()) field_srcPosVector = other_value.srcPosVector();
  else field_srcPosVector.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
}
return *this;
}

boolean SHBHeader::operator==(const SHBHeader& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_srcPosVector==other_value.field_srcPosVector
  && field_reserved==other_value.field_reserved;
}

boolean SHBHeader::is_bound() const
{
if (bound_flag) return TRUE;
if(field_srcPosVector.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
return FALSE;
}
boolean SHBHeader::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_srcPosVector.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
return TRUE;
}
int SHBHeader::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.SHBHeader");
  return 2;
}

void SHBHeader::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ srcPosVector := ");
field_srcPosVector.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(" }");
}

void SHBHeader::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.SHBHeader'");
    }
    if (strcmp("srcPosVector", param_field) == 0) {
      srcPosVector().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.SHBHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.SHBHeader has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) srcPosVector().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.SHBHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.SHBHeader");
  }
}

Module_Param* SHBHeader::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.SHBHeader'");
    }
    if (strcmp("srcPosVector", param_field) == 0) {
      return srcPosVector().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.SHBHeader'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_srcPosVector = field_srcPosVector.get_param(param_name);
  mp_field_srcPosVector->set_id(new Module_Param_FieldName(mcopystr("srcPosVector")));
  mp->add_elem(mp_field_srcPosVector);
  Module_Param* mp_field_reserved = field_reserved.get_param(param_name);
  mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
  mp->add_elem(mp_field_reserved);
  return mp;
  }

void SHBHeader::set_implicit_omit()
{
if (srcPosVector().is_bound()) srcPosVector().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
}

void SHBHeader::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.SHBHeader.");
field_srcPosVector.encode_text(text_buf);
field_reserved.encode_text(text_buf);
}

void SHBHeader::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_srcPosVector.decode_text(text_buf);
field_reserved.decode_text(text_buf);
}

void SHBHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SHBHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SHBHeader::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_srcPosVector.RAW_decode(LongPosVector_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved.RAW_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int SHBHeader::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LongPosVector_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt32_descr_.raw);
  encoded_length += field_srcPosVector.RAW_encode(LongPosVector_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_reserved.RAW_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int SHBHeader::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.SHBHeader.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "srcPosVector");
    enc_len += field_srcPosVector.JSON_encode(LongPosVector_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SHBHeader::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "srcPosVector", name_len)) {
         int ret_val = field_srcPosVector.JSON_decode(LongPosVector_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "srcPosVector");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
         int ret_val = field_reserved.JSON_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_srcPosVector.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "srcPosVector");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct SHBHeader_template::single_value_struct {
LongPosVector_template field_srcPosVector;
INTEGER_template field_reserved;
};

void SHBHeader_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_srcPosVector = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
}
}
}

void SHBHeader_template::copy_value(const SHBHeader& other_value)
{
single_value = new single_value_struct;
if (other_value.srcPosVector().is_bound()) {
  single_value->field_srcPosVector = other_value.srcPosVector();
} else {
  single_value->field_srcPosVector.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SHBHeader_template::copy_template(const SHBHeader_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.srcPosVector().get_selection()) {
single_value->field_srcPosVector = other_value.srcPosVector();
} else {
single_value->field_srcPosVector.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SHBHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader.");
break;
}
set_selection(other_value);
}

SHBHeader_template::SHBHeader_template()
{
}

SHBHeader_template::SHBHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SHBHeader_template::SHBHeader_template(const SHBHeader& other_value)
{
copy_value(other_value);
}

SHBHeader_template::SHBHeader_template(const OPTIONAL<SHBHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SHBHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader from an unbound optional field.");
}
}

SHBHeader_template::SHBHeader_template(const SHBHeader_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SHBHeader_template::~SHBHeader_template()
{
clean_up();
}

SHBHeader_template& SHBHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SHBHeader_template& SHBHeader_template::operator=(const SHBHeader& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SHBHeader_template& SHBHeader_template::operator=(const OPTIONAL<SHBHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SHBHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader.");
}
return *this;
}

SHBHeader_template& SHBHeader_template::operator=(const SHBHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SHBHeader_template::match(const SHBHeader& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.srcPosVector().is_bound()) return FALSE;
if(!single_value->field_srcPosVector.match(other_value.srcPosVector(), legacy))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader.");
}
return FALSE;
}

boolean SHBHeader_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_srcPosVector.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
return FALSE;
}

boolean SHBHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_srcPosVector.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
return TRUE;
}

void SHBHeader_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SHBHeader SHBHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader.");
SHBHeader ret_val;
if (single_value->field_srcPosVector.is_bound()) {
ret_val.srcPosVector() = single_value->field_srcPosVector.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
return ret_val;
}

void SHBHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SHBHeader_template[list_length];
}

SHBHeader_template& SHBHeader_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader.");
return value_list.list_value[list_index];
}

LongPosVector_template& SHBHeader_template::srcPosVector()
{
set_specific();
return single_value->field_srcPosVector;
}

const LongPosVector_template& SHBHeader_template::srcPosVector() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field srcPosVector of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader.");
return single_value->field_srcPosVector;
}

INTEGER_template& SHBHeader_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const INTEGER_template& SHBHeader_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader.");
return single_value->field_reserved;
}

int SHBHeader_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader.");
  }
  return 0;
}

void SHBHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ srcPosVector := ");
single_value->field_srcPosVector.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SHBHeader_template::log_match(const SHBHeader& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_srcPosVector.match(match_value.srcPosVector(), legacy)){
TTCN_Logger::log_logmatch_info(".srcPosVector");
single_value->field_srcPosVector.log_match(match_value.srcPosVector(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ srcPosVector := ");
single_value->field_srcPosVector.log_match(match_value.srcPosVector(), legacy);
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SHBHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_srcPosVector.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader.");
}
}

void SHBHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_srcPosVector.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SHBHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader.");
}
}

void SHBHeader_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.SHBHeader'");
    }
    if (strcmp("srcPosVector", param_field) == 0) {
      srcPosVector().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.SHBHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SHBHeader_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.SHBHeader has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) srcPosVector().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.SHBHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.SHBHeader");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SHBHeader_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.SHBHeader'");
    }
    if (strcmp("srcPosVector", param_field) == 0) {
      return srcPosVector().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.SHBHeader'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_srcPosVector = single_value->field_srcPosVector.get_param(param_name);
    mp_field_srcPosVector->set_id(new Module_Param_FieldName(mcopystr("srcPosVector")));
    mp->add_elem(mp_field_srcPosVector);
    Module_Param* mp_field_reserved = single_value->field_reserved.get_param(param_name);
    mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
    mp->add_elem(mp_field_reserved);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SHBHeader_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_srcPosVector.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.SHBHeader");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.SHBHeader");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.SHBHeader");
}

boolean SHBHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SHBHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

GeoAnycastHeader::GeoAnycastHeader()
{
  bound_flag = FALSE;
}

GeoAnycastHeader::GeoAnycastHeader(const INTEGER& par_seqNumber,
    const INTEGER& par_reserved,
    const LongPosVector& par_srcPosVector,
    const INTEGER& par_geoAreaPosLatitude,
    const INTEGER& par_geoAreaPosLongitude,
    const INTEGER& par_distanceA,
    const INTEGER& par_distanceB,
    const INTEGER& par_angle,
    const INTEGER& par_reserved2)
  :   field_seqNumber(par_seqNumber),
  field_reserved(par_reserved),
  field_srcPosVector(par_srcPosVector),
  field_geoAreaPosLatitude(par_geoAreaPosLatitude),
  field_geoAreaPosLongitude(par_geoAreaPosLongitude),
  field_distanceA(par_distanceA),
  field_distanceB(par_distanceB),
  field_angle(par_angle),
  field_reserved2(par_reserved2)
{
  bound_flag = TRUE;
}

GeoAnycastHeader::GeoAnycastHeader(const GeoAnycastHeader& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
bound_flag = TRUE;
if (other_value.seqNumber().is_bound()) field_seqNumber = other_value.seqNumber();
else field_seqNumber.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
if (other_value.srcPosVector().is_bound()) field_srcPosVector = other_value.srcPosVector();
else field_srcPosVector.clean_up();
if (other_value.geoAreaPosLatitude().is_bound()) field_geoAreaPosLatitude = other_value.geoAreaPosLatitude();
else field_geoAreaPosLatitude.clean_up();
if (other_value.geoAreaPosLongitude().is_bound()) field_geoAreaPosLongitude = other_value.geoAreaPosLongitude();
else field_geoAreaPosLongitude.clean_up();
if (other_value.distanceA().is_bound()) field_distanceA = other_value.distanceA();
else field_distanceA.clean_up();
if (other_value.distanceB().is_bound()) field_distanceB = other_value.distanceB();
else field_distanceB.clean_up();
if (other_value.angle().is_bound()) field_angle = other_value.angle();
else field_angle.clean_up();
if (other_value.reserved2().is_bound()) field_reserved2 = other_value.reserved2();
else field_reserved2.clean_up();
}

void GeoAnycastHeader::clean_up()
{
field_seqNumber.clean_up();
field_reserved.clean_up();
field_srcPosVector.clean_up();
field_geoAreaPosLatitude.clean_up();
field_geoAreaPosLongitude.clean_up();
field_distanceA.clean_up();
field_distanceB.clean_up();
field_angle.clean_up();
field_reserved2.clean_up();
bound_flag = FALSE;
}

GeoAnycastHeader& GeoAnycastHeader::operator=(const GeoAnycastHeader& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
  bound_flag = TRUE;
  if (other_value.seqNumber().is_bound()) field_seqNumber = other_value.seqNumber();
  else field_seqNumber.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
  if (other_value.srcPosVector().is_bound()) field_srcPosVector = other_value.srcPosVector();
  else field_srcPosVector.clean_up();
  if (other_value.geoAreaPosLatitude().is_bound()) field_geoAreaPosLatitude = other_value.geoAreaPosLatitude();
  else field_geoAreaPosLatitude.clean_up();
  if (other_value.geoAreaPosLongitude().is_bound()) field_geoAreaPosLongitude = other_value.geoAreaPosLongitude();
  else field_geoAreaPosLongitude.clean_up();
  if (other_value.distanceA().is_bound()) field_distanceA = other_value.distanceA();
  else field_distanceA.clean_up();
  if (other_value.distanceB().is_bound()) field_distanceB = other_value.distanceB();
  else field_distanceB.clean_up();
  if (other_value.angle().is_bound()) field_angle = other_value.angle();
  else field_angle.clean_up();
  if (other_value.reserved2().is_bound()) field_reserved2 = other_value.reserved2();
  else field_reserved2.clean_up();
}
return *this;
}

boolean GeoAnycastHeader::operator==(const GeoAnycastHeader& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_seqNumber==other_value.field_seqNumber
  && field_reserved==other_value.field_reserved
  && field_srcPosVector==other_value.field_srcPosVector
  && field_geoAreaPosLatitude==other_value.field_geoAreaPosLatitude
  && field_geoAreaPosLongitude==other_value.field_geoAreaPosLongitude
  && field_distanceA==other_value.field_distanceA
  && field_distanceB==other_value.field_distanceB
  && field_angle==other_value.field_angle
  && field_reserved2==other_value.field_reserved2;
}

boolean GeoAnycastHeader::is_bound() const
{
if (bound_flag) return TRUE;
if(field_seqNumber.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
if(field_srcPosVector.is_bound()) return TRUE;
if(field_geoAreaPosLatitude.is_bound()) return TRUE;
if(field_geoAreaPosLongitude.is_bound()) return TRUE;
if(field_distanceA.is_bound()) return TRUE;
if(field_distanceB.is_bound()) return TRUE;
if(field_angle.is_bound()) return TRUE;
if(field_reserved2.is_bound()) return TRUE;
return FALSE;
}
boolean GeoAnycastHeader::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_seqNumber.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
if(!field_srcPosVector.is_value()) return FALSE;
if(!field_geoAreaPosLatitude.is_value()) return FALSE;
if(!field_geoAreaPosLongitude.is_value()) return FALSE;
if(!field_distanceA.is_value()) return FALSE;
if(!field_distanceB.is_value()) return FALSE;
if(!field_angle.is_value()) return FALSE;
if(!field_reserved2.is_value()) return FALSE;
return TRUE;
}
int GeoAnycastHeader::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader");
  return 9;
}

void GeoAnycastHeader::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ seqNumber := ");
field_seqNumber.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(", srcPosVector := ");
field_srcPosVector.log();
TTCN_Logger::log_event_str(", geoAreaPosLatitude := ");
field_geoAreaPosLatitude.log();
TTCN_Logger::log_event_str(", geoAreaPosLongitude := ");
field_geoAreaPosLongitude.log();
TTCN_Logger::log_event_str(", distanceA := ");
field_distanceA.log();
TTCN_Logger::log_event_str(", distanceB := ");
field_distanceB.log();
TTCN_Logger::log_event_str(", angle := ");
field_angle.log();
TTCN_Logger::log_event_str(", reserved2 := ");
field_reserved2.log();
TTCN_Logger::log_event_str(" }");
}

void GeoAnycastHeader::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      seqNumber().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("srcPosVector", param_field) == 0) {
      srcPosVector().set_param(param);
      return;
    } else if (strcmp("geoAreaPosLatitude", param_field) == 0) {
      geoAreaPosLatitude().set_param(param);
      return;
    } else if (strcmp("geoAreaPosLongitude", param_field) == 0) {
      geoAreaPosLongitude().set_param(param);
      return;
    } else if (strcmp("distanceA", param_field) == 0) {
      distanceA().set_param(param);
      return;
    } else if (strcmp("distanceB", param_field) == 0) {
      distanceB().set_param(param);
      return;
    } else if (strcmp("angle", param_field) == 0) {
      angle().set_param(param);
      return;
    } else if (strcmp("reserved2", param_field) == 0) {
      reserved2().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (9<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader has 9 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) seqNumber().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) srcPosVector().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) geoAreaPosLatitude().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) geoAreaPosLongitude().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) distanceA().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) distanceB().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) angle().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) reserved2().set_param(*mp->get_elem(8));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "seqNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          seqNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoAreaPosLatitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoAreaPosLatitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoAreaPosLongitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoAreaPosLongitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "distanceA")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          distanceA().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "distanceB")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          distanceB().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "angle")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          angle().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved2().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader");
  }
}

Module_Param* GeoAnycastHeader::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      return seqNumber().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("srcPosVector", param_field) == 0) {
      return srcPosVector().get_param(param_name);
    } else if (strcmp("geoAreaPosLatitude", param_field) == 0) {
      return geoAreaPosLatitude().get_param(param_name);
    } else if (strcmp("geoAreaPosLongitude", param_field) == 0) {
      return geoAreaPosLongitude().get_param(param_name);
    } else if (strcmp("distanceA", param_field) == 0) {
      return distanceA().get_param(param_name);
    } else if (strcmp("distanceB", param_field) == 0) {
      return distanceB().get_param(param_name);
    } else if (strcmp("angle", param_field) == 0) {
      return angle().get_param(param_name);
    } else if (strcmp("reserved2", param_field) == 0) {
      return reserved2().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_seqNumber = field_seqNumber.get_param(param_name);
  mp_field_seqNumber->set_id(new Module_Param_FieldName(mcopystr("seqNumber")));
  mp->add_elem(mp_field_seqNumber);
  Module_Param* mp_field_reserved = field_reserved.get_param(param_name);
  mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
  mp->add_elem(mp_field_reserved);
  Module_Param* mp_field_srcPosVector = field_srcPosVector.get_param(param_name);
  mp_field_srcPosVector->set_id(new Module_Param_FieldName(mcopystr("srcPosVector")));
  mp->add_elem(mp_field_srcPosVector);
  Module_Param* mp_field_geoAreaPosLatitude = field_geoAreaPosLatitude.get_param(param_name);
  mp_field_geoAreaPosLatitude->set_id(new Module_Param_FieldName(mcopystr("geoAreaPosLatitude")));
  mp->add_elem(mp_field_geoAreaPosLatitude);
  Module_Param* mp_field_geoAreaPosLongitude = field_geoAreaPosLongitude.get_param(param_name);
  mp_field_geoAreaPosLongitude->set_id(new Module_Param_FieldName(mcopystr("geoAreaPosLongitude")));
  mp->add_elem(mp_field_geoAreaPosLongitude);
  Module_Param* mp_field_distanceA = field_distanceA.get_param(param_name);
  mp_field_distanceA->set_id(new Module_Param_FieldName(mcopystr("distanceA")));
  mp->add_elem(mp_field_distanceA);
  Module_Param* mp_field_distanceB = field_distanceB.get_param(param_name);
  mp_field_distanceB->set_id(new Module_Param_FieldName(mcopystr("distanceB")));
  mp->add_elem(mp_field_distanceB);
  Module_Param* mp_field_angle = field_angle.get_param(param_name);
  mp_field_angle->set_id(new Module_Param_FieldName(mcopystr("angle")));
  mp->add_elem(mp_field_angle);
  Module_Param* mp_field_reserved2 = field_reserved2.get_param(param_name);
  mp_field_reserved2->set_id(new Module_Param_FieldName(mcopystr("reserved2")));
  mp->add_elem(mp_field_reserved2);
  return mp;
  }

void GeoAnycastHeader::set_implicit_omit()
{
if (seqNumber().is_bound()) seqNumber().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
if (srcPosVector().is_bound()) srcPosVector().set_implicit_omit();
if (geoAreaPosLatitude().is_bound()) geoAreaPosLatitude().set_implicit_omit();
if (geoAreaPosLongitude().is_bound()) geoAreaPosLongitude().set_implicit_omit();
if (distanceA().is_bound()) distanceA().set_implicit_omit();
if (distanceB().is_bound()) distanceB().set_implicit_omit();
if (angle().is_bound()) angle().set_implicit_omit();
if (reserved2().is_bound()) reserved2().set_implicit_omit();
}

void GeoAnycastHeader::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
field_seqNumber.encode_text(text_buf);
field_reserved.encode_text(text_buf);
field_srcPosVector.encode_text(text_buf);
field_geoAreaPosLatitude.encode_text(text_buf);
field_geoAreaPosLongitude.encode_text(text_buf);
field_distanceA.encode_text(text_buf);
field_distanceB.encode_text(text_buf);
field_angle.encode_text(text_buf);
field_reserved2.encode_text(text_buf);
}

void GeoAnycastHeader::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_seqNumber.decode_text(text_buf);
field_reserved.decode_text(text_buf);
field_srcPosVector.decode_text(text_buf);
field_geoAreaPosLatitude.decode_text(text_buf);
field_geoAreaPosLongitude.decode_text(text_buf);
field_distanceA.decode_text(text_buf);
field_distanceB.decode_text(text_buf);
field_angle.decode_text(text_buf);
field_reserved2.decode_text(text_buf);
}

void GeoAnycastHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GeoAnycastHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GeoAnycastHeader::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_seqNumber.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_srcPosVector.RAW_decode(LongPosVector_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_geoAreaPosLatitude.RAW_decode(LibCommon__BasicTypesAndValues::Int32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_geoAreaPosLongitude.RAW_decode(LibCommon__BasicTypesAndValues::Int32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_distanceA.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_distanceB.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_angle.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved2.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GeoAnycastHeader::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 9;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(9);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LongPosVector_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, LibCommon__BasicTypesAndValues::Int32_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, LibCommon__BasicTypesAndValues::Int32_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[7] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 7, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[8] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 8, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  encoded_length += field_seqNumber.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_reserved.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_srcPosVector.RAW_encode(LongPosVector_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_geoAreaPosLatitude.RAW_encode(LibCommon__BasicTypesAndValues::Int32_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_geoAreaPosLongitude.RAW_encode(LibCommon__BasicTypesAndValues::Int32_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_distanceA.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_distanceB.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[6]);
  encoded_length += field_angle.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[7]);
  encoded_length += field_reserved2.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[8]);
  return myleaf.length = encoded_length;
}

int GeoAnycastHeader::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "seqNumber");
    enc_len += field_seqNumber.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "srcPosVector");
    enc_len += field_srcPosVector.JSON_encode(LongPosVector_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoAreaPosLatitude");
    enc_len += field_geoAreaPosLatitude.JSON_encode(LibCommon__BasicTypesAndValues::Int32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoAreaPosLongitude");
    enc_len += field_geoAreaPosLongitude.JSON_encode(LibCommon__BasicTypesAndValues::Int32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "distanceA");
    enc_len += field_distanceA.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "distanceB");
    enc_len += field_distanceB.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "angle");
    enc_len += field_angle.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved2");
    enc_len += field_reserved2.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GeoAnycastHeader::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (9 == name_len && 0 == strncmp(fld_name, "seqNumber", name_len)) {
         int ret_val = field_seqNumber.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "seqNumber");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
         int ret_val = field_reserved.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "srcPosVector", name_len)) {
         int ret_val = field_srcPosVector.JSON_decode(LongPosVector_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "srcPosVector");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "geoAreaPosLatitude", name_len)) {
         int ret_val = field_geoAreaPosLatitude.JSON_decode(LibCommon__BasicTypesAndValues::Int32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoAreaPosLatitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (19 == name_len && 0 == strncmp(fld_name, "geoAreaPosLongitude", name_len)) {
         int ret_val = field_geoAreaPosLongitude.JSON_decode(LibCommon__BasicTypesAndValues::Int32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoAreaPosLongitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "distanceA", name_len)) {
         int ret_val = field_distanceA.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "distanceA");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "distanceB", name_len)) {
         int ret_val = field_distanceB.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "distanceB");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (5 == name_len && 0 == strncmp(fld_name, "angle", name_len)) {
         int ret_val = field_angle.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "angle");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "reserved2", name_len)) {
         int ret_val = field_reserved2.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved2");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_seqNumber.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "seqNumber");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }
if (!field_srcPosVector.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "srcPosVector");
    return JSON_ERROR_FATAL;
  }
if (!field_geoAreaPosLatitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoAreaPosLatitude");
    return JSON_ERROR_FATAL;
  }
if (!field_geoAreaPosLongitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "geoAreaPosLongitude");
    return JSON_ERROR_FATAL;
  }
if (!field_distanceA.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "distanceA");
    return JSON_ERROR_FATAL;
  }
if (!field_distanceB.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "distanceB");
    return JSON_ERROR_FATAL;
  }
if (!field_angle.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "angle");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved2.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved2");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GeoAnycastHeader_template::single_value_struct {
INTEGER_template field_seqNumber;
INTEGER_template field_reserved;
LongPosVector_template field_srcPosVector;
INTEGER_template field_geoAreaPosLatitude;
INTEGER_template field_geoAreaPosLongitude;
INTEGER_template field_distanceA;
INTEGER_template field_distanceB;
INTEGER_template field_angle;
INTEGER_template field_reserved2;
};

void GeoAnycastHeader_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_seqNumber = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
single_value->field_srcPosVector = ANY_VALUE;
single_value->field_geoAreaPosLatitude = ANY_VALUE;
single_value->field_geoAreaPosLongitude = ANY_VALUE;
single_value->field_distanceA = ANY_VALUE;
single_value->field_distanceB = ANY_VALUE;
single_value->field_angle = ANY_VALUE;
single_value->field_reserved2 = ANY_VALUE;
}
}
}

void GeoAnycastHeader_template::copy_value(const GeoAnycastHeader& other_value)
{
single_value = new single_value_struct;
if (other_value.seqNumber().is_bound()) {
  single_value->field_seqNumber = other_value.seqNumber();
} else {
  single_value->field_seqNumber.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
if (other_value.srcPosVector().is_bound()) {
  single_value->field_srcPosVector = other_value.srcPosVector();
} else {
  single_value->field_srcPosVector.clean_up();
}
if (other_value.geoAreaPosLatitude().is_bound()) {
  single_value->field_geoAreaPosLatitude = other_value.geoAreaPosLatitude();
} else {
  single_value->field_geoAreaPosLatitude.clean_up();
}
if (other_value.geoAreaPosLongitude().is_bound()) {
  single_value->field_geoAreaPosLongitude = other_value.geoAreaPosLongitude();
} else {
  single_value->field_geoAreaPosLongitude.clean_up();
}
if (other_value.distanceA().is_bound()) {
  single_value->field_distanceA = other_value.distanceA();
} else {
  single_value->field_distanceA.clean_up();
}
if (other_value.distanceB().is_bound()) {
  single_value->field_distanceB = other_value.distanceB();
} else {
  single_value->field_distanceB.clean_up();
}
if (other_value.angle().is_bound()) {
  single_value->field_angle = other_value.angle();
} else {
  single_value->field_angle.clean_up();
}
if (other_value.reserved2().is_bound()) {
  single_value->field_reserved2 = other_value.reserved2();
} else {
  single_value->field_reserved2.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GeoAnycastHeader_template::copy_template(const GeoAnycastHeader_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.seqNumber().get_selection()) {
single_value->field_seqNumber = other_value.seqNumber();
} else {
single_value->field_seqNumber.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.srcPosVector().get_selection()) {
single_value->field_srcPosVector = other_value.srcPosVector();
} else {
single_value->field_srcPosVector.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoAreaPosLatitude().get_selection()) {
single_value->field_geoAreaPosLatitude = other_value.geoAreaPosLatitude();
} else {
single_value->field_geoAreaPosLatitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.geoAreaPosLongitude().get_selection()) {
single_value->field_geoAreaPosLongitude = other_value.geoAreaPosLongitude();
} else {
single_value->field_geoAreaPosLongitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.distanceA().get_selection()) {
single_value->field_distanceA = other_value.distanceA();
} else {
single_value->field_distanceA.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.distanceB().get_selection()) {
single_value->field_distanceB = other_value.distanceB();
} else {
single_value->field_distanceB.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.angle().get_selection()) {
single_value->field_angle = other_value.angle();
} else {
single_value->field_angle.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved2().get_selection()) {
single_value->field_reserved2 = other_value.reserved2();
} else {
single_value->field_reserved2.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GeoAnycastHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
break;
}
set_selection(other_value);
}

GeoAnycastHeader_template::GeoAnycastHeader_template()
{
}

GeoAnycastHeader_template::GeoAnycastHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GeoAnycastHeader_template::GeoAnycastHeader_template(const GeoAnycastHeader& other_value)
{
copy_value(other_value);
}

GeoAnycastHeader_template::GeoAnycastHeader_template(const OPTIONAL<GeoAnycastHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoAnycastHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader from an unbound optional field.");
}
}

GeoAnycastHeader_template::GeoAnycastHeader_template(const GeoAnycastHeader_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GeoAnycastHeader_template::~GeoAnycastHeader_template()
{
clean_up();
}

GeoAnycastHeader_template& GeoAnycastHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GeoAnycastHeader_template& GeoAnycastHeader_template::operator=(const GeoAnycastHeader& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GeoAnycastHeader_template& GeoAnycastHeader_template::operator=(const OPTIONAL<GeoAnycastHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoAnycastHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
}
return *this;
}

GeoAnycastHeader_template& GeoAnycastHeader_template::operator=(const GeoAnycastHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GeoAnycastHeader_template::match(const GeoAnycastHeader& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.seqNumber().is_bound()) return FALSE;
if(!single_value->field_seqNumber.match(other_value.seqNumber(), legacy))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved(), legacy))return FALSE;
if(!other_value.srcPosVector().is_bound()) return FALSE;
if(!single_value->field_srcPosVector.match(other_value.srcPosVector(), legacy))return FALSE;
if(!other_value.geoAreaPosLatitude().is_bound()) return FALSE;
if(!single_value->field_geoAreaPosLatitude.match(other_value.geoAreaPosLatitude(), legacy))return FALSE;
if(!other_value.geoAreaPosLongitude().is_bound()) return FALSE;
if(!single_value->field_geoAreaPosLongitude.match(other_value.geoAreaPosLongitude(), legacy))return FALSE;
if(!other_value.distanceA().is_bound()) return FALSE;
if(!single_value->field_distanceA.match(other_value.distanceA(), legacy))return FALSE;
if(!other_value.distanceB().is_bound()) return FALSE;
if(!single_value->field_distanceB.match(other_value.distanceB(), legacy))return FALSE;
if(!other_value.angle().is_bound()) return FALSE;
if(!single_value->field_angle.match(other_value.angle(), legacy))return FALSE;
if(!other_value.reserved2().is_bound()) return FALSE;
if(!single_value->field_reserved2.match(other_value.reserved2(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
}
return FALSE;
}

boolean GeoAnycastHeader_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_seqNumber.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
if (single_value->field_srcPosVector.is_bound()) return TRUE;
if (single_value->field_geoAreaPosLatitude.is_bound()) return TRUE;
if (single_value->field_geoAreaPosLongitude.is_bound()) return TRUE;
if (single_value->field_distanceA.is_bound()) return TRUE;
if (single_value->field_distanceB.is_bound()) return TRUE;
if (single_value->field_angle.is_bound()) return TRUE;
if (single_value->field_reserved2.is_bound()) return TRUE;
return FALSE;
}

boolean GeoAnycastHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_seqNumber.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
if (!single_value->field_srcPosVector.is_value()) return FALSE;
if (!single_value->field_geoAreaPosLatitude.is_value()) return FALSE;
if (!single_value->field_geoAreaPosLongitude.is_value()) return FALSE;
if (!single_value->field_distanceA.is_value()) return FALSE;
if (!single_value->field_distanceB.is_value()) return FALSE;
if (!single_value->field_angle.is_value()) return FALSE;
if (!single_value->field_reserved2.is_value()) return FALSE;
return TRUE;
}

void GeoAnycastHeader_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GeoAnycastHeader GeoAnycastHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
GeoAnycastHeader ret_val;
if (single_value->field_seqNumber.is_bound()) {
ret_val.seqNumber() = single_value->field_seqNumber.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
if (single_value->field_srcPosVector.is_bound()) {
ret_val.srcPosVector() = single_value->field_srcPosVector.valueof();
}
if (single_value->field_geoAreaPosLatitude.is_bound()) {
ret_val.geoAreaPosLatitude() = single_value->field_geoAreaPosLatitude.valueof();
}
if (single_value->field_geoAreaPosLongitude.is_bound()) {
ret_val.geoAreaPosLongitude() = single_value->field_geoAreaPosLongitude.valueof();
}
if (single_value->field_distanceA.is_bound()) {
ret_val.distanceA() = single_value->field_distanceA.valueof();
}
if (single_value->field_distanceB.is_bound()) {
ret_val.distanceB() = single_value->field_distanceB.valueof();
}
if (single_value->field_angle.is_bound()) {
ret_val.angle() = single_value->field_angle.valueof();
}
if (single_value->field_reserved2.is_bound()) {
ret_val.reserved2() = single_value->field_reserved2.valueof();
}
return ret_val;
}

void GeoAnycastHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GeoAnycastHeader_template[list_length];
}

GeoAnycastHeader_template& GeoAnycastHeader_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
return value_list.list_value[list_index];
}

INTEGER_template& GeoAnycastHeader_template::seqNumber()
{
set_specific();
return single_value->field_seqNumber;
}

const INTEGER_template& GeoAnycastHeader_template::seqNumber() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field seqNumber of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
return single_value->field_seqNumber;
}

INTEGER_template& GeoAnycastHeader_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const INTEGER_template& GeoAnycastHeader_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
return single_value->field_reserved;
}

LongPosVector_template& GeoAnycastHeader_template::srcPosVector()
{
set_specific();
return single_value->field_srcPosVector;
}

const LongPosVector_template& GeoAnycastHeader_template::srcPosVector() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field srcPosVector of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
return single_value->field_srcPosVector;
}

INTEGER_template& GeoAnycastHeader_template::geoAreaPosLatitude()
{
set_specific();
return single_value->field_geoAreaPosLatitude;
}

const INTEGER_template& GeoAnycastHeader_template::geoAreaPosLatitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoAreaPosLatitude of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
return single_value->field_geoAreaPosLatitude;
}

INTEGER_template& GeoAnycastHeader_template::geoAreaPosLongitude()
{
set_specific();
return single_value->field_geoAreaPosLongitude;
}

const INTEGER_template& GeoAnycastHeader_template::geoAreaPosLongitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field geoAreaPosLongitude of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
return single_value->field_geoAreaPosLongitude;
}

INTEGER_template& GeoAnycastHeader_template::distanceA()
{
set_specific();
return single_value->field_distanceA;
}

const INTEGER_template& GeoAnycastHeader_template::distanceA() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field distanceA of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
return single_value->field_distanceA;
}

INTEGER_template& GeoAnycastHeader_template::distanceB()
{
set_specific();
return single_value->field_distanceB;
}

const INTEGER_template& GeoAnycastHeader_template::distanceB() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field distanceB of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
return single_value->field_distanceB;
}

INTEGER_template& GeoAnycastHeader_template::angle()
{
set_specific();
return single_value->field_angle;
}

const INTEGER_template& GeoAnycastHeader_template::angle() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field angle of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
return single_value->field_angle;
}

INTEGER_template& GeoAnycastHeader_template::reserved2()
{
set_specific();
return single_value->field_reserved2;
}

const INTEGER_template& GeoAnycastHeader_template::reserved2() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved2 of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
return single_value->field_reserved2;
}

int GeoAnycastHeader_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 9;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
  }
  return 0;
}

void GeoAnycastHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ seqNumber := ");
single_value->field_seqNumber.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(", srcPosVector := ");
single_value->field_srcPosVector.log();
TTCN_Logger::log_event_str(", geoAreaPosLatitude := ");
single_value->field_geoAreaPosLatitude.log();
TTCN_Logger::log_event_str(", geoAreaPosLongitude := ");
single_value->field_geoAreaPosLongitude.log();
TTCN_Logger::log_event_str(", distanceA := ");
single_value->field_distanceA.log();
TTCN_Logger::log_event_str(", distanceB := ");
single_value->field_distanceB.log();
TTCN_Logger::log_event_str(", angle := ");
single_value->field_angle.log();
TTCN_Logger::log_event_str(", reserved2 := ");
single_value->field_reserved2.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GeoAnycastHeader_template::log_match(const GeoAnycastHeader& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_seqNumber.match(match_value.seqNumber(), legacy)){
TTCN_Logger::log_logmatch_info(".seqNumber");
single_value->field_seqNumber.log_match(match_value.seqNumber(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_srcPosVector.match(match_value.srcPosVector(), legacy)){
TTCN_Logger::log_logmatch_info(".srcPosVector");
single_value->field_srcPosVector.log_match(match_value.srcPosVector(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoAreaPosLatitude.match(match_value.geoAreaPosLatitude(), legacy)){
TTCN_Logger::log_logmatch_info(".geoAreaPosLatitude");
single_value->field_geoAreaPosLatitude.log_match(match_value.geoAreaPosLatitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_geoAreaPosLongitude.match(match_value.geoAreaPosLongitude(), legacy)){
TTCN_Logger::log_logmatch_info(".geoAreaPosLongitude");
single_value->field_geoAreaPosLongitude.log_match(match_value.geoAreaPosLongitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_distanceA.match(match_value.distanceA(), legacy)){
TTCN_Logger::log_logmatch_info(".distanceA");
single_value->field_distanceA.log_match(match_value.distanceA(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_distanceB.match(match_value.distanceB(), legacy)){
TTCN_Logger::log_logmatch_info(".distanceB");
single_value->field_distanceB.log_match(match_value.distanceB(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_angle.match(match_value.angle(), legacy)){
TTCN_Logger::log_logmatch_info(".angle");
single_value->field_angle.log_match(match_value.angle(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved2.match(match_value.reserved2(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved2");
single_value->field_reserved2.log_match(match_value.reserved2(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ seqNumber := ");
single_value->field_seqNumber.log_match(match_value.seqNumber(), legacy);
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::log_event_str(", srcPosVector := ");
single_value->field_srcPosVector.log_match(match_value.srcPosVector(), legacy);
TTCN_Logger::log_event_str(", geoAreaPosLatitude := ");
single_value->field_geoAreaPosLatitude.log_match(match_value.geoAreaPosLatitude(), legacy);
TTCN_Logger::log_event_str(", geoAreaPosLongitude := ");
single_value->field_geoAreaPosLongitude.log_match(match_value.geoAreaPosLongitude(), legacy);
TTCN_Logger::log_event_str(", distanceA := ");
single_value->field_distanceA.log_match(match_value.distanceA(), legacy);
TTCN_Logger::log_event_str(", distanceB := ");
single_value->field_distanceB.log_match(match_value.distanceB(), legacy);
TTCN_Logger::log_event_str(", angle := ");
single_value->field_angle.log_match(match_value.angle(), legacy);
TTCN_Logger::log_event_str(", reserved2 := ");
single_value->field_reserved2.log_match(match_value.reserved2(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GeoAnycastHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_seqNumber.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
single_value->field_srcPosVector.encode_text(text_buf);
single_value->field_geoAreaPosLatitude.encode_text(text_buf);
single_value->field_geoAreaPosLongitude.encode_text(text_buf);
single_value->field_distanceA.encode_text(text_buf);
single_value->field_distanceB.encode_text(text_buf);
single_value->field_angle.encode_text(text_buf);
single_value->field_reserved2.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
}
}

void GeoAnycastHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_seqNumber.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
single_value->field_srcPosVector.decode_text(text_buf);
single_value->field_geoAreaPosLatitude.decode_text(text_buf);
single_value->field_geoAreaPosLongitude.decode_text(text_buf);
single_value->field_distanceA.decode_text(text_buf);
single_value->field_distanceB.decode_text(text_buf);
single_value->field_angle.decode_text(text_buf);
single_value->field_reserved2.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GeoAnycastHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader.");
}
}

void GeoAnycastHeader_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      seqNumber().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("srcPosVector", param_field) == 0) {
      srcPosVector().set_param(param);
      return;
    } else if (strcmp("geoAreaPosLatitude", param_field) == 0) {
      geoAreaPosLatitude().set_param(param);
      return;
    } else if (strcmp("geoAreaPosLongitude", param_field) == 0) {
      geoAreaPosLongitude().set_param(param);
      return;
    } else if (strcmp("distanceA", param_field) == 0) {
      distanceA().set_param(param);
      return;
    } else if (strcmp("distanceB", param_field) == 0) {
      distanceB().set_param(param);
      return;
    } else if (strcmp("angle", param_field) == 0) {
      angle().set_param(param);
      return;
    } else if (strcmp("reserved2", param_field) == 0) {
      reserved2().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GeoAnycastHeader_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (9<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader has 9 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) seqNumber().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) srcPosVector().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) geoAreaPosLatitude().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) geoAreaPosLongitude().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) distanceA().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) distanceB().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) angle().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) reserved2().set_param(*mp->get_elem(8));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "seqNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          seqNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoAreaPosLatitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoAreaPosLatitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "geoAreaPosLongitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          geoAreaPosLongitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "distanceA")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          distanceA().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "distanceB")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          distanceB().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "angle")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          angle().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved2().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GeoAnycastHeader_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      return seqNumber().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("srcPosVector", param_field) == 0) {
      return srcPosVector().get_param(param_name);
    } else if (strcmp("geoAreaPosLatitude", param_field) == 0) {
      return geoAreaPosLatitude().get_param(param_name);
    } else if (strcmp("geoAreaPosLongitude", param_field) == 0) {
      return geoAreaPosLongitude().get_param(param_name);
    } else if (strcmp("distanceA", param_field) == 0) {
      return distanceA().get_param(param_name);
    } else if (strcmp("distanceB", param_field) == 0) {
      return distanceB().get_param(param_name);
    } else if (strcmp("angle", param_field) == 0) {
      return angle().get_param(param_name);
    } else if (strcmp("reserved2", param_field) == 0) {
      return reserved2().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_seqNumber = single_value->field_seqNumber.get_param(param_name);
    mp_field_seqNumber->set_id(new Module_Param_FieldName(mcopystr("seqNumber")));
    mp->add_elem(mp_field_seqNumber);
    Module_Param* mp_field_reserved = single_value->field_reserved.get_param(param_name);
    mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
    mp->add_elem(mp_field_reserved);
    Module_Param* mp_field_srcPosVector = single_value->field_srcPosVector.get_param(param_name);
    mp_field_srcPosVector->set_id(new Module_Param_FieldName(mcopystr("srcPosVector")));
    mp->add_elem(mp_field_srcPosVector);
    Module_Param* mp_field_geoAreaPosLatitude = single_value->field_geoAreaPosLatitude.get_param(param_name);
    mp_field_geoAreaPosLatitude->set_id(new Module_Param_FieldName(mcopystr("geoAreaPosLatitude")));
    mp->add_elem(mp_field_geoAreaPosLatitude);
    Module_Param* mp_field_geoAreaPosLongitude = single_value->field_geoAreaPosLongitude.get_param(param_name);
    mp_field_geoAreaPosLongitude->set_id(new Module_Param_FieldName(mcopystr("geoAreaPosLongitude")));
    mp->add_elem(mp_field_geoAreaPosLongitude);
    Module_Param* mp_field_distanceA = single_value->field_distanceA.get_param(param_name);
    mp_field_distanceA->set_id(new Module_Param_FieldName(mcopystr("distanceA")));
    mp->add_elem(mp_field_distanceA);
    Module_Param* mp_field_distanceB = single_value->field_distanceB.get_param(param_name);
    mp_field_distanceB->set_id(new Module_Param_FieldName(mcopystr("distanceB")));
    mp->add_elem(mp_field_distanceB);
    Module_Param* mp_field_angle = single_value->field_angle.get_param(param_name);
    mp_field_angle->set_id(new Module_Param_FieldName(mcopystr("angle")));
    mp->add_elem(mp_field_angle);
    Module_Param* mp_field_reserved2 = single_value->field_reserved2.get_param(param_name);
    mp_field_reserved2->set_id(new Module_Param_FieldName(mcopystr("reserved2")));
    mp->add_elem(mp_field_reserved2);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GeoAnycastHeader_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_seqNumber.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader");
single_value->field_srcPosVector.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader");
single_value->field_geoAreaPosLatitude.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader");
single_value->field_geoAreaPosLongitude.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader");
single_value->field_distanceA.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader");
single_value->field_distanceB.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader");
single_value->field_angle.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader");
single_value->field_reserved2.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoAnycastHeader");
}

boolean GeoAnycastHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GeoAnycastHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

BeaconHeader::BeaconHeader()
{
  bound_flag = FALSE;
}

BeaconHeader::BeaconHeader(const LongPosVector& par_srcPosVector)
  :   field_srcPosVector(par_srcPosVector)
{
  bound_flag = TRUE;
}

BeaconHeader::BeaconHeader(const BeaconHeader& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader.");
bound_flag = TRUE;
if (other_value.srcPosVector().is_bound()) field_srcPosVector = other_value.srcPosVector();
else field_srcPosVector.clean_up();
}

void BeaconHeader::clean_up()
{
field_srcPosVector.clean_up();
bound_flag = FALSE;
}

BeaconHeader& BeaconHeader::operator=(const BeaconHeader& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader.");
  bound_flag = TRUE;
  if (other_value.srcPosVector().is_bound()) field_srcPosVector = other_value.srcPosVector();
  else field_srcPosVector.clean_up();
}
return *this;
}

boolean BeaconHeader::operator==(const BeaconHeader& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_srcPosVector==other_value.field_srcPosVector;
}

boolean BeaconHeader::is_bound() const
{
if (bound_flag) return TRUE;
if(field_srcPosVector.is_bound()) return TRUE;
return FALSE;
}
boolean BeaconHeader::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_srcPosVector.is_value()) return FALSE;
return TRUE;
}
int BeaconHeader::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader");
  return 1;
}

void BeaconHeader::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ srcPosVector := ");
field_srcPosVector.log();
TTCN_Logger::log_event_str(" }");
}

void BeaconHeader::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.BeaconHeader'");
    }
    if (strcmp("srcPosVector", param_field) == 0) {
      srcPosVector().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.BeaconHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) srcPosVector().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.BeaconHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.BeaconHeader");
  }
}

Module_Param* BeaconHeader::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.BeaconHeader'");
    }
    if (strcmp("srcPosVector", param_field) == 0) {
      return srcPosVector().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.BeaconHeader'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_srcPosVector = field_srcPosVector.get_param(param_name);
  mp_field_srcPosVector->set_id(new Module_Param_FieldName(mcopystr("srcPosVector")));
  mp->add_elem(mp_field_srcPosVector);
  return mp;
  }

void BeaconHeader::set_implicit_omit()
{
if (srcPosVector().is_bound()) srcPosVector().set_implicit_omit();
}

void BeaconHeader::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader.");
field_srcPosVector.encode_text(text_buf);
}

void BeaconHeader::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_srcPosVector.decode_text(text_buf);
}

void BeaconHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void BeaconHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int BeaconHeader::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_srcPosVector.RAW_decode(LongPosVector_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int BeaconHeader::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LongPosVector_descr_.raw);
  encoded_length += field_srcPosVector.RAW_encode(LongPosVector_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int BeaconHeader::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "srcPosVector");
    enc_len += field_srcPosVector.JSON_encode(LongPosVector_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int BeaconHeader::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "srcPosVector", name_len)) {
         int ret_val = field_srcPosVector.JSON_decode(LongPosVector_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "srcPosVector");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_srcPosVector.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "srcPosVector");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct BeaconHeader_template::single_value_struct {
LongPosVector_template field_srcPosVector;
};

void BeaconHeader_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_srcPosVector = ANY_VALUE;
}
}
}

void BeaconHeader_template::copy_value(const BeaconHeader& other_value)
{
single_value = new single_value_struct;
if (other_value.srcPosVector().is_bound()) {
  single_value->field_srcPosVector = other_value.srcPosVector();
} else {
  single_value->field_srcPosVector.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void BeaconHeader_template::copy_template(const BeaconHeader_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.srcPosVector().get_selection()) {
single_value->field_srcPosVector = other_value.srcPosVector();
} else {
single_value->field_srcPosVector.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new BeaconHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader.");
break;
}
set_selection(other_value);
}

BeaconHeader_template::BeaconHeader_template()
{
}

BeaconHeader_template::BeaconHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

BeaconHeader_template::BeaconHeader_template(const BeaconHeader& other_value)
{
copy_value(other_value);
}

BeaconHeader_template::BeaconHeader_template(const OPTIONAL<BeaconHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BeaconHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader from an unbound optional field.");
}
}

BeaconHeader_template::BeaconHeader_template(const BeaconHeader_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

BeaconHeader_template::~BeaconHeader_template()
{
clean_up();
}

BeaconHeader_template& BeaconHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

BeaconHeader_template& BeaconHeader_template::operator=(const BeaconHeader& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

BeaconHeader_template& BeaconHeader_template::operator=(const OPTIONAL<BeaconHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const BeaconHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader.");
}
return *this;
}

BeaconHeader_template& BeaconHeader_template::operator=(const BeaconHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean BeaconHeader_template::match(const BeaconHeader& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.srcPosVector().is_bound()) return FALSE;
if(!single_value->field_srcPosVector.match(other_value.srcPosVector(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader.");
}
return FALSE;
}

boolean BeaconHeader_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_srcPosVector.is_bound()) return TRUE;
return FALSE;
}

boolean BeaconHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_srcPosVector.is_value()) return FALSE;
return TRUE;
}

void BeaconHeader_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

BeaconHeader BeaconHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader.");
BeaconHeader ret_val;
if (single_value->field_srcPosVector.is_bound()) {
ret_val.srcPosVector() = single_value->field_srcPosVector.valueof();
}
return ret_val;
}

void BeaconHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new BeaconHeader_template[list_length];
}

BeaconHeader_template& BeaconHeader_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader.");
return value_list.list_value[list_index];
}

LongPosVector_template& BeaconHeader_template::srcPosVector()
{
set_specific();
return single_value->field_srcPosVector;
}

const LongPosVector_template& BeaconHeader_template::srcPosVector() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field srcPosVector of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader.");
return single_value->field_srcPosVector;
}

int BeaconHeader_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader.");
  }
  return 0;
}

void BeaconHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ srcPosVector := ");
single_value->field_srcPosVector.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void BeaconHeader_template::log_match(const BeaconHeader& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_srcPosVector.match(match_value.srcPosVector(), legacy)){
TTCN_Logger::log_logmatch_info(".srcPosVector");
single_value->field_srcPosVector.log_match(match_value.srcPosVector(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ srcPosVector := ");
single_value->field_srcPosVector.log_match(match_value.srcPosVector(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void BeaconHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_srcPosVector.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader.");
}
}

void BeaconHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_srcPosVector.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new BeaconHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader.");
}
}

void BeaconHeader_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.BeaconHeader'");
    }
    if (strcmp("srcPosVector", param_field) == 0) {
      srcPosVector().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.BeaconHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    BeaconHeader_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.BeaconHeader has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) srcPosVector().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.BeaconHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.BeaconHeader");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* BeaconHeader_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.BeaconHeader'");
    }
    if (strcmp("srcPosVector", param_field) == 0) {
      return srcPosVector().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.BeaconHeader'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_srcPosVector = single_value->field_srcPosVector.get_param(param_name);
    mp_field_srcPosVector->set_id(new Module_Param_FieldName(mcopystr("srcPosVector")));
    mp->add_elem(mp_field_srcPosVector);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void BeaconHeader_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_srcPosVector.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.BeaconHeader");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.BeaconHeader");
}

boolean BeaconHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean BeaconHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

LSRequestHeader::LSRequestHeader()
{
  bound_flag = FALSE;
}

LSRequestHeader::LSRequestHeader(const INTEGER& par_seqNumber,
    const INTEGER& par_reserved,
    const LongPosVector& par_srcPosVector,
    const GN__Address& par_gnAddress)
  :   field_seqNumber(par_seqNumber),
  field_reserved(par_reserved),
  field_srcPosVector(par_srcPosVector),
  field_gnAddress(par_gnAddress)
{
  bound_flag = TRUE;
}

LSRequestHeader::LSRequestHeader(const LSRequestHeader& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
bound_flag = TRUE;
if (other_value.seqNumber().is_bound()) field_seqNumber = other_value.seqNumber();
else field_seqNumber.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
if (other_value.srcPosVector().is_bound()) field_srcPosVector = other_value.srcPosVector();
else field_srcPosVector.clean_up();
if (other_value.gnAddress().is_bound()) field_gnAddress = other_value.gnAddress();
else field_gnAddress.clean_up();
}

void LSRequestHeader::clean_up()
{
field_seqNumber.clean_up();
field_reserved.clean_up();
field_srcPosVector.clean_up();
field_gnAddress.clean_up();
bound_flag = FALSE;
}

LSRequestHeader& LSRequestHeader::operator=(const LSRequestHeader& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
  bound_flag = TRUE;
  if (other_value.seqNumber().is_bound()) field_seqNumber = other_value.seqNumber();
  else field_seqNumber.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
  if (other_value.srcPosVector().is_bound()) field_srcPosVector = other_value.srcPosVector();
  else field_srcPosVector.clean_up();
  if (other_value.gnAddress().is_bound()) field_gnAddress = other_value.gnAddress();
  else field_gnAddress.clean_up();
}
return *this;
}

boolean LSRequestHeader::operator==(const LSRequestHeader& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_seqNumber==other_value.field_seqNumber
  && field_reserved==other_value.field_reserved
  && field_srcPosVector==other_value.field_srcPosVector
  && field_gnAddress==other_value.field_gnAddress;
}

boolean LSRequestHeader::is_bound() const
{
if (bound_flag) return TRUE;
if(field_seqNumber.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
if(field_srcPosVector.is_bound()) return TRUE;
if(field_gnAddress.is_bound()) return TRUE;
return FALSE;
}
boolean LSRequestHeader::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_seqNumber.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
if(!field_srcPosVector.is_value()) return FALSE;
if(!field_gnAddress.is_value()) return FALSE;
return TRUE;
}
int LSRequestHeader::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader");
  return 4;
}

void LSRequestHeader::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ seqNumber := ");
field_seqNumber.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(", srcPosVector := ");
field_srcPosVector.log();
TTCN_Logger::log_event_str(", gnAddress := ");
field_gnAddress.log();
TTCN_Logger::log_event_str(" }");
}

void LSRequestHeader::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.LSRequestHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      seqNumber().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("srcPosVector", param_field) == 0) {
      srcPosVector().set_param(param);
      return;
    } else if (strcmp("gnAddress", param_field) == 0) {
      gnAddress().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.LSRequestHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) seqNumber().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) srcPosVector().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) gnAddress().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "seqNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          seqNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnAddress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnAddress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.LSRequestHeader");
  }
}

Module_Param* LSRequestHeader::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.LSRequestHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      return seqNumber().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("srcPosVector", param_field) == 0) {
      return srcPosVector().get_param(param_name);
    } else if (strcmp("gnAddress", param_field) == 0) {
      return gnAddress().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.LSRequestHeader'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_seqNumber = field_seqNumber.get_param(param_name);
  mp_field_seqNumber->set_id(new Module_Param_FieldName(mcopystr("seqNumber")));
  mp->add_elem(mp_field_seqNumber);
  Module_Param* mp_field_reserved = field_reserved.get_param(param_name);
  mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
  mp->add_elem(mp_field_reserved);
  Module_Param* mp_field_srcPosVector = field_srcPosVector.get_param(param_name);
  mp_field_srcPosVector->set_id(new Module_Param_FieldName(mcopystr("srcPosVector")));
  mp->add_elem(mp_field_srcPosVector);
  Module_Param* mp_field_gnAddress = field_gnAddress.get_param(param_name);
  mp_field_gnAddress->set_id(new Module_Param_FieldName(mcopystr("gnAddress")));
  mp->add_elem(mp_field_gnAddress);
  return mp;
  }

void LSRequestHeader::set_implicit_omit()
{
if (seqNumber().is_bound()) seqNumber().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
if (srcPosVector().is_bound()) srcPosVector().set_implicit_omit();
if (gnAddress().is_bound()) gnAddress().set_implicit_omit();
}

void LSRequestHeader::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
field_seqNumber.encode_text(text_buf);
field_reserved.encode_text(text_buf);
field_srcPosVector.encode_text(text_buf);
field_gnAddress.encode_text(text_buf);
}

void LSRequestHeader::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_seqNumber.decode_text(text_buf);
field_reserved.decode_text(text_buf);
field_srcPosVector.decode_text(text_buf);
field_gnAddress.decode_text(text_buf);
}

void LSRequestHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void LSRequestHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int LSRequestHeader::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_seqNumber.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_srcPosVector.RAW_decode(LongPosVector_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnAddress.RAW_decode(GN__Address_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int LSRequestHeader::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 4;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(4);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LongPosVector_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, GN__Address_descr_.raw);
  encoded_length += field_seqNumber.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_reserved.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_srcPosVector.RAW_encode(LongPosVector_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_gnAddress.RAW_encode(GN__Address_descr_, *myleaf.body.node.nodes[3]);
  return myleaf.length = encoded_length;
}

int LSRequestHeader::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "seqNumber");
    enc_len += field_seqNumber.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "srcPosVector");
    enc_len += field_srcPosVector.JSON_encode(LongPosVector_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnAddress");
    enc_len += field_gnAddress.JSON_encode(GN__Address_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int LSRequestHeader::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (9 == name_len && 0 == strncmp(fld_name, "seqNumber", name_len)) {
         int ret_val = field_seqNumber.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "seqNumber");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
         int ret_val = field_reserved.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "srcPosVector", name_len)) {
         int ret_val = field_srcPosVector.JSON_decode(LongPosVector_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "srcPosVector");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "gnAddress", name_len)) {
         int ret_val = field_gnAddress.JSON_decode(GN__Address_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnAddress");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_seqNumber.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "seqNumber");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }
if (!field_srcPosVector.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "srcPosVector");
    return JSON_ERROR_FATAL;
  }
if (!field_gnAddress.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnAddress");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct LSRequestHeader_template::single_value_struct {
INTEGER_template field_seqNumber;
INTEGER_template field_reserved;
LongPosVector_template field_srcPosVector;
GN__Address_template field_gnAddress;
};

void LSRequestHeader_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_seqNumber = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
single_value->field_srcPosVector = ANY_VALUE;
single_value->field_gnAddress = ANY_VALUE;
}
}
}

void LSRequestHeader_template::copy_value(const LSRequestHeader& other_value)
{
single_value = new single_value_struct;
if (other_value.seqNumber().is_bound()) {
  single_value->field_seqNumber = other_value.seqNumber();
} else {
  single_value->field_seqNumber.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
if (other_value.srcPosVector().is_bound()) {
  single_value->field_srcPosVector = other_value.srcPosVector();
} else {
  single_value->field_srcPosVector.clean_up();
}
if (other_value.gnAddress().is_bound()) {
  single_value->field_gnAddress = other_value.gnAddress();
} else {
  single_value->field_gnAddress.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void LSRequestHeader_template::copy_template(const LSRequestHeader_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.seqNumber().get_selection()) {
single_value->field_seqNumber = other_value.seqNumber();
} else {
single_value->field_seqNumber.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.srcPosVector().get_selection()) {
single_value->field_srcPosVector = other_value.srcPosVector();
} else {
single_value->field_srcPosVector.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnAddress().get_selection()) {
single_value->field_gnAddress = other_value.gnAddress();
} else {
single_value->field_gnAddress.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new LSRequestHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
break;
}
set_selection(other_value);
}

LSRequestHeader_template::LSRequestHeader_template()
{
}

LSRequestHeader_template::LSRequestHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

LSRequestHeader_template::LSRequestHeader_template(const LSRequestHeader& other_value)
{
copy_value(other_value);
}

LSRequestHeader_template::LSRequestHeader_template(const OPTIONAL<LSRequestHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LSRequestHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader from an unbound optional field.");
}
}

LSRequestHeader_template::LSRequestHeader_template(const LSRequestHeader_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

LSRequestHeader_template::~LSRequestHeader_template()
{
clean_up();
}

LSRequestHeader_template& LSRequestHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

LSRequestHeader_template& LSRequestHeader_template::operator=(const LSRequestHeader& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

LSRequestHeader_template& LSRequestHeader_template::operator=(const OPTIONAL<LSRequestHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LSRequestHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
}
return *this;
}

LSRequestHeader_template& LSRequestHeader_template::operator=(const LSRequestHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean LSRequestHeader_template::match(const LSRequestHeader& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.seqNumber().is_bound()) return FALSE;
if(!single_value->field_seqNumber.match(other_value.seqNumber(), legacy))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved(), legacy))return FALSE;
if(!other_value.srcPosVector().is_bound()) return FALSE;
if(!single_value->field_srcPosVector.match(other_value.srcPosVector(), legacy))return FALSE;
if(!other_value.gnAddress().is_bound()) return FALSE;
if(!single_value->field_gnAddress.match(other_value.gnAddress(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
}
return FALSE;
}

boolean LSRequestHeader_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_seqNumber.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
if (single_value->field_srcPosVector.is_bound()) return TRUE;
if (single_value->field_gnAddress.is_bound()) return TRUE;
return FALSE;
}

boolean LSRequestHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_seqNumber.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
if (!single_value->field_srcPosVector.is_value()) return FALSE;
if (!single_value->field_gnAddress.is_value()) return FALSE;
return TRUE;
}

void LSRequestHeader_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

LSRequestHeader LSRequestHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
LSRequestHeader ret_val;
if (single_value->field_seqNumber.is_bound()) {
ret_val.seqNumber() = single_value->field_seqNumber.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
if (single_value->field_srcPosVector.is_bound()) {
ret_val.srcPosVector() = single_value->field_srcPosVector.valueof();
}
if (single_value->field_gnAddress.is_bound()) {
ret_val.gnAddress() = single_value->field_gnAddress.valueof();
}
return ret_val;
}

void LSRequestHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new LSRequestHeader_template[list_length];
}

LSRequestHeader_template& LSRequestHeader_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
return value_list.list_value[list_index];
}

INTEGER_template& LSRequestHeader_template::seqNumber()
{
set_specific();
return single_value->field_seqNumber;
}

const INTEGER_template& LSRequestHeader_template::seqNumber() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field seqNumber of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
return single_value->field_seqNumber;
}

INTEGER_template& LSRequestHeader_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const INTEGER_template& LSRequestHeader_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
return single_value->field_reserved;
}

LongPosVector_template& LSRequestHeader_template::srcPosVector()
{
set_specific();
return single_value->field_srcPosVector;
}

const LongPosVector_template& LSRequestHeader_template::srcPosVector() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field srcPosVector of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
return single_value->field_srcPosVector;
}

GN__Address_template& LSRequestHeader_template::gnAddress()
{
set_specific();
return single_value->field_gnAddress;
}

const GN__Address_template& LSRequestHeader_template::gnAddress() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnAddress of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
return single_value->field_gnAddress;
}

int LSRequestHeader_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 4;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
  }
  return 0;
}

void LSRequestHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ seqNumber := ");
single_value->field_seqNumber.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(", srcPosVector := ");
single_value->field_srcPosVector.log();
TTCN_Logger::log_event_str(", gnAddress := ");
single_value->field_gnAddress.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void LSRequestHeader_template::log_match(const LSRequestHeader& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_seqNumber.match(match_value.seqNumber(), legacy)){
TTCN_Logger::log_logmatch_info(".seqNumber");
single_value->field_seqNumber.log_match(match_value.seqNumber(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_srcPosVector.match(match_value.srcPosVector(), legacy)){
TTCN_Logger::log_logmatch_info(".srcPosVector");
single_value->field_srcPosVector.log_match(match_value.srcPosVector(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnAddress.match(match_value.gnAddress(), legacy)){
TTCN_Logger::log_logmatch_info(".gnAddress");
single_value->field_gnAddress.log_match(match_value.gnAddress(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ seqNumber := ");
single_value->field_seqNumber.log_match(match_value.seqNumber(), legacy);
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::log_event_str(", srcPosVector := ");
single_value->field_srcPosVector.log_match(match_value.srcPosVector(), legacy);
TTCN_Logger::log_event_str(", gnAddress := ");
single_value->field_gnAddress.log_match(match_value.gnAddress(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void LSRequestHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_seqNumber.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
single_value->field_srcPosVector.encode_text(text_buf);
single_value->field_gnAddress.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
}
}

void LSRequestHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_seqNumber.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
single_value->field_srcPosVector.decode_text(text_buf);
single_value->field_gnAddress.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new LSRequestHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader.");
}
}

void LSRequestHeader_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.LSRequestHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      seqNumber().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("srcPosVector", param_field) == 0) {
      srcPosVector().set_param(param);
      return;
    } else if (strcmp("gnAddress", param_field) == 0) {
      gnAddress().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.LSRequestHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    LSRequestHeader_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) seqNumber().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) srcPosVector().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) gnAddress().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "seqNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          seqNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnAddress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnAddress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.LSRequestHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.LSRequestHeader");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* LSRequestHeader_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.LSRequestHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      return seqNumber().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("srcPosVector", param_field) == 0) {
      return srcPosVector().get_param(param_name);
    } else if (strcmp("gnAddress", param_field) == 0) {
      return gnAddress().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.LSRequestHeader'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_seqNumber = single_value->field_seqNumber.get_param(param_name);
    mp_field_seqNumber->set_id(new Module_Param_FieldName(mcopystr("seqNumber")));
    mp->add_elem(mp_field_seqNumber);
    Module_Param* mp_field_reserved = single_value->field_reserved.get_param(param_name);
    mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
    mp->add_elem(mp_field_reserved);
    Module_Param* mp_field_srcPosVector = single_value->field_srcPosVector.get_param(param_name);
    mp_field_srcPosVector->set_id(new Module_Param_FieldName(mcopystr("srcPosVector")));
    mp->add_elem(mp_field_srcPosVector);
    Module_Param* mp_field_gnAddress = single_value->field_gnAddress.get_param(param_name);
    mp_field_gnAddress->set_id(new Module_Param_FieldName(mcopystr("gnAddress")));
    mp->add_elem(mp_field_gnAddress);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void LSRequestHeader_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_seqNumber.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LSRequestHeader");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LSRequestHeader");
single_value->field_srcPosVector.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LSRequestHeader");
single_value->field_gnAddress.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LSRequestHeader");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LSRequestHeader");
}

boolean LSRequestHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean LSRequestHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

LSReplyHeader::LSReplyHeader()
{
  bound_flag = FALSE;
}

LSReplyHeader::LSReplyHeader(const INTEGER& par_seqNumber,
    const INTEGER& par_reserved,
    const LongPosVector& par_srcPosVector,
    const ShortPosVector& par_dstPosVector)
  :   field_seqNumber(par_seqNumber),
  field_reserved(par_reserved),
  field_srcPosVector(par_srcPosVector),
  field_dstPosVector(par_dstPosVector)
{
  bound_flag = TRUE;
}

LSReplyHeader::LSReplyHeader(const LSReplyHeader& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
bound_flag = TRUE;
if (other_value.seqNumber().is_bound()) field_seqNumber = other_value.seqNumber();
else field_seqNumber.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
if (other_value.srcPosVector().is_bound()) field_srcPosVector = other_value.srcPosVector();
else field_srcPosVector.clean_up();
if (other_value.dstPosVector().is_bound()) field_dstPosVector = other_value.dstPosVector();
else field_dstPosVector.clean_up();
}

void LSReplyHeader::clean_up()
{
field_seqNumber.clean_up();
field_reserved.clean_up();
field_srcPosVector.clean_up();
field_dstPosVector.clean_up();
bound_flag = FALSE;
}

LSReplyHeader& LSReplyHeader::operator=(const LSReplyHeader& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
  bound_flag = TRUE;
  if (other_value.seqNumber().is_bound()) field_seqNumber = other_value.seqNumber();
  else field_seqNumber.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
  if (other_value.srcPosVector().is_bound()) field_srcPosVector = other_value.srcPosVector();
  else field_srcPosVector.clean_up();
  if (other_value.dstPosVector().is_bound()) field_dstPosVector = other_value.dstPosVector();
  else field_dstPosVector.clean_up();
}
return *this;
}

boolean LSReplyHeader::operator==(const LSReplyHeader& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_seqNumber==other_value.field_seqNumber
  && field_reserved==other_value.field_reserved
  && field_srcPosVector==other_value.field_srcPosVector
  && field_dstPosVector==other_value.field_dstPosVector;
}

boolean LSReplyHeader::is_bound() const
{
if (bound_flag) return TRUE;
if(field_seqNumber.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
if(field_srcPosVector.is_bound()) return TRUE;
if(field_dstPosVector.is_bound()) return TRUE;
return FALSE;
}
boolean LSReplyHeader::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_seqNumber.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
if(!field_srcPosVector.is_value()) return FALSE;
if(!field_dstPosVector.is_value()) return FALSE;
return TRUE;
}
int LSReplyHeader::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader");
  return 4;
}

void LSReplyHeader::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ seqNumber := ");
field_seqNumber.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(", srcPosVector := ");
field_srcPosVector.log();
TTCN_Logger::log_event_str(", dstPosVector := ");
field_dstPosVector.log();
TTCN_Logger::log_event_str(" }");
}

void LSReplyHeader::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.LSReplyHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      seqNumber().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("srcPosVector", param_field) == 0) {
      srcPosVector().set_param(param);
      return;
    } else if (strcmp("dstPosVector", param_field) == 0) {
      dstPosVector().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.LSReplyHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) seqNumber().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) srcPosVector().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) dstPosVector().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "seqNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          seqNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dstPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dstPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.LSReplyHeader");
  }
}

Module_Param* LSReplyHeader::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.LSReplyHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      return seqNumber().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("srcPosVector", param_field) == 0) {
      return srcPosVector().get_param(param_name);
    } else if (strcmp("dstPosVector", param_field) == 0) {
      return dstPosVector().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.LSReplyHeader'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_seqNumber = field_seqNumber.get_param(param_name);
  mp_field_seqNumber->set_id(new Module_Param_FieldName(mcopystr("seqNumber")));
  mp->add_elem(mp_field_seqNumber);
  Module_Param* mp_field_reserved = field_reserved.get_param(param_name);
  mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
  mp->add_elem(mp_field_reserved);
  Module_Param* mp_field_srcPosVector = field_srcPosVector.get_param(param_name);
  mp_field_srcPosVector->set_id(new Module_Param_FieldName(mcopystr("srcPosVector")));
  mp->add_elem(mp_field_srcPosVector);
  Module_Param* mp_field_dstPosVector = field_dstPosVector.get_param(param_name);
  mp_field_dstPosVector->set_id(new Module_Param_FieldName(mcopystr("dstPosVector")));
  mp->add_elem(mp_field_dstPosVector);
  return mp;
  }

void LSReplyHeader::set_implicit_omit()
{
if (seqNumber().is_bound()) seqNumber().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
if (srcPosVector().is_bound()) srcPosVector().set_implicit_omit();
if (dstPosVector().is_bound()) dstPosVector().set_implicit_omit();
}

void LSReplyHeader::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
field_seqNumber.encode_text(text_buf);
field_reserved.encode_text(text_buf);
field_srcPosVector.encode_text(text_buf);
field_dstPosVector.encode_text(text_buf);
}

void LSReplyHeader::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_seqNumber.decode_text(text_buf);
field_reserved.decode_text(text_buf);
field_srcPosVector.decode_text(text_buf);
field_dstPosVector.decode_text(text_buf);
}

void LSReplyHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void LSReplyHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int LSReplyHeader::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_seqNumber.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_srcPosVector.RAW_decode(LongPosVector_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_dstPosVector.RAW_decode(ShortPosVector_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int LSReplyHeader::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 4;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(4);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LongPosVector_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, ShortPosVector_descr_.raw);
  encoded_length += field_seqNumber.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_reserved.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_srcPosVector.RAW_encode(LongPosVector_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_dstPosVector.RAW_encode(ShortPosVector_descr_, *myleaf.body.node.nodes[3]);
  return myleaf.length = encoded_length;
}

int LSReplyHeader::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "seqNumber");
    enc_len += field_seqNumber.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "srcPosVector");
    enc_len += field_srcPosVector.JSON_encode(LongPosVector_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "dstPosVector");
    enc_len += field_dstPosVector.JSON_encode(ShortPosVector_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int LSReplyHeader::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (9 == name_len && 0 == strncmp(fld_name, "seqNumber", name_len)) {
         int ret_val = field_seqNumber.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "seqNumber");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
         int ret_val = field_reserved.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "srcPosVector", name_len)) {
         int ret_val = field_srcPosVector.JSON_decode(LongPosVector_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "srcPosVector");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "dstPosVector", name_len)) {
         int ret_val = field_dstPosVector.JSON_decode(ShortPosVector_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "dstPosVector");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_seqNumber.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "seqNumber");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }
if (!field_srcPosVector.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "srcPosVector");
    return JSON_ERROR_FATAL;
  }
if (!field_dstPosVector.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "dstPosVector");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct LSReplyHeader_template::single_value_struct {
INTEGER_template field_seqNumber;
INTEGER_template field_reserved;
LongPosVector_template field_srcPosVector;
ShortPosVector_template field_dstPosVector;
};

void LSReplyHeader_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_seqNumber = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
single_value->field_srcPosVector = ANY_VALUE;
single_value->field_dstPosVector = ANY_VALUE;
}
}
}

void LSReplyHeader_template::copy_value(const LSReplyHeader& other_value)
{
single_value = new single_value_struct;
if (other_value.seqNumber().is_bound()) {
  single_value->field_seqNumber = other_value.seqNumber();
} else {
  single_value->field_seqNumber.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
if (other_value.srcPosVector().is_bound()) {
  single_value->field_srcPosVector = other_value.srcPosVector();
} else {
  single_value->field_srcPosVector.clean_up();
}
if (other_value.dstPosVector().is_bound()) {
  single_value->field_dstPosVector = other_value.dstPosVector();
} else {
  single_value->field_dstPosVector.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void LSReplyHeader_template::copy_template(const LSReplyHeader_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.seqNumber().get_selection()) {
single_value->field_seqNumber = other_value.seqNumber();
} else {
single_value->field_seqNumber.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.srcPosVector().get_selection()) {
single_value->field_srcPosVector = other_value.srcPosVector();
} else {
single_value->field_srcPosVector.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.dstPosVector().get_selection()) {
single_value->field_dstPosVector = other_value.dstPosVector();
} else {
single_value->field_dstPosVector.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new LSReplyHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
break;
}
set_selection(other_value);
}

LSReplyHeader_template::LSReplyHeader_template()
{
}

LSReplyHeader_template::LSReplyHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

LSReplyHeader_template::LSReplyHeader_template(const LSReplyHeader& other_value)
{
copy_value(other_value);
}

LSReplyHeader_template::LSReplyHeader_template(const OPTIONAL<LSReplyHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LSReplyHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader from an unbound optional field.");
}
}

LSReplyHeader_template::LSReplyHeader_template(const LSReplyHeader_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

LSReplyHeader_template::~LSReplyHeader_template()
{
clean_up();
}

LSReplyHeader_template& LSReplyHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

LSReplyHeader_template& LSReplyHeader_template::operator=(const LSReplyHeader& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

LSReplyHeader_template& LSReplyHeader_template::operator=(const OPTIONAL<LSReplyHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const LSReplyHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
}
return *this;
}

LSReplyHeader_template& LSReplyHeader_template::operator=(const LSReplyHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean LSReplyHeader_template::match(const LSReplyHeader& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.seqNumber().is_bound()) return FALSE;
if(!single_value->field_seqNumber.match(other_value.seqNumber(), legacy))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved(), legacy))return FALSE;
if(!other_value.srcPosVector().is_bound()) return FALSE;
if(!single_value->field_srcPosVector.match(other_value.srcPosVector(), legacy))return FALSE;
if(!other_value.dstPosVector().is_bound()) return FALSE;
if(!single_value->field_dstPosVector.match(other_value.dstPosVector(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
}
return FALSE;
}

boolean LSReplyHeader_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_seqNumber.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
if (single_value->field_srcPosVector.is_bound()) return TRUE;
if (single_value->field_dstPosVector.is_bound()) return TRUE;
return FALSE;
}

boolean LSReplyHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_seqNumber.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
if (!single_value->field_srcPosVector.is_value()) return FALSE;
if (!single_value->field_dstPosVector.is_value()) return FALSE;
return TRUE;
}

void LSReplyHeader_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

LSReplyHeader LSReplyHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
LSReplyHeader ret_val;
if (single_value->field_seqNumber.is_bound()) {
ret_val.seqNumber() = single_value->field_seqNumber.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
if (single_value->field_srcPosVector.is_bound()) {
ret_val.srcPosVector() = single_value->field_srcPosVector.valueof();
}
if (single_value->field_dstPosVector.is_bound()) {
ret_val.dstPosVector() = single_value->field_dstPosVector.valueof();
}
return ret_val;
}

void LSReplyHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new LSReplyHeader_template[list_length];
}

LSReplyHeader_template& LSReplyHeader_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
return value_list.list_value[list_index];
}

INTEGER_template& LSReplyHeader_template::seqNumber()
{
set_specific();
return single_value->field_seqNumber;
}

const INTEGER_template& LSReplyHeader_template::seqNumber() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field seqNumber of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
return single_value->field_seqNumber;
}

INTEGER_template& LSReplyHeader_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const INTEGER_template& LSReplyHeader_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
return single_value->field_reserved;
}

LongPosVector_template& LSReplyHeader_template::srcPosVector()
{
set_specific();
return single_value->field_srcPosVector;
}

const LongPosVector_template& LSReplyHeader_template::srcPosVector() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field srcPosVector of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
return single_value->field_srcPosVector;
}

ShortPosVector_template& LSReplyHeader_template::dstPosVector()
{
set_specific();
return single_value->field_dstPosVector;
}

const ShortPosVector_template& LSReplyHeader_template::dstPosVector() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field dstPosVector of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
return single_value->field_dstPosVector;
}

int LSReplyHeader_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 4;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
  }
  return 0;
}

void LSReplyHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ seqNumber := ");
single_value->field_seqNumber.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(", srcPosVector := ");
single_value->field_srcPosVector.log();
TTCN_Logger::log_event_str(", dstPosVector := ");
single_value->field_dstPosVector.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void LSReplyHeader_template::log_match(const LSReplyHeader& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_seqNumber.match(match_value.seqNumber(), legacy)){
TTCN_Logger::log_logmatch_info(".seqNumber");
single_value->field_seqNumber.log_match(match_value.seqNumber(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_srcPosVector.match(match_value.srcPosVector(), legacy)){
TTCN_Logger::log_logmatch_info(".srcPosVector");
single_value->field_srcPosVector.log_match(match_value.srcPosVector(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_dstPosVector.match(match_value.dstPosVector(), legacy)){
TTCN_Logger::log_logmatch_info(".dstPosVector");
single_value->field_dstPosVector.log_match(match_value.dstPosVector(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ seqNumber := ");
single_value->field_seqNumber.log_match(match_value.seqNumber(), legacy);
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::log_event_str(", srcPosVector := ");
single_value->field_srcPosVector.log_match(match_value.srcPosVector(), legacy);
TTCN_Logger::log_event_str(", dstPosVector := ");
single_value->field_dstPosVector.log_match(match_value.dstPosVector(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void LSReplyHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_seqNumber.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
single_value->field_srcPosVector.encode_text(text_buf);
single_value->field_dstPosVector.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
}
}

void LSReplyHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_seqNumber.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
single_value->field_srcPosVector.decode_text(text_buf);
single_value->field_dstPosVector.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new LSReplyHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader.");
}
}

void LSReplyHeader_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.LSReplyHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      seqNumber().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("srcPosVector", param_field) == 0) {
      srcPosVector().set_param(param);
      return;
    } else if (strcmp("dstPosVector", param_field) == 0) {
      dstPosVector().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.LSReplyHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    LSReplyHeader_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) seqNumber().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) srcPosVector().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) dstPosVector().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "seqNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          seqNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dstPosVector")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dstPosVector().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.LSReplyHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.LSReplyHeader");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* LSReplyHeader_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.LSReplyHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      return seqNumber().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("srcPosVector", param_field) == 0) {
      return srcPosVector().get_param(param_name);
    } else if (strcmp("dstPosVector", param_field) == 0) {
      return dstPosVector().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.LSReplyHeader'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_seqNumber = single_value->field_seqNumber.get_param(param_name);
    mp_field_seqNumber->set_id(new Module_Param_FieldName(mcopystr("seqNumber")));
    mp->add_elem(mp_field_seqNumber);
    Module_Param* mp_field_reserved = single_value->field_reserved.get_param(param_name);
    mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
    mp->add_elem(mp_field_reserved);
    Module_Param* mp_field_srcPosVector = single_value->field_srcPosVector.get_param(param_name);
    mp_field_srcPosVector->set_id(new Module_Param_FieldName(mcopystr("srcPosVector")));
    mp->add_elem(mp_field_srcPosVector);
    Module_Param* mp_field_dstPosVector = single_value->field_dstPosVector.get_param(param_name);
    mp_field_dstPosVector->set_id(new Module_Param_FieldName(mcopystr("dstPosVector")));
    mp->add_elem(mp_field_dstPosVector);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void LSReplyHeader_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_seqNumber.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LSReplyHeader");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LSReplyHeader");
single_value->field_srcPosVector.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LSReplyHeader");
single_value->field_dstPosVector.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LSReplyHeader");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.LSReplyHeader");
}

boolean LSReplyHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean LSReplyHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

AnyHeader::AnyHeader()
{
  bound_flag = FALSE;
}

AnyHeader::AnyHeader(const INTEGER& par_seqNumber,
    const INTEGER& par_reserved)
  :   field_seqNumber(par_seqNumber),
  field_reserved(par_reserved)
{
  bound_flag = TRUE;
}

AnyHeader::AnyHeader(const AnyHeader& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.AnyHeader.");
bound_flag = TRUE;
if (other_value.seqNumber().is_bound()) field_seqNumber = other_value.seqNumber();
else field_seqNumber.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
}

void AnyHeader::clean_up()
{
field_seqNumber.clean_up();
field_reserved.clean_up();
bound_flag = FALSE;
}

AnyHeader& AnyHeader::operator=(const AnyHeader& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AnyHeader.");
  bound_flag = TRUE;
  if (other_value.seqNumber().is_bound()) field_seqNumber = other_value.seqNumber();
  else field_seqNumber.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
}
return *this;
}

boolean AnyHeader::operator==(const AnyHeader& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_seqNumber==other_value.field_seqNumber
  && field_reserved==other_value.field_reserved;
}

boolean AnyHeader::is_bound() const
{
if (bound_flag) return TRUE;
if(field_seqNumber.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
return FALSE;
}
boolean AnyHeader::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_seqNumber.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
return TRUE;
}
int AnyHeader::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.AnyHeader");
  return 2;
}

void AnyHeader::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ seqNumber := ");
field_seqNumber.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(" }");
}

void AnyHeader::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.AnyHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      seqNumber().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AnyHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.AnyHeader has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) seqNumber().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "seqNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          seqNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.AnyHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.AnyHeader");
  }
}

Module_Param* AnyHeader::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.AnyHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      return seqNumber().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AnyHeader'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_seqNumber = field_seqNumber.get_param(param_name);
  mp_field_seqNumber->set_id(new Module_Param_FieldName(mcopystr("seqNumber")));
  mp->add_elem(mp_field_seqNumber);
  Module_Param* mp_field_reserved = field_reserved.get_param(param_name);
  mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
  mp->add_elem(mp_field_reserved);
  return mp;
  }

void AnyHeader::set_implicit_omit()
{
if (seqNumber().is_bound()) seqNumber().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
}

void AnyHeader::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.AnyHeader.");
field_seqNumber.encode_text(text_buf);
field_reserved.encode_text(text_buf);
}

void AnyHeader::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_seqNumber.decode_text(text_buf);
field_reserved.decode_text(text_buf);
}

void AnyHeader::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AnyHeader::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AnyHeader::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_seqNumber.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int AnyHeader::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  encoded_length += field_seqNumber.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_reserved.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int AnyHeader::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.AnyHeader.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "seqNumber");
    enc_len += field_seqNumber.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AnyHeader::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (9 == name_len && 0 == strncmp(fld_name, "seqNumber", name_len)) {
         int ret_val = field_seqNumber.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "seqNumber");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
         int ret_val = field_reserved.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_seqNumber.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "seqNumber");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct AnyHeader_template::single_value_struct {
INTEGER_template field_seqNumber;
INTEGER_template field_reserved;
};

void AnyHeader_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_seqNumber = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
}
}
}

void AnyHeader_template::copy_value(const AnyHeader& other_value)
{
single_value = new single_value_struct;
if (other_value.seqNumber().is_bound()) {
  single_value->field_seqNumber = other_value.seqNumber();
} else {
  single_value->field_seqNumber.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void AnyHeader_template::copy_template(const AnyHeader_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.seqNumber().get_selection()) {
single_value->field_seqNumber = other_value.seqNumber();
} else {
single_value->field_seqNumber.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AnyHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader.");
break;
}
set_selection(other_value);
}

AnyHeader_template::AnyHeader_template()
{
}

AnyHeader_template::AnyHeader_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AnyHeader_template::AnyHeader_template(const AnyHeader& other_value)
{
copy_value(other_value);
}

AnyHeader_template::AnyHeader_template(const OPTIONAL<AnyHeader>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AnyHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader from an unbound optional field.");
}
}

AnyHeader_template::AnyHeader_template(const AnyHeader_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

AnyHeader_template::~AnyHeader_template()
{
clean_up();
}

AnyHeader_template& AnyHeader_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AnyHeader_template& AnyHeader_template::operator=(const AnyHeader& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AnyHeader_template& AnyHeader_template::operator=(const OPTIONAL<AnyHeader>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AnyHeader&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader.");
}
return *this;
}

AnyHeader_template& AnyHeader_template::operator=(const AnyHeader_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AnyHeader_template::match(const AnyHeader& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.seqNumber().is_bound()) return FALSE;
if(!single_value->field_seqNumber.match(other_value.seqNumber(), legacy))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader.");
}
return FALSE;
}

boolean AnyHeader_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_seqNumber.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
return FALSE;
}

boolean AnyHeader_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_seqNumber.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
return TRUE;
}

void AnyHeader_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AnyHeader AnyHeader_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader.");
AnyHeader ret_val;
if (single_value->field_seqNumber.is_bound()) {
ret_val.seqNumber() = single_value->field_seqNumber.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
return ret_val;
}

void AnyHeader_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AnyHeader_template[list_length];
}

AnyHeader_template& AnyHeader_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader.");
return value_list.list_value[list_index];
}

INTEGER_template& AnyHeader_template::seqNumber()
{
set_specific();
return single_value->field_seqNumber;
}

const INTEGER_template& AnyHeader_template::seqNumber() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field seqNumber of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader.");
return single_value->field_seqNumber;
}

INTEGER_template& AnyHeader_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const INTEGER_template& AnyHeader_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader.");
return single_value->field_reserved;
}

int AnyHeader_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader.");
  }
  return 0;
}

void AnyHeader_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ seqNumber := ");
single_value->field_seqNumber.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AnyHeader_template::log_match(const AnyHeader& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_seqNumber.match(match_value.seqNumber(), legacy)){
TTCN_Logger::log_logmatch_info(".seqNumber");
single_value->field_seqNumber.log_match(match_value.seqNumber(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ seqNumber := ");
single_value->field_seqNumber.log_match(match_value.seqNumber(), legacy);
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AnyHeader_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_seqNumber.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader.");
}
}

void AnyHeader_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_seqNumber.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AnyHeader_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader.");
}
}

void AnyHeader_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.AnyHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      seqNumber().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.AnyHeader'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AnyHeader_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.AnyHeader has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) seqNumber().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "seqNumber")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          seqNumber().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.AnyHeader: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.AnyHeader");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AnyHeader_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.AnyHeader'");
    }
    if (strcmp("seqNumber", param_field) == 0) {
      return seqNumber().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AnyHeader'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_seqNumber = single_value->field_seqNumber.get_param(param_name);
    mp_field_seqNumber->set_id(new Module_Param_FieldName(mcopystr("seqNumber")));
    mp->add_elem(mp_field_seqNumber);
    Module_Param* mp_field_reserved = single_value->field_reserved.get_param(param_name);
    mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
    mp->add_elem(mp_field_reserved);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AnyHeader_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_seqNumber.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AnyHeader");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AnyHeader");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AnyHeader");
}

boolean AnyHeader_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AnyHeader_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

Payload::Payload()
{
  bound_flag = FALSE;
}

Payload::Payload(const OPTIONAL<DecodedPayload>& par_decodedPayload,
    const OCTETSTRING& par_rawPayload)
  :   field_decodedPayload(par_decodedPayload),
  field_rawPayload(par_rawPayload)
{
  bound_flag = TRUE;
}

Payload::Payload(const Payload& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.Payload.");
bound_flag = TRUE;
if (other_value.decodedPayload().is_bound()) field_decodedPayload = other_value.decodedPayload();
else field_decodedPayload.clean_up();
if (other_value.rawPayload().is_bound()) field_rawPayload = other_value.rawPayload();
else field_rawPayload.clean_up();
}

void Payload::clean_up()
{
field_decodedPayload.clean_up();
field_rawPayload.clean_up();
bound_flag = FALSE;
}

Payload& Payload::operator=(const Payload& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.Payload.");
  bound_flag = TRUE;
  if (other_value.decodedPayload().is_bound()) field_decodedPayload = other_value.decodedPayload();
  else field_decodedPayload.clean_up();
  if (other_value.rawPayload().is_bound()) field_rawPayload = other_value.rawPayload();
  else field_rawPayload.clean_up();
}
return *this;
}

boolean Payload::operator==(const Payload& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_decodedPayload==other_value.field_decodedPayload
  && field_rawPayload==other_value.field_rawPayload;
}

boolean Payload::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_decodedPayload.get_selection() || field_decodedPayload.is_bound()) return TRUE;
if(field_rawPayload.is_bound()) return TRUE;
return FALSE;
}
boolean Payload::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_decodedPayload.get_selection() && !field_decodedPayload.is_value()) return FALSE;
if(!field_rawPayload.is_value()) return FALSE;
return TRUE;
}
int Payload::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.Payload");
  int ret_val = 1;
  if (field_decodedPayload.ispresent()) ret_val++;
  return ret_val;
}

void Payload::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ decodedPayload := ");
field_decodedPayload.log();
TTCN_Logger::log_event_str(", rawPayload := ");
field_rawPayload.log();
TTCN_Logger::log_event_str(" }");
}

void Payload::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.Payload'");
    }
    if (strcmp("decodedPayload", param_field) == 0) {
      decodedPayload().set_param(param);
      return;
    } else if (strcmp("rawPayload", param_field) == 0) {
      rawPayload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.Payload'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.Payload has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) decodedPayload().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) rawPayload().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "decodedPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          decodedPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.Payload: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.Payload");
  }
}

Module_Param* Payload::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.Payload'");
    }
    if (strcmp("decodedPayload", param_field) == 0) {
      return decodedPayload().get_param(param_name);
    } else if (strcmp("rawPayload", param_field) == 0) {
      return rawPayload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.Payload'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_decodedPayload = field_decodedPayload.get_param(param_name);
  mp_field_decodedPayload->set_id(new Module_Param_FieldName(mcopystr("decodedPayload")));
  mp->add_elem(mp_field_decodedPayload);
  Module_Param* mp_field_rawPayload = field_rawPayload.get_param(param_name);
  mp_field_rawPayload->set_id(new Module_Param_FieldName(mcopystr("rawPayload")));
  mp->add_elem(mp_field_rawPayload);
  return mp;
  }

void Payload::set_implicit_omit()
{
if (!decodedPayload().is_bound()) decodedPayload() = OMIT_VALUE;
else decodedPayload().set_implicit_omit();
if (rawPayload().is_bound()) rawPayload().set_implicit_omit();
}

void Payload::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.Payload.");
field_decodedPayload.encode_text(text_buf);
field_rawPayload.encode_text(text_buf);
}

void Payload::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_decodedPayload.decode_text(text_buf);
field_rawPayload.decode_text(text_buf);
}

void Payload::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Payload::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int Payload::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_decodedPayload().RAW_decode(DecodedPayload_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_decodedPayload = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_decodedPayload=OMIT_VALUE;
  decoded_field_length = field_rawPayload.RAW_decode(GnRawPayload_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int Payload::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  if (field_decodedPayload.ispresent()) {
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, DecodedPayload_descr_.raw);
  }
  else myleaf.body.node.nodes[0] = NULL;
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, GnRawPayload_descr_.raw);
  if (field_decodedPayload.ispresent()) {
  encoded_length += field_decodedPayload().RAW_encode(DecodedPayload_descr_, *myleaf.body.node.nodes[0]);
  }
  encoded_length += field_rawPayload.RAW_encode(GnRawPayload_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int Payload::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.Payload.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_decodedPayload.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "decodedPayload");
    enc_len += field_decodedPayload.JSON_encode(DecodedPayload_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "rawPayload");
    enc_len += field_rawPayload.JSON_encode(GnRawPayload_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Payload::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (14 == name_len && 0 == strncmp(fld_name, "decodedPayload", name_len)) {
         int ret_val = field_decodedPayload.JSON_decode(DecodedPayload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "decodedPayload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "rawPayload", name_len)) {
         int ret_val = field_rawPayload.JSON_decode(GnRawPayload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "rawPayload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_decodedPayload.is_bound()) {
    field_decodedPayload = OMIT_VALUE;
  }
if (!field_rawPayload.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "rawPayload");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct Payload_template::single_value_struct {
DecodedPayload_template field_decodedPayload;
OCTETSTRING_template field_rawPayload;
};

void Payload_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_decodedPayload = ANY_OR_OMIT;
single_value->field_rawPayload = ANY_VALUE;
}
}
}

void Payload_template::copy_value(const Payload& other_value)
{
single_value = new single_value_struct;
if (other_value.decodedPayload().is_bound()) {
  if (other_value.decodedPayload().ispresent()) single_value->field_decodedPayload = other_value.decodedPayload()();
  else single_value->field_decodedPayload = OMIT_VALUE;
} else {
  single_value->field_decodedPayload.clean_up();
}
if (other_value.rawPayload().is_bound()) {
  single_value->field_rawPayload = other_value.rawPayload();
} else {
  single_value->field_rawPayload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Payload_template::copy_template(const Payload_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.decodedPayload().get_selection()) {
single_value->field_decodedPayload = other_value.decodedPayload();
} else {
single_value->field_decodedPayload.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rawPayload().get_selection()) {
single_value->field_rawPayload = other_value.rawPayload();
} else {
single_value->field_rawPayload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Payload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.Payload.");
break;
}
set_selection(other_value);
}

Payload_template::Payload_template()
{
}

Payload_template::Payload_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Payload_template::Payload_template(const Payload& other_value)
{
copy_value(other_value);
}

Payload_template::Payload_template(const OPTIONAL<Payload>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Payload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.Payload from an unbound optional field.");
}
}

Payload_template::Payload_template(const Payload_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Payload_template::~Payload_template()
{
clean_up();
}

Payload_template& Payload_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Payload_template& Payload_template::operator=(const Payload& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Payload_template& Payload_template::operator=(const OPTIONAL<Payload>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Payload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.Payload.");
}
return *this;
}

Payload_template& Payload_template::operator=(const Payload_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Payload_template::match(const Payload& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.decodedPayload().is_bound()) return FALSE;
if((other_value.decodedPayload().ispresent() ? !single_value->field_decodedPayload.match((const DecodedPayload&)other_value.decodedPayload(), legacy) : !single_value->field_decodedPayload.match_omit(legacy)))return FALSE;
if(!other_value.rawPayload().is_bound()) return FALSE;
if(!single_value->field_rawPayload.match(other_value.rawPayload(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.Payload.");
}
return FALSE;
}

boolean Payload_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_decodedPayload.is_omit() || single_value->field_decodedPayload.is_bound()) return TRUE;
if (single_value->field_rawPayload.is_bound()) return TRUE;
return FALSE;
}

boolean Payload_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_decodedPayload.is_omit() && !single_value->field_decodedPayload.is_value()) return FALSE;
if (!single_value->field_rawPayload.is_value()) return FALSE;
return TRUE;
}

void Payload_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Payload Payload_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.Payload.");
Payload ret_val;
if (single_value->field_decodedPayload.is_omit()) ret_val.decodedPayload() = OMIT_VALUE;
else if (single_value->field_decodedPayload.is_bound()) {
ret_val.decodedPayload() = single_value->field_decodedPayload.valueof();
}
if (single_value->field_rawPayload.is_bound()) {
ret_val.rawPayload() = single_value->field_rawPayload.valueof();
}
return ret_val;
}

void Payload_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.Payload.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Payload_template[list_length];
}

Payload_template& Payload_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.Payload.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.Payload.");
return value_list.list_value[list_index];
}

DecodedPayload_template& Payload_template::decodedPayload()
{
set_specific();
return single_value->field_decodedPayload;
}

const DecodedPayload_template& Payload_template::decodedPayload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field decodedPayload of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.Payload.");
return single_value->field_decodedPayload;
}

OCTETSTRING_template& Payload_template::rawPayload()
{
set_specific();
return single_value->field_rawPayload;
}

const OCTETSTRING_template& Payload_template::rawPayload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rawPayload of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.Payload.");
return single_value->field_rawPayload;
}

int Payload_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Payload which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_decodedPayload.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Payload containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Payload containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Payload containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Payload containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.Payload containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.Payload.");
  }
  return 0;
}

void Payload_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ decodedPayload := ");
single_value->field_decodedPayload.log();
TTCN_Logger::log_event_str(", rawPayload := ");
single_value->field_rawPayload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Payload_template::log_match(const Payload& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.decodedPayload().ispresent()){
if(!single_value->field_decodedPayload.match(match_value.decodedPayload(), legacy)){
TTCN_Logger::log_logmatch_info(".decodedPayload");
single_value->field_decodedPayload.log_match(match_value.decodedPayload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_decodedPayload.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".decodedPayload := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_decodedPayload.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if(!single_value->field_rawPayload.match(match_value.rawPayload(), legacy)){
TTCN_Logger::log_logmatch_info(".rawPayload");
single_value->field_rawPayload.log_match(match_value.rawPayload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ decodedPayload := ");
if (match_value.decodedPayload().ispresent()) single_value->field_decodedPayload.log_match(match_value.decodedPayload(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_decodedPayload.log();
if (single_value->field_decodedPayload.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", rawPayload := ");
single_value->field_rawPayload.log_match(match_value.rawPayload(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Payload_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_decodedPayload.encode_text(text_buf);
single_value->field_rawPayload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.Payload.");
}
}

void Payload_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_decodedPayload.decode_text(text_buf);
single_value->field_rawPayload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Payload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.Payload.");
}
}

void Payload_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.Payload'");
    }
    if (strcmp("decodedPayload", param_field) == 0) {
      decodedPayload().set_param(param);
      return;
    } else if (strcmp("rawPayload", param_field) == 0) {
      rawPayload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.Payload'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Payload_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.Payload has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) decodedPayload().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) rawPayload().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "decodedPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          decodedPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.Payload: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.Payload");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Payload_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.Payload'");
    }
    if (strcmp("decodedPayload", param_field) == 0) {
      return decodedPayload().get_param(param_name);
    } else if (strcmp("rawPayload", param_field) == 0) {
      return rawPayload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.Payload'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_decodedPayload = single_value->field_decodedPayload.get_param(param_name);
    mp_field_decodedPayload->set_id(new Module_Param_FieldName(mcopystr("decodedPayload")));
    mp->add_elem(mp_field_decodedPayload);
    Module_Param* mp_field_rawPayload = single_value->field_rawPayload.get_param(param_name);
    mp_field_rawPayload->set_id(new Module_Param_FieldName(mcopystr("rawPayload")));
    mp->add_elem(mp_field_rawPayload);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Payload_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_decodedPayload.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.Payload");
single_value->field_rawPayload.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.Payload");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.Payload");
}

boolean Payload_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Payload_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void DecodedPayload::copy_value(const DecodedPayload& other_value)
{
switch (other_value.union_selection) {
case ALT_ipv6Packet:
field_ipv6Packet = new LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet(*other_value.field_ipv6Packet);
break;
case ALT_btpPacket:
field_btpPacket = new LibItsBtp__TypesAndValues::BtpPacket(*other_value.field_btpPacket);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
}
union_selection = other_value.union_selection;
}

DecodedPayload::DecodedPayload()
{
union_selection = UNBOUND_VALUE;
}

DecodedPayload::DecodedPayload(const DecodedPayload& other_value)
: Base_Type(){
copy_value(other_value);
}

DecodedPayload::~DecodedPayload()
{
clean_up();
}

DecodedPayload& DecodedPayload::operator=(const DecodedPayload& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean DecodedPayload::operator==(const DecodedPayload& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_ipv6Packet:
return *field_ipv6Packet == *other_value.field_ipv6Packet;
case ALT_btpPacket:
return *field_btpPacket == *other_value.field_btpPacket;
default:
return FALSE;
}
}

LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet& DecodedPayload::ipv6Packet()
{
if (union_selection != ALT_ipv6Packet) {
clean_up();
field_ipv6Packet = new LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet;
union_selection = ALT_ipv6Packet;
}
return *field_ipv6Packet;
}

const LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet& DecodedPayload::ipv6Packet() const
{
if (union_selection != ALT_ipv6Packet) TTCN_error("Using non-selected field ipv6Packet in a value of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
return *field_ipv6Packet;
}

LibItsBtp__TypesAndValues::BtpPacket& DecodedPayload::btpPacket()
{
if (union_selection != ALT_btpPacket) {
clean_up();
field_btpPacket = new LibItsBtp__TypesAndValues::BtpPacket;
union_selection = ALT_btpPacket;
}
return *field_btpPacket;
}

const LibItsBtp__TypesAndValues::BtpPacket& DecodedPayload::btpPacket() const
{
if (union_selection != ALT_btpPacket) TTCN_error("Using non-selected field btpPacket in a value of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
return *field_btpPacket;
}

boolean DecodedPayload::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
return union_selection == checked_selection;
}

boolean DecodedPayload::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean DecodedPayload::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_ipv6Packet: return field_ipv6Packet->is_value();
case ALT_btpPacket: return field_btpPacket->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void DecodedPayload::clean_up()
{
switch (union_selection) {
case ALT_ipv6Packet:
  delete field_ipv6Packet;
  break;
case ALT_btpPacket:
  delete field_btpPacket;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void DecodedPayload::log() const
{
switch (union_selection) {
case ALT_ipv6Packet:
TTCN_Logger::log_event_str("{ ipv6Packet := ");
field_ipv6Packet->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_btpPacket:
TTCN_Logger::log_event_str("{ btpPacket := ");
field_btpPacket->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void DecodedPayload::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsGeoNetworking_TypesAndValues.DecodedPayload'");
    }
    if (strcmp("ipv6Packet", param_field) == 0) {
      ipv6Packet().set_param(param);
      return;
    } else if (strcmp("btpPacket", param_field) == 0) {
      btpPacket().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsGeoNetworking_TypesAndValues.DecodedPayload'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "ipv6Packet")) {
    ipv6Packet().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "btpPacket")) {
    btpPacket().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.", mp_last->get_id()->get_name());
}

Module_Param* DecodedPayload::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsGeoNetworking_TypesAndValues.DecodedPayload'");
    }
    if (strcmp("ipv6Packet", param_field) == 0) {
      return ipv6Packet().get_param(param_name);
    } else if (strcmp("btpPacket", param_field) == 0) {
      return btpPacket().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `DecodedPayload'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_ipv6Packet:
    mp_field = field_ipv6Packet->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("ipv6Packet")));
    break;
  case ALT_btpPacket:
    mp_field = field_btpPacket->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("btpPacket")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void DecodedPayload::set_implicit_omit()
{
switch (union_selection) {
case ALT_ipv6Packet:
field_ipv6Packet->set_implicit_omit(); break;
case ALT_btpPacket:
field_btpPacket->set_implicit_omit(); break;
default: break;
}
}

void DecodedPayload::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_ipv6Packet:
field_ipv6Packet->encode_text(text_buf);
break;
case ALT_btpPacket:
field_btpPacket->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
}
}

void DecodedPayload::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_ipv6Packet:
ipv6Packet().decode_text(text_buf);
break;
case ALT_btpPacket:
btpPacket().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
}
}

void DecodedPayload::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void DecodedPayload::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int DecodedPayload::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = ipv6Packet().RAW_decode(LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = btpPacket().RAW_decode(LibItsBtp__TypesAndValues::BtpPacket_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = ipv6Packet().RAW_decode(LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = btpPacket().RAW_decode(LibItsBtp__TypesAndValues::BtpPacket_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int DecodedPayload::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  memset(myleaf.body.node.nodes, 0, 2 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_ipv6Packet:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_descr_.raw);
    encoded_length = field_ipv6Packet->RAW_encode(LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_descr_;
    break;
  case ALT_btpPacket:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, LibItsBtp__TypesAndValues::BtpPacket_descr_.raw);
    encoded_length = field_btpPacket->RAW_encode(LibItsBtp__TypesAndValues::BtpPacket_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &LibItsBtp__TypesAndValues::BtpPacket_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int DecodedPayload::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_ipv6Packet:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ipv6Packet");
    enc_len += field_ipv6Packet->JSON_encode(LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_descr_, p_tok);
    break;
  case ALT_btpPacket:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "btpPacket");
    enc_len += field_btpPacket->JSON_encode(LibItsBtp__TypesAndValues::BtpPacket_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int DecodedPayload::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "ipv6Packet", name_len)) {
      int ret_val = ipv6Packet().JSON_decode(LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ipv6Packet");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "btpPacket", name_len)) {
      int ret_val = btpPacket().JSON_decode(LibItsBtp__TypesAndValues::BtpPacket_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "btpPacket");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void DecodedPayload_template::copy_value(const DecodedPayload& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case DecodedPayload::ALT_ipv6Packet:
single_value.field_ipv6Packet = new LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_template(other_value.ipv6Packet());
break;
case DecodedPayload::ALT_btpPacket:
single_value.field_btpPacket = new LibItsBtp__TypesAndValues::BtpPacket_template(other_value.btpPacket());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
}
set_selection(SPECIFIC_VALUE);
}

void DecodedPayload_template::copy_template(const DecodedPayload_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case DecodedPayload::ALT_ipv6Packet:
single_value.field_ipv6Packet = new LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_template(*other_value.single_value.field_ipv6Packet);
break;
case DecodedPayload::ALT_btpPacket:
single_value.field_btpPacket = new LibItsBtp__TypesAndValues::BtpPacket_template(*other_value.single_value.field_btpPacket);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new DecodedPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
}
set_selection(other_value);
}

DecodedPayload_template::DecodedPayload_template()
{
}

DecodedPayload_template::DecodedPayload_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

DecodedPayload_template::DecodedPayload_template(const DecodedPayload& other_value)
{
copy_value(other_value);
}

DecodedPayload_template::DecodedPayload_template(const OPTIONAL<DecodedPayload>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DecodedPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload from an unbound optional field.");
}
}

DecodedPayload_template::DecodedPayload_template(const DecodedPayload_template& other_value)
: Base_Template(){
copy_template(other_value);
}

DecodedPayload_template::~DecodedPayload_template()
{
clean_up();
}

void DecodedPayload_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case DecodedPayload::ALT_ipv6Packet:
delete single_value.field_ipv6Packet;
break;
case DecodedPayload::ALT_btpPacket:
delete single_value.field_btpPacket;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

DecodedPayload_template& DecodedPayload_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

DecodedPayload_template& DecodedPayload_template::operator=(const DecodedPayload& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

DecodedPayload_template& DecodedPayload_template::operator=(const OPTIONAL<DecodedPayload>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const DecodedPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
}
return *this;
}

DecodedPayload_template& DecodedPayload_template::operator=(const DecodedPayload_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean DecodedPayload_template::match(const DecodedPayload& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
DecodedPayload::union_selection_type value_selection = other_value.get_selection();
if (value_selection == DecodedPayload::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case DecodedPayload::ALT_ipv6Packet:
return single_value.field_ipv6Packet->match(other_value.ipv6Packet(), legacy);
case DecodedPayload::ALT_btpPacket:
return single_value.field_btpPacket->match(other_value.btpPacket(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
}
return FALSE;
}

boolean DecodedPayload_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case DecodedPayload::ALT_ipv6Packet:
return single_value.field_ipv6Packet->is_value();
case DecodedPayload::ALT_btpPacket:
return single_value.field_btpPacket->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
}
}

DecodedPayload DecodedPayload_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
DecodedPayload ret_val;
switch (single_value.union_selection) {
case DecodedPayload::ALT_ipv6Packet:
ret_val.ipv6Packet() = single_value.field_ipv6Packet->valueof();
break;
case DecodedPayload::ALT_btpPacket:
ret_val.btpPacket() = single_value.field_btpPacket->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
}
return ret_val;
}

DecodedPayload_template& DecodedPayload_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
return value_list.list_value[list_index];
}
void DecodedPayload_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new DecodedPayload_template[list_length];
}

LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_template& DecodedPayload_template::ipv6Packet()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != DecodedPayload::ALT_ipv6Packet) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_ipv6Packet = new LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_template(ANY_VALUE);
else single_value.field_ipv6Packet = new LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_template;
single_value.union_selection = DecodedPayload::ALT_ipv6Packet;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_ipv6Packet;
}

const LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_template& DecodedPayload_template::ipv6Packet() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field ipv6Packet in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
if (single_value.union_selection != DecodedPayload::ALT_ipv6Packet) TTCN_error("Accessing non-selected field ipv6Packet in a template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
return *single_value.field_ipv6Packet;
}

LibItsBtp__TypesAndValues::BtpPacket_template& DecodedPayload_template::btpPacket()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != DecodedPayload::ALT_btpPacket) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_btpPacket = new LibItsBtp__TypesAndValues::BtpPacket_template(ANY_VALUE);
else single_value.field_btpPacket = new LibItsBtp__TypesAndValues::BtpPacket_template;
single_value.union_selection = DecodedPayload::ALT_btpPacket;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_btpPacket;
}

const LibItsBtp__TypesAndValues::BtpPacket_template& DecodedPayload_template::btpPacket() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field btpPacket in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
if (single_value.union_selection != DecodedPayload::ALT_btpPacket) TTCN_error("Accessing non-selected field btpPacket in a template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
return *single_value.field_btpPacket;
}

boolean DecodedPayload_template::ischosen(DecodedPayload::union_selection_type checked_selection) const
{
if (checked_selection == DecodedPayload::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == DecodedPayload::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload");
}
return FALSE;
}

void DecodedPayload_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case DecodedPayload::ALT_ipv6Packet:
TTCN_Logger::log_event_str("{ ipv6Packet := ");
single_value.field_ipv6Packet->log();
TTCN_Logger::log_event_str(" }");
break;
case DecodedPayload::ALT_btpPacket:
TTCN_Logger::log_event_str("{ btpPacket := ");
single_value.field_btpPacket->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void DecodedPayload_template::log_match(const DecodedPayload& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case DecodedPayload::ALT_ipv6Packet:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".ipv6Packet");
single_value.field_ipv6Packet->log_match(match_value.ipv6Packet(), legacy);
} else {
TTCN_Logger::log_event_str("{ ipv6Packet := ");
single_value.field_ipv6Packet->log_match(match_value.ipv6Packet(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case DecodedPayload::ALT_btpPacket:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".btpPacket");
single_value.field_btpPacket->log_match(match_value.btpPacket(), legacy);
} else {
TTCN_Logger::log_event_str("{ btpPacket := ");
single_value.field_btpPacket->log_match(match_value.btpPacket(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void DecodedPayload_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case DecodedPayload::ALT_ipv6Packet:
single_value.field_ipv6Packet->encode_text(text_buf);
break;
case DecodedPayload::ALT_btpPacket:
single_value.field_btpPacket->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
}
}

void DecodedPayload_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = DecodedPayload::UNBOUND_VALUE;
DecodedPayload::union_selection_type new_selection = (DecodedPayload::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case DecodedPayload::ALT_ipv6Packet:
single_value.field_ipv6Packet = new LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_template;
single_value.field_ipv6Packet->decode_text(text_buf);
break;
case DecodedPayload::ALT_btpPacket:
single_value.field_btpPacket = new LibItsBtp__TypesAndValues::BtpPacket_template;
single_value.field_btpPacket->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new DecodedPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
}
}

boolean DecodedPayload_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean DecodedPayload_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void DecodedPayload_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsGeoNetworking_TypesAndValues.DecodedPayload'");
    }
    if (strcmp("ipv6Packet", param_field) == 0) {
      ipv6Packet().set_param(param);
      return;
    } else if (strcmp("btpPacket", param_field) == 0) {
      btpPacket().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsGeoNetworking_TypesAndValues.DecodedPayload'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    DecodedPayload_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsGeoNetworking_TypesAndValues.DecodedPayload");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "ipv6Packet")) {
      ipv6Packet().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "btpPacket")) {
      btpPacket().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsGeoNetworking_TypesAndValues.DecodedPayload");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* DecodedPayload_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsGeoNetworking_TypesAndValues.DecodedPayload'");
    }
    if (strcmp("ipv6Packet", param_field) == 0) {
      return ipv6Packet().get_param(param_name);
    } else if (strcmp("btpPacket", param_field) == 0) {
      return btpPacket().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `DecodedPayload'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case DecodedPayload::ALT_ipv6Packet:
      mp_field = single_value.field_ipv6Packet->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("ipv6Packet")));
      break;
    case DecodedPayload::ALT_btpPacket:
      mp_field = single_value.field_btpPacket->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("btpPacket")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void DecodedPayload_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case DecodedPayload::ALT_ipv6Packet:
single_value.field_ipv6Packet->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.DecodedPayload");
return;
case DecodedPayload::ALT_btpPacket:
single_value.field_btpPacket->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.DecodedPayload");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsGeoNetworking_TypesAndValues.DecodedPayload.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.DecodedPayload");
}

GeoNetworkingPacket::GeoNetworkingPacket()
{
  bound_flag = FALSE;
}

GeoNetworkingPacket::GeoNetworkingPacket(const GnNonSecuredPacket& par_packet,
    const OPTIONAL<LibItsSecurity__TypesAndValues::SecuredMessage>& par_securedMsg)
  :   field_packet(par_packet),
  field_securedMsg(par_securedMsg)
{
  bound_flag = TRUE;
}

GeoNetworkingPacket::GeoNetworkingPacket(const GeoNetworkingPacket& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket.");
bound_flag = TRUE;
if (other_value.packet().is_bound()) field_packet = other_value.packet();
else field_packet.clean_up();
if (other_value.securedMsg().is_bound()) field_securedMsg = other_value.securedMsg();
else field_securedMsg.clean_up();
}

void GeoNetworkingPacket::clean_up()
{
field_packet.clean_up();
field_securedMsg.clean_up();
bound_flag = FALSE;
}

GeoNetworkingPacket& GeoNetworkingPacket::operator=(const GeoNetworkingPacket& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket.");
  bound_flag = TRUE;
  if (other_value.packet().is_bound()) field_packet = other_value.packet();
  else field_packet.clean_up();
  if (other_value.securedMsg().is_bound()) field_securedMsg = other_value.securedMsg();
  else field_securedMsg.clean_up();
}
return *this;
}

boolean GeoNetworkingPacket::operator==(const GeoNetworkingPacket& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_packet==other_value.field_packet
  && field_securedMsg==other_value.field_securedMsg;
}

boolean GeoNetworkingPacket::is_bound() const
{
if (bound_flag) return TRUE;
if(field_packet.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_securedMsg.get_selection() || field_securedMsg.is_bound()) return TRUE;
return FALSE;
}
boolean GeoNetworkingPacket::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_packet.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_securedMsg.get_selection() && !field_securedMsg.is_value()) return FALSE;
return TRUE;
}
int GeoNetworkingPacket::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket");
  int ret_val = 1;
  if (field_securedMsg.ispresent()) ret_val++;
  return ret_val;
}

void GeoNetworkingPacket::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ packet := ");
field_packet.log();
TTCN_Logger::log_event_str(", securedMsg := ");
field_securedMsg.log();
TTCN_Logger::log_event_str(" }");
}

void GeoNetworkingPacket::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket'");
    }
    if (strcmp("packet", param_field) == 0) {
      packet().set_param(param);
      return;
    } else if (strcmp("securedMsg", param_field) == 0) {
      securedMsg().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) packet().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) securedMsg().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "packet")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          packet().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "securedMsg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          securedMsg().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket");
  }
}

Module_Param* GeoNetworkingPacket::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket'");
    }
    if (strcmp("packet", param_field) == 0) {
      return packet().get_param(param_name);
    } else if (strcmp("securedMsg", param_field) == 0) {
      return securedMsg().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_packet = field_packet.get_param(param_name);
  mp_field_packet->set_id(new Module_Param_FieldName(mcopystr("packet")));
  mp->add_elem(mp_field_packet);
  Module_Param* mp_field_securedMsg = field_securedMsg.get_param(param_name);
  mp_field_securedMsg->set_id(new Module_Param_FieldName(mcopystr("securedMsg")));
  mp->add_elem(mp_field_securedMsg);
  return mp;
  }

void GeoNetworkingPacket::set_implicit_omit()
{
if (packet().is_bound()) packet().set_implicit_omit();
if (!securedMsg().is_bound()) securedMsg() = OMIT_VALUE;
else securedMsg().set_implicit_omit();
}

void GeoNetworkingPacket::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket.");
field_packet.encode_text(text_buf);
field_securedMsg.encode_text(text_buf);
}

void GeoNetworkingPacket::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_packet.decode_text(text_buf);
field_securedMsg.decode_text(text_buf);
}

void GeoNetworkingPacket::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GeoNetworkingPacket::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GeoNetworkingPacket::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_packet.RAW_decode(GnNonSecuredPacket_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_securedMsg().RAW_decode(LibItsSecurity__TypesAndValues::SecuredMessage_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_securedMsg = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_securedMsg=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GeoNetworkingPacket::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, GnNonSecuredPacket_descr_.raw);
  if (field_securedMsg.ispresent()) {
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibItsSecurity__TypesAndValues::SecuredMessage_descr_.raw);
  }
  else myleaf.body.node.nodes[1] = NULL;
  encoded_length += field_packet.RAW_encode(GnNonSecuredPacket_descr_, *myleaf.body.node.nodes[0]);
  if (field_securedMsg.ispresent()) {
  encoded_length += field_securedMsg().RAW_encode(LibItsSecurity__TypesAndValues::SecuredMessage_descr_, *myleaf.body.node.nodes[1]);
  }
  return myleaf.length = encoded_length;
}

int GeoNetworkingPacket::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "packet");
    enc_len += field_packet.JSON_encode(GnNonSecuredPacket_descr_, p_tok);
  }

  if (field_securedMsg.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "securedMsg");
    enc_len += field_securedMsg.JSON_encode(LibItsSecurity__TypesAndValues::SecuredMessage_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GeoNetworkingPacket::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (6 == name_len && 0 == strncmp(fld_name, "packet", name_len)) {
         int ret_val = field_packet.JSON_decode(GnNonSecuredPacket_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "packet");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "securedMsg", name_len)) {
         int ret_val = field_securedMsg.JSON_decode(LibItsSecurity__TypesAndValues::SecuredMessage_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "securedMsg");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_packet.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "packet");
    return JSON_ERROR_FATAL;
  }
if (!field_securedMsg.is_bound()) {
    field_securedMsg = OMIT_VALUE;
  }

  return dec_len;
}

struct GeoNetworkingPacket_template::single_value_struct {
GnNonSecuredPacket_template field_packet;
LibItsSecurity__TypesAndValues::SecuredMessage_template field_securedMsg;
};

void GeoNetworkingPacket_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_packet = ANY_VALUE;
single_value->field_securedMsg = ANY_OR_OMIT;
}
}
}

void GeoNetworkingPacket_template::copy_value(const GeoNetworkingPacket& other_value)
{
single_value = new single_value_struct;
if (other_value.packet().is_bound()) {
  single_value->field_packet = other_value.packet();
} else {
  single_value->field_packet.clean_up();
}
if (other_value.securedMsg().is_bound()) {
  if (other_value.securedMsg().ispresent()) single_value->field_securedMsg = other_value.securedMsg()();
  else single_value->field_securedMsg = OMIT_VALUE;
} else {
  single_value->field_securedMsg.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GeoNetworkingPacket_template::copy_template(const GeoNetworkingPacket_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.packet().get_selection()) {
single_value->field_packet = other_value.packet();
} else {
single_value->field_packet.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.securedMsg().get_selection()) {
single_value->field_securedMsg = other_value.securedMsg();
} else {
single_value->field_securedMsg.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GeoNetworkingPacket_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket.");
break;
}
set_selection(other_value);
}

GeoNetworkingPacket_template::GeoNetworkingPacket_template()
{
}

GeoNetworkingPacket_template::GeoNetworkingPacket_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GeoNetworkingPacket_template::GeoNetworkingPacket_template(const GeoNetworkingPacket& other_value)
{
copy_value(other_value);
}

GeoNetworkingPacket_template::GeoNetworkingPacket_template(const OPTIONAL<GeoNetworkingPacket>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoNetworkingPacket&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket from an unbound optional field.");
}
}

GeoNetworkingPacket_template::GeoNetworkingPacket_template(const GeoNetworkingPacket_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GeoNetworkingPacket_template::~GeoNetworkingPacket_template()
{
clean_up();
}

GeoNetworkingPacket_template& GeoNetworkingPacket_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GeoNetworkingPacket_template& GeoNetworkingPacket_template::operator=(const GeoNetworkingPacket& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GeoNetworkingPacket_template& GeoNetworkingPacket_template::operator=(const OPTIONAL<GeoNetworkingPacket>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoNetworkingPacket&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket.");
}
return *this;
}

GeoNetworkingPacket_template& GeoNetworkingPacket_template::operator=(const GeoNetworkingPacket_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GeoNetworkingPacket_template::match(const GeoNetworkingPacket& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.packet().is_bound()) return FALSE;
if(!single_value->field_packet.match(other_value.packet(), legacy))return FALSE;
if(!other_value.securedMsg().is_bound()) return FALSE;
if((other_value.securedMsg().ispresent() ? !single_value->field_securedMsg.match((const LibItsSecurity__TypesAndValues::SecuredMessage&)other_value.securedMsg(), legacy) : !single_value->field_securedMsg.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket.");
}
return FALSE;
}

boolean GeoNetworkingPacket_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_packet.is_bound()) return TRUE;
if (single_value->field_securedMsg.is_omit() || single_value->field_securedMsg.is_bound()) return TRUE;
return FALSE;
}

boolean GeoNetworkingPacket_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_packet.is_value()) return FALSE;
if (!single_value->field_securedMsg.is_omit() && !single_value->field_securedMsg.is_value()) return FALSE;
return TRUE;
}

void GeoNetworkingPacket_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GeoNetworkingPacket GeoNetworkingPacket_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket.");
GeoNetworkingPacket ret_val;
if (single_value->field_packet.is_bound()) {
ret_val.packet() = single_value->field_packet.valueof();
}
if (single_value->field_securedMsg.is_omit()) ret_val.securedMsg() = OMIT_VALUE;
else if (single_value->field_securedMsg.is_bound()) {
ret_val.securedMsg() = single_value->field_securedMsg.valueof();
}
return ret_val;
}

void GeoNetworkingPacket_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GeoNetworkingPacket_template[list_length];
}

GeoNetworkingPacket_template& GeoNetworkingPacket_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket.");
return value_list.list_value[list_index];
}

GnNonSecuredPacket_template& GeoNetworkingPacket_template::packet()
{
set_specific();
return single_value->field_packet;
}

const GnNonSecuredPacket_template& GeoNetworkingPacket_template::packet() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field packet of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket.");
return single_value->field_packet;
}

LibItsSecurity__TypesAndValues::SecuredMessage_template& GeoNetworkingPacket_template::securedMsg()
{
set_specific();
return single_value->field_securedMsg;
}

const LibItsSecurity__TypesAndValues::SecuredMessage_template& GeoNetworkingPacket_template::securedMsg() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field securedMsg of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket.");
return single_value->field_securedMsg;
}

int GeoNetworkingPacket_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_securedMsg.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket.");
  }
  return 0;
}

void GeoNetworkingPacket_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ packet := ");
single_value->field_packet.log();
TTCN_Logger::log_event_str(", securedMsg := ");
single_value->field_securedMsg.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GeoNetworkingPacket_template::log_match(const GeoNetworkingPacket& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_packet.match(match_value.packet(), legacy)){
TTCN_Logger::log_logmatch_info(".packet");
single_value->field_packet.log_match(match_value.packet(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.securedMsg().ispresent()){
if(!single_value->field_securedMsg.match(match_value.securedMsg(), legacy)){
TTCN_Logger::log_logmatch_info(".securedMsg");
single_value->field_securedMsg.log_match(match_value.securedMsg(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_securedMsg.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".securedMsg := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_securedMsg.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ packet := ");
single_value->field_packet.log_match(match_value.packet(), legacy);
TTCN_Logger::log_event_str(", securedMsg := ");
if (match_value.securedMsg().ispresent()) single_value->field_securedMsg.log_match(match_value.securedMsg(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_securedMsg.log();
if (single_value->field_securedMsg.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GeoNetworkingPacket_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_packet.encode_text(text_buf);
single_value->field_securedMsg.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket.");
}
}

void GeoNetworkingPacket_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_packet.decode_text(text_buf);
single_value->field_securedMsg.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GeoNetworkingPacket_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket.");
}
}

void GeoNetworkingPacket_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket'");
    }
    if (strcmp("packet", param_field) == 0) {
      packet().set_param(param);
      return;
    } else if (strcmp("securedMsg", param_field) == 0) {
      securedMsg().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GeoNetworkingPacket_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) packet().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) securedMsg().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "packet")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          packet().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "securedMsg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          securedMsg().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GeoNetworkingPacket_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket'");
    }
    if (strcmp("packet", param_field) == 0) {
      return packet().get_param(param_name);
    } else if (strcmp("securedMsg", param_field) == 0) {
      return securedMsg().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_packet = single_value->field_packet.get_param(param_name);
    mp_field_packet->set_id(new Module_Param_FieldName(mcopystr("packet")));
    mp->add_elem(mp_field_packet);
    Module_Param* mp_field_securedMsg = single_value->field_securedMsg.get_param(param_name);
    mp_field_securedMsg->set_id(new Module_Param_FieldName(mcopystr("securedMsg")));
    mp->add_elem(mp_field_securedMsg);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GeoNetworkingPacket_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_packet.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket");
single_value->field_securedMsg.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPacket");
}

boolean GeoNetworkingPacket_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GeoNetworkingPacket_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

GeoNetworkingPdu::GeoNetworkingPdu()
{
  bound_flag = FALSE;
}

GeoNetworkingPdu::GeoNetworkingPdu(const BasicHeader& par_basicHeader,
    const GeoNetworkingPacket& par_gnPacket)
  :   field_basicHeader(par_basicHeader),
  field_gnPacket(par_gnPacket)
{
  bound_flag = TRUE;
}

GeoNetworkingPdu::GeoNetworkingPdu(const GeoNetworkingPdu& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu.");
bound_flag = TRUE;
if (other_value.basicHeader().is_bound()) field_basicHeader = other_value.basicHeader();
else field_basicHeader.clean_up();
if (other_value.gnPacket().is_bound()) field_gnPacket = other_value.gnPacket();
else field_gnPacket.clean_up();
}

void GeoNetworkingPdu::clean_up()
{
field_basicHeader.clean_up();
field_gnPacket.clean_up();
bound_flag = FALSE;
}

GeoNetworkingPdu& GeoNetworkingPdu::operator=(const GeoNetworkingPdu& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu.");
  bound_flag = TRUE;
  if (other_value.basicHeader().is_bound()) field_basicHeader = other_value.basicHeader();
  else field_basicHeader.clean_up();
  if (other_value.gnPacket().is_bound()) field_gnPacket = other_value.gnPacket();
  else field_gnPacket.clean_up();
}
return *this;
}

boolean GeoNetworkingPdu::operator==(const GeoNetworkingPdu& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_basicHeader==other_value.field_basicHeader
  && field_gnPacket==other_value.field_gnPacket;
}

boolean GeoNetworkingPdu::is_bound() const
{
if (bound_flag) return TRUE;
if(field_basicHeader.is_bound()) return TRUE;
if(field_gnPacket.is_bound()) return TRUE;
return FALSE;
}
boolean GeoNetworkingPdu::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_basicHeader.is_value()) return FALSE;
if(!field_gnPacket.is_value()) return FALSE;
return TRUE;
}
int GeoNetworkingPdu::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu");
  return 2;
}

void GeoNetworkingPdu::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ basicHeader := ");
field_basicHeader.log();
TTCN_Logger::log_event_str(", gnPacket := ");
field_gnPacket.log();
TTCN_Logger::log_event_str(" }");
}

void GeoNetworkingPdu::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu'");
    }
    if (strcmp("basicHeader", param_field) == 0) {
      basicHeader().set_param(param);
      return;
    } else if (strcmp("gnPacket", param_field) == 0) {
      gnPacket().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) basicHeader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) gnPacket().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "basicHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          basicHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnPacket")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnPacket().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu");
  }
}

Module_Param* GeoNetworkingPdu::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu'");
    }
    if (strcmp("basicHeader", param_field) == 0) {
      return basicHeader().get_param(param_name);
    } else if (strcmp("gnPacket", param_field) == 0) {
      return gnPacket().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_basicHeader = field_basicHeader.get_param(param_name);
  mp_field_basicHeader->set_id(new Module_Param_FieldName(mcopystr("basicHeader")));
  mp->add_elem(mp_field_basicHeader);
  Module_Param* mp_field_gnPacket = field_gnPacket.get_param(param_name);
  mp_field_gnPacket->set_id(new Module_Param_FieldName(mcopystr("gnPacket")));
  mp->add_elem(mp_field_gnPacket);
  return mp;
  }

void GeoNetworkingPdu::set_implicit_omit()
{
if (basicHeader().is_bound()) basicHeader().set_implicit_omit();
if (gnPacket().is_bound()) gnPacket().set_implicit_omit();
}

void GeoNetworkingPdu::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu.");
field_basicHeader.encode_text(text_buf);
field_gnPacket.encode_text(text_buf);
}

void GeoNetworkingPdu::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_basicHeader.decode_text(text_buf);
field_gnPacket.decode_text(text_buf);
}

void GeoNetworkingPdu::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GeoNetworkingPdu::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GeoNetworkingPdu::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_basicHeader.RAW_decode(BasicHeader_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_gnPacket.RAW_decode(GeoNetworkingPacket_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GeoNetworkingPdu::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, BasicHeader_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, GeoNetworkingPacket_descr_.raw);
  encoded_length += field_basicHeader.RAW_encode(BasicHeader_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_gnPacket.RAW_encode(GeoNetworkingPacket_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int GeoNetworkingPdu::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "basicHeader");
    enc_len += field_basicHeader.JSON_encode(BasicHeader_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnPacket");
    enc_len += field_gnPacket.JSON_encode(GeoNetworkingPacket_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GeoNetworkingPdu::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (11 == name_len && 0 == strncmp(fld_name, "basicHeader", name_len)) {
         int ret_val = field_basicHeader.JSON_decode(BasicHeader_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "basicHeader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "gnPacket", name_len)) {
         int ret_val = field_gnPacket.JSON_decode(GeoNetworkingPacket_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnPacket");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_basicHeader.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "basicHeader");
    return JSON_ERROR_FATAL;
  }
if (!field_gnPacket.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnPacket");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GeoNetworkingPdu_template::single_value_struct {
BasicHeader_template field_basicHeader;
GeoNetworkingPacket_template field_gnPacket;
};

void GeoNetworkingPdu_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_basicHeader = ANY_VALUE;
single_value->field_gnPacket = ANY_VALUE;
}
}
}

void GeoNetworkingPdu_template::copy_value(const GeoNetworkingPdu& other_value)
{
single_value = new single_value_struct;
if (other_value.basicHeader().is_bound()) {
  single_value->field_basicHeader = other_value.basicHeader();
} else {
  single_value->field_basicHeader.clean_up();
}
if (other_value.gnPacket().is_bound()) {
  single_value->field_gnPacket = other_value.gnPacket();
} else {
  single_value->field_gnPacket.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GeoNetworkingPdu_template::copy_template(const GeoNetworkingPdu_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.basicHeader().get_selection()) {
single_value->field_basicHeader = other_value.basicHeader();
} else {
single_value->field_basicHeader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnPacket().get_selection()) {
single_value->field_gnPacket = other_value.gnPacket();
} else {
single_value->field_gnPacket.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GeoNetworkingPdu_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu.");
break;
}
set_selection(other_value);
}

GeoNetworkingPdu_template::GeoNetworkingPdu_template()
{
}

GeoNetworkingPdu_template::GeoNetworkingPdu_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GeoNetworkingPdu_template::GeoNetworkingPdu_template(const GeoNetworkingPdu& other_value)
{
copy_value(other_value);
}

GeoNetworkingPdu_template::GeoNetworkingPdu_template(const OPTIONAL<GeoNetworkingPdu>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoNetworkingPdu&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu from an unbound optional field.");
}
}

GeoNetworkingPdu_template::GeoNetworkingPdu_template(const GeoNetworkingPdu_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GeoNetworkingPdu_template::~GeoNetworkingPdu_template()
{
clean_up();
}

GeoNetworkingPdu_template& GeoNetworkingPdu_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GeoNetworkingPdu_template& GeoNetworkingPdu_template::operator=(const GeoNetworkingPdu& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GeoNetworkingPdu_template& GeoNetworkingPdu_template::operator=(const OPTIONAL<GeoNetworkingPdu>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeoNetworkingPdu&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu.");
}
return *this;
}

GeoNetworkingPdu_template& GeoNetworkingPdu_template::operator=(const GeoNetworkingPdu_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GeoNetworkingPdu_template::match(const GeoNetworkingPdu& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.basicHeader().is_bound()) return FALSE;
if(!single_value->field_basicHeader.match(other_value.basicHeader(), legacy))return FALSE;
if(!other_value.gnPacket().is_bound()) return FALSE;
if(!single_value->field_gnPacket.match(other_value.gnPacket(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu.");
}
return FALSE;
}

boolean GeoNetworkingPdu_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_basicHeader.is_bound()) return TRUE;
if (single_value->field_gnPacket.is_bound()) return TRUE;
return FALSE;
}

boolean GeoNetworkingPdu_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_basicHeader.is_value()) return FALSE;
if (!single_value->field_gnPacket.is_value()) return FALSE;
return TRUE;
}

void GeoNetworkingPdu_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GeoNetworkingPdu GeoNetworkingPdu_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu.");
GeoNetworkingPdu ret_val;
if (single_value->field_basicHeader.is_bound()) {
ret_val.basicHeader() = single_value->field_basicHeader.valueof();
}
if (single_value->field_gnPacket.is_bound()) {
ret_val.gnPacket() = single_value->field_gnPacket.valueof();
}
return ret_val;
}

void GeoNetworkingPdu_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GeoNetworkingPdu_template[list_length];
}

GeoNetworkingPdu_template& GeoNetworkingPdu_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu.");
return value_list.list_value[list_index];
}

BasicHeader_template& GeoNetworkingPdu_template::basicHeader()
{
set_specific();
return single_value->field_basicHeader;
}

const BasicHeader_template& GeoNetworkingPdu_template::basicHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field basicHeader of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu.");
return single_value->field_basicHeader;
}

GeoNetworkingPacket_template& GeoNetworkingPdu_template::gnPacket()
{
set_specific();
return single_value->field_gnPacket;
}

const GeoNetworkingPacket_template& GeoNetworkingPdu_template::gnPacket() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnPacket of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu.");
return single_value->field_gnPacket;
}

int GeoNetworkingPdu_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu.");
  }
  return 0;
}

void GeoNetworkingPdu_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ basicHeader := ");
single_value->field_basicHeader.log();
TTCN_Logger::log_event_str(", gnPacket := ");
single_value->field_gnPacket.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GeoNetworkingPdu_template::log_match(const GeoNetworkingPdu& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_basicHeader.match(match_value.basicHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".basicHeader");
single_value->field_basicHeader.log_match(match_value.basicHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_gnPacket.match(match_value.gnPacket(), legacy)){
TTCN_Logger::log_logmatch_info(".gnPacket");
single_value->field_gnPacket.log_match(match_value.gnPacket(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ basicHeader := ");
single_value->field_basicHeader.log_match(match_value.basicHeader(), legacy);
TTCN_Logger::log_event_str(", gnPacket := ");
single_value->field_gnPacket.log_match(match_value.gnPacket(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GeoNetworkingPdu_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_basicHeader.encode_text(text_buf);
single_value->field_gnPacket.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu.");
}
}

void GeoNetworkingPdu_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_basicHeader.decode_text(text_buf);
single_value->field_gnPacket.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GeoNetworkingPdu_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu.");
}
}

void GeoNetworkingPdu_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu'");
    }
    if (strcmp("basicHeader", param_field) == 0) {
      basicHeader().set_param(param);
      return;
    } else if (strcmp("gnPacket", param_field) == 0) {
      gnPacket().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GeoNetworkingPdu_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) basicHeader().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) gnPacket().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "basicHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          basicHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnPacket")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnPacket().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GeoNetworkingPdu_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu'");
    }
    if (strcmp("basicHeader", param_field) == 0) {
      return basicHeader().get_param(param_name);
    } else if (strcmp("gnPacket", param_field) == 0) {
      return gnPacket().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_basicHeader = single_value->field_basicHeader.get_param(param_name);
    mp_field_basicHeader->set_id(new Module_Param_FieldName(mcopystr("basicHeader")));
    mp->add_elem(mp_field_basicHeader);
    Module_Param* mp_field_gnPacket = single_value->field_gnPacket.get_param(param_name);
    mp_field_gnPacket->set_id(new Module_Param_FieldName(mcopystr("gnPacket")));
    mp->add_elem(mp_field_gnPacket);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GeoNetworkingPdu_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_basicHeader.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu");
single_value->field_gnPacket.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoNetworkingPdu");
}

boolean GeoNetworkingPdu_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GeoNetworkingPdu_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

GeoUnicastForwardingAlgorithm::GeoUnicastForwardingAlgorithm()
{
enum_value = UNBOUND_VALUE;
}

GeoUnicastForwardingAlgorithm::GeoUnicastForwardingAlgorithm(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

GeoUnicastForwardingAlgorithm::GeoUnicastForwardingAlgorithm(enum_type other_value)
{
enum_value = other_value;
}

GeoUnicastForwardingAlgorithm::GeoUnicastForwardingAlgorithm(const GeoUnicastForwardingAlgorithm& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
enum_value = other_value.enum_value;
}

GeoUnicastForwardingAlgorithm& GeoUnicastForwardingAlgorithm::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

GeoUnicastForwardingAlgorithm& GeoUnicastForwardingAlgorithm::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

GeoUnicastForwardingAlgorithm& GeoUnicastForwardingAlgorithm::operator=(const GeoUnicastForwardingAlgorithm& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
enum_value = other_value.enum_value;
return *this;
}

boolean GeoUnicastForwardingAlgorithm::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
return enum_value == other_value;
}

boolean GeoUnicastForwardingAlgorithm::operator==(const GeoUnicastForwardingAlgorithm& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
return enum_value == other_value.enum_value;
}

boolean GeoUnicastForwardingAlgorithm::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
return enum_value < other_value;
}

boolean GeoUnicastForwardingAlgorithm::operator<(const GeoUnicastForwardingAlgorithm& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
return enum_value < other_value.enum_value;
}

boolean GeoUnicastForwardingAlgorithm::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
return enum_value > other_value;
}

boolean GeoUnicastForwardingAlgorithm::operator>(const GeoUnicastForwardingAlgorithm& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
return enum_value > other_value.enum_value;
}

const char *GeoUnicastForwardingAlgorithm::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__unspecified: return "e_unspecified";
case e__greedy: return "e_greedy";
case e__cbf: return "e_cbf";
default: return "<unknown>";
}
}

GeoUnicastForwardingAlgorithm::enum_type GeoUnicastForwardingAlgorithm::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_unspecified")) return e__unspecified;
else if (!strcmp(str_par, "e_greedy")) return e__greedy;
else if (!strcmp(str_par, "e_cbf")) return e__cbf;
else return UNKNOWN_VALUE;
}

boolean GeoUnicastForwardingAlgorithm::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
return TRUE;
default:
return FALSE;
}
}

int GeoUnicastForwardingAlgorithm::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int GeoUnicastForwardingAlgorithm::enum2int(const GeoUnicastForwardingAlgorithm& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void GeoUnicastForwardingAlgorithm::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.", int_val);
enum_value = (enum_type)int_val;
}

GeoUnicastForwardingAlgorithm::operator GeoUnicastForwardingAlgorithm::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
return enum_value;
}

void GeoUnicastForwardingAlgorithm::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void GeoUnicastForwardingAlgorithm::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
  }
}

Module_Param* GeoUnicastForwardingAlgorithm::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void GeoUnicastForwardingAlgorithm::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
text_buf.push_int(enum_value);
}

void GeoUnicastForwardingAlgorithm::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.", enum_value);
}

void GeoUnicastForwardingAlgorithm::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GeoUnicastForwardingAlgorithm::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GeoUnicastForwardingAlgorithm::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 2, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int GeoUnicastForwardingAlgorithm::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 2);
}

void GeoUnicastForwardingAlgorithm_template::copy_template(const GeoUnicastForwardingAlgorithm_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GeoUnicastForwardingAlgorithm_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
}
}

GeoUnicastForwardingAlgorithm_template::GeoUnicastForwardingAlgorithm_template()
{
}

GeoUnicastForwardingAlgorithm_template::GeoUnicastForwardingAlgorithm_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GeoUnicastForwardingAlgorithm_template::GeoUnicastForwardingAlgorithm_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!GeoUnicastForwardingAlgorithm::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm with unknown numeric value %d.", other_value);
single_value = (GeoUnicastForwardingAlgorithm::enum_type)other_value;
}

GeoUnicastForwardingAlgorithm_template::GeoUnicastForwardingAlgorithm_template(GeoUnicastForwardingAlgorithm::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

GeoUnicastForwardingAlgorithm_template::GeoUnicastForwardingAlgorithm_template(const GeoUnicastForwardingAlgorithm& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == GeoUnicastForwardingAlgorithm::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
single_value = other_value.enum_value;
}

GeoUnicastForwardingAlgorithm_template::GeoUnicastForwardingAlgorithm_template(const OPTIONAL<GeoUnicastForwardingAlgorithm>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GeoUnicastForwardingAlgorithm::enum_type)(const GeoUnicastForwardingAlgorithm&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm from an unbound optional field.");
}
}

GeoUnicastForwardingAlgorithm_template::GeoUnicastForwardingAlgorithm_template(const GeoUnicastForwardingAlgorithm_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

GeoUnicastForwardingAlgorithm_template::~GeoUnicastForwardingAlgorithm_template()
{
clean_up();
}

boolean GeoUnicastForwardingAlgorithm_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean GeoUnicastForwardingAlgorithm_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != GeoUnicastForwardingAlgorithm::UNBOUND_VALUE;
}

void GeoUnicastForwardingAlgorithm_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

GeoUnicastForwardingAlgorithm_template& GeoUnicastForwardingAlgorithm_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GeoUnicastForwardingAlgorithm_template& GeoUnicastForwardingAlgorithm_template::operator=(int other_value)
{
if (!GeoUnicastForwardingAlgorithm::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (GeoUnicastForwardingAlgorithm::enum_type)other_value;
return *this;
}

GeoUnicastForwardingAlgorithm_template& GeoUnicastForwardingAlgorithm_template::operator=(GeoUnicastForwardingAlgorithm::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

GeoUnicastForwardingAlgorithm_template& GeoUnicastForwardingAlgorithm_template::operator=(const GeoUnicastForwardingAlgorithm& other_value)
{
if (other_value.enum_value == GeoUnicastForwardingAlgorithm::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

GeoUnicastForwardingAlgorithm_template& GeoUnicastForwardingAlgorithm_template::operator=(const OPTIONAL<GeoUnicastForwardingAlgorithm>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GeoUnicastForwardingAlgorithm::enum_type)(const GeoUnicastForwardingAlgorithm&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
}
return *this;
}

GeoUnicastForwardingAlgorithm_template& GeoUnicastForwardingAlgorithm_template::operator=(const GeoUnicastForwardingAlgorithm_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GeoUnicastForwardingAlgorithm_template::match(GeoUnicastForwardingAlgorithm::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
}
return FALSE;
}

boolean GeoUnicastForwardingAlgorithm_template::match(const GeoUnicastForwardingAlgorithm& other_value, boolean) const
{
if (other_value.enum_value == GeoUnicastForwardingAlgorithm::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm with an unbound value.");
return match(other_value.enum_value);
}

GeoUnicastForwardingAlgorithm::enum_type GeoUnicastForwardingAlgorithm_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
return single_value;
}

void GeoUnicastForwardingAlgorithm_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GeoUnicastForwardingAlgorithm_template[list_length];
}

GeoUnicastForwardingAlgorithm_template& GeoUnicastForwardingAlgorithm_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
return value_list.list_value[list_index];
}

void GeoUnicastForwardingAlgorithm_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(GeoUnicastForwardingAlgorithm::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GeoUnicastForwardingAlgorithm_template::log_match(const GeoUnicastForwardingAlgorithm& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void GeoUnicastForwardingAlgorithm_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
}
}

void GeoUnicastForwardingAlgorithm_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (GeoUnicastForwardingAlgorithm::enum_type)text_buf.pull_int().get_val();
if (!GeoUnicastForwardingAlgorithm::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GeoUnicastForwardingAlgorithm_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
}
}

boolean GeoUnicastForwardingAlgorithm_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GeoUnicastForwardingAlgorithm_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GeoUnicastForwardingAlgorithm_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    GeoUnicastForwardingAlgorithm::enum_type enum_val = (enum_name != NULL) ? GeoUnicastForwardingAlgorithm::str_to_enum(enum_name) : GeoUnicastForwardingAlgorithm::UNKNOWN_VALUE;
    if (GeoUnicastForwardingAlgorithm::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GeoUnicastForwardingAlgorithm_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    GeoUnicastForwardingAlgorithm::enum_type enum_val = GeoUnicastForwardingAlgorithm::str_to_enum(mp->get_enumerated());
    if (!GeoUnicastForwardingAlgorithm::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GeoUnicastForwardingAlgorithm_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(GeoUnicastForwardingAlgorithm::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GeoUnicastForwardingAlgorithm_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoUnicastForwardingAlgorithm");
}

GeoBroadcastForwardingAlgorithm::GeoBroadcastForwardingAlgorithm()
{
enum_value = UNBOUND_VALUE;
}

GeoBroadcastForwardingAlgorithm::GeoBroadcastForwardingAlgorithm(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

GeoBroadcastForwardingAlgorithm::GeoBroadcastForwardingAlgorithm(enum_type other_value)
{
enum_value = other_value;
}

GeoBroadcastForwardingAlgorithm::GeoBroadcastForwardingAlgorithm(const GeoBroadcastForwardingAlgorithm& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
enum_value = other_value.enum_value;
}

GeoBroadcastForwardingAlgorithm& GeoBroadcastForwardingAlgorithm::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

GeoBroadcastForwardingAlgorithm& GeoBroadcastForwardingAlgorithm::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

GeoBroadcastForwardingAlgorithm& GeoBroadcastForwardingAlgorithm::operator=(const GeoBroadcastForwardingAlgorithm& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
enum_value = other_value.enum_value;
return *this;
}

boolean GeoBroadcastForwardingAlgorithm::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
return enum_value == other_value;
}

boolean GeoBroadcastForwardingAlgorithm::operator==(const GeoBroadcastForwardingAlgorithm& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
return enum_value == other_value.enum_value;
}

boolean GeoBroadcastForwardingAlgorithm::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
return enum_value < other_value;
}

boolean GeoBroadcastForwardingAlgorithm::operator<(const GeoBroadcastForwardingAlgorithm& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
return enum_value < other_value.enum_value;
}

boolean GeoBroadcastForwardingAlgorithm::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
return enum_value > other_value;
}

boolean GeoBroadcastForwardingAlgorithm::operator>(const GeoBroadcastForwardingAlgorithm& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
return enum_value > other_value.enum_value;
}

const char *GeoBroadcastForwardingAlgorithm::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__unspecified: return "e_unspecified";
case e__simple: return "e_simple";
case e__cbf: return "e_cbf";
case e__advanced: return "e_advanced";
default: return "<unknown>";
}
}

GeoBroadcastForwardingAlgorithm::enum_type GeoBroadcastForwardingAlgorithm::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_unspecified")) return e__unspecified;
else if (!strcmp(str_par, "e_simple")) return e__simple;
else if (!strcmp(str_par, "e_cbf")) return e__cbf;
else if (!strcmp(str_par, "e_advanced")) return e__advanced;
else return UNKNOWN_VALUE;
}

boolean GeoBroadcastForwardingAlgorithm::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
return TRUE;
default:
return FALSE;
}
}

int GeoBroadcastForwardingAlgorithm::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int GeoBroadcastForwardingAlgorithm::enum2int(const GeoBroadcastForwardingAlgorithm& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void GeoBroadcastForwardingAlgorithm::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.", int_val);
enum_value = (enum_type)int_val;
}

GeoBroadcastForwardingAlgorithm::operator GeoBroadcastForwardingAlgorithm::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
return enum_value;
}

void GeoBroadcastForwardingAlgorithm::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void GeoBroadcastForwardingAlgorithm::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
  }
}

Module_Param* GeoBroadcastForwardingAlgorithm::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void GeoBroadcastForwardingAlgorithm::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
text_buf.push_int(enum_value);
}

void GeoBroadcastForwardingAlgorithm::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.", enum_value);
}

void GeoBroadcastForwardingAlgorithm::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GeoBroadcastForwardingAlgorithm::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GeoBroadcastForwardingAlgorithm::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int GeoBroadcastForwardingAlgorithm::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

void GeoBroadcastForwardingAlgorithm_template::copy_template(const GeoBroadcastForwardingAlgorithm_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GeoBroadcastForwardingAlgorithm_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
}
}

GeoBroadcastForwardingAlgorithm_template::GeoBroadcastForwardingAlgorithm_template()
{
}

GeoBroadcastForwardingAlgorithm_template::GeoBroadcastForwardingAlgorithm_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GeoBroadcastForwardingAlgorithm_template::GeoBroadcastForwardingAlgorithm_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!GeoBroadcastForwardingAlgorithm::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm with unknown numeric value %d.", other_value);
single_value = (GeoBroadcastForwardingAlgorithm::enum_type)other_value;
}

GeoBroadcastForwardingAlgorithm_template::GeoBroadcastForwardingAlgorithm_template(GeoBroadcastForwardingAlgorithm::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

GeoBroadcastForwardingAlgorithm_template::GeoBroadcastForwardingAlgorithm_template(const GeoBroadcastForwardingAlgorithm& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == GeoBroadcastForwardingAlgorithm::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
single_value = other_value.enum_value;
}

GeoBroadcastForwardingAlgorithm_template::GeoBroadcastForwardingAlgorithm_template(const OPTIONAL<GeoBroadcastForwardingAlgorithm>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GeoBroadcastForwardingAlgorithm::enum_type)(const GeoBroadcastForwardingAlgorithm&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm from an unbound optional field.");
}
}

GeoBroadcastForwardingAlgorithm_template::GeoBroadcastForwardingAlgorithm_template(const GeoBroadcastForwardingAlgorithm_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

GeoBroadcastForwardingAlgorithm_template::~GeoBroadcastForwardingAlgorithm_template()
{
clean_up();
}

boolean GeoBroadcastForwardingAlgorithm_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean GeoBroadcastForwardingAlgorithm_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != GeoBroadcastForwardingAlgorithm::UNBOUND_VALUE;
}

void GeoBroadcastForwardingAlgorithm_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

GeoBroadcastForwardingAlgorithm_template& GeoBroadcastForwardingAlgorithm_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GeoBroadcastForwardingAlgorithm_template& GeoBroadcastForwardingAlgorithm_template::operator=(int other_value)
{
if (!GeoBroadcastForwardingAlgorithm::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (GeoBroadcastForwardingAlgorithm::enum_type)other_value;
return *this;
}

GeoBroadcastForwardingAlgorithm_template& GeoBroadcastForwardingAlgorithm_template::operator=(GeoBroadcastForwardingAlgorithm::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

GeoBroadcastForwardingAlgorithm_template& GeoBroadcastForwardingAlgorithm_template::operator=(const GeoBroadcastForwardingAlgorithm& other_value)
{
if (other_value.enum_value == GeoBroadcastForwardingAlgorithm::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

GeoBroadcastForwardingAlgorithm_template& GeoBroadcastForwardingAlgorithm_template::operator=(const OPTIONAL<GeoBroadcastForwardingAlgorithm>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GeoBroadcastForwardingAlgorithm::enum_type)(const GeoBroadcastForwardingAlgorithm&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
}
return *this;
}

GeoBroadcastForwardingAlgorithm_template& GeoBroadcastForwardingAlgorithm_template::operator=(const GeoBroadcastForwardingAlgorithm_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GeoBroadcastForwardingAlgorithm_template::match(GeoBroadcastForwardingAlgorithm::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
}
return FALSE;
}

boolean GeoBroadcastForwardingAlgorithm_template::match(const GeoBroadcastForwardingAlgorithm& other_value, boolean) const
{
if (other_value.enum_value == GeoBroadcastForwardingAlgorithm::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm with an unbound value.");
return match(other_value.enum_value);
}

GeoBroadcastForwardingAlgorithm::enum_type GeoBroadcastForwardingAlgorithm_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
return single_value;
}

void GeoBroadcastForwardingAlgorithm_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GeoBroadcastForwardingAlgorithm_template[list_length];
}

GeoBroadcastForwardingAlgorithm_template& GeoBroadcastForwardingAlgorithm_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
return value_list.list_value[list_index];
}

void GeoBroadcastForwardingAlgorithm_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(GeoBroadcastForwardingAlgorithm::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GeoBroadcastForwardingAlgorithm_template::log_match(const GeoBroadcastForwardingAlgorithm& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void GeoBroadcastForwardingAlgorithm_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
}
}

void GeoBroadcastForwardingAlgorithm_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (GeoBroadcastForwardingAlgorithm::enum_type)text_buf.pull_int().get_val();
if (!GeoBroadcastForwardingAlgorithm::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GeoBroadcastForwardingAlgorithm_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
}
}

boolean GeoBroadcastForwardingAlgorithm_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GeoBroadcastForwardingAlgorithm_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GeoBroadcastForwardingAlgorithm_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    GeoBroadcastForwardingAlgorithm::enum_type enum_val = (enum_name != NULL) ? GeoBroadcastForwardingAlgorithm::str_to_enum(enum_name) : GeoBroadcastForwardingAlgorithm::UNKNOWN_VALUE;
    if (GeoBroadcastForwardingAlgorithm::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GeoBroadcastForwardingAlgorithm_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    GeoBroadcastForwardingAlgorithm::enum_type enum_val = GeoBroadcastForwardingAlgorithm::str_to_enum(mp->get_enumerated());
    if (!GeoBroadcastForwardingAlgorithm::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GeoBroadcastForwardingAlgorithm_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(GeoBroadcastForwardingAlgorithm::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GeoBroadcastForwardingAlgorithm_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GeoBroadcastForwardingAlgorithm");
}

GnAddressConfigurationMethod::GnAddressConfigurationMethod()
{
enum_value = UNBOUND_VALUE;
}

GnAddressConfigurationMethod::GnAddressConfigurationMethod(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

GnAddressConfigurationMethod::GnAddressConfigurationMethod(enum_type other_value)
{
enum_value = other_value;
}

GnAddressConfigurationMethod::GnAddressConfigurationMethod(const GnAddressConfigurationMethod& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
enum_value = other_value.enum_value;
}

GnAddressConfigurationMethod& GnAddressConfigurationMethod::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

GnAddressConfigurationMethod& GnAddressConfigurationMethod::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

GnAddressConfigurationMethod& GnAddressConfigurationMethod::operator=(const GnAddressConfigurationMethod& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
enum_value = other_value.enum_value;
return *this;
}

boolean GnAddressConfigurationMethod::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
return enum_value == other_value;
}

boolean GnAddressConfigurationMethod::operator==(const GnAddressConfigurationMethod& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
return enum_value == other_value.enum_value;
}

boolean GnAddressConfigurationMethod::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
return enum_value < other_value;
}

boolean GnAddressConfigurationMethod::operator<(const GnAddressConfigurationMethod& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
return enum_value < other_value.enum_value;
}

boolean GnAddressConfigurationMethod::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
return enum_value > other_value;
}

boolean GnAddressConfigurationMethod::operator>(const GnAddressConfigurationMethod& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
return enum_value > other_value.enum_value;
}

const char *GnAddressConfigurationMethod::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__auto: return "e_auto";
case e__managed: return "e_managed";
case e__anonymous: return "e_anonymous";
default: return "<unknown>";
}
}

GnAddressConfigurationMethod::enum_type GnAddressConfigurationMethod::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_auto")) return e__auto;
else if (!strcmp(str_par, "e_managed")) return e__managed;
else if (!strcmp(str_par, "e_anonymous")) return e__anonymous;
else return UNKNOWN_VALUE;
}

boolean GnAddressConfigurationMethod::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
return TRUE;
default:
return FALSE;
}
}

int GnAddressConfigurationMethod::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int GnAddressConfigurationMethod::enum2int(const GnAddressConfigurationMethod& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void GnAddressConfigurationMethod::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.", int_val);
enum_value = (enum_type)int_val;
}

GnAddressConfigurationMethod::operator GnAddressConfigurationMethod::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
return enum_value;
}

void GnAddressConfigurationMethod::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void GnAddressConfigurationMethod::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
  }
}

Module_Param* GnAddressConfigurationMethod::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void GnAddressConfigurationMethod::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
text_buf.push_int(enum_value);
}

void GnAddressConfigurationMethod::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.", enum_value);
}

void GnAddressConfigurationMethod::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GnAddressConfigurationMethod::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GnAddressConfigurationMethod::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 2, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int GnAddressConfigurationMethod::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 2);
}

void GnAddressConfigurationMethod_template::copy_template(const GnAddressConfigurationMethod_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GnAddressConfigurationMethod_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
}
}

GnAddressConfigurationMethod_template::GnAddressConfigurationMethod_template()
{
}

GnAddressConfigurationMethod_template::GnAddressConfigurationMethod_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GnAddressConfigurationMethod_template::GnAddressConfigurationMethod_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!GnAddressConfigurationMethod::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod with unknown numeric value %d.", other_value);
single_value = (GnAddressConfigurationMethod::enum_type)other_value;
}

GnAddressConfigurationMethod_template::GnAddressConfigurationMethod_template(GnAddressConfigurationMethod::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

GnAddressConfigurationMethod_template::GnAddressConfigurationMethod_template(const GnAddressConfigurationMethod& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == GnAddressConfigurationMethod::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
single_value = other_value.enum_value;
}

GnAddressConfigurationMethod_template::GnAddressConfigurationMethod_template(const OPTIONAL<GnAddressConfigurationMethod>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GnAddressConfigurationMethod::enum_type)(const GnAddressConfigurationMethod&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod from an unbound optional field.");
}
}

GnAddressConfigurationMethod_template::GnAddressConfigurationMethod_template(const GnAddressConfigurationMethod_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

GnAddressConfigurationMethod_template::~GnAddressConfigurationMethod_template()
{
clean_up();
}

boolean GnAddressConfigurationMethod_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean GnAddressConfigurationMethod_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != GnAddressConfigurationMethod::UNBOUND_VALUE;
}

void GnAddressConfigurationMethod_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

GnAddressConfigurationMethod_template& GnAddressConfigurationMethod_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GnAddressConfigurationMethod_template& GnAddressConfigurationMethod_template::operator=(int other_value)
{
if (!GnAddressConfigurationMethod::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (GnAddressConfigurationMethod::enum_type)other_value;
return *this;
}

GnAddressConfigurationMethod_template& GnAddressConfigurationMethod_template::operator=(GnAddressConfigurationMethod::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

GnAddressConfigurationMethod_template& GnAddressConfigurationMethod_template::operator=(const GnAddressConfigurationMethod& other_value)
{
if (other_value.enum_value == GnAddressConfigurationMethod::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

GnAddressConfigurationMethod_template& GnAddressConfigurationMethod_template::operator=(const OPTIONAL<GnAddressConfigurationMethod>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (GnAddressConfigurationMethod::enum_type)(const GnAddressConfigurationMethod&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
}
return *this;
}

GnAddressConfigurationMethod_template& GnAddressConfigurationMethod_template::operator=(const GnAddressConfigurationMethod_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GnAddressConfigurationMethod_template::match(GnAddressConfigurationMethod::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
}
return FALSE;
}

boolean GnAddressConfigurationMethod_template::match(const GnAddressConfigurationMethod& other_value, boolean) const
{
if (other_value.enum_value == GnAddressConfigurationMethod::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod with an unbound value.");
return match(other_value.enum_value);
}

GnAddressConfigurationMethod::enum_type GnAddressConfigurationMethod_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
return single_value;
}

void GnAddressConfigurationMethod_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GnAddressConfigurationMethod_template[list_length];
}

GnAddressConfigurationMethod_template& GnAddressConfigurationMethod_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
return value_list.list_value[list_index];
}

void GnAddressConfigurationMethod_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(GnAddressConfigurationMethod::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GnAddressConfigurationMethod_template::log_match(const GnAddressConfigurationMethod& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void GnAddressConfigurationMethod_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
}
}

void GnAddressConfigurationMethod_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (GnAddressConfigurationMethod::enum_type)text_buf.pull_int().get_val();
if (!GnAddressConfigurationMethod::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GnAddressConfigurationMethod_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
}
}

boolean GnAddressConfigurationMethod_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GnAddressConfigurationMethod_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GnAddressConfigurationMethod_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    GnAddressConfigurationMethod::enum_type enum_val = (enum_name != NULL) ? GnAddressConfigurationMethod::str_to_enum(enum_name) : GnAddressConfigurationMethod::UNKNOWN_VALUE;
    if (GnAddressConfigurationMethod::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GnAddressConfigurationMethod_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    GnAddressConfigurationMethod::enum_type enum_val = GnAddressConfigurationMethod::str_to_enum(mp->get_enumerated());
    if (!GnAddressConfigurationMethod::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GnAddressConfigurationMethod_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(GnAddressConfigurationMethod::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GnAddressConfigurationMethod_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GnAddressConfigurationMethod");
}

void UtGnTrigger::copy_value(const UtGnTrigger& other_value)
{
switch (other_value.union_selection) {
case ALT_geoUnicast:
field_geoUnicast = new GenerateGeoUnicastMessage(*other_value.field_geoUnicast);
break;
case ALT_geoBroadcast:
field_geoBroadcast = new GenerateGeoBroadcastMessage(*other_value.field_geoBroadcast);
break;
case ALT_geoAnycast:
field_geoAnycast = new GenerateGeoBroadcastMessage(*other_value.field_geoAnycast);
break;
case ALT_shb:
field_shb = new GenerateSHBMessage(*other_value.field_shb);
break;
case ALT_tsb:
field_tsb = new GenerateTSBMessage(*other_value.field_tsb);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
}
union_selection = other_value.union_selection;
}

UtGnTrigger::UtGnTrigger()
{
union_selection = UNBOUND_VALUE;
}

UtGnTrigger::UtGnTrigger(const UtGnTrigger& other_value)
: Base_Type(){
copy_value(other_value);
}

UtGnTrigger::~UtGnTrigger()
{
clean_up();
}

UtGnTrigger& UtGnTrigger::operator=(const UtGnTrigger& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean UtGnTrigger::operator==(const UtGnTrigger& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_geoUnicast:
return *field_geoUnicast == *other_value.field_geoUnicast;
case ALT_geoBroadcast:
return *field_geoBroadcast == *other_value.field_geoBroadcast;
case ALT_geoAnycast:
return *field_geoAnycast == *other_value.field_geoAnycast;
case ALT_shb:
return *field_shb == *other_value.field_shb;
case ALT_tsb:
return *field_tsb == *other_value.field_tsb;
default:
return FALSE;
}
}

GenerateGeoUnicastMessage& UtGnTrigger::geoUnicast()
{
if (union_selection != ALT_geoUnicast) {
clean_up();
field_geoUnicast = new GenerateGeoUnicastMessage;
union_selection = ALT_geoUnicast;
}
return *field_geoUnicast;
}

const GenerateGeoUnicastMessage& UtGnTrigger::geoUnicast() const
{
if (union_selection != ALT_geoUnicast) TTCN_error("Using non-selected field geoUnicast in a value of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
return *field_geoUnicast;
}

GenerateGeoBroadcastMessage& UtGnTrigger::geoBroadcast()
{
if (union_selection != ALT_geoBroadcast) {
clean_up();
field_geoBroadcast = new GenerateGeoBroadcastMessage;
union_selection = ALT_geoBroadcast;
}
return *field_geoBroadcast;
}

const GenerateGeoBroadcastMessage& UtGnTrigger::geoBroadcast() const
{
if (union_selection != ALT_geoBroadcast) TTCN_error("Using non-selected field geoBroadcast in a value of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
return *field_geoBroadcast;
}

GenerateGeoBroadcastMessage& UtGnTrigger::geoAnycast()
{
if (union_selection != ALT_geoAnycast) {
clean_up();
field_geoAnycast = new GenerateGeoBroadcastMessage;
union_selection = ALT_geoAnycast;
}
return *field_geoAnycast;
}

const GenerateGeoBroadcastMessage& UtGnTrigger::geoAnycast() const
{
if (union_selection != ALT_geoAnycast) TTCN_error("Using non-selected field geoAnycast in a value of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
return *field_geoAnycast;
}

GenerateSHBMessage& UtGnTrigger::shb()
{
if (union_selection != ALT_shb) {
clean_up();
field_shb = new GenerateSHBMessage;
union_selection = ALT_shb;
}
return *field_shb;
}

const GenerateSHBMessage& UtGnTrigger::shb() const
{
if (union_selection != ALT_shb) TTCN_error("Using non-selected field shb in a value of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
return *field_shb;
}

GenerateTSBMessage& UtGnTrigger::tsb()
{
if (union_selection != ALT_tsb) {
clean_up();
field_tsb = new GenerateTSBMessage;
union_selection = ALT_tsb;
}
return *field_tsb;
}

const GenerateTSBMessage& UtGnTrigger::tsb() const
{
if (union_selection != ALT_tsb) TTCN_error("Using non-selected field tsb in a value of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
return *field_tsb;
}

boolean UtGnTrigger::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
return union_selection == checked_selection;
}

boolean UtGnTrigger::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean UtGnTrigger::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_geoUnicast: return field_geoUnicast->is_value();
case ALT_geoBroadcast: return field_geoBroadcast->is_value();
case ALT_geoAnycast: return field_geoAnycast->is_value();
case ALT_shb: return field_shb->is_value();
case ALT_tsb: return field_tsb->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void UtGnTrigger::clean_up()
{
switch (union_selection) {
case ALT_geoUnicast:
  delete field_geoUnicast;
  break;
case ALT_geoBroadcast:
  delete field_geoBroadcast;
  break;
case ALT_geoAnycast:
  delete field_geoAnycast;
  break;
case ALT_shb:
  delete field_shb;
  break;
case ALT_tsb:
  delete field_tsb;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void UtGnTrigger::log() const
{
switch (union_selection) {
case ALT_geoUnicast:
TTCN_Logger::log_event_str("{ geoUnicast := ");
field_geoUnicast->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_geoBroadcast:
TTCN_Logger::log_event_str("{ geoBroadcast := ");
field_geoBroadcast->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_geoAnycast:
TTCN_Logger::log_event_str("{ geoAnycast := ");
field_geoAnycast->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_shb:
TTCN_Logger::log_event_str("{ shb := ");
field_shb->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_tsb:
TTCN_Logger::log_event_str("{ tsb := ");
field_tsb->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void UtGnTrigger::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsGeoNetworking_TypesAndValues.UtGnTrigger'");
    }
    if (strcmp("geoUnicast", param_field) == 0) {
      geoUnicast().set_param(param);
      return;
    } else if (strcmp("geoBroadcast", param_field) == 0) {
      geoBroadcast().set_param(param);
      return;
    } else if (strcmp("geoAnycast", param_field) == 0) {
      geoAnycast().set_param(param);
      return;
    } else if (strcmp("shb", param_field) == 0) {
      shb().set_param(param);
      return;
    } else if (strcmp("tsb", param_field) == 0) {
      tsb().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsGeoNetworking_TypesAndValues.UtGnTrigger'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "geoUnicast")) {
    geoUnicast().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "geoBroadcast")) {
    geoBroadcast().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "geoAnycast")) {
    geoAnycast().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "shb")) {
    shb().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "tsb")) {
    tsb().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.", mp_last->get_id()->get_name());
}

Module_Param* UtGnTrigger::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsGeoNetworking_TypesAndValues.UtGnTrigger'");
    }
    if (strcmp("geoUnicast", param_field) == 0) {
      return geoUnicast().get_param(param_name);
    } else if (strcmp("geoBroadcast", param_field) == 0) {
      return geoBroadcast().get_param(param_name);
    } else if (strcmp("geoAnycast", param_field) == 0) {
      return geoAnycast().get_param(param_name);
    } else if (strcmp("shb", param_field) == 0) {
      return shb().get_param(param_name);
    } else if (strcmp("tsb", param_field) == 0) {
      return tsb().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `UtGnTrigger'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_geoUnicast:
    mp_field = field_geoUnicast->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("geoUnicast")));
    break;
  case ALT_geoBroadcast:
    mp_field = field_geoBroadcast->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("geoBroadcast")));
    break;
  case ALT_geoAnycast:
    mp_field = field_geoAnycast->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("geoAnycast")));
    break;
  case ALT_shb:
    mp_field = field_shb->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("shb")));
    break;
  case ALT_tsb:
    mp_field = field_tsb->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("tsb")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void UtGnTrigger::set_implicit_omit()
{
switch (union_selection) {
case ALT_geoUnicast:
field_geoUnicast->set_implicit_omit(); break;
case ALT_geoBroadcast:
field_geoBroadcast->set_implicit_omit(); break;
case ALT_geoAnycast:
field_geoAnycast->set_implicit_omit(); break;
case ALT_shb:
field_shb->set_implicit_omit(); break;
case ALT_tsb:
field_tsb->set_implicit_omit(); break;
default: break;
}
}

void UtGnTrigger::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_geoUnicast:
field_geoUnicast->encode_text(text_buf);
break;
case ALT_geoBroadcast:
field_geoBroadcast->encode_text(text_buf);
break;
case ALT_geoAnycast:
field_geoAnycast->encode_text(text_buf);
break;
case ALT_shb:
field_shb->encode_text(text_buf);
break;
case ALT_tsb:
field_tsb->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
}
}

void UtGnTrigger::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_geoUnicast:
geoUnicast().decode_text(text_buf);
break;
case ALT_geoBroadcast:
geoBroadcast().decode_text(text_buf);
break;
case ALT_geoAnycast:
geoAnycast().decode_text(text_buf);
break;
case ALT_shb:
shb().decode_text(text_buf);
break;
case ALT_tsb:
tsb().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
}
}

void UtGnTrigger::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void UtGnTrigger::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int UtGnTrigger::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = geoUnicast().RAW_decode(GenerateGeoUnicastMessage_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = geoBroadcast().RAW_decode(GenerateGeoBroadcastMessage_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 2:
      decoded_length = geoAnycast().RAW_decode(GenerateGeoAnycastMessage_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 3:
      decoded_length = shb().RAW_decode(GenerateSHBMessage_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 4:
      decoded_length = tsb().RAW_decode(GenerateTSBMessage_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = geoUnicast().RAW_decode(GenerateGeoUnicastMessage_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = geoBroadcast().RAW_decode(GenerateGeoBroadcastMessage_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = geoAnycast().RAW_decode(GenerateGeoAnycastMessage_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = shb().RAW_decode(GenerateSHBMessage_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = tsb().RAW_decode(GenerateTSBMessage_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int UtGnTrigger::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 5;  myleaf.body.node.nodes = init_nodes_of_enc_tree(5);
  memset(myleaf.body.node.nodes, 0, 5 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_geoUnicast:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, GenerateGeoUnicastMessage_descr_.raw);
    encoded_length = field_geoUnicast->RAW_encode(GenerateGeoUnicastMessage_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &GenerateGeoUnicastMessage_descr_;
    break;
  case ALT_geoBroadcast:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, GenerateGeoBroadcastMessage_descr_.raw);
    encoded_length = field_geoBroadcast->RAW_encode(GenerateGeoBroadcastMessage_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &GenerateGeoBroadcastMessage_descr_;
    break;
  case ALT_geoAnycast:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, GenerateGeoAnycastMessage_descr_.raw);
    encoded_length = field_geoAnycast->RAW_encode(GenerateGeoAnycastMessage_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &GenerateGeoAnycastMessage_descr_;
    break;
  case ALT_shb:
    myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 3, GenerateSHBMessage_descr_.raw);
    encoded_length = field_shb->RAW_encode(GenerateSHBMessage_descr_, *myleaf.body.node.nodes[3]);
    myleaf.body.node.nodes[3]->coding_descr = &GenerateSHBMessage_descr_;
    break;
  case ALT_tsb:
    myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 4, GenerateTSBMessage_descr_.raw);
    encoded_length = field_tsb->RAW_encode(GenerateTSBMessage_descr_, *myleaf.body.node.nodes[4]);
    myleaf.body.node.nodes[4]->coding_descr = &GenerateTSBMessage_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int UtGnTrigger::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_geoUnicast:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoUnicast");
    enc_len += field_geoUnicast->JSON_encode(GenerateGeoUnicastMessage_descr_, p_tok);
    break;
  case ALT_geoBroadcast:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoBroadcast");
    enc_len += field_geoBroadcast->JSON_encode(GenerateGeoBroadcastMessage_descr_, p_tok);
    break;
  case ALT_geoAnycast:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "geoAnycast");
    enc_len += field_geoAnycast->JSON_encode(GenerateGeoAnycastMessage_descr_, p_tok);
    break;
  case ALT_shb:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "shb");
    enc_len += field_shb->JSON_encode(GenerateSHBMessage_descr_, p_tok);
    break;
  case ALT_tsb:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "tsb");
    enc_len += field_tsb->JSON_encode(GenerateTSBMessage_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int UtGnTrigger::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "geoUnicast", name_len)) {
      int ret_val = geoUnicast().JSON_decode(GenerateGeoUnicastMessage_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoUnicast");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "geoBroadcast", name_len)) {
      int ret_val = geoBroadcast().JSON_decode(GenerateGeoBroadcastMessage_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoBroadcast");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "geoAnycast", name_len)) {
      int ret_val = geoAnycast().JSON_decode(GenerateGeoAnycastMessage_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "geoAnycast");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "shb", name_len)) {
      int ret_val = shb().JSON_decode(GenerateSHBMessage_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "shb");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "tsb", name_len)) {
      int ret_val = tsb().JSON_decode(GenerateTSBMessage_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "tsb");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void UtGnTrigger_template::copy_value(const UtGnTrigger& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case UtGnTrigger::ALT_geoUnicast:
single_value.field_geoUnicast = new GenerateGeoUnicastMessage_template(other_value.geoUnicast());
break;
case UtGnTrigger::ALT_geoBroadcast:
single_value.field_geoBroadcast = new GenerateGeoBroadcastMessage_template(other_value.geoBroadcast());
break;
case UtGnTrigger::ALT_geoAnycast:
single_value.field_geoAnycast = new GenerateGeoBroadcastMessage_template(other_value.geoAnycast());
break;
case UtGnTrigger::ALT_shb:
single_value.field_shb = new GenerateSHBMessage_template(other_value.shb());
break;
case UtGnTrigger::ALT_tsb:
single_value.field_tsb = new GenerateTSBMessage_template(other_value.tsb());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
}
set_selection(SPECIFIC_VALUE);
}

void UtGnTrigger_template::copy_template(const UtGnTrigger_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case UtGnTrigger::ALT_geoUnicast:
single_value.field_geoUnicast = new GenerateGeoUnicastMessage_template(*other_value.single_value.field_geoUnicast);
break;
case UtGnTrigger::ALT_geoBroadcast:
single_value.field_geoBroadcast = new GenerateGeoBroadcastMessage_template(*other_value.single_value.field_geoBroadcast);
break;
case UtGnTrigger::ALT_geoAnycast:
single_value.field_geoAnycast = new GenerateGeoBroadcastMessage_template(*other_value.single_value.field_geoAnycast);
break;
case UtGnTrigger::ALT_shb:
single_value.field_shb = new GenerateSHBMessage_template(*other_value.single_value.field_shb);
break;
case UtGnTrigger::ALT_tsb:
single_value.field_tsb = new GenerateTSBMessage_template(*other_value.single_value.field_tsb);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new UtGnTrigger_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
}
set_selection(other_value);
}

UtGnTrigger_template::UtGnTrigger_template()
{
}

UtGnTrigger_template::UtGnTrigger_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

UtGnTrigger_template::UtGnTrigger_template(const UtGnTrigger& other_value)
{
copy_value(other_value);
}

UtGnTrigger_template::UtGnTrigger_template(const OPTIONAL<UtGnTrigger>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtGnTrigger&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger from an unbound optional field.");
}
}

UtGnTrigger_template::UtGnTrigger_template(const UtGnTrigger_template& other_value)
: Base_Template(){
copy_template(other_value);
}

UtGnTrigger_template::~UtGnTrigger_template()
{
clean_up();
}

void UtGnTrigger_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case UtGnTrigger::ALT_geoUnicast:
delete single_value.field_geoUnicast;
break;
case UtGnTrigger::ALT_geoBroadcast:
delete single_value.field_geoBroadcast;
break;
case UtGnTrigger::ALT_geoAnycast:
delete single_value.field_geoAnycast;
break;
case UtGnTrigger::ALT_shb:
delete single_value.field_shb;
break;
case UtGnTrigger::ALT_tsb:
delete single_value.field_tsb;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

UtGnTrigger_template& UtGnTrigger_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

UtGnTrigger_template& UtGnTrigger_template::operator=(const UtGnTrigger& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

UtGnTrigger_template& UtGnTrigger_template::operator=(const OPTIONAL<UtGnTrigger>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtGnTrigger&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
}
return *this;
}

UtGnTrigger_template& UtGnTrigger_template::operator=(const UtGnTrigger_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean UtGnTrigger_template::match(const UtGnTrigger& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
UtGnTrigger::union_selection_type value_selection = other_value.get_selection();
if (value_selection == UtGnTrigger::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case UtGnTrigger::ALT_geoUnicast:
return single_value.field_geoUnicast->match(other_value.geoUnicast(), legacy);
case UtGnTrigger::ALT_geoBroadcast:
return single_value.field_geoBroadcast->match(other_value.geoBroadcast(), legacy);
case UtGnTrigger::ALT_geoAnycast:
return single_value.field_geoAnycast->match(other_value.geoAnycast(), legacy);
case UtGnTrigger::ALT_shb:
return single_value.field_shb->match(other_value.shb(), legacy);
case UtGnTrigger::ALT_tsb:
return single_value.field_tsb->match(other_value.tsb(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
}
return FALSE;
}

boolean UtGnTrigger_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case UtGnTrigger::ALT_geoUnicast:
return single_value.field_geoUnicast->is_value();
case UtGnTrigger::ALT_geoBroadcast:
return single_value.field_geoBroadcast->is_value();
case UtGnTrigger::ALT_geoAnycast:
return single_value.field_geoAnycast->is_value();
case UtGnTrigger::ALT_shb:
return single_value.field_shb->is_value();
case UtGnTrigger::ALT_tsb:
return single_value.field_tsb->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
}
}

UtGnTrigger UtGnTrigger_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
UtGnTrigger ret_val;
switch (single_value.union_selection) {
case UtGnTrigger::ALT_geoUnicast:
ret_val.geoUnicast() = single_value.field_geoUnicast->valueof();
break;
case UtGnTrigger::ALT_geoBroadcast:
ret_val.geoBroadcast() = single_value.field_geoBroadcast->valueof();
break;
case UtGnTrigger::ALT_geoAnycast:
ret_val.geoAnycast() = single_value.field_geoAnycast->valueof();
break;
case UtGnTrigger::ALT_shb:
ret_val.shb() = single_value.field_shb->valueof();
break;
case UtGnTrigger::ALT_tsb:
ret_val.tsb() = single_value.field_tsb->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
}
return ret_val;
}

UtGnTrigger_template& UtGnTrigger_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
return value_list.list_value[list_index];
}
void UtGnTrigger_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new UtGnTrigger_template[list_length];
}

GenerateGeoUnicastMessage_template& UtGnTrigger_template::geoUnicast()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtGnTrigger::ALT_geoUnicast) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_geoUnicast = new GenerateGeoUnicastMessage_template(ANY_VALUE);
else single_value.field_geoUnicast = new GenerateGeoUnicastMessage_template;
single_value.union_selection = UtGnTrigger::ALT_geoUnicast;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_geoUnicast;
}

const GenerateGeoUnicastMessage_template& UtGnTrigger_template::geoUnicast() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field geoUnicast in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
if (single_value.union_selection != UtGnTrigger::ALT_geoUnicast) TTCN_error("Accessing non-selected field geoUnicast in a template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
return *single_value.field_geoUnicast;
}

GenerateGeoBroadcastMessage_template& UtGnTrigger_template::geoBroadcast()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtGnTrigger::ALT_geoBroadcast) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_geoBroadcast = new GenerateGeoBroadcastMessage_template(ANY_VALUE);
else single_value.field_geoBroadcast = new GenerateGeoBroadcastMessage_template;
single_value.union_selection = UtGnTrigger::ALT_geoBroadcast;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_geoBroadcast;
}

const GenerateGeoBroadcastMessage_template& UtGnTrigger_template::geoBroadcast() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field geoBroadcast in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
if (single_value.union_selection != UtGnTrigger::ALT_geoBroadcast) TTCN_error("Accessing non-selected field geoBroadcast in a template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
return *single_value.field_geoBroadcast;
}

GenerateGeoBroadcastMessage_template& UtGnTrigger_template::geoAnycast()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtGnTrigger::ALT_geoAnycast) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_geoAnycast = new GenerateGeoBroadcastMessage_template(ANY_VALUE);
else single_value.field_geoAnycast = new GenerateGeoBroadcastMessage_template;
single_value.union_selection = UtGnTrigger::ALT_geoAnycast;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_geoAnycast;
}

const GenerateGeoBroadcastMessage_template& UtGnTrigger_template::geoAnycast() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field geoAnycast in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
if (single_value.union_selection != UtGnTrigger::ALT_geoAnycast) TTCN_error("Accessing non-selected field geoAnycast in a template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
return *single_value.field_geoAnycast;
}

GenerateSHBMessage_template& UtGnTrigger_template::shb()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtGnTrigger::ALT_shb) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_shb = new GenerateSHBMessage_template(ANY_VALUE);
else single_value.field_shb = new GenerateSHBMessage_template;
single_value.union_selection = UtGnTrigger::ALT_shb;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_shb;
}

const GenerateSHBMessage_template& UtGnTrigger_template::shb() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field shb in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
if (single_value.union_selection != UtGnTrigger::ALT_shb) TTCN_error("Accessing non-selected field shb in a template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
return *single_value.field_shb;
}

GenerateTSBMessage_template& UtGnTrigger_template::tsb()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != UtGnTrigger::ALT_tsb) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_tsb = new GenerateTSBMessage_template(ANY_VALUE);
else single_value.field_tsb = new GenerateTSBMessage_template;
single_value.union_selection = UtGnTrigger::ALT_tsb;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_tsb;
}

const GenerateTSBMessage_template& UtGnTrigger_template::tsb() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field tsb in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
if (single_value.union_selection != UtGnTrigger::ALT_tsb) TTCN_error("Accessing non-selected field tsb in a template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
return *single_value.field_tsb;
}

boolean UtGnTrigger_template::ischosen(UtGnTrigger::union_selection_type checked_selection) const
{
if (checked_selection == UtGnTrigger::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == UtGnTrigger::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger");
}
return FALSE;
}

void UtGnTrigger_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case UtGnTrigger::ALT_geoUnicast:
TTCN_Logger::log_event_str("{ geoUnicast := ");
single_value.field_geoUnicast->log();
TTCN_Logger::log_event_str(" }");
break;
case UtGnTrigger::ALT_geoBroadcast:
TTCN_Logger::log_event_str("{ geoBroadcast := ");
single_value.field_geoBroadcast->log();
TTCN_Logger::log_event_str(" }");
break;
case UtGnTrigger::ALT_geoAnycast:
TTCN_Logger::log_event_str("{ geoAnycast := ");
single_value.field_geoAnycast->log();
TTCN_Logger::log_event_str(" }");
break;
case UtGnTrigger::ALT_shb:
TTCN_Logger::log_event_str("{ shb := ");
single_value.field_shb->log();
TTCN_Logger::log_event_str(" }");
break;
case UtGnTrigger::ALT_tsb:
TTCN_Logger::log_event_str("{ tsb := ");
single_value.field_tsb->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void UtGnTrigger_template::log_match(const UtGnTrigger& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case UtGnTrigger::ALT_geoUnicast:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".geoUnicast");
single_value.field_geoUnicast->log_match(match_value.geoUnicast(), legacy);
} else {
TTCN_Logger::log_event_str("{ geoUnicast := ");
single_value.field_geoUnicast->log_match(match_value.geoUnicast(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case UtGnTrigger::ALT_geoBroadcast:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".geoBroadcast");
single_value.field_geoBroadcast->log_match(match_value.geoBroadcast(), legacy);
} else {
TTCN_Logger::log_event_str("{ geoBroadcast := ");
single_value.field_geoBroadcast->log_match(match_value.geoBroadcast(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case UtGnTrigger::ALT_geoAnycast:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".geoAnycast");
single_value.field_geoAnycast->log_match(match_value.geoAnycast(), legacy);
} else {
TTCN_Logger::log_event_str("{ geoAnycast := ");
single_value.field_geoAnycast->log_match(match_value.geoAnycast(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case UtGnTrigger::ALT_shb:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".shb");
single_value.field_shb->log_match(match_value.shb(), legacy);
} else {
TTCN_Logger::log_event_str("{ shb := ");
single_value.field_shb->log_match(match_value.shb(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case UtGnTrigger::ALT_tsb:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".tsb");
single_value.field_tsb->log_match(match_value.tsb(), legacy);
} else {
TTCN_Logger::log_event_str("{ tsb := ");
single_value.field_tsb->log_match(match_value.tsb(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void UtGnTrigger_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case UtGnTrigger::ALT_geoUnicast:
single_value.field_geoUnicast->encode_text(text_buf);
break;
case UtGnTrigger::ALT_geoBroadcast:
single_value.field_geoBroadcast->encode_text(text_buf);
break;
case UtGnTrigger::ALT_geoAnycast:
single_value.field_geoAnycast->encode_text(text_buf);
break;
case UtGnTrigger::ALT_shb:
single_value.field_shb->encode_text(text_buf);
break;
case UtGnTrigger::ALT_tsb:
single_value.field_tsb->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
}
}

void UtGnTrigger_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = UtGnTrigger::UNBOUND_VALUE;
UtGnTrigger::union_selection_type new_selection = (UtGnTrigger::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case UtGnTrigger::ALT_geoUnicast:
single_value.field_geoUnicast = new GenerateGeoUnicastMessage_template;
single_value.field_geoUnicast->decode_text(text_buf);
break;
case UtGnTrigger::ALT_geoBroadcast:
single_value.field_geoBroadcast = new GenerateGeoBroadcastMessage_template;
single_value.field_geoBroadcast->decode_text(text_buf);
break;
case UtGnTrigger::ALT_geoAnycast:
single_value.field_geoAnycast = new GenerateGeoBroadcastMessage_template;
single_value.field_geoAnycast->decode_text(text_buf);
break;
case UtGnTrigger::ALT_shb:
single_value.field_shb = new GenerateSHBMessage_template;
single_value.field_shb->decode_text(text_buf);
break;
case UtGnTrigger::ALT_tsb:
single_value.field_tsb = new GenerateTSBMessage_template;
single_value.field_tsb->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new UtGnTrigger_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
}
}

boolean UtGnTrigger_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean UtGnTrigger_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void UtGnTrigger_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsGeoNetworking_TypesAndValues.UtGnTrigger'");
    }
    if (strcmp("geoUnicast", param_field) == 0) {
      geoUnicast().set_param(param);
      return;
    } else if (strcmp("geoBroadcast", param_field) == 0) {
      geoBroadcast().set_param(param);
      return;
    } else if (strcmp("geoAnycast", param_field) == 0) {
      geoAnycast().set_param(param);
      return;
    } else if (strcmp("shb", param_field) == 0) {
      shb().set_param(param);
      return;
    } else if (strcmp("tsb", param_field) == 0) {
      tsb().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsGeoNetworking_TypesAndValues.UtGnTrigger'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    UtGnTrigger_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsGeoNetworking_TypesAndValues.UtGnTrigger");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "geoUnicast")) {
      geoUnicast().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "geoBroadcast")) {
      geoBroadcast().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "geoAnycast")) {
      geoAnycast().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "shb")) {
      shb().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "tsb")) {
      tsb().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsGeoNetworking_TypesAndValues.UtGnTrigger");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* UtGnTrigger_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsGeoNetworking_TypesAndValues.UtGnTrigger'");
    }
    if (strcmp("geoUnicast", param_field) == 0) {
      return geoUnicast().get_param(param_name);
    } else if (strcmp("geoBroadcast", param_field) == 0) {
      return geoBroadcast().get_param(param_name);
    } else if (strcmp("geoAnycast", param_field) == 0) {
      return geoAnycast().get_param(param_name);
    } else if (strcmp("shb", param_field) == 0) {
      return shb().get_param(param_name);
    } else if (strcmp("tsb", param_field) == 0) {
      return tsb().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `UtGnTrigger'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case UtGnTrigger::ALT_geoUnicast:
      mp_field = single_value.field_geoUnicast->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("geoUnicast")));
      break;
    case UtGnTrigger::ALT_geoBroadcast:
      mp_field = single_value.field_geoBroadcast->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("geoBroadcast")));
      break;
    case UtGnTrigger::ALT_geoAnycast:
      mp_field = single_value.field_geoAnycast->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("geoAnycast")));
      break;
    case UtGnTrigger::ALT_shb:
      mp_field = single_value.field_shb->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("shb")));
      break;
    case UtGnTrigger::ALT_tsb:
      mp_field = single_value.field_tsb->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("tsb")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void UtGnTrigger_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case UtGnTrigger::ALT_geoUnicast:
single_value.field_geoUnicast->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.UtGnTrigger");
return;
case UtGnTrigger::ALT_geoBroadcast:
single_value.field_geoBroadcast->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.UtGnTrigger");
return;
case UtGnTrigger::ALT_geoAnycast:
single_value.field_geoAnycast->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.UtGnTrigger");
return;
case UtGnTrigger::ALT_shb:
single_value.field_shb->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.UtGnTrigger");
return;
case UtGnTrigger::ALT_tsb:
single_value.field_tsb->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.UtGnTrigger");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsGeoNetworking_TypesAndValues.UtGnTrigger.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.UtGnTrigger");
}

GenerateGeoUnicastMessage::GenerateGeoUnicastMessage()
{
  bound_flag = FALSE;
}

GenerateGeoUnicastMessage::GenerateGeoUnicastMessage(const GN__Address& par_gnAddress,
    const INTEGER& par_lifetime,
    const TrafficClass& par_trafficClass,
    const Payload& par_payload)
  :   field_gnAddress(par_gnAddress),
  field_lifetime(par_lifetime),
  field_trafficClass(par_trafficClass),
  field_payload(par_payload)
{
  bound_flag = TRUE;
}

GenerateGeoUnicastMessage::GenerateGeoUnicastMessage(const GenerateGeoUnicastMessage& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
bound_flag = TRUE;
if (other_value.gnAddress().is_bound()) field_gnAddress = other_value.gnAddress();
else field_gnAddress.clean_up();
if (other_value.lifetime().is_bound()) field_lifetime = other_value.lifetime();
else field_lifetime.clean_up();
if (other_value.trafficClass().is_bound()) field_trafficClass = other_value.trafficClass();
else field_trafficClass.clean_up();
if (other_value.payload().is_bound()) field_payload = other_value.payload();
else field_payload.clean_up();
}

void GenerateGeoUnicastMessage::clean_up()
{
field_gnAddress.clean_up();
field_lifetime.clean_up();
field_trafficClass.clean_up();
field_payload.clean_up();
bound_flag = FALSE;
}

GenerateGeoUnicastMessage& GenerateGeoUnicastMessage::operator=(const GenerateGeoUnicastMessage& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
  bound_flag = TRUE;
  if (other_value.gnAddress().is_bound()) field_gnAddress = other_value.gnAddress();
  else field_gnAddress.clean_up();
  if (other_value.lifetime().is_bound()) field_lifetime = other_value.lifetime();
  else field_lifetime.clean_up();
  if (other_value.trafficClass().is_bound()) field_trafficClass = other_value.trafficClass();
  else field_trafficClass.clean_up();
  if (other_value.payload().is_bound()) field_payload = other_value.payload();
  else field_payload.clean_up();
}
return *this;
}

boolean GenerateGeoUnicastMessage::operator==(const GenerateGeoUnicastMessage& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_gnAddress==other_value.field_gnAddress
  && field_lifetime==other_value.field_lifetime
  && field_trafficClass==other_value.field_trafficClass
  && field_payload==other_value.field_payload;
}

boolean GenerateGeoUnicastMessage::is_bound() const
{
if (bound_flag) return TRUE;
if(field_gnAddress.is_bound()) return TRUE;
if(field_lifetime.is_bound()) return TRUE;
if(field_trafficClass.is_bound()) return TRUE;
if(field_payload.is_bound()) return TRUE;
return FALSE;
}
boolean GenerateGeoUnicastMessage::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_gnAddress.is_value()) return FALSE;
if(!field_lifetime.is_value()) return FALSE;
if(!field_trafficClass.is_value()) return FALSE;
if(!field_payload.is_value()) return FALSE;
return TRUE;
}
int GenerateGeoUnicastMessage::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage");
  return 4;
}

void GenerateGeoUnicastMessage::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ gnAddress := ");
field_gnAddress.log();
TTCN_Logger::log_event_str(", lifetime := ");
field_lifetime.log();
TTCN_Logger::log_event_str(", trafficClass := ");
field_trafficClass.log();
TTCN_Logger::log_event_str(", payload := ");
field_payload.log();
TTCN_Logger::log_event_str(" }");
}

void GenerateGeoUnicastMessage::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage'");
    }
    if (strcmp("gnAddress", param_field) == 0) {
      gnAddress().set_param(param);
      return;
    } else if (strcmp("lifetime", param_field) == 0) {
      lifetime().set_param(param);
      return;
    } else if (strcmp("trafficClass", param_field) == 0) {
      trafficClass().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) gnAddress().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) lifetime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) trafficClass().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnAddress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnAddress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage");
  }
}

Module_Param* GenerateGeoUnicastMessage::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage'");
    }
    if (strcmp("gnAddress", param_field) == 0) {
      return gnAddress().get_param(param_name);
    } else if (strcmp("lifetime", param_field) == 0) {
      return lifetime().get_param(param_name);
    } else if (strcmp("trafficClass", param_field) == 0) {
      return trafficClass().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_gnAddress = field_gnAddress.get_param(param_name);
  mp_field_gnAddress->set_id(new Module_Param_FieldName(mcopystr("gnAddress")));
  mp->add_elem(mp_field_gnAddress);
  Module_Param* mp_field_lifetime = field_lifetime.get_param(param_name);
  mp_field_lifetime->set_id(new Module_Param_FieldName(mcopystr("lifetime")));
  mp->add_elem(mp_field_lifetime);
  Module_Param* mp_field_trafficClass = field_trafficClass.get_param(param_name);
  mp_field_trafficClass->set_id(new Module_Param_FieldName(mcopystr("trafficClass")));
  mp->add_elem(mp_field_trafficClass);
  Module_Param* mp_field_payload = field_payload.get_param(param_name);
  mp_field_payload->set_id(new Module_Param_FieldName(mcopystr("payload")));
  mp->add_elem(mp_field_payload);
  return mp;
  }

void GenerateGeoUnicastMessage::set_implicit_omit()
{
if (gnAddress().is_bound()) gnAddress().set_implicit_omit();
if (lifetime().is_bound()) lifetime().set_implicit_omit();
if (trafficClass().is_bound()) trafficClass().set_implicit_omit();
if (payload().is_bound()) payload().set_implicit_omit();
}

void GenerateGeoUnicastMessage::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
field_gnAddress.encode_text(text_buf);
field_lifetime.encode_text(text_buf);
field_trafficClass.encode_text(text_buf);
field_payload.encode_text(text_buf);
}

void GenerateGeoUnicastMessage::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_gnAddress.decode_text(text_buf);
field_lifetime.decode_text(text_buf);
field_trafficClass.decode_text(text_buf);
field_payload.decode_text(text_buf);
}

void GenerateGeoUnicastMessage::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GenerateGeoUnicastMessage::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GenerateGeoUnicastMessage::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_gnAddress.RAW_decode(GN__Address_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_lifetime.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_trafficClass.RAW_decode(TrafficClass_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_payload.RAW_decode(Payload_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GenerateGeoUnicastMessage::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 4;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(4);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, GN__Address_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, TrafficClass_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, Payload_descr_.raw);
  encoded_length += field_gnAddress.RAW_encode(GN__Address_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_lifetime.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_trafficClass.RAW_encode(TrafficClass_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_payload.RAW_encode(Payload_descr_, *myleaf.body.node.nodes[3]);
  return myleaf.length = encoded_length;
}

int GenerateGeoUnicastMessage::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnAddress");
    enc_len += field_gnAddress.JSON_encode(GN__Address_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lifetime");
    enc_len += field_lifetime.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "trafficClass");
    enc_len += field_trafficClass.JSON_encode(TrafficClass_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payload");
    enc_len += field_payload.JSON_encode(Payload_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GenerateGeoUnicastMessage::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (9 == name_len && 0 == strncmp(fld_name, "gnAddress", name_len)) {
         int ret_val = field_gnAddress.JSON_decode(GN__Address_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnAddress");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "lifetime", name_len)) {
         int ret_val = field_lifetime.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lifetime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "trafficClass", name_len)) {
         int ret_val = field_trafficClass.JSON_decode(TrafficClass_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "trafficClass");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "payload", name_len)) {
         int ret_val = field_payload.JSON_decode(Payload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "payload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_gnAddress.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnAddress");
    return JSON_ERROR_FATAL;
  }
if (!field_lifetime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "lifetime");
    return JSON_ERROR_FATAL;
  }
if (!field_trafficClass.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "trafficClass");
    return JSON_ERROR_FATAL;
  }
if (!field_payload.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "payload");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GenerateGeoUnicastMessage_template::single_value_struct {
GN__Address_template field_gnAddress;
INTEGER_template field_lifetime;
TrafficClass_template field_trafficClass;
Payload_template field_payload;
};

void GenerateGeoUnicastMessage_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_gnAddress = ANY_VALUE;
single_value->field_lifetime = ANY_VALUE;
single_value->field_trafficClass = ANY_VALUE;
single_value->field_payload = ANY_VALUE;
}
}
}

void GenerateGeoUnicastMessage_template::copy_value(const GenerateGeoUnicastMessage& other_value)
{
single_value = new single_value_struct;
if (other_value.gnAddress().is_bound()) {
  single_value->field_gnAddress = other_value.gnAddress();
} else {
  single_value->field_gnAddress.clean_up();
}
if (other_value.lifetime().is_bound()) {
  single_value->field_lifetime = other_value.lifetime();
} else {
  single_value->field_lifetime.clean_up();
}
if (other_value.trafficClass().is_bound()) {
  single_value->field_trafficClass = other_value.trafficClass();
} else {
  single_value->field_trafficClass.clean_up();
}
if (other_value.payload().is_bound()) {
  single_value->field_payload = other_value.payload();
} else {
  single_value->field_payload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GenerateGeoUnicastMessage_template::copy_template(const GenerateGeoUnicastMessage_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.gnAddress().get_selection()) {
single_value->field_gnAddress = other_value.gnAddress();
} else {
single_value->field_gnAddress.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lifetime().get_selection()) {
single_value->field_lifetime = other_value.lifetime();
} else {
single_value->field_lifetime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trafficClass().get_selection()) {
single_value->field_trafficClass = other_value.trafficClass();
} else {
single_value->field_trafficClass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload().get_selection()) {
single_value->field_payload = other_value.payload();
} else {
single_value->field_payload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GenerateGeoUnicastMessage_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
break;
}
set_selection(other_value);
}

GenerateGeoUnicastMessage_template::GenerateGeoUnicastMessage_template()
{
}

GenerateGeoUnicastMessage_template::GenerateGeoUnicastMessage_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GenerateGeoUnicastMessage_template::GenerateGeoUnicastMessage_template(const GenerateGeoUnicastMessage& other_value)
{
copy_value(other_value);
}

GenerateGeoUnicastMessage_template::GenerateGeoUnicastMessage_template(const OPTIONAL<GenerateGeoUnicastMessage>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GenerateGeoUnicastMessage&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage from an unbound optional field.");
}
}

GenerateGeoUnicastMessage_template::GenerateGeoUnicastMessage_template(const GenerateGeoUnicastMessage_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GenerateGeoUnicastMessage_template::~GenerateGeoUnicastMessage_template()
{
clean_up();
}

GenerateGeoUnicastMessage_template& GenerateGeoUnicastMessage_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GenerateGeoUnicastMessage_template& GenerateGeoUnicastMessage_template::operator=(const GenerateGeoUnicastMessage& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GenerateGeoUnicastMessage_template& GenerateGeoUnicastMessage_template::operator=(const OPTIONAL<GenerateGeoUnicastMessage>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GenerateGeoUnicastMessage&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
}
return *this;
}

GenerateGeoUnicastMessage_template& GenerateGeoUnicastMessage_template::operator=(const GenerateGeoUnicastMessage_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GenerateGeoUnicastMessage_template::match(const GenerateGeoUnicastMessage& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.gnAddress().is_bound()) return FALSE;
if(!single_value->field_gnAddress.match(other_value.gnAddress(), legacy))return FALSE;
if(!other_value.lifetime().is_bound()) return FALSE;
if(!single_value->field_lifetime.match(other_value.lifetime(), legacy))return FALSE;
if(!other_value.trafficClass().is_bound()) return FALSE;
if(!single_value->field_trafficClass.match(other_value.trafficClass(), legacy))return FALSE;
if(!other_value.payload().is_bound()) return FALSE;
if(!single_value->field_payload.match(other_value.payload(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
}
return FALSE;
}

boolean GenerateGeoUnicastMessage_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_gnAddress.is_bound()) return TRUE;
if (single_value->field_lifetime.is_bound()) return TRUE;
if (single_value->field_trafficClass.is_bound()) return TRUE;
if (single_value->field_payload.is_bound()) return TRUE;
return FALSE;
}

boolean GenerateGeoUnicastMessage_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_gnAddress.is_value()) return FALSE;
if (!single_value->field_lifetime.is_value()) return FALSE;
if (!single_value->field_trafficClass.is_value()) return FALSE;
if (!single_value->field_payload.is_value()) return FALSE;
return TRUE;
}

void GenerateGeoUnicastMessage_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GenerateGeoUnicastMessage GenerateGeoUnicastMessage_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
GenerateGeoUnicastMessage ret_val;
if (single_value->field_gnAddress.is_bound()) {
ret_val.gnAddress() = single_value->field_gnAddress.valueof();
}
if (single_value->field_lifetime.is_bound()) {
ret_val.lifetime() = single_value->field_lifetime.valueof();
}
if (single_value->field_trafficClass.is_bound()) {
ret_val.trafficClass() = single_value->field_trafficClass.valueof();
}
if (single_value->field_payload.is_bound()) {
ret_val.payload() = single_value->field_payload.valueof();
}
return ret_val;
}

void GenerateGeoUnicastMessage_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GenerateGeoUnicastMessage_template[list_length];
}

GenerateGeoUnicastMessage_template& GenerateGeoUnicastMessage_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
return value_list.list_value[list_index];
}

GN__Address_template& GenerateGeoUnicastMessage_template::gnAddress()
{
set_specific();
return single_value->field_gnAddress;
}

const GN__Address_template& GenerateGeoUnicastMessage_template::gnAddress() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnAddress of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
return single_value->field_gnAddress;
}

INTEGER_template& GenerateGeoUnicastMessage_template::lifetime()
{
set_specific();
return single_value->field_lifetime;
}

const INTEGER_template& GenerateGeoUnicastMessage_template::lifetime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lifetime of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
return single_value->field_lifetime;
}

TrafficClass_template& GenerateGeoUnicastMessage_template::trafficClass()
{
set_specific();
return single_value->field_trafficClass;
}

const TrafficClass_template& GenerateGeoUnicastMessage_template::trafficClass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trafficClass of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
return single_value->field_trafficClass;
}

Payload_template& GenerateGeoUnicastMessage_template::payload()
{
set_specific();
return single_value->field_payload;
}

const Payload_template& GenerateGeoUnicastMessage_template::payload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
return single_value->field_payload;
}

int GenerateGeoUnicastMessage_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 4;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
  }
  return 0;
}

void GenerateGeoUnicastMessage_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ gnAddress := ");
single_value->field_gnAddress.log();
TTCN_Logger::log_event_str(", lifetime := ");
single_value->field_lifetime.log();
TTCN_Logger::log_event_str(", trafficClass := ");
single_value->field_trafficClass.log();
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GenerateGeoUnicastMessage_template::log_match(const GenerateGeoUnicastMessage& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_gnAddress.match(match_value.gnAddress(), legacy)){
TTCN_Logger::log_logmatch_info(".gnAddress");
single_value->field_gnAddress.log_match(match_value.gnAddress(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_lifetime.match(match_value.lifetime(), legacy)){
TTCN_Logger::log_logmatch_info(".lifetime");
single_value->field_lifetime.log_match(match_value.lifetime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_trafficClass.match(match_value.trafficClass(), legacy)){
TTCN_Logger::log_logmatch_info(".trafficClass");
single_value->field_trafficClass.log_match(match_value.trafficClass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_payload.match(match_value.payload(), legacy)){
TTCN_Logger::log_logmatch_info(".payload");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ gnAddress := ");
single_value->field_gnAddress.log_match(match_value.gnAddress(), legacy);
TTCN_Logger::log_event_str(", lifetime := ");
single_value->field_lifetime.log_match(match_value.lifetime(), legacy);
TTCN_Logger::log_event_str(", trafficClass := ");
single_value->field_trafficClass.log_match(match_value.trafficClass(), legacy);
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GenerateGeoUnicastMessage_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_gnAddress.encode_text(text_buf);
single_value->field_lifetime.encode_text(text_buf);
single_value->field_trafficClass.encode_text(text_buf);
single_value->field_payload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
}
}

void GenerateGeoUnicastMessage_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_gnAddress.decode_text(text_buf);
single_value->field_lifetime.decode_text(text_buf);
single_value->field_trafficClass.decode_text(text_buf);
single_value->field_payload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GenerateGeoUnicastMessage_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage.");
}
}

void GenerateGeoUnicastMessage_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage'");
    }
    if (strcmp("gnAddress", param_field) == 0) {
      gnAddress().set_param(param);
      return;
    } else if (strcmp("lifetime", param_field) == 0) {
      lifetime().set_param(param);
      return;
    } else if (strcmp("trafficClass", param_field) == 0) {
      trafficClass().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GenerateGeoUnicastMessage_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) gnAddress().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) lifetime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) trafficClass().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnAddress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnAddress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GenerateGeoUnicastMessage_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage'");
    }
    if (strcmp("gnAddress", param_field) == 0) {
      return gnAddress().get_param(param_name);
    } else if (strcmp("lifetime", param_field) == 0) {
      return lifetime().get_param(param_name);
    } else if (strcmp("trafficClass", param_field) == 0) {
      return trafficClass().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_gnAddress = single_value->field_gnAddress.get_param(param_name);
    mp_field_gnAddress->set_id(new Module_Param_FieldName(mcopystr("gnAddress")));
    mp->add_elem(mp_field_gnAddress);
    Module_Param* mp_field_lifetime = single_value->field_lifetime.get_param(param_name);
    mp_field_lifetime->set_id(new Module_Param_FieldName(mcopystr("lifetime")));
    mp->add_elem(mp_field_lifetime);
    Module_Param* mp_field_trafficClass = single_value->field_trafficClass.get_param(param_name);
    mp_field_trafficClass->set_id(new Module_Param_FieldName(mcopystr("trafficClass")));
    mp->add_elem(mp_field_trafficClass);
    Module_Param* mp_field_payload = single_value->field_payload.get_param(param_name);
    mp_field_payload->set_id(new Module_Param_FieldName(mcopystr("payload")));
    mp->add_elem(mp_field_payload);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GenerateGeoUnicastMessage_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_gnAddress.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage");
single_value->field_lifetime.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage");
single_value->field_trafficClass.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage");
single_value->field_payload.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateGeoUnicastMessage");
}

boolean GenerateGeoUnicastMessage_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GenerateGeoUnicastMessage_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

GenerateGeoBroadcastMessage::GenerateGeoBroadcastMessage()
{
  bound_flag = FALSE;
}

GenerateGeoBroadcastMessage::GenerateGeoBroadcastMessage(const GeoShape& par_shape,
    const INTEGER& par_lifetime,
    const TrafficClass& par_trafficClass,
    const INTEGER& par_reserved,
    const Area& par_area,
    const Payload& par_payload)
  :   field_shape(par_shape),
  field_lifetime(par_lifetime),
  field_trafficClass(par_trafficClass),
  field_reserved(par_reserved),
  field_area(par_area),
  field_payload(par_payload)
{
  bound_flag = TRUE;
}

GenerateGeoBroadcastMessage::GenerateGeoBroadcastMessage(const GenerateGeoBroadcastMessage& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
bound_flag = TRUE;
if (other_value.shape().is_bound()) field_shape = other_value.shape();
else field_shape.clean_up();
if (other_value.lifetime().is_bound()) field_lifetime = other_value.lifetime();
else field_lifetime.clean_up();
if (other_value.trafficClass().is_bound()) field_trafficClass = other_value.trafficClass();
else field_trafficClass.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
if (other_value.area().is_bound()) field_area = other_value.area();
else field_area.clean_up();
if (other_value.payload().is_bound()) field_payload = other_value.payload();
else field_payload.clean_up();
}

void GenerateGeoBroadcastMessage::clean_up()
{
field_shape.clean_up();
field_lifetime.clean_up();
field_trafficClass.clean_up();
field_reserved.clean_up();
field_area.clean_up();
field_payload.clean_up();
bound_flag = FALSE;
}

GenerateGeoBroadcastMessage& GenerateGeoBroadcastMessage::operator=(const GenerateGeoBroadcastMessage& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
  bound_flag = TRUE;
  if (other_value.shape().is_bound()) field_shape = other_value.shape();
  else field_shape.clean_up();
  if (other_value.lifetime().is_bound()) field_lifetime = other_value.lifetime();
  else field_lifetime.clean_up();
  if (other_value.trafficClass().is_bound()) field_trafficClass = other_value.trafficClass();
  else field_trafficClass.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
  if (other_value.area().is_bound()) field_area = other_value.area();
  else field_area.clean_up();
  if (other_value.payload().is_bound()) field_payload = other_value.payload();
  else field_payload.clean_up();
}
return *this;
}

boolean GenerateGeoBroadcastMessage::operator==(const GenerateGeoBroadcastMessage& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_shape==other_value.field_shape
  && field_lifetime==other_value.field_lifetime
  && field_trafficClass==other_value.field_trafficClass
  && field_reserved==other_value.field_reserved
  && field_area==other_value.field_area
  && field_payload==other_value.field_payload;
}

boolean GenerateGeoBroadcastMessage::is_bound() const
{
if (bound_flag) return TRUE;
if(field_shape.is_bound()) return TRUE;
if(field_lifetime.is_bound()) return TRUE;
if(field_trafficClass.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
if(field_area.is_bound()) return TRUE;
if(field_payload.is_bound()) return TRUE;
return FALSE;
}
boolean GenerateGeoBroadcastMessage::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_shape.is_value()) return FALSE;
if(!field_lifetime.is_value()) return FALSE;
if(!field_trafficClass.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
if(!field_area.is_value()) return FALSE;
if(!field_payload.is_value()) return FALSE;
return TRUE;
}
int GenerateGeoBroadcastMessage::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage");
  return 6;
}

void GenerateGeoBroadcastMessage::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ shape := ");
field_shape.log();
TTCN_Logger::log_event_str(", lifetime := ");
field_lifetime.log();
TTCN_Logger::log_event_str(", trafficClass := ");
field_trafficClass.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(", area := ");
field_area.log();
TTCN_Logger::log_event_str(", payload := ");
field_payload.log();
TTCN_Logger::log_event_str(" }");
}

void GenerateGeoBroadcastMessage::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage'");
    }
    if (strcmp("shape", param_field) == 0) {
      shape().set_param(param);
      return;
    } else if (strcmp("lifetime", param_field) == 0) {
      lifetime().set_param(param);
      return;
    } else if (strcmp("trafficClass", param_field) == 0) {
      trafficClass().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("area", param_field) == 0) {
      area().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) shape().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) lifetime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) trafficClass().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) area().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "shape")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          shape().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "area")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          area().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage");
  }
}

Module_Param* GenerateGeoBroadcastMessage::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage'");
    }
    if (strcmp("shape", param_field) == 0) {
      return shape().get_param(param_name);
    } else if (strcmp("lifetime", param_field) == 0) {
      return lifetime().get_param(param_name);
    } else if (strcmp("trafficClass", param_field) == 0) {
      return trafficClass().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("area", param_field) == 0) {
      return area().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_shape = field_shape.get_param(param_name);
  mp_field_shape->set_id(new Module_Param_FieldName(mcopystr("shape")));
  mp->add_elem(mp_field_shape);
  Module_Param* mp_field_lifetime = field_lifetime.get_param(param_name);
  mp_field_lifetime->set_id(new Module_Param_FieldName(mcopystr("lifetime")));
  mp->add_elem(mp_field_lifetime);
  Module_Param* mp_field_trafficClass = field_trafficClass.get_param(param_name);
  mp_field_trafficClass->set_id(new Module_Param_FieldName(mcopystr("trafficClass")));
  mp->add_elem(mp_field_trafficClass);
  Module_Param* mp_field_reserved = field_reserved.get_param(param_name);
  mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
  mp->add_elem(mp_field_reserved);
  Module_Param* mp_field_area = field_area.get_param(param_name);
  mp_field_area->set_id(new Module_Param_FieldName(mcopystr("area")));
  mp->add_elem(mp_field_area);
  Module_Param* mp_field_payload = field_payload.get_param(param_name);
  mp_field_payload->set_id(new Module_Param_FieldName(mcopystr("payload")));
  mp->add_elem(mp_field_payload);
  return mp;
  }

void GenerateGeoBroadcastMessage::set_implicit_omit()
{
if (shape().is_bound()) shape().set_implicit_omit();
if (lifetime().is_bound()) lifetime().set_implicit_omit();
if (trafficClass().is_bound()) trafficClass().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
if (area().is_bound()) area().set_implicit_omit();
if (payload().is_bound()) payload().set_implicit_omit();
}

void GenerateGeoBroadcastMessage::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
field_shape.encode_text(text_buf);
field_lifetime.encode_text(text_buf);
field_trafficClass.encode_text(text_buf);
field_reserved.encode_text(text_buf);
field_area.encode_text(text_buf);
field_payload.encode_text(text_buf);
}

void GenerateGeoBroadcastMessage::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_shape.decode_text(text_buf);
field_lifetime.decode_text(text_buf);
field_trafficClass.decode_text(text_buf);
field_reserved.decode_text(text_buf);
field_area.decode_text(text_buf);
field_payload.decode_text(text_buf);
}

void GenerateGeoBroadcastMessage::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GenerateGeoBroadcastMessage::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GenerateGeoBroadcastMessage::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_shape.RAW_decode(GeoShape_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_lifetime.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_trafficClass.RAW_decode(TrafficClass_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved.RAW_decode(LibCommon__BasicTypesAndValues::UInt24_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_area.RAW_decode(Area_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_payload.RAW_decode(Payload_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GenerateGeoBroadcastMessage::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 6;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(6);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, GeoShape_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, TrafficClass_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, LibCommon__BasicTypesAndValues::UInt24_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, Area_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, Payload_descr_.raw);
  encoded_length += field_shape.RAW_encode(GeoShape_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_lifetime.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_trafficClass.RAW_encode(TrafficClass_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_reserved.RAW_encode(LibCommon__BasicTypesAndValues::UInt24_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_area.RAW_encode(Area_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_payload.RAW_encode(Payload_descr_, *myleaf.body.node.nodes[5]);
  return myleaf.length = encoded_length;
}

int GenerateGeoBroadcastMessage::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "shape");
    enc_len += field_shape.JSON_encode(GeoShape_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lifetime");
    enc_len += field_lifetime.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "trafficClass");
    enc_len += field_trafficClass.JSON_encode(TrafficClass_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(LibCommon__BasicTypesAndValues::UInt24_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "area");
    enc_len += field_area.JSON_encode(Area_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payload");
    enc_len += field_payload.JSON_encode(Payload_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GenerateGeoBroadcastMessage::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (5 == name_len && 0 == strncmp(fld_name, "shape", name_len)) {
         int ret_val = field_shape.JSON_decode(GeoShape_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "shape");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "lifetime", name_len)) {
         int ret_val = field_lifetime.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lifetime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "trafficClass", name_len)) {
         int ret_val = field_trafficClass.JSON_decode(TrafficClass_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "trafficClass");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
         int ret_val = field_reserved.JSON_decode(LibCommon__BasicTypesAndValues::UInt24_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (4 == name_len && 0 == strncmp(fld_name, "area", name_len)) {
         int ret_val = field_area.JSON_decode(Area_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "area");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "payload", name_len)) {
         int ret_val = field_payload.JSON_decode(Payload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "payload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_shape.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "shape");
    return JSON_ERROR_FATAL;
  }
if (!field_lifetime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "lifetime");
    return JSON_ERROR_FATAL;
  }
if (!field_trafficClass.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "trafficClass");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }
if (!field_area.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "area");
    return JSON_ERROR_FATAL;
  }
if (!field_payload.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "payload");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GenerateGeoBroadcastMessage_template::single_value_struct {
GeoShape_template field_shape;
INTEGER_template field_lifetime;
TrafficClass_template field_trafficClass;
INTEGER_template field_reserved;
Area_template field_area;
Payload_template field_payload;
};

void GenerateGeoBroadcastMessage_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_shape = ANY_VALUE;
single_value->field_lifetime = ANY_VALUE;
single_value->field_trafficClass = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
single_value->field_area = ANY_VALUE;
single_value->field_payload = ANY_VALUE;
}
}
}

void GenerateGeoBroadcastMessage_template::copy_value(const GenerateGeoBroadcastMessage& other_value)
{
single_value = new single_value_struct;
if (other_value.shape().is_bound()) {
  single_value->field_shape = other_value.shape();
} else {
  single_value->field_shape.clean_up();
}
if (other_value.lifetime().is_bound()) {
  single_value->field_lifetime = other_value.lifetime();
} else {
  single_value->field_lifetime.clean_up();
}
if (other_value.trafficClass().is_bound()) {
  single_value->field_trafficClass = other_value.trafficClass();
} else {
  single_value->field_trafficClass.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
if (other_value.area().is_bound()) {
  single_value->field_area = other_value.area();
} else {
  single_value->field_area.clean_up();
}
if (other_value.payload().is_bound()) {
  single_value->field_payload = other_value.payload();
} else {
  single_value->field_payload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GenerateGeoBroadcastMessage_template::copy_template(const GenerateGeoBroadcastMessage_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.shape().get_selection()) {
single_value->field_shape = other_value.shape();
} else {
single_value->field_shape.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lifetime().get_selection()) {
single_value->field_lifetime = other_value.lifetime();
} else {
single_value->field_lifetime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trafficClass().get_selection()) {
single_value->field_trafficClass = other_value.trafficClass();
} else {
single_value->field_trafficClass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.area().get_selection()) {
single_value->field_area = other_value.area();
} else {
single_value->field_area.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload().get_selection()) {
single_value->field_payload = other_value.payload();
} else {
single_value->field_payload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GenerateGeoBroadcastMessage_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
break;
}
set_selection(other_value);
}

GenerateGeoBroadcastMessage_template::GenerateGeoBroadcastMessage_template()
{
}

GenerateGeoBroadcastMessage_template::GenerateGeoBroadcastMessage_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GenerateGeoBroadcastMessage_template::GenerateGeoBroadcastMessage_template(const GenerateGeoBroadcastMessage& other_value)
{
copy_value(other_value);
}

GenerateGeoBroadcastMessage_template::GenerateGeoBroadcastMessage_template(const OPTIONAL<GenerateGeoBroadcastMessage>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GenerateGeoBroadcastMessage&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage from an unbound optional field.");
}
}

GenerateGeoBroadcastMessage_template::GenerateGeoBroadcastMessage_template(const GenerateGeoBroadcastMessage_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GenerateGeoBroadcastMessage_template::~GenerateGeoBroadcastMessage_template()
{
clean_up();
}

GenerateGeoBroadcastMessage_template& GenerateGeoBroadcastMessage_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GenerateGeoBroadcastMessage_template& GenerateGeoBroadcastMessage_template::operator=(const GenerateGeoBroadcastMessage& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GenerateGeoBroadcastMessage_template& GenerateGeoBroadcastMessage_template::operator=(const OPTIONAL<GenerateGeoBroadcastMessage>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GenerateGeoBroadcastMessage&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
}
return *this;
}

GenerateGeoBroadcastMessage_template& GenerateGeoBroadcastMessage_template::operator=(const GenerateGeoBroadcastMessage_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GenerateGeoBroadcastMessage_template::match(const GenerateGeoBroadcastMessage& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.shape().is_bound()) return FALSE;
if(!single_value->field_shape.match(other_value.shape(), legacy))return FALSE;
if(!other_value.lifetime().is_bound()) return FALSE;
if(!single_value->field_lifetime.match(other_value.lifetime(), legacy))return FALSE;
if(!other_value.trafficClass().is_bound()) return FALSE;
if(!single_value->field_trafficClass.match(other_value.trafficClass(), legacy))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved(), legacy))return FALSE;
if(!other_value.area().is_bound()) return FALSE;
if(!single_value->field_area.match(other_value.area(), legacy))return FALSE;
if(!other_value.payload().is_bound()) return FALSE;
if(!single_value->field_payload.match(other_value.payload(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
}
return FALSE;
}

boolean GenerateGeoBroadcastMessage_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_shape.is_bound()) return TRUE;
if (single_value->field_lifetime.is_bound()) return TRUE;
if (single_value->field_trafficClass.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
if (single_value->field_area.is_bound()) return TRUE;
if (single_value->field_payload.is_bound()) return TRUE;
return FALSE;
}

boolean GenerateGeoBroadcastMessage_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_shape.is_value()) return FALSE;
if (!single_value->field_lifetime.is_value()) return FALSE;
if (!single_value->field_trafficClass.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
if (!single_value->field_area.is_value()) return FALSE;
if (!single_value->field_payload.is_value()) return FALSE;
return TRUE;
}

void GenerateGeoBroadcastMessage_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GenerateGeoBroadcastMessage GenerateGeoBroadcastMessage_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
GenerateGeoBroadcastMessage ret_val;
if (single_value->field_shape.is_bound()) {
ret_val.shape() = single_value->field_shape.valueof();
}
if (single_value->field_lifetime.is_bound()) {
ret_val.lifetime() = single_value->field_lifetime.valueof();
}
if (single_value->field_trafficClass.is_bound()) {
ret_val.trafficClass() = single_value->field_trafficClass.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
if (single_value->field_area.is_bound()) {
ret_val.area() = single_value->field_area.valueof();
}
if (single_value->field_payload.is_bound()) {
ret_val.payload() = single_value->field_payload.valueof();
}
return ret_val;
}

void GenerateGeoBroadcastMessage_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GenerateGeoBroadcastMessage_template[list_length];
}

GenerateGeoBroadcastMessage_template& GenerateGeoBroadcastMessage_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
return value_list.list_value[list_index];
}

GeoShape_template& GenerateGeoBroadcastMessage_template::shape()
{
set_specific();
return single_value->field_shape;
}

const GeoShape_template& GenerateGeoBroadcastMessage_template::shape() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field shape of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
return single_value->field_shape;
}

INTEGER_template& GenerateGeoBroadcastMessage_template::lifetime()
{
set_specific();
return single_value->field_lifetime;
}

const INTEGER_template& GenerateGeoBroadcastMessage_template::lifetime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lifetime of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
return single_value->field_lifetime;
}

TrafficClass_template& GenerateGeoBroadcastMessage_template::trafficClass()
{
set_specific();
return single_value->field_trafficClass;
}

const TrafficClass_template& GenerateGeoBroadcastMessage_template::trafficClass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trafficClass of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
return single_value->field_trafficClass;
}

INTEGER_template& GenerateGeoBroadcastMessage_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const INTEGER_template& GenerateGeoBroadcastMessage_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
return single_value->field_reserved;
}

Area_template& GenerateGeoBroadcastMessage_template::area()
{
set_specific();
return single_value->field_area;
}

const Area_template& GenerateGeoBroadcastMessage_template::area() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field area of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
return single_value->field_area;
}

Payload_template& GenerateGeoBroadcastMessage_template::payload()
{
set_specific();
return single_value->field_payload;
}

const Payload_template& GenerateGeoBroadcastMessage_template::payload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
return single_value->field_payload;
}

int GenerateGeoBroadcastMessage_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 6;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
  }
  return 0;
}

void GenerateGeoBroadcastMessage_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ shape := ");
single_value->field_shape.log();
TTCN_Logger::log_event_str(", lifetime := ");
single_value->field_lifetime.log();
TTCN_Logger::log_event_str(", trafficClass := ");
single_value->field_trafficClass.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(", area := ");
single_value->field_area.log();
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GenerateGeoBroadcastMessage_template::log_match(const GenerateGeoBroadcastMessage& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_shape.match(match_value.shape(), legacy)){
TTCN_Logger::log_logmatch_info(".shape");
single_value->field_shape.log_match(match_value.shape(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_lifetime.match(match_value.lifetime(), legacy)){
TTCN_Logger::log_logmatch_info(".lifetime");
single_value->field_lifetime.log_match(match_value.lifetime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_trafficClass.match(match_value.trafficClass(), legacy)){
TTCN_Logger::log_logmatch_info(".trafficClass");
single_value->field_trafficClass.log_match(match_value.trafficClass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_area.match(match_value.area(), legacy)){
TTCN_Logger::log_logmatch_info(".area");
single_value->field_area.log_match(match_value.area(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_payload.match(match_value.payload(), legacy)){
TTCN_Logger::log_logmatch_info(".payload");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ shape := ");
single_value->field_shape.log_match(match_value.shape(), legacy);
TTCN_Logger::log_event_str(", lifetime := ");
single_value->field_lifetime.log_match(match_value.lifetime(), legacy);
TTCN_Logger::log_event_str(", trafficClass := ");
single_value->field_trafficClass.log_match(match_value.trafficClass(), legacy);
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::log_event_str(", area := ");
single_value->field_area.log_match(match_value.area(), legacy);
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GenerateGeoBroadcastMessage_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_shape.encode_text(text_buf);
single_value->field_lifetime.encode_text(text_buf);
single_value->field_trafficClass.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
single_value->field_area.encode_text(text_buf);
single_value->field_payload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
}
}

void GenerateGeoBroadcastMessage_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_shape.decode_text(text_buf);
single_value->field_lifetime.decode_text(text_buf);
single_value->field_trafficClass.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
single_value->field_area.decode_text(text_buf);
single_value->field_payload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GenerateGeoBroadcastMessage_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage.");
}
}

void GenerateGeoBroadcastMessage_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage'");
    }
    if (strcmp("shape", param_field) == 0) {
      shape().set_param(param);
      return;
    } else if (strcmp("lifetime", param_field) == 0) {
      lifetime().set_param(param);
      return;
    } else if (strcmp("trafficClass", param_field) == 0) {
      trafficClass().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("area", param_field) == 0) {
      area().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GenerateGeoBroadcastMessage_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) shape().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) lifetime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) trafficClass().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) area().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "shape")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          shape().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "area")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          area().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GenerateGeoBroadcastMessage_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage'");
    }
    if (strcmp("shape", param_field) == 0) {
      return shape().get_param(param_name);
    } else if (strcmp("lifetime", param_field) == 0) {
      return lifetime().get_param(param_name);
    } else if (strcmp("trafficClass", param_field) == 0) {
      return trafficClass().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("area", param_field) == 0) {
      return area().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_shape = single_value->field_shape.get_param(param_name);
    mp_field_shape->set_id(new Module_Param_FieldName(mcopystr("shape")));
    mp->add_elem(mp_field_shape);
    Module_Param* mp_field_lifetime = single_value->field_lifetime.get_param(param_name);
    mp_field_lifetime->set_id(new Module_Param_FieldName(mcopystr("lifetime")));
    mp->add_elem(mp_field_lifetime);
    Module_Param* mp_field_trafficClass = single_value->field_trafficClass.get_param(param_name);
    mp_field_trafficClass->set_id(new Module_Param_FieldName(mcopystr("trafficClass")));
    mp->add_elem(mp_field_trafficClass);
    Module_Param* mp_field_reserved = single_value->field_reserved.get_param(param_name);
    mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
    mp->add_elem(mp_field_reserved);
    Module_Param* mp_field_area = single_value->field_area.get_param(param_name);
    mp_field_area->set_id(new Module_Param_FieldName(mcopystr("area")));
    mp->add_elem(mp_field_area);
    Module_Param* mp_field_payload = single_value->field_payload.get_param(param_name);
    mp_field_payload->set_id(new Module_Param_FieldName(mcopystr("payload")));
    mp->add_elem(mp_field_payload);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GenerateGeoBroadcastMessage_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_shape.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage");
single_value->field_lifetime.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage");
single_value->field_trafficClass.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage");
single_value->field_area.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage");
single_value->field_payload.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateGeoBroadcastMessage");
}

boolean GenerateGeoBroadcastMessage_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GenerateGeoBroadcastMessage_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

GenerateSHBMessage::GenerateSHBMessage()
{
  bound_flag = FALSE;
}

GenerateSHBMessage::GenerateSHBMessage(const TrafficClass& par_trafficClass,
    const Payload& par_payload)
  :   field_trafficClass(par_trafficClass),
  field_payload(par_payload)
{
  bound_flag = TRUE;
}

GenerateSHBMessage::GenerateSHBMessage(const GenerateSHBMessage& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage.");
bound_flag = TRUE;
if (other_value.trafficClass().is_bound()) field_trafficClass = other_value.trafficClass();
else field_trafficClass.clean_up();
if (other_value.payload().is_bound()) field_payload = other_value.payload();
else field_payload.clean_up();
}

void GenerateSHBMessage::clean_up()
{
field_trafficClass.clean_up();
field_payload.clean_up();
bound_flag = FALSE;
}

GenerateSHBMessage& GenerateSHBMessage::operator=(const GenerateSHBMessage& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage.");
  bound_flag = TRUE;
  if (other_value.trafficClass().is_bound()) field_trafficClass = other_value.trafficClass();
  else field_trafficClass.clean_up();
  if (other_value.payload().is_bound()) field_payload = other_value.payload();
  else field_payload.clean_up();
}
return *this;
}

boolean GenerateSHBMessage::operator==(const GenerateSHBMessage& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_trafficClass==other_value.field_trafficClass
  && field_payload==other_value.field_payload;
}

boolean GenerateSHBMessage::is_bound() const
{
if (bound_flag) return TRUE;
if(field_trafficClass.is_bound()) return TRUE;
if(field_payload.is_bound()) return TRUE;
return FALSE;
}
boolean GenerateSHBMessage::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_trafficClass.is_value()) return FALSE;
if(!field_payload.is_value()) return FALSE;
return TRUE;
}
int GenerateSHBMessage::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage");
  return 2;
}

void GenerateSHBMessage::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ trafficClass := ");
field_trafficClass.log();
TTCN_Logger::log_event_str(", payload := ");
field_payload.log();
TTCN_Logger::log_event_str(" }");
}

void GenerateSHBMessage::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage'");
    }
    if (strcmp("trafficClass", param_field) == 0) {
      trafficClass().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) trafficClass().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage");
  }
}

Module_Param* GenerateSHBMessage::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage'");
    }
    if (strcmp("trafficClass", param_field) == 0) {
      return trafficClass().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_trafficClass = field_trafficClass.get_param(param_name);
  mp_field_trafficClass->set_id(new Module_Param_FieldName(mcopystr("trafficClass")));
  mp->add_elem(mp_field_trafficClass);
  Module_Param* mp_field_payload = field_payload.get_param(param_name);
  mp_field_payload->set_id(new Module_Param_FieldName(mcopystr("payload")));
  mp->add_elem(mp_field_payload);
  return mp;
  }

void GenerateSHBMessage::set_implicit_omit()
{
if (trafficClass().is_bound()) trafficClass().set_implicit_omit();
if (payload().is_bound()) payload().set_implicit_omit();
}

void GenerateSHBMessage::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage.");
field_trafficClass.encode_text(text_buf);
field_payload.encode_text(text_buf);
}

void GenerateSHBMessage::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_trafficClass.decode_text(text_buf);
field_payload.decode_text(text_buf);
}

void GenerateSHBMessage::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GenerateSHBMessage::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GenerateSHBMessage::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_trafficClass.RAW_decode(TrafficClass_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_payload.RAW_decode(Payload_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GenerateSHBMessage::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, TrafficClass_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, Payload_descr_.raw);
  encoded_length += field_trafficClass.RAW_encode(TrafficClass_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_payload.RAW_encode(Payload_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int GenerateSHBMessage::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "trafficClass");
    enc_len += field_trafficClass.JSON_encode(TrafficClass_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payload");
    enc_len += field_payload.JSON_encode(Payload_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GenerateSHBMessage::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "trafficClass", name_len)) {
         int ret_val = field_trafficClass.JSON_decode(TrafficClass_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "trafficClass");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "payload", name_len)) {
         int ret_val = field_payload.JSON_decode(Payload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "payload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_trafficClass.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "trafficClass");
    return JSON_ERROR_FATAL;
  }
if (!field_payload.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "payload");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GenerateSHBMessage_template::single_value_struct {
TrafficClass_template field_trafficClass;
Payload_template field_payload;
};

void GenerateSHBMessage_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_trafficClass = ANY_VALUE;
single_value->field_payload = ANY_VALUE;
}
}
}

void GenerateSHBMessage_template::copy_value(const GenerateSHBMessage& other_value)
{
single_value = new single_value_struct;
if (other_value.trafficClass().is_bound()) {
  single_value->field_trafficClass = other_value.trafficClass();
} else {
  single_value->field_trafficClass.clean_up();
}
if (other_value.payload().is_bound()) {
  single_value->field_payload = other_value.payload();
} else {
  single_value->field_payload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GenerateSHBMessage_template::copy_template(const GenerateSHBMessage_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.trafficClass().get_selection()) {
single_value->field_trafficClass = other_value.trafficClass();
} else {
single_value->field_trafficClass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload().get_selection()) {
single_value->field_payload = other_value.payload();
} else {
single_value->field_payload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GenerateSHBMessage_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage.");
break;
}
set_selection(other_value);
}

GenerateSHBMessage_template::GenerateSHBMessage_template()
{
}

GenerateSHBMessage_template::GenerateSHBMessage_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GenerateSHBMessage_template::GenerateSHBMessage_template(const GenerateSHBMessage& other_value)
{
copy_value(other_value);
}

GenerateSHBMessage_template::GenerateSHBMessage_template(const OPTIONAL<GenerateSHBMessage>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GenerateSHBMessage&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage from an unbound optional field.");
}
}

GenerateSHBMessage_template::GenerateSHBMessage_template(const GenerateSHBMessage_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GenerateSHBMessage_template::~GenerateSHBMessage_template()
{
clean_up();
}

GenerateSHBMessage_template& GenerateSHBMessage_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GenerateSHBMessage_template& GenerateSHBMessage_template::operator=(const GenerateSHBMessage& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GenerateSHBMessage_template& GenerateSHBMessage_template::operator=(const OPTIONAL<GenerateSHBMessage>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GenerateSHBMessage&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage.");
}
return *this;
}

GenerateSHBMessage_template& GenerateSHBMessage_template::operator=(const GenerateSHBMessage_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GenerateSHBMessage_template::match(const GenerateSHBMessage& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.trafficClass().is_bound()) return FALSE;
if(!single_value->field_trafficClass.match(other_value.trafficClass(), legacy))return FALSE;
if(!other_value.payload().is_bound()) return FALSE;
if(!single_value->field_payload.match(other_value.payload(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage.");
}
return FALSE;
}

boolean GenerateSHBMessage_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_trafficClass.is_bound()) return TRUE;
if (single_value->field_payload.is_bound()) return TRUE;
return FALSE;
}

boolean GenerateSHBMessage_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_trafficClass.is_value()) return FALSE;
if (!single_value->field_payload.is_value()) return FALSE;
return TRUE;
}

void GenerateSHBMessage_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GenerateSHBMessage GenerateSHBMessage_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage.");
GenerateSHBMessage ret_val;
if (single_value->field_trafficClass.is_bound()) {
ret_val.trafficClass() = single_value->field_trafficClass.valueof();
}
if (single_value->field_payload.is_bound()) {
ret_val.payload() = single_value->field_payload.valueof();
}
return ret_val;
}

void GenerateSHBMessage_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GenerateSHBMessage_template[list_length];
}

GenerateSHBMessage_template& GenerateSHBMessage_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage.");
return value_list.list_value[list_index];
}

TrafficClass_template& GenerateSHBMessage_template::trafficClass()
{
set_specific();
return single_value->field_trafficClass;
}

const TrafficClass_template& GenerateSHBMessage_template::trafficClass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trafficClass of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage.");
return single_value->field_trafficClass;
}

Payload_template& GenerateSHBMessage_template::payload()
{
set_specific();
return single_value->field_payload;
}

const Payload_template& GenerateSHBMessage_template::payload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage.");
return single_value->field_payload;
}

int GenerateSHBMessage_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage.");
  }
  return 0;
}

void GenerateSHBMessage_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ trafficClass := ");
single_value->field_trafficClass.log();
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GenerateSHBMessage_template::log_match(const GenerateSHBMessage& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_trafficClass.match(match_value.trafficClass(), legacy)){
TTCN_Logger::log_logmatch_info(".trafficClass");
single_value->field_trafficClass.log_match(match_value.trafficClass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_payload.match(match_value.payload(), legacy)){
TTCN_Logger::log_logmatch_info(".payload");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ trafficClass := ");
single_value->field_trafficClass.log_match(match_value.trafficClass(), legacy);
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GenerateSHBMessage_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_trafficClass.encode_text(text_buf);
single_value->field_payload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage.");
}
}

void GenerateSHBMessage_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_trafficClass.decode_text(text_buf);
single_value->field_payload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GenerateSHBMessage_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage.");
}
}

void GenerateSHBMessage_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage'");
    }
    if (strcmp("trafficClass", param_field) == 0) {
      trafficClass().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GenerateSHBMessage_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) trafficClass().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GenerateSHBMessage_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage'");
    }
    if (strcmp("trafficClass", param_field) == 0) {
      return trafficClass().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_trafficClass = single_value->field_trafficClass.get_param(param_name);
    mp_field_trafficClass->set_id(new Module_Param_FieldName(mcopystr("trafficClass")));
    mp->add_elem(mp_field_trafficClass);
    Module_Param* mp_field_payload = single_value->field_payload.get_param(param_name);
    mp_field_payload->set_id(new Module_Param_FieldName(mcopystr("payload")));
    mp->add_elem(mp_field_payload);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GenerateSHBMessage_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_trafficClass.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage");
single_value->field_payload.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateSHBMessage");
}

boolean GenerateSHBMessage_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GenerateSHBMessage_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

GenerateTSBMessage::GenerateTSBMessage()
{
  bound_flag = FALSE;
}

GenerateTSBMessage::GenerateTSBMessage(const INTEGER& par_nbHops,
    const INTEGER& par_lifetime,
    const TrafficClass& par_trafficClass,
    const Payload& par_payload)
  :   field_nbHops(par_nbHops),
  field_lifetime(par_lifetime),
  field_trafficClass(par_trafficClass),
  field_payload(par_payload)
{
  bound_flag = TRUE;
}

GenerateTSBMessage::GenerateTSBMessage(const GenerateTSBMessage& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
bound_flag = TRUE;
if (other_value.nbHops().is_bound()) field_nbHops = other_value.nbHops();
else field_nbHops.clean_up();
if (other_value.lifetime().is_bound()) field_lifetime = other_value.lifetime();
else field_lifetime.clean_up();
if (other_value.trafficClass().is_bound()) field_trafficClass = other_value.trafficClass();
else field_trafficClass.clean_up();
if (other_value.payload().is_bound()) field_payload = other_value.payload();
else field_payload.clean_up();
}

void GenerateTSBMessage::clean_up()
{
field_nbHops.clean_up();
field_lifetime.clean_up();
field_trafficClass.clean_up();
field_payload.clean_up();
bound_flag = FALSE;
}

GenerateTSBMessage& GenerateTSBMessage::operator=(const GenerateTSBMessage& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
  bound_flag = TRUE;
  if (other_value.nbHops().is_bound()) field_nbHops = other_value.nbHops();
  else field_nbHops.clean_up();
  if (other_value.lifetime().is_bound()) field_lifetime = other_value.lifetime();
  else field_lifetime.clean_up();
  if (other_value.trafficClass().is_bound()) field_trafficClass = other_value.trafficClass();
  else field_trafficClass.clean_up();
  if (other_value.payload().is_bound()) field_payload = other_value.payload();
  else field_payload.clean_up();
}
return *this;
}

boolean GenerateTSBMessage::operator==(const GenerateTSBMessage& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_nbHops==other_value.field_nbHops
  && field_lifetime==other_value.field_lifetime
  && field_trafficClass==other_value.field_trafficClass
  && field_payload==other_value.field_payload;
}

boolean GenerateTSBMessage::is_bound() const
{
if (bound_flag) return TRUE;
if(field_nbHops.is_bound()) return TRUE;
if(field_lifetime.is_bound()) return TRUE;
if(field_trafficClass.is_bound()) return TRUE;
if(field_payload.is_bound()) return TRUE;
return FALSE;
}
boolean GenerateTSBMessage::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_nbHops.is_value()) return FALSE;
if(!field_lifetime.is_value()) return FALSE;
if(!field_trafficClass.is_value()) return FALSE;
if(!field_payload.is_value()) return FALSE;
return TRUE;
}
int GenerateTSBMessage::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage");
  return 4;
}

void GenerateTSBMessage::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ nbHops := ");
field_nbHops.log();
TTCN_Logger::log_event_str(", lifetime := ");
field_lifetime.log();
TTCN_Logger::log_event_str(", trafficClass := ");
field_trafficClass.log();
TTCN_Logger::log_event_str(", payload := ");
field_payload.log();
TTCN_Logger::log_event_str(" }");
}

void GenerateTSBMessage::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage'");
    }
    if (strcmp("nbHops", param_field) == 0) {
      nbHops().set_param(param);
      return;
    } else if (strcmp("lifetime", param_field) == 0) {
      lifetime().set_param(param);
      return;
    } else if (strcmp("trafficClass", param_field) == 0) {
      trafficClass().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) nbHops().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) lifetime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) trafficClass().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nbHops")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nbHops().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage");
  }
}

Module_Param* GenerateTSBMessage::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage'");
    }
    if (strcmp("nbHops", param_field) == 0) {
      return nbHops().get_param(param_name);
    } else if (strcmp("lifetime", param_field) == 0) {
      return lifetime().get_param(param_name);
    } else if (strcmp("trafficClass", param_field) == 0) {
      return trafficClass().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_nbHops = field_nbHops.get_param(param_name);
  mp_field_nbHops->set_id(new Module_Param_FieldName(mcopystr("nbHops")));
  mp->add_elem(mp_field_nbHops);
  Module_Param* mp_field_lifetime = field_lifetime.get_param(param_name);
  mp_field_lifetime->set_id(new Module_Param_FieldName(mcopystr("lifetime")));
  mp->add_elem(mp_field_lifetime);
  Module_Param* mp_field_trafficClass = field_trafficClass.get_param(param_name);
  mp_field_trafficClass->set_id(new Module_Param_FieldName(mcopystr("trafficClass")));
  mp->add_elem(mp_field_trafficClass);
  Module_Param* mp_field_payload = field_payload.get_param(param_name);
  mp_field_payload->set_id(new Module_Param_FieldName(mcopystr("payload")));
  mp->add_elem(mp_field_payload);
  return mp;
  }

void GenerateTSBMessage::set_implicit_omit()
{
if (nbHops().is_bound()) nbHops().set_implicit_omit();
if (lifetime().is_bound()) lifetime().set_implicit_omit();
if (trafficClass().is_bound()) trafficClass().set_implicit_omit();
if (payload().is_bound()) payload().set_implicit_omit();
}

void GenerateTSBMessage::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
field_nbHops.encode_text(text_buf);
field_lifetime.encode_text(text_buf);
field_trafficClass.encode_text(text_buf);
field_payload.encode_text(text_buf);
}

void GenerateTSBMessage::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_nbHops.decode_text(text_buf);
field_lifetime.decode_text(text_buf);
field_trafficClass.decode_text(text_buf);
field_payload.decode_text(text_buf);
}

void GenerateTSBMessage::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GenerateTSBMessage::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GenerateTSBMessage::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_nbHops.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_lifetime.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_trafficClass.RAW_decode(TrafficClass_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_payload.RAW_decode(Payload_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GenerateTSBMessage::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 4;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(4);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, TrafficClass_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, Payload_descr_.raw);
  encoded_length += field_nbHops.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_lifetime.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_trafficClass.RAW_encode(TrafficClass_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_payload.RAW_encode(Payload_descr_, *myleaf.body.node.nodes[3]);
  return myleaf.length = encoded_length;
}

int GenerateTSBMessage::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "nbHops");
    enc_len += field_nbHops.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lifetime");
    enc_len += field_lifetime.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "trafficClass");
    enc_len += field_trafficClass.JSON_encode(TrafficClass_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payload");
    enc_len += field_payload.JSON_encode(Payload_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GenerateTSBMessage::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (6 == name_len && 0 == strncmp(fld_name, "nbHops", name_len)) {
         int ret_val = field_nbHops.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "nbHops");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "lifetime", name_len)) {
         int ret_val = field_lifetime.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lifetime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "trafficClass", name_len)) {
         int ret_val = field_trafficClass.JSON_decode(TrafficClass_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "trafficClass");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "payload", name_len)) {
         int ret_val = field_payload.JSON_decode(Payload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "payload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_nbHops.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "nbHops");
    return JSON_ERROR_FATAL;
  }
if (!field_lifetime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "lifetime");
    return JSON_ERROR_FATAL;
  }
if (!field_trafficClass.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "trafficClass");
    return JSON_ERROR_FATAL;
  }
if (!field_payload.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "payload");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GenerateTSBMessage_template::single_value_struct {
INTEGER_template field_nbHops;
INTEGER_template field_lifetime;
TrafficClass_template field_trafficClass;
Payload_template field_payload;
};

void GenerateTSBMessage_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_nbHops = ANY_VALUE;
single_value->field_lifetime = ANY_VALUE;
single_value->field_trafficClass = ANY_VALUE;
single_value->field_payload = ANY_VALUE;
}
}
}

void GenerateTSBMessage_template::copy_value(const GenerateTSBMessage& other_value)
{
single_value = new single_value_struct;
if (other_value.nbHops().is_bound()) {
  single_value->field_nbHops = other_value.nbHops();
} else {
  single_value->field_nbHops.clean_up();
}
if (other_value.lifetime().is_bound()) {
  single_value->field_lifetime = other_value.lifetime();
} else {
  single_value->field_lifetime.clean_up();
}
if (other_value.trafficClass().is_bound()) {
  single_value->field_trafficClass = other_value.trafficClass();
} else {
  single_value->field_trafficClass.clean_up();
}
if (other_value.payload().is_bound()) {
  single_value->field_payload = other_value.payload();
} else {
  single_value->field_payload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GenerateTSBMessage_template::copy_template(const GenerateTSBMessage_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.nbHops().get_selection()) {
single_value->field_nbHops = other_value.nbHops();
} else {
single_value->field_nbHops.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lifetime().get_selection()) {
single_value->field_lifetime = other_value.lifetime();
} else {
single_value->field_lifetime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trafficClass().get_selection()) {
single_value->field_trafficClass = other_value.trafficClass();
} else {
single_value->field_trafficClass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload().get_selection()) {
single_value->field_payload = other_value.payload();
} else {
single_value->field_payload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GenerateTSBMessage_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
break;
}
set_selection(other_value);
}

GenerateTSBMessage_template::GenerateTSBMessage_template()
{
}

GenerateTSBMessage_template::GenerateTSBMessage_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GenerateTSBMessage_template::GenerateTSBMessage_template(const GenerateTSBMessage& other_value)
{
copy_value(other_value);
}

GenerateTSBMessage_template::GenerateTSBMessage_template(const OPTIONAL<GenerateTSBMessage>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GenerateTSBMessage&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage from an unbound optional field.");
}
}

GenerateTSBMessage_template::GenerateTSBMessage_template(const GenerateTSBMessage_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GenerateTSBMessage_template::~GenerateTSBMessage_template()
{
clean_up();
}

GenerateTSBMessage_template& GenerateTSBMessage_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GenerateTSBMessage_template& GenerateTSBMessage_template::operator=(const GenerateTSBMessage& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GenerateTSBMessage_template& GenerateTSBMessage_template::operator=(const OPTIONAL<GenerateTSBMessage>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GenerateTSBMessage&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
}
return *this;
}

GenerateTSBMessage_template& GenerateTSBMessage_template::operator=(const GenerateTSBMessage_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GenerateTSBMessage_template::match(const GenerateTSBMessage& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.nbHops().is_bound()) return FALSE;
if(!single_value->field_nbHops.match(other_value.nbHops(), legacy))return FALSE;
if(!other_value.lifetime().is_bound()) return FALSE;
if(!single_value->field_lifetime.match(other_value.lifetime(), legacy))return FALSE;
if(!other_value.trafficClass().is_bound()) return FALSE;
if(!single_value->field_trafficClass.match(other_value.trafficClass(), legacy))return FALSE;
if(!other_value.payload().is_bound()) return FALSE;
if(!single_value->field_payload.match(other_value.payload(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
}
return FALSE;
}

boolean GenerateTSBMessage_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_nbHops.is_bound()) return TRUE;
if (single_value->field_lifetime.is_bound()) return TRUE;
if (single_value->field_trafficClass.is_bound()) return TRUE;
if (single_value->field_payload.is_bound()) return TRUE;
return FALSE;
}

boolean GenerateTSBMessage_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_nbHops.is_value()) return FALSE;
if (!single_value->field_lifetime.is_value()) return FALSE;
if (!single_value->field_trafficClass.is_value()) return FALSE;
if (!single_value->field_payload.is_value()) return FALSE;
return TRUE;
}

void GenerateTSBMessage_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GenerateTSBMessage GenerateTSBMessage_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
GenerateTSBMessage ret_val;
if (single_value->field_nbHops.is_bound()) {
ret_val.nbHops() = single_value->field_nbHops.valueof();
}
if (single_value->field_lifetime.is_bound()) {
ret_val.lifetime() = single_value->field_lifetime.valueof();
}
if (single_value->field_trafficClass.is_bound()) {
ret_val.trafficClass() = single_value->field_trafficClass.valueof();
}
if (single_value->field_payload.is_bound()) {
ret_val.payload() = single_value->field_payload.valueof();
}
return ret_val;
}

void GenerateTSBMessage_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GenerateTSBMessage_template[list_length];
}

GenerateTSBMessage_template& GenerateTSBMessage_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
return value_list.list_value[list_index];
}

INTEGER_template& GenerateTSBMessage_template::nbHops()
{
set_specific();
return single_value->field_nbHops;
}

const INTEGER_template& GenerateTSBMessage_template::nbHops() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field nbHops of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
return single_value->field_nbHops;
}

INTEGER_template& GenerateTSBMessage_template::lifetime()
{
set_specific();
return single_value->field_lifetime;
}

const INTEGER_template& GenerateTSBMessage_template::lifetime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lifetime of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
return single_value->field_lifetime;
}

TrafficClass_template& GenerateTSBMessage_template::trafficClass()
{
set_specific();
return single_value->field_trafficClass;
}

const TrafficClass_template& GenerateTSBMessage_template::trafficClass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trafficClass of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
return single_value->field_trafficClass;
}

Payload_template& GenerateTSBMessage_template::payload()
{
set_specific();
return single_value->field_payload;
}

const Payload_template& GenerateTSBMessage_template::payload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
return single_value->field_payload;
}

int GenerateTSBMessage_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 4;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
  }
  return 0;
}

void GenerateTSBMessage_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ nbHops := ");
single_value->field_nbHops.log();
TTCN_Logger::log_event_str(", lifetime := ");
single_value->field_lifetime.log();
TTCN_Logger::log_event_str(", trafficClass := ");
single_value->field_trafficClass.log();
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GenerateTSBMessage_template::log_match(const GenerateTSBMessage& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_nbHops.match(match_value.nbHops(), legacy)){
TTCN_Logger::log_logmatch_info(".nbHops");
single_value->field_nbHops.log_match(match_value.nbHops(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_lifetime.match(match_value.lifetime(), legacy)){
TTCN_Logger::log_logmatch_info(".lifetime");
single_value->field_lifetime.log_match(match_value.lifetime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_trafficClass.match(match_value.trafficClass(), legacy)){
TTCN_Logger::log_logmatch_info(".trafficClass");
single_value->field_trafficClass.log_match(match_value.trafficClass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_payload.match(match_value.payload(), legacy)){
TTCN_Logger::log_logmatch_info(".payload");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ nbHops := ");
single_value->field_nbHops.log_match(match_value.nbHops(), legacy);
TTCN_Logger::log_event_str(", lifetime := ");
single_value->field_lifetime.log_match(match_value.lifetime(), legacy);
TTCN_Logger::log_event_str(", trafficClass := ");
single_value->field_trafficClass.log_match(match_value.trafficClass(), legacy);
TTCN_Logger::log_event_str(", payload := ");
single_value->field_payload.log_match(match_value.payload(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GenerateTSBMessage_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_nbHops.encode_text(text_buf);
single_value->field_lifetime.encode_text(text_buf);
single_value->field_trafficClass.encode_text(text_buf);
single_value->field_payload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
}
}

void GenerateTSBMessage_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_nbHops.decode_text(text_buf);
single_value->field_lifetime.decode_text(text_buf);
single_value->field_trafficClass.decode_text(text_buf);
single_value->field_payload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GenerateTSBMessage_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage.");
}
}

void GenerateTSBMessage_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage'");
    }
    if (strcmp("nbHops", param_field) == 0) {
      nbHops().set_param(param);
      return;
    } else if (strcmp("lifetime", param_field) == 0) {
      lifetime().set_param(param);
      return;
    } else if (strcmp("trafficClass", param_field) == 0) {
      trafficClass().set_param(param);
      return;
    } else if (strcmp("payload", param_field) == 0) {
      payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GenerateTSBMessage_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) nbHops().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) lifetime().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) trafficClass().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) payload().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nbHops")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nbHops().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GenerateTSBMessage_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage'");
    }
    if (strcmp("nbHops", param_field) == 0) {
      return nbHops().get_param(param_name);
    } else if (strcmp("lifetime", param_field) == 0) {
      return lifetime().get_param(param_name);
    } else if (strcmp("trafficClass", param_field) == 0) {
      return trafficClass().get_param(param_name);
    } else if (strcmp("payload", param_field) == 0) {
      return payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_nbHops = single_value->field_nbHops.get_param(param_name);
    mp_field_nbHops->set_id(new Module_Param_FieldName(mcopystr("nbHops")));
    mp->add_elem(mp_field_nbHops);
    Module_Param* mp_field_lifetime = single_value->field_lifetime.get_param(param_name);
    mp_field_lifetime->set_id(new Module_Param_FieldName(mcopystr("lifetime")));
    mp->add_elem(mp_field_lifetime);
    Module_Param* mp_field_trafficClass = single_value->field_trafficClass.get_param(param_name);
    mp_field_trafficClass->set_id(new Module_Param_FieldName(mcopystr("trafficClass")));
    mp->add_elem(mp_field_trafficClass);
    Module_Param* mp_field_payload = single_value->field_payload.get_param(param_name);
    mp_field_payload->set_id(new Module_Param_FieldName(mcopystr("payload")));
    mp->add_elem(mp_field_payload);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GenerateTSBMessage_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_nbHops.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage");
single_value->field_lifetime.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage");
single_value->field_trafficClass.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage");
single_value->field_payload.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.GenerateTSBMessage");
}

boolean GenerateTSBMessage_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GenerateTSBMessage_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

UtGnTriggerResult::UtGnTriggerResult()
{
  bound_flag = FALSE;
}

UtGnTriggerResult::UtGnTriggerResult(const BOOLEAN& par_utGnTriggerResult)
  :   field_utGnTriggerResult(par_utGnTriggerResult)
{
  bound_flag = TRUE;
}

UtGnTriggerResult::UtGnTriggerResult(const UtGnTriggerResult& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult.");
bound_flag = TRUE;
if (other_value.utGnTriggerResult().is_bound()) field_utGnTriggerResult = other_value.utGnTriggerResult();
else field_utGnTriggerResult.clean_up();
}

void UtGnTriggerResult::clean_up()
{
field_utGnTriggerResult.clean_up();
bound_flag = FALSE;
}

UtGnTriggerResult& UtGnTriggerResult::operator=(const UtGnTriggerResult& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult.");
  bound_flag = TRUE;
  if (other_value.utGnTriggerResult().is_bound()) field_utGnTriggerResult = other_value.utGnTriggerResult();
  else field_utGnTriggerResult.clean_up();
}
return *this;
}

boolean UtGnTriggerResult::operator==(const UtGnTriggerResult& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_utGnTriggerResult==other_value.field_utGnTriggerResult;
}

boolean UtGnTriggerResult::is_bound() const
{
if (bound_flag) return TRUE;
if(field_utGnTriggerResult.is_bound()) return TRUE;
return FALSE;
}
boolean UtGnTriggerResult::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_utGnTriggerResult.is_value()) return FALSE;
return TRUE;
}
int UtGnTriggerResult::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult");
  return 1;
}

void UtGnTriggerResult::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ utGnTriggerResult := ");
field_utGnTriggerResult.log();
TTCN_Logger::log_event_str(" }");
}

void UtGnTriggerResult::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult'");
    }
    if (strcmp("utGnTriggerResult", param_field) == 0) {
      utGnTriggerResult().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) utGnTriggerResult().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "utGnTriggerResult")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          utGnTriggerResult().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult");
  }
}

Module_Param* UtGnTriggerResult::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult'");
    }
    if (strcmp("utGnTriggerResult", param_field) == 0) {
      return utGnTriggerResult().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_utGnTriggerResult = field_utGnTriggerResult.get_param(param_name);
  mp_field_utGnTriggerResult->set_id(new Module_Param_FieldName(mcopystr("utGnTriggerResult")));
  mp->add_elem(mp_field_utGnTriggerResult);
  return mp;
  }

void UtGnTriggerResult::set_implicit_omit()
{
if (utGnTriggerResult().is_bound()) utGnTriggerResult().set_implicit_omit();
}

void UtGnTriggerResult::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult.");
field_utGnTriggerResult.encode_text(text_buf);
}

void UtGnTriggerResult::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_utGnTriggerResult.decode_text(text_buf);
}

void UtGnTriggerResult::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void UtGnTriggerResult::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int UtGnTriggerResult::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_utGnTriggerResult.RAW_decode(BOOLEAN_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int UtGnTriggerResult::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, BOOLEAN_descr_.raw);
  encoded_length += field_utGnTriggerResult.RAW_encode(BOOLEAN_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int UtGnTriggerResult::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "utGnTriggerResult");
    enc_len += field_utGnTriggerResult.JSON_encode(BOOLEAN_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int UtGnTriggerResult::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (17 == name_len && 0 == strncmp(fld_name, "utGnTriggerResult", name_len)) {
         int ret_val = field_utGnTriggerResult.JSON_decode(BOOLEAN_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "utGnTriggerResult");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_utGnTriggerResult.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "utGnTriggerResult");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct UtGnTriggerResult_template::single_value_struct {
BOOLEAN_template field_utGnTriggerResult;
};

void UtGnTriggerResult_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_utGnTriggerResult = ANY_VALUE;
}
}
}

void UtGnTriggerResult_template::copy_value(const UtGnTriggerResult& other_value)
{
single_value = new single_value_struct;
if (other_value.utGnTriggerResult().is_bound()) {
  single_value->field_utGnTriggerResult = other_value.utGnTriggerResult();
} else {
  single_value->field_utGnTriggerResult.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void UtGnTriggerResult_template::copy_template(const UtGnTriggerResult_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.utGnTriggerResult().get_selection()) {
single_value->field_utGnTriggerResult = other_value.utGnTriggerResult();
} else {
single_value->field_utGnTriggerResult.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new UtGnTriggerResult_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult.");
break;
}
set_selection(other_value);
}

UtGnTriggerResult_template::UtGnTriggerResult_template()
{
}

UtGnTriggerResult_template::UtGnTriggerResult_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

UtGnTriggerResult_template::UtGnTriggerResult_template(const UtGnTriggerResult& other_value)
{
copy_value(other_value);
}

UtGnTriggerResult_template::UtGnTriggerResult_template(const OPTIONAL<UtGnTriggerResult>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtGnTriggerResult&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult from an unbound optional field.");
}
}

UtGnTriggerResult_template::UtGnTriggerResult_template(const UtGnTriggerResult_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

UtGnTriggerResult_template::~UtGnTriggerResult_template()
{
clean_up();
}

UtGnTriggerResult_template& UtGnTriggerResult_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

UtGnTriggerResult_template& UtGnTriggerResult_template::operator=(const UtGnTriggerResult& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

UtGnTriggerResult_template& UtGnTriggerResult_template::operator=(const OPTIONAL<UtGnTriggerResult>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtGnTriggerResult&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult.");
}
return *this;
}

UtGnTriggerResult_template& UtGnTriggerResult_template::operator=(const UtGnTriggerResult_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean UtGnTriggerResult_template::match(const UtGnTriggerResult& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.utGnTriggerResult().is_bound()) return FALSE;
if(!single_value->field_utGnTriggerResult.match(other_value.utGnTriggerResult(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult.");
}
return FALSE;
}

boolean UtGnTriggerResult_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_utGnTriggerResult.is_bound()) return TRUE;
return FALSE;
}

boolean UtGnTriggerResult_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_utGnTriggerResult.is_value()) return FALSE;
return TRUE;
}

void UtGnTriggerResult_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

UtGnTriggerResult UtGnTriggerResult_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult.");
UtGnTriggerResult ret_val;
if (single_value->field_utGnTriggerResult.is_bound()) {
ret_val.utGnTriggerResult() = single_value->field_utGnTriggerResult.valueof();
}
return ret_val;
}

void UtGnTriggerResult_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new UtGnTriggerResult_template[list_length];
}

UtGnTriggerResult_template& UtGnTriggerResult_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult.");
return value_list.list_value[list_index];
}

BOOLEAN_template& UtGnTriggerResult_template::utGnTriggerResult()
{
set_specific();
return single_value->field_utGnTriggerResult;
}

const BOOLEAN_template& UtGnTriggerResult_template::utGnTriggerResult() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field utGnTriggerResult of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult.");
return single_value->field_utGnTriggerResult;
}

int UtGnTriggerResult_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult.");
  }
  return 0;
}

void UtGnTriggerResult_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ utGnTriggerResult := ");
single_value->field_utGnTriggerResult.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void UtGnTriggerResult_template::log_match(const UtGnTriggerResult& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_utGnTriggerResult.match(match_value.utGnTriggerResult(), legacy)){
TTCN_Logger::log_logmatch_info(".utGnTriggerResult");
single_value->field_utGnTriggerResult.log_match(match_value.utGnTriggerResult(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ utGnTriggerResult := ");
single_value->field_utGnTriggerResult.log_match(match_value.utGnTriggerResult(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void UtGnTriggerResult_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_utGnTriggerResult.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult.");
}
}

void UtGnTriggerResult_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_utGnTriggerResult.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new UtGnTriggerResult_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult.");
}
}

void UtGnTriggerResult_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult'");
    }
    if (strcmp("utGnTriggerResult", param_field) == 0) {
      utGnTriggerResult().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    UtGnTriggerResult_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) utGnTriggerResult().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "utGnTriggerResult")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          utGnTriggerResult().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* UtGnTriggerResult_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult'");
    }
    if (strcmp("utGnTriggerResult", param_field) == 0) {
      return utGnTriggerResult().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_utGnTriggerResult = single_value->field_utGnTriggerResult.get_param(param_name);
    mp_field_utGnTriggerResult->set_id(new Module_Param_FieldName(mcopystr("utGnTriggerResult")));
    mp->add_elem(mp_field_utGnTriggerResult);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void UtGnTriggerResult_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_utGnTriggerResult.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.UtGnTriggerResult");
}

boolean UtGnTriggerResult_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean UtGnTriggerResult_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

UtGnEventInd::UtGnEventInd()
{
  bound_flag = FALSE;
}

UtGnEventInd::UtGnEventInd(const OCTETSTRING& par_rawPayload)
  :   field_rawPayload(par_rawPayload)
{
  bound_flag = TRUE;
}

UtGnEventInd::UtGnEventInd(const UtGnEventInd& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd.");
bound_flag = TRUE;
if (other_value.rawPayload().is_bound()) field_rawPayload = other_value.rawPayload();
else field_rawPayload.clean_up();
}

void UtGnEventInd::clean_up()
{
field_rawPayload.clean_up();
bound_flag = FALSE;
}

UtGnEventInd& UtGnEventInd::operator=(const UtGnEventInd& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd.");
  bound_flag = TRUE;
  if (other_value.rawPayload().is_bound()) field_rawPayload = other_value.rawPayload();
  else field_rawPayload.clean_up();
}
return *this;
}

boolean UtGnEventInd::operator==(const UtGnEventInd& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_rawPayload==other_value.field_rawPayload;
}

boolean UtGnEventInd::is_bound() const
{
if (bound_flag) return TRUE;
if(field_rawPayload.is_bound()) return TRUE;
return FALSE;
}
boolean UtGnEventInd::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_rawPayload.is_value()) return FALSE;
return TRUE;
}
int UtGnEventInd::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd");
  return 1;
}

void UtGnEventInd::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ rawPayload := ");
field_rawPayload.log();
TTCN_Logger::log_event_str(" }");
}

void UtGnEventInd::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.UtGnEventInd'");
    }
    if (strcmp("rawPayload", param_field) == 0) {
      rawPayload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.UtGnEventInd'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) rawPayload().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.UtGnEventInd");
  }
}

Module_Param* UtGnEventInd::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.UtGnEventInd'");
    }
    if (strcmp("rawPayload", param_field) == 0) {
      return rawPayload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.UtGnEventInd'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_rawPayload = field_rawPayload.get_param(param_name);
  mp_field_rawPayload->set_id(new Module_Param_FieldName(mcopystr("rawPayload")));
  mp->add_elem(mp_field_rawPayload);
  return mp;
  }

void UtGnEventInd::set_implicit_omit()
{
if (rawPayload().is_bound()) rawPayload().set_implicit_omit();
}

void UtGnEventInd::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd.");
field_rawPayload.encode_text(text_buf);
}

void UtGnEventInd::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_rawPayload.decode_text(text_buf);
}

void UtGnEventInd::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void UtGnEventInd::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int UtGnEventInd::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_rawPayload.RAW_decode(GnRawPayload_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int UtGnEventInd::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, GnRawPayload_descr_.raw);
  encoded_length += field_rawPayload.RAW_encode(GnRawPayload_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int UtGnEventInd::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "rawPayload");
    enc_len += field_rawPayload.JSON_encode(GnRawPayload_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int UtGnEventInd::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (10 == name_len && 0 == strncmp(fld_name, "rawPayload", name_len)) {
         int ret_val = field_rawPayload.JSON_decode(GnRawPayload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "rawPayload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_rawPayload.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "rawPayload");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct UtGnEventInd_template::single_value_struct {
OCTETSTRING_template field_rawPayload;
};

void UtGnEventInd_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_rawPayload = ANY_VALUE;
}
}
}

void UtGnEventInd_template::copy_value(const UtGnEventInd& other_value)
{
single_value = new single_value_struct;
if (other_value.rawPayload().is_bound()) {
  single_value->field_rawPayload = other_value.rawPayload();
} else {
  single_value->field_rawPayload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void UtGnEventInd_template::copy_template(const UtGnEventInd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.rawPayload().get_selection()) {
single_value->field_rawPayload = other_value.rawPayload();
} else {
single_value->field_rawPayload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new UtGnEventInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd.");
break;
}
set_selection(other_value);
}

UtGnEventInd_template::UtGnEventInd_template()
{
}

UtGnEventInd_template::UtGnEventInd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

UtGnEventInd_template::UtGnEventInd_template(const UtGnEventInd& other_value)
{
copy_value(other_value);
}

UtGnEventInd_template::UtGnEventInd_template(const OPTIONAL<UtGnEventInd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtGnEventInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd from an unbound optional field.");
}
}

UtGnEventInd_template::UtGnEventInd_template(const UtGnEventInd_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

UtGnEventInd_template::~UtGnEventInd_template()
{
clean_up();
}

UtGnEventInd_template& UtGnEventInd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

UtGnEventInd_template& UtGnEventInd_template::operator=(const UtGnEventInd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

UtGnEventInd_template& UtGnEventInd_template::operator=(const OPTIONAL<UtGnEventInd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtGnEventInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd.");
}
return *this;
}

UtGnEventInd_template& UtGnEventInd_template::operator=(const UtGnEventInd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean UtGnEventInd_template::match(const UtGnEventInd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.rawPayload().is_bound()) return FALSE;
if(!single_value->field_rawPayload.match(other_value.rawPayload(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd.");
}
return FALSE;
}

boolean UtGnEventInd_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_rawPayload.is_bound()) return TRUE;
return FALSE;
}

boolean UtGnEventInd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_rawPayload.is_value()) return FALSE;
return TRUE;
}

void UtGnEventInd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

UtGnEventInd UtGnEventInd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd.");
UtGnEventInd ret_val;
if (single_value->field_rawPayload.is_bound()) {
ret_val.rawPayload() = single_value->field_rawPayload.valueof();
}
return ret_val;
}

void UtGnEventInd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new UtGnEventInd_template[list_length];
}

UtGnEventInd_template& UtGnEventInd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd.");
return value_list.list_value[list_index];
}

OCTETSTRING_template& UtGnEventInd_template::rawPayload()
{
set_specific();
return single_value->field_rawPayload;
}

const OCTETSTRING_template& UtGnEventInd_template::rawPayload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rawPayload of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd.");
return single_value->field_rawPayload;
}

int UtGnEventInd_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd.");
  }
  return 0;
}

void UtGnEventInd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ rawPayload := ");
single_value->field_rawPayload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void UtGnEventInd_template::log_match(const UtGnEventInd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_rawPayload.match(match_value.rawPayload(), legacy)){
TTCN_Logger::log_logmatch_info(".rawPayload");
single_value->field_rawPayload.log_match(match_value.rawPayload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ rawPayload := ");
single_value->field_rawPayload.log_match(match_value.rawPayload(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void UtGnEventInd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_rawPayload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd.");
}
}

void UtGnEventInd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_rawPayload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new UtGnEventInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd.");
}
}

void UtGnEventInd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.UtGnEventInd'");
    }
    if (strcmp("rawPayload", param_field) == 0) {
      rawPayload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.UtGnEventInd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    UtGnEventInd_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) rawPayload().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawPayload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawPayload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.UtGnEventInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.UtGnEventInd");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* UtGnEventInd_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.UtGnEventInd'");
    }
    if (strcmp("rawPayload", param_field) == 0) {
      return rawPayload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.UtGnEventInd'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_rawPayload = single_value->field_rawPayload.get_param(param_name);
    mp_field_rawPayload->set_id(new Module_Param_FieldName(mcopystr("rawPayload")));
    mp->add_elem(mp_field_rawPayload);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void UtGnEventInd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_rawPayload.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.UtGnEventInd");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.UtGnEventInd");
}

boolean UtGnEventInd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean UtGnEventInd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const UtGnEventInd UtGnEventIndList::UNBOUND_ELEM;
UtGnEventIndList::UtGnEventIndList()
{
val_ptr = NULL;
}

UtGnEventIndList::UtGnEventIndList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

UtGnEventIndList::UtGnEventIndList(const UtGnEventIndList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

UtGnEventIndList::~UtGnEventIndList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void UtGnEventIndList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

UtGnEventIndList& UtGnEventIndList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

UtGnEventIndList& UtGnEventIndList::operator=(const UtGnEventIndList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean UtGnEventIndList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
return val_ptr->n_elements == 0 ;
}

boolean UtGnEventIndList::operator==(const UtGnEventIndList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

UtGnEventInd& UtGnEventIndList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (UtGnEventInd**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new UtGnEventInd(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new UtGnEventInd;
}
return *val_ptr->value_elements[index_value];
}

UtGnEventInd& UtGnEventIndList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
return (*this)[(int)index_value];
}

const UtGnEventInd& UtGnEventIndList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const UtGnEventInd& UtGnEventIndList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
return (*this)[(int)index_value];
}

UtGnEventIndList UtGnEventIndList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

UtGnEventIndList UtGnEventIndList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

UtGnEventIndList UtGnEventIndList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

UtGnEventIndList UtGnEventIndList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
UtGnEventIndList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new UtGnEventInd(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

UtGnEventIndList UtGnEventIndList::operator+(const UtGnEventIndList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
UtGnEventIndList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new UtGnEventInd(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new UtGnEventInd(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

UtGnEventIndList UtGnEventIndList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsGeoNetworking_TypesAndValues.UtGnEventIndList","element");
UtGnEventIndList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new UtGnEventInd(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

UtGnEventIndList UtGnEventIndList::replace(int index, int len, const UtGnEventIndList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsGeoNetworking_TypesAndValues.UtGnEventIndList","element");
UtGnEventIndList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new UtGnEventInd(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new UtGnEventInd(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new UtGnEventInd(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

UtGnEventIndList UtGnEventIndList::replace(int index, int len, const UtGnEventIndList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void UtGnEventIndList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (UtGnEventInd**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new UtGnEventInd(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (UtGnEventInd**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (UtGnEventInd**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean UtGnEventIndList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int UtGnEventIndList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
return val_ptr->n_elements;
}

int UtGnEventIndList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void UtGnEventIndList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void UtGnEventIndList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@LibItsGeoNetworking_TypesAndValues.UtGnEventIndList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@LibItsGeoNetworking_TypesAndValues.UtGnEventIndList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@LibItsGeoNetworking_TypesAndValues.UtGnEventIndList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* UtGnEventIndList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@LibItsGeoNetworking_TypesAndValues.UtGnEventIndList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void UtGnEventIndList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void UtGnEventIndList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void UtGnEventIndList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
val_ptr->value_elements = (UtGnEventInd**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new UtGnEventInd;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void UtGnEventIndList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void UtGnEventIndList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int UtGnEventIndList::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int UtGnEventIndList::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

void UtGnEventIndList_template::copy_value(const UtGnEventIndList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (UtGnEventInd_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new UtGnEventInd_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new UtGnEventInd_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void UtGnEventIndList_template::copy_template(const UtGnEventIndList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (UtGnEventInd_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new UtGnEventInd_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new UtGnEventInd_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new UtGnEventIndList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
break;
}
set_selection(other_value);
}

boolean UtGnEventIndList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const UtGnEventIndList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const UtGnEventIndList*)value_ptr)[value_index], legacy);
else return ((const UtGnEventIndList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

UtGnEventIndList_template::UtGnEventIndList_template()
{
}

UtGnEventIndList_template::UtGnEventIndList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

UtGnEventIndList_template::UtGnEventIndList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

UtGnEventIndList_template::UtGnEventIndList_template(const UtGnEventIndList& other_value)
{
copy_value(other_value);
}

UtGnEventIndList_template::UtGnEventIndList_template(const OPTIONAL<UtGnEventIndList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtGnEventIndList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList from an unbound optional field.");
}
}

UtGnEventIndList_template::UtGnEventIndList_template(const UtGnEventIndList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

UtGnEventIndList_template::~UtGnEventIndList_template()
{
clean_up();
}

void UtGnEventIndList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

UtGnEventIndList_template& UtGnEventIndList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

UtGnEventIndList_template& UtGnEventIndList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

UtGnEventIndList_template& UtGnEventIndList_template::operator=(const UtGnEventIndList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

UtGnEventIndList_template& UtGnEventIndList_template::operator=(const OPTIONAL<UtGnEventIndList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const UtGnEventIndList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
}
return *this;
}

UtGnEventIndList_template& UtGnEventIndList_template::operator=(const UtGnEventIndList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

UtGnEventInd_template& UtGnEventIndList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
    break;
}
return *single_value.value_elements[index_value];
}

UtGnEventInd_template& UtGnEventIndList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
return (*this)[(int)index_value];
}

const UtGnEventInd_template& UtGnEventIndList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const UtGnEventInd_template& UtGnEventIndList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
return (*this)[(int)index_value];
}

void UtGnEventIndList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (UtGnEventInd_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new UtGnEventInd_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new UtGnEventInd_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (UtGnEventInd_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int UtGnEventIndList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int UtGnEventIndList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList");
}

boolean UtGnEventIndList_template::match(const UtGnEventIndList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
}
return FALSE;
}

boolean UtGnEventIndList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

UtGnEventIndList UtGnEventIndList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
UtGnEventIndList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

UtGnEventIndList UtGnEventIndList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

UtGnEventIndList UtGnEventIndList_template::replace(int index, int len, const UtGnEventIndList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

UtGnEventIndList UtGnEventIndList_template::replace(int index, int len, const UtGnEventIndList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void UtGnEventIndList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new UtGnEventIndList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
}
set_selection(template_type);
}

UtGnEventIndList_template& UtGnEventIndList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
return value_list.list_value[list_index];
}

void UtGnEventIndList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void UtGnEventIndList_template::log_match(const UtGnEventIndList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void UtGnEventIndList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
}
}

void UtGnEventIndList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
single_value.value_elements = (UtGnEventInd_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new UtGnEventInd_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new UtGnEventIndList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
}
}

boolean UtGnEventIndList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean UtGnEventIndList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void UtGnEventIndList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@LibItsGeoNetworking_TypesAndValues.UtGnEventIndList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    UtGnEventIndList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@LibItsGeoNetworking_TypesAndValues.UtGnEventIndList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* UtGnEventIndList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@LibItsGeoNetworking_TypesAndValues.UtGnEventIndList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void UtGnEventIndList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.UtGnEventIndList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.UtGnEventIndList");
}

void AcGnPrimitive::copy_value(const AcGnPrimitive& other_value)
{
switch (other_value.union_selection) {
case ALT_startBeaconing:
field_startBeaconing = new AcStartBeaconing(*other_value.field_startBeaconing);
break;
case ALT_stopBeaconing:
field_stopBeaconing = new AcStopBeaconing(*other_value.field_stopBeaconing);
break;
case ALT_startPassBeaconing:
field_startPassBeaconing = new AcStartPassBeaconing(*other_value.field_startPassBeaconing);
break;
case ALT_stopPassBeaconing:
field_stopPassBeaconing = new AcStopPassBeaconing(*other_value.field_stopPassBeaconing);
break;
case ALT_startBeaconingMultipleNeighbour:
field_startBeaconingMultipleNeighbour = new AcStartBeaconingMultipleNeighbour(*other_value.field_startBeaconingMultipleNeighbour);
break;
case ALT_stopBeaconingMultipleNeighbour:
field_stopBeaconingMultipleNeighbour = new AcStopBeaconingMultipleNeighbour(*other_value.field_stopBeaconingMultipleNeighbour);
break;
case ALT_getLongPosVector:
field_getLongPosVector = new AcGetLongPosVector(*other_value.field_getLongPosVector);
break;
case ALT_acEnableSecurity:
field_acEnableSecurity = new LibItsSecurity__TypesAndValues::AcEnableSecurity(*other_value.field_acEnableSecurity);
break;
case ALT_acDisableSecurity:
field_acDisableSecurity = new LibItsSecurity__TypesAndValues::AcDisableSecurity(*other_value.field_acDisableSecurity);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
}
union_selection = other_value.union_selection;
}

AcGnPrimitive::AcGnPrimitive()
{
union_selection = UNBOUND_VALUE;
}

AcGnPrimitive::AcGnPrimitive(const AcGnPrimitive& other_value)
: Base_Type(){
copy_value(other_value);
}

AcGnPrimitive::~AcGnPrimitive()
{
clean_up();
}

AcGnPrimitive& AcGnPrimitive::operator=(const AcGnPrimitive& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean AcGnPrimitive::operator==(const AcGnPrimitive& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_startBeaconing:
return *field_startBeaconing == *other_value.field_startBeaconing;
case ALT_stopBeaconing:
return *field_stopBeaconing == *other_value.field_stopBeaconing;
case ALT_startPassBeaconing:
return *field_startPassBeaconing == *other_value.field_startPassBeaconing;
case ALT_stopPassBeaconing:
return *field_stopPassBeaconing == *other_value.field_stopPassBeaconing;
case ALT_startBeaconingMultipleNeighbour:
return *field_startBeaconingMultipleNeighbour == *other_value.field_startBeaconingMultipleNeighbour;
case ALT_stopBeaconingMultipleNeighbour:
return *field_stopBeaconingMultipleNeighbour == *other_value.field_stopBeaconingMultipleNeighbour;
case ALT_getLongPosVector:
return *field_getLongPosVector == *other_value.field_getLongPosVector;
case ALT_acEnableSecurity:
return *field_acEnableSecurity == *other_value.field_acEnableSecurity;
case ALT_acDisableSecurity:
return *field_acDisableSecurity == *other_value.field_acDisableSecurity;
default:
return FALSE;
}
}

AcStartBeaconing& AcGnPrimitive::startBeaconing()
{
if (union_selection != ALT_startBeaconing) {
clean_up();
field_startBeaconing = new AcStartBeaconing;
union_selection = ALT_startBeaconing;
}
return *field_startBeaconing;
}

const AcStartBeaconing& AcGnPrimitive::startBeaconing() const
{
if (union_selection != ALT_startBeaconing) TTCN_error("Using non-selected field startBeaconing in a value of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *field_startBeaconing;
}

AcStopBeaconing& AcGnPrimitive::stopBeaconing()
{
if (union_selection != ALT_stopBeaconing) {
clean_up();
field_stopBeaconing = new AcStopBeaconing;
union_selection = ALT_stopBeaconing;
}
return *field_stopBeaconing;
}

const AcStopBeaconing& AcGnPrimitive::stopBeaconing() const
{
if (union_selection != ALT_stopBeaconing) TTCN_error("Using non-selected field stopBeaconing in a value of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *field_stopBeaconing;
}

AcStartPassBeaconing& AcGnPrimitive::startPassBeaconing()
{
if (union_selection != ALT_startPassBeaconing) {
clean_up();
field_startPassBeaconing = new AcStartPassBeaconing;
union_selection = ALT_startPassBeaconing;
}
return *field_startPassBeaconing;
}

const AcStartPassBeaconing& AcGnPrimitive::startPassBeaconing() const
{
if (union_selection != ALT_startPassBeaconing) TTCN_error("Using non-selected field startPassBeaconing in a value of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *field_startPassBeaconing;
}

AcStopPassBeaconing& AcGnPrimitive::stopPassBeaconing()
{
if (union_selection != ALT_stopPassBeaconing) {
clean_up();
field_stopPassBeaconing = new AcStopPassBeaconing;
union_selection = ALT_stopPassBeaconing;
}
return *field_stopPassBeaconing;
}

const AcStopPassBeaconing& AcGnPrimitive::stopPassBeaconing() const
{
if (union_selection != ALT_stopPassBeaconing) TTCN_error("Using non-selected field stopPassBeaconing in a value of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *field_stopPassBeaconing;
}

AcStartBeaconingMultipleNeighbour& AcGnPrimitive::startBeaconingMultipleNeighbour()
{
if (union_selection != ALT_startBeaconingMultipleNeighbour) {
clean_up();
field_startBeaconingMultipleNeighbour = new AcStartBeaconingMultipleNeighbour;
union_selection = ALT_startBeaconingMultipleNeighbour;
}
return *field_startBeaconingMultipleNeighbour;
}

const AcStartBeaconingMultipleNeighbour& AcGnPrimitive::startBeaconingMultipleNeighbour() const
{
if (union_selection != ALT_startBeaconingMultipleNeighbour) TTCN_error("Using non-selected field startBeaconingMultipleNeighbour in a value of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *field_startBeaconingMultipleNeighbour;
}

AcStopBeaconingMultipleNeighbour& AcGnPrimitive::stopBeaconingMultipleNeighbour()
{
if (union_selection != ALT_stopBeaconingMultipleNeighbour) {
clean_up();
field_stopBeaconingMultipleNeighbour = new AcStopBeaconingMultipleNeighbour;
union_selection = ALT_stopBeaconingMultipleNeighbour;
}
return *field_stopBeaconingMultipleNeighbour;
}

const AcStopBeaconingMultipleNeighbour& AcGnPrimitive::stopBeaconingMultipleNeighbour() const
{
if (union_selection != ALT_stopBeaconingMultipleNeighbour) TTCN_error("Using non-selected field stopBeaconingMultipleNeighbour in a value of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *field_stopBeaconingMultipleNeighbour;
}

AcGetLongPosVector& AcGnPrimitive::getLongPosVector()
{
if (union_selection != ALT_getLongPosVector) {
clean_up();
field_getLongPosVector = new AcGetLongPosVector;
union_selection = ALT_getLongPosVector;
}
return *field_getLongPosVector;
}

const AcGetLongPosVector& AcGnPrimitive::getLongPosVector() const
{
if (union_selection != ALT_getLongPosVector) TTCN_error("Using non-selected field getLongPosVector in a value of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *field_getLongPosVector;
}

LibItsSecurity__TypesAndValues::AcEnableSecurity& AcGnPrimitive::acEnableSecurity()
{
if (union_selection != ALT_acEnableSecurity) {
clean_up();
field_acEnableSecurity = new LibItsSecurity__TypesAndValues::AcEnableSecurity;
union_selection = ALT_acEnableSecurity;
}
return *field_acEnableSecurity;
}

const LibItsSecurity__TypesAndValues::AcEnableSecurity& AcGnPrimitive::acEnableSecurity() const
{
if (union_selection != ALT_acEnableSecurity) TTCN_error("Using non-selected field acEnableSecurity in a value of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *field_acEnableSecurity;
}

LibItsSecurity__TypesAndValues::AcDisableSecurity& AcGnPrimitive::acDisableSecurity()
{
if (union_selection != ALT_acDisableSecurity) {
clean_up();
field_acDisableSecurity = new LibItsSecurity__TypesAndValues::AcDisableSecurity;
union_selection = ALT_acDisableSecurity;
}
return *field_acDisableSecurity;
}

const LibItsSecurity__TypesAndValues::AcDisableSecurity& AcGnPrimitive::acDisableSecurity() const
{
if (union_selection != ALT_acDisableSecurity) TTCN_error("Using non-selected field acDisableSecurity in a value of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *field_acDisableSecurity;
}

boolean AcGnPrimitive::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return union_selection == checked_selection;
}

boolean AcGnPrimitive::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean AcGnPrimitive::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_startBeaconing: return field_startBeaconing->is_value();
case ALT_stopBeaconing: return field_stopBeaconing->is_value();
case ALT_startPassBeaconing: return field_startPassBeaconing->is_value();
case ALT_stopPassBeaconing: return field_stopPassBeaconing->is_value();
case ALT_startBeaconingMultipleNeighbour: return field_startBeaconingMultipleNeighbour->is_value();
case ALT_stopBeaconingMultipleNeighbour: return field_stopBeaconingMultipleNeighbour->is_value();
case ALT_getLongPosVector: return field_getLongPosVector->is_value();
case ALT_acEnableSecurity: return field_acEnableSecurity->is_value();
case ALT_acDisableSecurity: return field_acDisableSecurity->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void AcGnPrimitive::clean_up()
{
switch (union_selection) {
case ALT_startBeaconing:
  delete field_startBeaconing;
  break;
case ALT_stopBeaconing:
  delete field_stopBeaconing;
  break;
case ALT_startPassBeaconing:
  delete field_startPassBeaconing;
  break;
case ALT_stopPassBeaconing:
  delete field_stopPassBeaconing;
  break;
case ALT_startBeaconingMultipleNeighbour:
  delete field_startBeaconingMultipleNeighbour;
  break;
case ALT_stopBeaconingMultipleNeighbour:
  delete field_stopBeaconingMultipleNeighbour;
  break;
case ALT_getLongPosVector:
  delete field_getLongPosVector;
  break;
case ALT_acEnableSecurity:
  delete field_acEnableSecurity;
  break;
case ALT_acDisableSecurity:
  delete field_acDisableSecurity;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void AcGnPrimitive::log() const
{
switch (union_selection) {
case ALT_startBeaconing:
TTCN_Logger::log_event_str("{ startBeaconing := ");
field_startBeaconing->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_stopBeaconing:
TTCN_Logger::log_event_str("{ stopBeaconing := ");
field_stopBeaconing->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_startPassBeaconing:
TTCN_Logger::log_event_str("{ startPassBeaconing := ");
field_startPassBeaconing->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_stopPassBeaconing:
TTCN_Logger::log_event_str("{ stopPassBeaconing := ");
field_stopPassBeaconing->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_startBeaconingMultipleNeighbour:
TTCN_Logger::log_event_str("{ startBeaconingMultipleNeighbour := ");
field_startBeaconingMultipleNeighbour->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_stopBeaconingMultipleNeighbour:
TTCN_Logger::log_event_str("{ stopBeaconingMultipleNeighbour := ");
field_stopBeaconingMultipleNeighbour->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_getLongPosVector:
TTCN_Logger::log_event_str("{ getLongPosVector := ");
field_getLongPosVector->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_acEnableSecurity:
TTCN_Logger::log_event_str("{ acEnableSecurity := ");
field_acEnableSecurity->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_acDisableSecurity:
TTCN_Logger::log_event_str("{ acDisableSecurity := ");
field_acDisableSecurity->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void AcGnPrimitive::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive'");
    }
    if (strcmp("startBeaconing", param_field) == 0) {
      startBeaconing().set_param(param);
      return;
    } else if (strcmp("stopBeaconing", param_field) == 0) {
      stopBeaconing().set_param(param);
      return;
    } else if (strcmp("startPassBeaconing", param_field) == 0) {
      startPassBeaconing().set_param(param);
      return;
    } else if (strcmp("stopPassBeaconing", param_field) == 0) {
      stopPassBeaconing().set_param(param);
      return;
    } else if (strcmp("startBeaconingMultipleNeighbour", param_field) == 0) {
      startBeaconingMultipleNeighbour().set_param(param);
      return;
    } else if (strcmp("stopBeaconingMultipleNeighbour", param_field) == 0) {
      stopBeaconingMultipleNeighbour().set_param(param);
      return;
    } else if (strcmp("getLongPosVector", param_field) == 0) {
      getLongPosVector().set_param(param);
      return;
    } else if (strcmp("acEnableSecurity", param_field) == 0) {
      acEnableSecurity().set_param(param);
      return;
    } else if (strcmp("acDisableSecurity", param_field) == 0) {
      acDisableSecurity().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "startBeaconing")) {
    startBeaconing().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "stopBeaconing")) {
    stopBeaconing().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "startPassBeaconing")) {
    startPassBeaconing().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "stopPassBeaconing")) {
    stopPassBeaconing().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "startBeaconingMultipleNeighbour")) {
    startBeaconingMultipleNeighbour().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "stopBeaconingMultipleNeighbour")) {
    stopBeaconingMultipleNeighbour().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "getLongPosVector")) {
    getLongPosVector().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "acEnableSecurity")) {
    acEnableSecurity().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "acDisableSecurity")) {
    acDisableSecurity().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.", mp_last->get_id()->get_name());
}

Module_Param* AcGnPrimitive::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive'");
    }
    if (strcmp("startBeaconing", param_field) == 0) {
      return startBeaconing().get_param(param_name);
    } else if (strcmp("stopBeaconing", param_field) == 0) {
      return stopBeaconing().get_param(param_name);
    } else if (strcmp("startPassBeaconing", param_field) == 0) {
      return startPassBeaconing().get_param(param_name);
    } else if (strcmp("stopPassBeaconing", param_field) == 0) {
      return stopPassBeaconing().get_param(param_name);
    } else if (strcmp("startBeaconingMultipleNeighbour", param_field) == 0) {
      return startBeaconingMultipleNeighbour().get_param(param_name);
    } else if (strcmp("stopBeaconingMultipleNeighbour", param_field) == 0) {
      return stopBeaconingMultipleNeighbour().get_param(param_name);
    } else if (strcmp("getLongPosVector", param_field) == 0) {
      return getLongPosVector().get_param(param_name);
    } else if (strcmp("acEnableSecurity", param_field) == 0) {
      return acEnableSecurity().get_param(param_name);
    } else if (strcmp("acDisableSecurity", param_field) == 0) {
      return acDisableSecurity().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `AcGnPrimitive'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_startBeaconing:
    mp_field = field_startBeaconing->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("startBeaconing")));
    break;
  case ALT_stopBeaconing:
    mp_field = field_stopBeaconing->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("stopBeaconing")));
    break;
  case ALT_startPassBeaconing:
    mp_field = field_startPassBeaconing->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("startPassBeaconing")));
    break;
  case ALT_stopPassBeaconing:
    mp_field = field_stopPassBeaconing->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("stopPassBeaconing")));
    break;
  case ALT_startBeaconingMultipleNeighbour:
    mp_field = field_startBeaconingMultipleNeighbour->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("startBeaconingMultipleNeighbour")));
    break;
  case ALT_stopBeaconingMultipleNeighbour:
    mp_field = field_stopBeaconingMultipleNeighbour->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("stopBeaconingMultipleNeighbour")));
    break;
  case ALT_getLongPosVector:
    mp_field = field_getLongPosVector->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("getLongPosVector")));
    break;
  case ALT_acEnableSecurity:
    mp_field = field_acEnableSecurity->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("acEnableSecurity")));
    break;
  case ALT_acDisableSecurity:
    mp_field = field_acDisableSecurity->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("acDisableSecurity")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void AcGnPrimitive::set_implicit_omit()
{
switch (union_selection) {
case ALT_startBeaconing:
field_startBeaconing->set_implicit_omit(); break;
case ALT_stopBeaconing:
field_stopBeaconing->set_implicit_omit(); break;
case ALT_startPassBeaconing:
field_startPassBeaconing->set_implicit_omit(); break;
case ALT_stopPassBeaconing:
field_stopPassBeaconing->set_implicit_omit(); break;
case ALT_startBeaconingMultipleNeighbour:
field_startBeaconingMultipleNeighbour->set_implicit_omit(); break;
case ALT_stopBeaconingMultipleNeighbour:
field_stopBeaconingMultipleNeighbour->set_implicit_omit(); break;
case ALT_getLongPosVector:
field_getLongPosVector->set_implicit_omit(); break;
case ALT_acEnableSecurity:
field_acEnableSecurity->set_implicit_omit(); break;
case ALT_acDisableSecurity:
field_acDisableSecurity->set_implicit_omit(); break;
default: break;
}
}

void AcGnPrimitive::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_startBeaconing:
field_startBeaconing->encode_text(text_buf);
break;
case ALT_stopBeaconing:
field_stopBeaconing->encode_text(text_buf);
break;
case ALT_startPassBeaconing:
field_startPassBeaconing->encode_text(text_buf);
break;
case ALT_stopPassBeaconing:
field_stopPassBeaconing->encode_text(text_buf);
break;
case ALT_startBeaconingMultipleNeighbour:
field_startBeaconingMultipleNeighbour->encode_text(text_buf);
break;
case ALT_stopBeaconingMultipleNeighbour:
field_stopBeaconingMultipleNeighbour->encode_text(text_buf);
break;
case ALT_getLongPosVector:
field_getLongPosVector->encode_text(text_buf);
break;
case ALT_acEnableSecurity:
field_acEnableSecurity->encode_text(text_buf);
break;
case ALT_acDisableSecurity:
field_acDisableSecurity->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
}
}

void AcGnPrimitive::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_startBeaconing:
startBeaconing().decode_text(text_buf);
break;
case ALT_stopBeaconing:
stopBeaconing().decode_text(text_buf);
break;
case ALT_startPassBeaconing:
startPassBeaconing().decode_text(text_buf);
break;
case ALT_stopPassBeaconing:
stopPassBeaconing().decode_text(text_buf);
break;
case ALT_startBeaconingMultipleNeighbour:
startBeaconingMultipleNeighbour().decode_text(text_buf);
break;
case ALT_stopBeaconingMultipleNeighbour:
stopBeaconingMultipleNeighbour().decode_text(text_buf);
break;
case ALT_getLongPosVector:
getLongPosVector().decode_text(text_buf);
break;
case ALT_acEnableSecurity:
acEnableSecurity().decode_text(text_buf);
break;
case ALT_acDisableSecurity:
acDisableSecurity().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
}
}

void AcGnPrimitive::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AcGnPrimitive::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AcGnPrimitive::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = startBeaconing().RAW_decode(AcStartBeaconing_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = stopBeaconing().RAW_decode(AcStopBeaconing_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 2:
      decoded_length = startPassBeaconing().RAW_decode(AcStartPassBeaconing_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 3:
      decoded_length = stopPassBeaconing().RAW_decode(AcStopPassBeaconing_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 4:
      decoded_length = startBeaconingMultipleNeighbour().RAW_decode(AcStartBeaconingMultipleNeighbour_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 5:
      decoded_length = stopBeaconingMultipleNeighbour().RAW_decode(AcStopBeaconingMultipleNeighbour_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 6:
      decoded_length = getLongPosVector().RAW_decode(AcGetLongPosVector_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 7:
      decoded_length = acEnableSecurity().RAW_decode(LibItsSecurity__TypesAndValues::AcEnableSecurity_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 8:
      decoded_length = acDisableSecurity().RAW_decode(LibItsSecurity__TypesAndValues::AcDisableSecurity_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = startBeaconing().RAW_decode(AcStartBeaconing_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = stopBeaconing().RAW_decode(AcStopBeaconing_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = startPassBeaconing().RAW_decode(AcStartPassBeaconing_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = stopPassBeaconing().RAW_decode(AcStopPassBeaconing_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = startBeaconingMultipleNeighbour().RAW_decode(AcStartBeaconingMultipleNeighbour_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = stopBeaconingMultipleNeighbour().RAW_decode(AcStopBeaconingMultipleNeighbour_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = getLongPosVector().RAW_decode(AcGetLongPosVector_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = acEnableSecurity().RAW_decode(LibItsSecurity__TypesAndValues::AcEnableSecurity_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = acDisableSecurity().RAW_decode(LibItsSecurity__TypesAndValues::AcDisableSecurity_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int AcGnPrimitive::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 9;  myleaf.body.node.nodes = init_nodes_of_enc_tree(9);
  memset(myleaf.body.node.nodes, 0, 9 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_startBeaconing:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, AcStartBeaconing_descr_.raw);
    encoded_length = field_startBeaconing->RAW_encode(AcStartBeaconing_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &AcStartBeaconing_descr_;
    break;
  case ALT_stopBeaconing:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, AcStopBeaconing_descr_.raw);
    encoded_length = field_stopBeaconing->RAW_encode(AcStopBeaconing_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &AcStopBeaconing_descr_;
    break;
  case ALT_startPassBeaconing:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, AcStartPassBeaconing_descr_.raw);
    encoded_length = field_startPassBeaconing->RAW_encode(AcStartPassBeaconing_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &AcStartPassBeaconing_descr_;
    break;
  case ALT_stopPassBeaconing:
    myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 3, AcStopPassBeaconing_descr_.raw);
    encoded_length = field_stopPassBeaconing->RAW_encode(AcStopPassBeaconing_descr_, *myleaf.body.node.nodes[3]);
    myleaf.body.node.nodes[3]->coding_descr = &AcStopPassBeaconing_descr_;
    break;
  case ALT_startBeaconingMultipleNeighbour:
    myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 4, AcStartBeaconingMultipleNeighbour_descr_.raw);
    encoded_length = field_startBeaconingMultipleNeighbour->RAW_encode(AcStartBeaconingMultipleNeighbour_descr_, *myleaf.body.node.nodes[4]);
    myleaf.body.node.nodes[4]->coding_descr = &AcStartBeaconingMultipleNeighbour_descr_;
    break;
  case ALT_stopBeaconingMultipleNeighbour:
    myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 5, AcStopBeaconingMultipleNeighbour_descr_.raw);
    encoded_length = field_stopBeaconingMultipleNeighbour->RAW_encode(AcStopBeaconingMultipleNeighbour_descr_, *myleaf.body.node.nodes[5]);
    myleaf.body.node.nodes[5]->coding_descr = &AcStopBeaconingMultipleNeighbour_descr_;
    break;
  case ALT_getLongPosVector:
    myleaf.body.node.nodes[6] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 6, AcGetLongPosVector_descr_.raw);
    encoded_length = field_getLongPosVector->RAW_encode(AcGetLongPosVector_descr_, *myleaf.body.node.nodes[6]);
    myleaf.body.node.nodes[6]->coding_descr = &AcGetLongPosVector_descr_;
    break;
  case ALT_acEnableSecurity:
    myleaf.body.node.nodes[7] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 7, LibItsSecurity__TypesAndValues::AcEnableSecurity_descr_.raw);
    encoded_length = field_acEnableSecurity->RAW_encode(LibItsSecurity__TypesAndValues::AcEnableSecurity_descr_, *myleaf.body.node.nodes[7]);
    myleaf.body.node.nodes[7]->coding_descr = &LibItsSecurity__TypesAndValues::AcEnableSecurity_descr_;
    break;
  case ALT_acDisableSecurity:
    myleaf.body.node.nodes[8] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 8, LibItsSecurity__TypesAndValues::AcDisableSecurity_descr_.raw);
    encoded_length = field_acDisableSecurity->RAW_encode(LibItsSecurity__TypesAndValues::AcDisableSecurity_descr_, *myleaf.body.node.nodes[8]);
    myleaf.body.node.nodes[8]->coding_descr = &LibItsSecurity__TypesAndValues::AcDisableSecurity_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int AcGnPrimitive::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_startBeaconing:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "startBeaconing");
    enc_len += field_startBeaconing->JSON_encode(AcStartBeaconing_descr_, p_tok);
    break;
  case ALT_stopBeaconing:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "stopBeaconing");
    enc_len += field_stopBeaconing->JSON_encode(AcStopBeaconing_descr_, p_tok);
    break;
  case ALT_startPassBeaconing:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "startPassBeaconing");
    enc_len += field_startPassBeaconing->JSON_encode(AcStartPassBeaconing_descr_, p_tok);
    break;
  case ALT_stopPassBeaconing:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "stopPassBeaconing");
    enc_len += field_stopPassBeaconing->JSON_encode(AcStopPassBeaconing_descr_, p_tok);
    break;
  case ALT_startBeaconingMultipleNeighbour:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "startBeaconingMultipleNeighbour");
    enc_len += field_startBeaconingMultipleNeighbour->JSON_encode(AcStartBeaconingMultipleNeighbour_descr_, p_tok);
    break;
  case ALT_stopBeaconingMultipleNeighbour:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "stopBeaconingMultipleNeighbour");
    enc_len += field_stopBeaconingMultipleNeighbour->JSON_encode(AcStopBeaconingMultipleNeighbour_descr_, p_tok);
    break;
  case ALT_getLongPosVector:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "getLongPosVector");
    enc_len += field_getLongPosVector->JSON_encode(AcGetLongPosVector_descr_, p_tok);
    break;
  case ALT_acEnableSecurity:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "acEnableSecurity");
    enc_len += field_acEnableSecurity->JSON_encode(LibItsSecurity__TypesAndValues::AcEnableSecurity_descr_, p_tok);
    break;
  case ALT_acDisableSecurity:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "acDisableSecurity");
    enc_len += field_acDisableSecurity->JSON_encode(LibItsSecurity__TypesAndValues::AcDisableSecurity_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AcGnPrimitive::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "startBeaconing", name_len)) {
      int ret_val = startBeaconing().JSON_decode(AcStartBeaconing_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "startBeaconing");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "stopBeaconing", name_len)) {
      int ret_val = stopBeaconing().JSON_decode(AcStopBeaconing_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "stopBeaconing");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "startPassBeaconing", name_len)) {
      int ret_val = startPassBeaconing().JSON_decode(AcStartPassBeaconing_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "startPassBeaconing");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "stopPassBeaconing", name_len)) {
      int ret_val = stopPassBeaconing().JSON_decode(AcStopPassBeaconing_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "stopPassBeaconing");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "startBeaconingMultipleNeighbour", name_len)) {
      int ret_val = startBeaconingMultipleNeighbour().JSON_decode(AcStartBeaconingMultipleNeighbour_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "startBeaconingMultipleNeighbour");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "stopBeaconingMultipleNeighbour", name_len)) {
      int ret_val = stopBeaconingMultipleNeighbour().JSON_decode(AcStopBeaconingMultipleNeighbour_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "stopBeaconingMultipleNeighbour");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "getLongPosVector", name_len)) {
      int ret_val = getLongPosVector().JSON_decode(AcGetLongPosVector_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "getLongPosVector");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "acEnableSecurity", name_len)) {
      int ret_val = acEnableSecurity().JSON_decode(LibItsSecurity__TypesAndValues::AcEnableSecurity_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "acEnableSecurity");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "acDisableSecurity", name_len)) {
      int ret_val = acDisableSecurity().JSON_decode(LibItsSecurity__TypesAndValues::AcDisableSecurity_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "acDisableSecurity");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void AcGnPrimitive_template::copy_value(const AcGnPrimitive& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case AcGnPrimitive::ALT_startBeaconing:
single_value.field_startBeaconing = new AcStartBeaconing_template(other_value.startBeaconing());
break;
case AcGnPrimitive::ALT_stopBeaconing:
single_value.field_stopBeaconing = new AcStopBeaconing_template(other_value.stopBeaconing());
break;
case AcGnPrimitive::ALT_startPassBeaconing:
single_value.field_startPassBeaconing = new AcStartPassBeaconing_template(other_value.startPassBeaconing());
break;
case AcGnPrimitive::ALT_stopPassBeaconing:
single_value.field_stopPassBeaconing = new AcStopPassBeaconing_template(other_value.stopPassBeaconing());
break;
case AcGnPrimitive::ALT_startBeaconingMultipleNeighbour:
single_value.field_startBeaconingMultipleNeighbour = new AcStartBeaconingMultipleNeighbour_template(other_value.startBeaconingMultipleNeighbour());
break;
case AcGnPrimitive::ALT_stopBeaconingMultipleNeighbour:
single_value.field_stopBeaconingMultipleNeighbour = new AcStopBeaconingMultipleNeighbour_template(other_value.stopBeaconingMultipleNeighbour());
break;
case AcGnPrimitive::ALT_getLongPosVector:
single_value.field_getLongPosVector = new AcGetLongPosVector_template(other_value.getLongPosVector());
break;
case AcGnPrimitive::ALT_acEnableSecurity:
single_value.field_acEnableSecurity = new LibItsSecurity__TypesAndValues::AcEnableSecurity_template(other_value.acEnableSecurity());
break;
case AcGnPrimitive::ALT_acDisableSecurity:
single_value.field_acDisableSecurity = new LibItsSecurity__TypesAndValues::AcDisableSecurity_template(other_value.acDisableSecurity());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
}
set_selection(SPECIFIC_VALUE);
}

void AcGnPrimitive_template::copy_template(const AcGnPrimitive_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case AcGnPrimitive::ALT_startBeaconing:
single_value.field_startBeaconing = new AcStartBeaconing_template(*other_value.single_value.field_startBeaconing);
break;
case AcGnPrimitive::ALT_stopBeaconing:
single_value.field_stopBeaconing = new AcStopBeaconing_template(*other_value.single_value.field_stopBeaconing);
break;
case AcGnPrimitive::ALT_startPassBeaconing:
single_value.field_startPassBeaconing = new AcStartPassBeaconing_template(*other_value.single_value.field_startPassBeaconing);
break;
case AcGnPrimitive::ALT_stopPassBeaconing:
single_value.field_stopPassBeaconing = new AcStopPassBeaconing_template(*other_value.single_value.field_stopPassBeaconing);
break;
case AcGnPrimitive::ALT_startBeaconingMultipleNeighbour:
single_value.field_startBeaconingMultipleNeighbour = new AcStartBeaconingMultipleNeighbour_template(*other_value.single_value.field_startBeaconingMultipleNeighbour);
break;
case AcGnPrimitive::ALT_stopBeaconingMultipleNeighbour:
single_value.field_stopBeaconingMultipleNeighbour = new AcStopBeaconingMultipleNeighbour_template(*other_value.single_value.field_stopBeaconingMultipleNeighbour);
break;
case AcGnPrimitive::ALT_getLongPosVector:
single_value.field_getLongPosVector = new AcGetLongPosVector_template(*other_value.single_value.field_getLongPosVector);
break;
case AcGnPrimitive::ALT_acEnableSecurity:
single_value.field_acEnableSecurity = new LibItsSecurity__TypesAndValues::AcEnableSecurity_template(*other_value.single_value.field_acEnableSecurity);
break;
case AcGnPrimitive::ALT_acDisableSecurity:
single_value.field_acDisableSecurity = new LibItsSecurity__TypesAndValues::AcDisableSecurity_template(*other_value.single_value.field_acDisableSecurity);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AcGnPrimitive_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
}
set_selection(other_value);
}

AcGnPrimitive_template::AcGnPrimitive_template()
{
}

AcGnPrimitive_template::AcGnPrimitive_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AcGnPrimitive_template::AcGnPrimitive_template(const AcGnPrimitive& other_value)
{
copy_value(other_value);
}

AcGnPrimitive_template::AcGnPrimitive_template(const OPTIONAL<AcGnPrimitive>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcGnPrimitive&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive from an unbound optional field.");
}
}

AcGnPrimitive_template::AcGnPrimitive_template(const AcGnPrimitive_template& other_value)
: Base_Template(){
copy_template(other_value);
}

AcGnPrimitive_template::~AcGnPrimitive_template()
{
clean_up();
}

void AcGnPrimitive_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case AcGnPrimitive::ALT_startBeaconing:
delete single_value.field_startBeaconing;
break;
case AcGnPrimitive::ALT_stopBeaconing:
delete single_value.field_stopBeaconing;
break;
case AcGnPrimitive::ALT_startPassBeaconing:
delete single_value.field_startPassBeaconing;
break;
case AcGnPrimitive::ALT_stopPassBeaconing:
delete single_value.field_stopPassBeaconing;
break;
case AcGnPrimitive::ALT_startBeaconingMultipleNeighbour:
delete single_value.field_startBeaconingMultipleNeighbour;
break;
case AcGnPrimitive::ALT_stopBeaconingMultipleNeighbour:
delete single_value.field_stopBeaconingMultipleNeighbour;
break;
case AcGnPrimitive::ALT_getLongPosVector:
delete single_value.field_getLongPosVector;
break;
case AcGnPrimitive::ALT_acEnableSecurity:
delete single_value.field_acEnableSecurity;
break;
case AcGnPrimitive::ALT_acDisableSecurity:
delete single_value.field_acDisableSecurity;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AcGnPrimitive_template& AcGnPrimitive_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AcGnPrimitive_template& AcGnPrimitive_template::operator=(const AcGnPrimitive& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AcGnPrimitive_template& AcGnPrimitive_template::operator=(const OPTIONAL<AcGnPrimitive>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcGnPrimitive&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
}
return *this;
}

AcGnPrimitive_template& AcGnPrimitive_template::operator=(const AcGnPrimitive_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AcGnPrimitive_template::match(const AcGnPrimitive& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
AcGnPrimitive::union_selection_type value_selection = other_value.get_selection();
if (value_selection == AcGnPrimitive::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case AcGnPrimitive::ALT_startBeaconing:
return single_value.field_startBeaconing->match(other_value.startBeaconing(), legacy);
case AcGnPrimitive::ALT_stopBeaconing:
return single_value.field_stopBeaconing->match(other_value.stopBeaconing(), legacy);
case AcGnPrimitive::ALT_startPassBeaconing:
return single_value.field_startPassBeaconing->match(other_value.startPassBeaconing(), legacy);
case AcGnPrimitive::ALT_stopPassBeaconing:
return single_value.field_stopPassBeaconing->match(other_value.stopPassBeaconing(), legacy);
case AcGnPrimitive::ALT_startBeaconingMultipleNeighbour:
return single_value.field_startBeaconingMultipleNeighbour->match(other_value.startBeaconingMultipleNeighbour(), legacy);
case AcGnPrimitive::ALT_stopBeaconingMultipleNeighbour:
return single_value.field_stopBeaconingMultipleNeighbour->match(other_value.stopBeaconingMultipleNeighbour(), legacy);
case AcGnPrimitive::ALT_getLongPosVector:
return single_value.field_getLongPosVector->match(other_value.getLongPosVector(), legacy);
case AcGnPrimitive::ALT_acEnableSecurity:
return single_value.field_acEnableSecurity->match(other_value.acEnableSecurity(), legacy);
case AcGnPrimitive::ALT_acDisableSecurity:
return single_value.field_acDisableSecurity->match(other_value.acDisableSecurity(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
}
return FALSE;
}

boolean AcGnPrimitive_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case AcGnPrimitive::ALT_startBeaconing:
return single_value.field_startBeaconing->is_value();
case AcGnPrimitive::ALT_stopBeaconing:
return single_value.field_stopBeaconing->is_value();
case AcGnPrimitive::ALT_startPassBeaconing:
return single_value.field_startPassBeaconing->is_value();
case AcGnPrimitive::ALT_stopPassBeaconing:
return single_value.field_stopPassBeaconing->is_value();
case AcGnPrimitive::ALT_startBeaconingMultipleNeighbour:
return single_value.field_startBeaconingMultipleNeighbour->is_value();
case AcGnPrimitive::ALT_stopBeaconingMultipleNeighbour:
return single_value.field_stopBeaconingMultipleNeighbour->is_value();
case AcGnPrimitive::ALT_getLongPosVector:
return single_value.field_getLongPosVector->is_value();
case AcGnPrimitive::ALT_acEnableSecurity:
return single_value.field_acEnableSecurity->is_value();
case AcGnPrimitive::ALT_acDisableSecurity:
return single_value.field_acDisableSecurity->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
}
}

AcGnPrimitive AcGnPrimitive_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
AcGnPrimitive ret_val;
switch (single_value.union_selection) {
case AcGnPrimitive::ALT_startBeaconing:
ret_val.startBeaconing() = single_value.field_startBeaconing->valueof();
break;
case AcGnPrimitive::ALT_stopBeaconing:
ret_val.stopBeaconing() = single_value.field_stopBeaconing->valueof();
break;
case AcGnPrimitive::ALT_startPassBeaconing:
ret_val.startPassBeaconing() = single_value.field_startPassBeaconing->valueof();
break;
case AcGnPrimitive::ALT_stopPassBeaconing:
ret_val.stopPassBeaconing() = single_value.field_stopPassBeaconing->valueof();
break;
case AcGnPrimitive::ALT_startBeaconingMultipleNeighbour:
ret_val.startBeaconingMultipleNeighbour() = single_value.field_startBeaconingMultipleNeighbour->valueof();
break;
case AcGnPrimitive::ALT_stopBeaconingMultipleNeighbour:
ret_val.stopBeaconingMultipleNeighbour() = single_value.field_stopBeaconingMultipleNeighbour->valueof();
break;
case AcGnPrimitive::ALT_getLongPosVector:
ret_val.getLongPosVector() = single_value.field_getLongPosVector->valueof();
break;
case AcGnPrimitive::ALT_acEnableSecurity:
ret_val.acEnableSecurity() = single_value.field_acEnableSecurity->valueof();
break;
case AcGnPrimitive::ALT_acDisableSecurity:
ret_val.acDisableSecurity() = single_value.field_acDisableSecurity->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
}
return ret_val;
}

AcGnPrimitive_template& AcGnPrimitive_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return value_list.list_value[list_index];
}
void AcGnPrimitive_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AcGnPrimitive_template[list_length];
}

AcStartBeaconing_template& AcGnPrimitive_template::startBeaconing()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != AcGnPrimitive::ALT_startBeaconing) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_startBeaconing = new AcStartBeaconing_template(ANY_VALUE);
else single_value.field_startBeaconing = new AcStartBeaconing_template;
single_value.union_selection = AcGnPrimitive::ALT_startBeaconing;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_startBeaconing;
}

const AcStartBeaconing_template& AcGnPrimitive_template::startBeaconing() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field startBeaconing in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
if (single_value.union_selection != AcGnPrimitive::ALT_startBeaconing) TTCN_error("Accessing non-selected field startBeaconing in a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *single_value.field_startBeaconing;
}

AcStopBeaconing_template& AcGnPrimitive_template::stopBeaconing()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != AcGnPrimitive::ALT_stopBeaconing) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_stopBeaconing = new AcStopBeaconing_template(ANY_VALUE);
else single_value.field_stopBeaconing = new AcStopBeaconing_template;
single_value.union_selection = AcGnPrimitive::ALT_stopBeaconing;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_stopBeaconing;
}

const AcStopBeaconing_template& AcGnPrimitive_template::stopBeaconing() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field stopBeaconing in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
if (single_value.union_selection != AcGnPrimitive::ALT_stopBeaconing) TTCN_error("Accessing non-selected field stopBeaconing in a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *single_value.field_stopBeaconing;
}

AcStartPassBeaconing_template& AcGnPrimitive_template::startPassBeaconing()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != AcGnPrimitive::ALT_startPassBeaconing) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_startPassBeaconing = new AcStartPassBeaconing_template(ANY_VALUE);
else single_value.field_startPassBeaconing = new AcStartPassBeaconing_template;
single_value.union_selection = AcGnPrimitive::ALT_startPassBeaconing;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_startPassBeaconing;
}

const AcStartPassBeaconing_template& AcGnPrimitive_template::startPassBeaconing() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field startPassBeaconing in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
if (single_value.union_selection != AcGnPrimitive::ALT_startPassBeaconing) TTCN_error("Accessing non-selected field startPassBeaconing in a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *single_value.field_startPassBeaconing;
}

AcStopPassBeaconing_template& AcGnPrimitive_template::stopPassBeaconing()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != AcGnPrimitive::ALT_stopPassBeaconing) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_stopPassBeaconing = new AcStopPassBeaconing_template(ANY_VALUE);
else single_value.field_stopPassBeaconing = new AcStopPassBeaconing_template;
single_value.union_selection = AcGnPrimitive::ALT_stopPassBeaconing;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_stopPassBeaconing;
}

const AcStopPassBeaconing_template& AcGnPrimitive_template::stopPassBeaconing() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field stopPassBeaconing in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
if (single_value.union_selection != AcGnPrimitive::ALT_stopPassBeaconing) TTCN_error("Accessing non-selected field stopPassBeaconing in a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *single_value.field_stopPassBeaconing;
}

AcStartBeaconingMultipleNeighbour_template& AcGnPrimitive_template::startBeaconingMultipleNeighbour()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != AcGnPrimitive::ALT_startBeaconingMultipleNeighbour) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_startBeaconingMultipleNeighbour = new AcStartBeaconingMultipleNeighbour_template(ANY_VALUE);
else single_value.field_startBeaconingMultipleNeighbour = new AcStartBeaconingMultipleNeighbour_template;
single_value.union_selection = AcGnPrimitive::ALT_startBeaconingMultipleNeighbour;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_startBeaconingMultipleNeighbour;
}

const AcStartBeaconingMultipleNeighbour_template& AcGnPrimitive_template::startBeaconingMultipleNeighbour() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field startBeaconingMultipleNeighbour in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
if (single_value.union_selection != AcGnPrimitive::ALT_startBeaconingMultipleNeighbour) TTCN_error("Accessing non-selected field startBeaconingMultipleNeighbour in a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *single_value.field_startBeaconingMultipleNeighbour;
}

AcStopBeaconingMultipleNeighbour_template& AcGnPrimitive_template::stopBeaconingMultipleNeighbour()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != AcGnPrimitive::ALT_stopBeaconingMultipleNeighbour) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_stopBeaconingMultipleNeighbour = new AcStopBeaconingMultipleNeighbour_template(ANY_VALUE);
else single_value.field_stopBeaconingMultipleNeighbour = new AcStopBeaconingMultipleNeighbour_template;
single_value.union_selection = AcGnPrimitive::ALT_stopBeaconingMultipleNeighbour;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_stopBeaconingMultipleNeighbour;
}

const AcStopBeaconingMultipleNeighbour_template& AcGnPrimitive_template::stopBeaconingMultipleNeighbour() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field stopBeaconingMultipleNeighbour in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
if (single_value.union_selection != AcGnPrimitive::ALT_stopBeaconingMultipleNeighbour) TTCN_error("Accessing non-selected field stopBeaconingMultipleNeighbour in a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *single_value.field_stopBeaconingMultipleNeighbour;
}

AcGetLongPosVector_template& AcGnPrimitive_template::getLongPosVector()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != AcGnPrimitive::ALT_getLongPosVector) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_getLongPosVector = new AcGetLongPosVector_template(ANY_VALUE);
else single_value.field_getLongPosVector = new AcGetLongPosVector_template;
single_value.union_selection = AcGnPrimitive::ALT_getLongPosVector;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_getLongPosVector;
}

const AcGetLongPosVector_template& AcGnPrimitive_template::getLongPosVector() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field getLongPosVector in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
if (single_value.union_selection != AcGnPrimitive::ALT_getLongPosVector) TTCN_error("Accessing non-selected field getLongPosVector in a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *single_value.field_getLongPosVector;
}

LibItsSecurity__TypesAndValues::AcEnableSecurity_template& AcGnPrimitive_template::acEnableSecurity()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != AcGnPrimitive::ALT_acEnableSecurity) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_acEnableSecurity = new LibItsSecurity__TypesAndValues::AcEnableSecurity_template(ANY_VALUE);
else single_value.field_acEnableSecurity = new LibItsSecurity__TypesAndValues::AcEnableSecurity_template;
single_value.union_selection = AcGnPrimitive::ALT_acEnableSecurity;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_acEnableSecurity;
}

const LibItsSecurity__TypesAndValues::AcEnableSecurity_template& AcGnPrimitive_template::acEnableSecurity() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field acEnableSecurity in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
if (single_value.union_selection != AcGnPrimitive::ALT_acEnableSecurity) TTCN_error("Accessing non-selected field acEnableSecurity in a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *single_value.field_acEnableSecurity;
}

LibItsSecurity__TypesAndValues::AcDisableSecurity_template& AcGnPrimitive_template::acDisableSecurity()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != AcGnPrimitive::ALT_acDisableSecurity) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_acDisableSecurity = new LibItsSecurity__TypesAndValues::AcDisableSecurity_template(ANY_VALUE);
else single_value.field_acDisableSecurity = new LibItsSecurity__TypesAndValues::AcDisableSecurity_template;
single_value.union_selection = AcGnPrimitive::ALT_acDisableSecurity;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_acDisableSecurity;
}

const LibItsSecurity__TypesAndValues::AcDisableSecurity_template& AcGnPrimitive_template::acDisableSecurity() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field acDisableSecurity in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
if (single_value.union_selection != AcGnPrimitive::ALT_acDisableSecurity) TTCN_error("Accessing non-selected field acDisableSecurity in a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return *single_value.field_acDisableSecurity;
}

boolean AcGnPrimitive_template::ischosen(AcGnPrimitive::union_selection_type checked_selection) const
{
if (checked_selection == AcGnPrimitive::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == AcGnPrimitive::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive");
}
return FALSE;
}

void AcGnPrimitive_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case AcGnPrimitive::ALT_startBeaconing:
TTCN_Logger::log_event_str("{ startBeaconing := ");
single_value.field_startBeaconing->log();
TTCN_Logger::log_event_str(" }");
break;
case AcGnPrimitive::ALT_stopBeaconing:
TTCN_Logger::log_event_str("{ stopBeaconing := ");
single_value.field_stopBeaconing->log();
TTCN_Logger::log_event_str(" }");
break;
case AcGnPrimitive::ALT_startPassBeaconing:
TTCN_Logger::log_event_str("{ startPassBeaconing := ");
single_value.field_startPassBeaconing->log();
TTCN_Logger::log_event_str(" }");
break;
case AcGnPrimitive::ALT_stopPassBeaconing:
TTCN_Logger::log_event_str("{ stopPassBeaconing := ");
single_value.field_stopPassBeaconing->log();
TTCN_Logger::log_event_str(" }");
break;
case AcGnPrimitive::ALT_startBeaconingMultipleNeighbour:
TTCN_Logger::log_event_str("{ startBeaconingMultipleNeighbour := ");
single_value.field_startBeaconingMultipleNeighbour->log();
TTCN_Logger::log_event_str(" }");
break;
case AcGnPrimitive::ALT_stopBeaconingMultipleNeighbour:
TTCN_Logger::log_event_str("{ stopBeaconingMultipleNeighbour := ");
single_value.field_stopBeaconingMultipleNeighbour->log();
TTCN_Logger::log_event_str(" }");
break;
case AcGnPrimitive::ALT_getLongPosVector:
TTCN_Logger::log_event_str("{ getLongPosVector := ");
single_value.field_getLongPosVector->log();
TTCN_Logger::log_event_str(" }");
break;
case AcGnPrimitive::ALT_acEnableSecurity:
TTCN_Logger::log_event_str("{ acEnableSecurity := ");
single_value.field_acEnableSecurity->log();
TTCN_Logger::log_event_str(" }");
break;
case AcGnPrimitive::ALT_acDisableSecurity:
TTCN_Logger::log_event_str("{ acDisableSecurity := ");
single_value.field_acDisableSecurity->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AcGnPrimitive_template::log_match(const AcGnPrimitive& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case AcGnPrimitive::ALT_startBeaconing:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".startBeaconing");
single_value.field_startBeaconing->log_match(match_value.startBeaconing(), legacy);
} else {
TTCN_Logger::log_event_str("{ startBeaconing := ");
single_value.field_startBeaconing->log_match(match_value.startBeaconing(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case AcGnPrimitive::ALT_stopBeaconing:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".stopBeaconing");
single_value.field_stopBeaconing->log_match(match_value.stopBeaconing(), legacy);
} else {
TTCN_Logger::log_event_str("{ stopBeaconing := ");
single_value.field_stopBeaconing->log_match(match_value.stopBeaconing(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case AcGnPrimitive::ALT_startPassBeaconing:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".startPassBeaconing");
single_value.field_startPassBeaconing->log_match(match_value.startPassBeaconing(), legacy);
} else {
TTCN_Logger::log_event_str("{ startPassBeaconing := ");
single_value.field_startPassBeaconing->log_match(match_value.startPassBeaconing(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case AcGnPrimitive::ALT_stopPassBeaconing:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".stopPassBeaconing");
single_value.field_stopPassBeaconing->log_match(match_value.stopPassBeaconing(), legacy);
} else {
TTCN_Logger::log_event_str("{ stopPassBeaconing := ");
single_value.field_stopPassBeaconing->log_match(match_value.stopPassBeaconing(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case AcGnPrimitive::ALT_startBeaconingMultipleNeighbour:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".startBeaconingMultipleNeighbour");
single_value.field_startBeaconingMultipleNeighbour->log_match(match_value.startBeaconingMultipleNeighbour(), legacy);
} else {
TTCN_Logger::log_event_str("{ startBeaconingMultipleNeighbour := ");
single_value.field_startBeaconingMultipleNeighbour->log_match(match_value.startBeaconingMultipleNeighbour(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case AcGnPrimitive::ALT_stopBeaconingMultipleNeighbour:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".stopBeaconingMultipleNeighbour");
single_value.field_stopBeaconingMultipleNeighbour->log_match(match_value.stopBeaconingMultipleNeighbour(), legacy);
} else {
TTCN_Logger::log_event_str("{ stopBeaconingMultipleNeighbour := ");
single_value.field_stopBeaconingMultipleNeighbour->log_match(match_value.stopBeaconingMultipleNeighbour(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case AcGnPrimitive::ALT_getLongPosVector:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".getLongPosVector");
single_value.field_getLongPosVector->log_match(match_value.getLongPosVector(), legacy);
} else {
TTCN_Logger::log_event_str("{ getLongPosVector := ");
single_value.field_getLongPosVector->log_match(match_value.getLongPosVector(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case AcGnPrimitive::ALT_acEnableSecurity:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".acEnableSecurity");
single_value.field_acEnableSecurity->log_match(match_value.acEnableSecurity(), legacy);
} else {
TTCN_Logger::log_event_str("{ acEnableSecurity := ");
single_value.field_acEnableSecurity->log_match(match_value.acEnableSecurity(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case AcGnPrimitive::ALT_acDisableSecurity:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".acDisableSecurity");
single_value.field_acDisableSecurity->log_match(match_value.acDisableSecurity(), legacy);
} else {
TTCN_Logger::log_event_str("{ acDisableSecurity := ");
single_value.field_acDisableSecurity->log_match(match_value.acDisableSecurity(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AcGnPrimitive_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case AcGnPrimitive::ALT_startBeaconing:
single_value.field_startBeaconing->encode_text(text_buf);
break;
case AcGnPrimitive::ALT_stopBeaconing:
single_value.field_stopBeaconing->encode_text(text_buf);
break;
case AcGnPrimitive::ALT_startPassBeaconing:
single_value.field_startPassBeaconing->encode_text(text_buf);
break;
case AcGnPrimitive::ALT_stopPassBeaconing:
single_value.field_stopPassBeaconing->encode_text(text_buf);
break;
case AcGnPrimitive::ALT_startBeaconingMultipleNeighbour:
single_value.field_startBeaconingMultipleNeighbour->encode_text(text_buf);
break;
case AcGnPrimitive::ALT_stopBeaconingMultipleNeighbour:
single_value.field_stopBeaconingMultipleNeighbour->encode_text(text_buf);
break;
case AcGnPrimitive::ALT_getLongPosVector:
single_value.field_getLongPosVector->encode_text(text_buf);
break;
case AcGnPrimitive::ALT_acEnableSecurity:
single_value.field_acEnableSecurity->encode_text(text_buf);
break;
case AcGnPrimitive::ALT_acDisableSecurity:
single_value.field_acDisableSecurity->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
}
}

void AcGnPrimitive_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = AcGnPrimitive::UNBOUND_VALUE;
AcGnPrimitive::union_selection_type new_selection = (AcGnPrimitive::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case AcGnPrimitive::ALT_startBeaconing:
single_value.field_startBeaconing = new AcStartBeaconing_template;
single_value.field_startBeaconing->decode_text(text_buf);
break;
case AcGnPrimitive::ALT_stopBeaconing:
single_value.field_stopBeaconing = new AcStopBeaconing_template;
single_value.field_stopBeaconing->decode_text(text_buf);
break;
case AcGnPrimitive::ALT_startPassBeaconing:
single_value.field_startPassBeaconing = new AcStartPassBeaconing_template;
single_value.field_startPassBeaconing->decode_text(text_buf);
break;
case AcGnPrimitive::ALT_stopPassBeaconing:
single_value.field_stopPassBeaconing = new AcStopPassBeaconing_template;
single_value.field_stopPassBeaconing->decode_text(text_buf);
break;
case AcGnPrimitive::ALT_startBeaconingMultipleNeighbour:
single_value.field_startBeaconingMultipleNeighbour = new AcStartBeaconingMultipleNeighbour_template;
single_value.field_startBeaconingMultipleNeighbour->decode_text(text_buf);
break;
case AcGnPrimitive::ALT_stopBeaconingMultipleNeighbour:
single_value.field_stopBeaconingMultipleNeighbour = new AcStopBeaconingMultipleNeighbour_template;
single_value.field_stopBeaconingMultipleNeighbour->decode_text(text_buf);
break;
case AcGnPrimitive::ALT_getLongPosVector:
single_value.field_getLongPosVector = new AcGetLongPosVector_template;
single_value.field_getLongPosVector->decode_text(text_buf);
break;
case AcGnPrimitive::ALT_acEnableSecurity:
single_value.field_acEnableSecurity = new LibItsSecurity__TypesAndValues::AcEnableSecurity_template;
single_value.field_acEnableSecurity->decode_text(text_buf);
break;
case AcGnPrimitive::ALT_acDisableSecurity:
single_value.field_acDisableSecurity = new LibItsSecurity__TypesAndValues::AcDisableSecurity_template;
single_value.field_acDisableSecurity->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AcGnPrimitive_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
}
}

boolean AcGnPrimitive_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AcGnPrimitive_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void AcGnPrimitive_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive'");
    }
    if (strcmp("startBeaconing", param_field) == 0) {
      startBeaconing().set_param(param);
      return;
    } else if (strcmp("stopBeaconing", param_field) == 0) {
      stopBeaconing().set_param(param);
      return;
    } else if (strcmp("startPassBeaconing", param_field) == 0) {
      startPassBeaconing().set_param(param);
      return;
    } else if (strcmp("stopPassBeaconing", param_field) == 0) {
      stopPassBeaconing().set_param(param);
      return;
    } else if (strcmp("startBeaconingMultipleNeighbour", param_field) == 0) {
      startBeaconingMultipleNeighbour().set_param(param);
      return;
    } else if (strcmp("stopBeaconingMultipleNeighbour", param_field) == 0) {
      stopBeaconingMultipleNeighbour().set_param(param);
      return;
    } else if (strcmp("getLongPosVector", param_field) == 0) {
      getLongPosVector().set_param(param);
      return;
    } else if (strcmp("acEnableSecurity", param_field) == 0) {
      acEnableSecurity().set_param(param);
      return;
    } else if (strcmp("acDisableSecurity", param_field) == 0) {
      acDisableSecurity().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AcGnPrimitive_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "startBeaconing")) {
      startBeaconing().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "stopBeaconing")) {
      stopBeaconing().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "startPassBeaconing")) {
      startPassBeaconing().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "stopPassBeaconing")) {
      stopPassBeaconing().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "startBeaconingMultipleNeighbour")) {
      startBeaconingMultipleNeighbour().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "stopBeaconingMultipleNeighbour")) {
      stopBeaconingMultipleNeighbour().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "getLongPosVector")) {
      getLongPosVector().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "acEnableSecurity")) {
      acEnableSecurity().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "acDisableSecurity")) {
      acDisableSecurity().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AcGnPrimitive_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive'");
    }
    if (strcmp("startBeaconing", param_field) == 0) {
      return startBeaconing().get_param(param_name);
    } else if (strcmp("stopBeaconing", param_field) == 0) {
      return stopBeaconing().get_param(param_name);
    } else if (strcmp("startPassBeaconing", param_field) == 0) {
      return startPassBeaconing().get_param(param_name);
    } else if (strcmp("stopPassBeaconing", param_field) == 0) {
      return stopPassBeaconing().get_param(param_name);
    } else if (strcmp("startBeaconingMultipleNeighbour", param_field) == 0) {
      return startBeaconingMultipleNeighbour().get_param(param_name);
    } else if (strcmp("stopBeaconingMultipleNeighbour", param_field) == 0) {
      return stopBeaconingMultipleNeighbour().get_param(param_name);
    } else if (strcmp("getLongPosVector", param_field) == 0) {
      return getLongPosVector().get_param(param_name);
    } else if (strcmp("acEnableSecurity", param_field) == 0) {
      return acEnableSecurity().get_param(param_name);
    } else if (strcmp("acDisableSecurity", param_field) == 0) {
      return acDisableSecurity().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `AcGnPrimitive'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case AcGnPrimitive::ALT_startBeaconing:
      mp_field = single_value.field_startBeaconing->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("startBeaconing")));
      break;
    case AcGnPrimitive::ALT_stopBeaconing:
      mp_field = single_value.field_stopBeaconing->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("stopBeaconing")));
      break;
    case AcGnPrimitive::ALT_startPassBeaconing:
      mp_field = single_value.field_startPassBeaconing->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("startPassBeaconing")));
      break;
    case AcGnPrimitive::ALT_stopPassBeaconing:
      mp_field = single_value.field_stopPassBeaconing->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("stopPassBeaconing")));
      break;
    case AcGnPrimitive::ALT_startBeaconingMultipleNeighbour:
      mp_field = single_value.field_startBeaconingMultipleNeighbour->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("startBeaconingMultipleNeighbour")));
      break;
    case AcGnPrimitive::ALT_stopBeaconingMultipleNeighbour:
      mp_field = single_value.field_stopBeaconingMultipleNeighbour->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("stopBeaconingMultipleNeighbour")));
      break;
    case AcGnPrimitive::ALT_getLongPosVector:
      mp_field = single_value.field_getLongPosVector->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("getLongPosVector")));
      break;
    case AcGnPrimitive::ALT_acEnableSecurity:
      mp_field = single_value.field_acEnableSecurity->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("acEnableSecurity")));
      break;
    case AcGnPrimitive::ALT_acDisableSecurity:
      mp_field = single_value.field_acDisableSecurity->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("acDisableSecurity")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AcGnPrimitive_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case AcGnPrimitive::ALT_startBeaconing:
single_value.field_startBeaconing->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive");
return;
case AcGnPrimitive::ALT_stopBeaconing:
single_value.field_stopBeaconing->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive");
return;
case AcGnPrimitive::ALT_startPassBeaconing:
single_value.field_startPassBeaconing->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive");
return;
case AcGnPrimitive::ALT_stopPassBeaconing:
single_value.field_stopPassBeaconing->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive");
return;
case AcGnPrimitive::ALT_startBeaconingMultipleNeighbour:
single_value.field_startBeaconingMultipleNeighbour->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive");
return;
case AcGnPrimitive::ALT_stopBeaconingMultipleNeighbour:
single_value.field_stopBeaconingMultipleNeighbour->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive");
return;
case AcGnPrimitive::ALT_getLongPosVector:
single_value.field_getLongPosVector->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive");
return;
case AcGnPrimitive::ALT_acEnableSecurity:
single_value.field_acEnableSecurity->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive");
return;
case AcGnPrimitive::ALT_acDisableSecurity:
single_value.field_acDisableSecurity->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnPrimitive.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcGnPrimitive");
}

AcStartBeaconing::AcStartBeaconing()
{
  bound_flag = FALSE;
}

AcStartBeaconing::AcStartBeaconing(const GeoNetworkingPdu& par_beaconPacket)
  :   field_beaconPacket(par_beaconPacket)
{
  bound_flag = TRUE;
}

AcStartBeaconing::AcStartBeaconing(const AcStartBeaconing& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing.");
bound_flag = TRUE;
if (other_value.beaconPacket().is_bound()) field_beaconPacket = other_value.beaconPacket();
else field_beaconPacket.clean_up();
}

void AcStartBeaconing::clean_up()
{
field_beaconPacket.clean_up();
bound_flag = FALSE;
}

AcStartBeaconing& AcStartBeaconing::operator=(const AcStartBeaconing& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing.");
  bound_flag = TRUE;
  if (other_value.beaconPacket().is_bound()) field_beaconPacket = other_value.beaconPacket();
  else field_beaconPacket.clean_up();
}
return *this;
}

boolean AcStartBeaconing::operator==(const AcStartBeaconing& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_beaconPacket==other_value.field_beaconPacket;
}

boolean AcStartBeaconing::is_bound() const
{
if (bound_flag) return TRUE;
if(field_beaconPacket.is_bound()) return TRUE;
return FALSE;
}
boolean AcStartBeaconing::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_beaconPacket.is_value()) return FALSE;
return TRUE;
}
int AcStartBeaconing::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing");
  return 1;
}

void AcStartBeaconing::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ beaconPacket := ");
field_beaconPacket.log();
TTCN_Logger::log_event_str(" }");
}

void AcStartBeaconing::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.AcStartBeaconing'");
    }
    if (strcmp("beaconPacket", param_field) == 0) {
      beaconPacket().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AcStartBeaconing'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) beaconPacket().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "beaconPacket")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          beaconPacket().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.AcStartBeaconing");
  }
}

Module_Param* AcStartBeaconing::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.AcStartBeaconing'");
    }
    if (strcmp("beaconPacket", param_field) == 0) {
      return beaconPacket().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AcStartBeaconing'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_beaconPacket = field_beaconPacket.get_param(param_name);
  mp_field_beaconPacket->set_id(new Module_Param_FieldName(mcopystr("beaconPacket")));
  mp->add_elem(mp_field_beaconPacket);
  return mp;
  }

void AcStartBeaconing::set_implicit_omit()
{
if (beaconPacket().is_bound()) beaconPacket().set_implicit_omit();
}

void AcStartBeaconing::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing.");
field_beaconPacket.encode_text(text_buf);
}

void AcStartBeaconing::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_beaconPacket.decode_text(text_buf);
}

void AcStartBeaconing::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AcStartBeaconing::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AcStartBeaconing::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_beaconPacket.RAW_decode(GeoNetworkingPdu_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int AcStartBeaconing::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, GeoNetworkingPdu_descr_.raw);
  encoded_length += field_beaconPacket.RAW_encode(GeoNetworkingPdu_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int AcStartBeaconing::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "beaconPacket");
    enc_len += field_beaconPacket.JSON_encode(GeoNetworkingPdu_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AcStartBeaconing::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "beaconPacket", name_len)) {
         int ret_val = field_beaconPacket.JSON_decode(GeoNetworkingPdu_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "beaconPacket");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_beaconPacket.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "beaconPacket");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct AcStartBeaconing_template::single_value_struct {
GeoNetworkingPdu_template field_beaconPacket;
};

void AcStartBeaconing_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_beaconPacket = ANY_VALUE;
}
}
}

void AcStartBeaconing_template::copy_value(const AcStartBeaconing& other_value)
{
single_value = new single_value_struct;
if (other_value.beaconPacket().is_bound()) {
  single_value->field_beaconPacket = other_value.beaconPacket();
} else {
  single_value->field_beaconPacket.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void AcStartBeaconing_template::copy_template(const AcStartBeaconing_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.beaconPacket().get_selection()) {
single_value->field_beaconPacket = other_value.beaconPacket();
} else {
single_value->field_beaconPacket.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AcStartBeaconing_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing.");
break;
}
set_selection(other_value);
}

AcStartBeaconing_template::AcStartBeaconing_template()
{
}

AcStartBeaconing_template::AcStartBeaconing_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AcStartBeaconing_template::AcStartBeaconing_template(const AcStartBeaconing& other_value)
{
copy_value(other_value);
}

AcStartBeaconing_template::AcStartBeaconing_template(const OPTIONAL<AcStartBeaconing>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcStartBeaconing&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing from an unbound optional field.");
}
}

AcStartBeaconing_template::AcStartBeaconing_template(const AcStartBeaconing_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

AcStartBeaconing_template::~AcStartBeaconing_template()
{
clean_up();
}

AcStartBeaconing_template& AcStartBeaconing_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AcStartBeaconing_template& AcStartBeaconing_template::operator=(const AcStartBeaconing& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AcStartBeaconing_template& AcStartBeaconing_template::operator=(const OPTIONAL<AcStartBeaconing>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcStartBeaconing&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing.");
}
return *this;
}

AcStartBeaconing_template& AcStartBeaconing_template::operator=(const AcStartBeaconing_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AcStartBeaconing_template::match(const AcStartBeaconing& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.beaconPacket().is_bound()) return FALSE;
if(!single_value->field_beaconPacket.match(other_value.beaconPacket(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing.");
}
return FALSE;
}

boolean AcStartBeaconing_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_beaconPacket.is_bound()) return TRUE;
return FALSE;
}

boolean AcStartBeaconing_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_beaconPacket.is_value()) return FALSE;
return TRUE;
}

void AcStartBeaconing_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AcStartBeaconing AcStartBeaconing_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing.");
AcStartBeaconing ret_val;
if (single_value->field_beaconPacket.is_bound()) {
ret_val.beaconPacket() = single_value->field_beaconPacket.valueof();
}
return ret_val;
}

void AcStartBeaconing_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AcStartBeaconing_template[list_length];
}

AcStartBeaconing_template& AcStartBeaconing_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing.");
return value_list.list_value[list_index];
}

GeoNetworkingPdu_template& AcStartBeaconing_template::beaconPacket()
{
set_specific();
return single_value->field_beaconPacket;
}

const GeoNetworkingPdu_template& AcStartBeaconing_template::beaconPacket() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field beaconPacket of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing.");
return single_value->field_beaconPacket;
}

int AcStartBeaconing_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing.");
  }
  return 0;
}

void AcStartBeaconing_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ beaconPacket := ");
single_value->field_beaconPacket.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AcStartBeaconing_template::log_match(const AcStartBeaconing& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_beaconPacket.match(match_value.beaconPacket(), legacy)){
TTCN_Logger::log_logmatch_info(".beaconPacket");
single_value->field_beaconPacket.log_match(match_value.beaconPacket(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ beaconPacket := ");
single_value->field_beaconPacket.log_match(match_value.beaconPacket(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AcStartBeaconing_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_beaconPacket.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing.");
}
}

void AcStartBeaconing_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_beaconPacket.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AcStartBeaconing_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing.");
}
}

void AcStartBeaconing_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.AcStartBeaconing'");
    }
    if (strcmp("beaconPacket", param_field) == 0) {
      beaconPacket().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.AcStartBeaconing'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AcStartBeaconing_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) beaconPacket().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "beaconPacket")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          beaconPacket().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconing: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.AcStartBeaconing");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AcStartBeaconing_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.AcStartBeaconing'");
    }
    if (strcmp("beaconPacket", param_field) == 0) {
      return beaconPacket().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AcStartBeaconing'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_beaconPacket = single_value->field_beaconPacket.get_param(param_name);
    mp_field_beaconPacket->set_id(new Module_Param_FieldName(mcopystr("beaconPacket")));
    mp->add_elem(mp_field_beaconPacket);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AcStartBeaconing_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_beaconPacket.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcStartBeaconing");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcStartBeaconing");
}

boolean AcStartBeaconing_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AcStartBeaconing_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

AcStopBeaconing::AcStopBeaconing()
{
bound_flag = FALSE;
}

AcStopBeaconing::AcStopBeaconing(null_type)
{
bound_flag = TRUE;
}

AcStopBeaconing::AcStopBeaconing(const AcStopBeaconing& other_value)
{
other_value.must_bound("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
bound_flag = TRUE;
}

AcStopBeaconing& AcStopBeaconing::operator=(null_type)
{
bound_flag = TRUE;
return *this;
}

AcStopBeaconing& AcStopBeaconing::operator=(const AcStopBeaconing& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
bound_flag = TRUE;
return *this;
}

boolean AcStopBeaconing::operator==(null_type) const
{
must_bound("Comparison of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
return TRUE;
}

boolean AcStopBeaconing::operator==(const AcStopBeaconing& other_value) const
{
must_bound("Comparison of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
other_value.must_bound("Comparison of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
return TRUE;
}

void AcStopBeaconing::log() const
{
if (bound_flag) TTCN_Logger::log_event_str("{ }");
else TTCN_Logger::log_event_unbound();
}

void AcStopBeaconing::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "empty record/set value (i.e. { })");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Value_List || mp->get_size()>0) {
    param.type_error("empty record/set value (i.e. { })", "@LibItsGeoNetworking_TypesAndValues.AcStopBeaconing");
  }
  bound_flag = TRUE;
}

Module_Param* AcStopBeaconing::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Value_List();
}

void AcStopBeaconing::encode_text(Text_Buf& /*text_buf*/) const
{
must_bound("Text encoder: Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
}

void AcStopBeaconing::decode_text(Text_Buf& /*text_buf*/)
{
bound_flag = TRUE;
}

void AcStopBeaconing::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AcStopBeaconing::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AcStopBeaconing::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& /*myleaf*/) const
{
if (!bound_flag) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value of type %s.", p_td.name);
return 0;
}

int AcStopBeaconing::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int, raw_order_t, boolean, int, boolean)
{
bound_flag = TRUE;
return p_buf.increase_pos_padd(p_td.raw->prepadding) + p_buf.increase_pos_padd(p_td.raw->padding);
}

int AcStopBeaconing::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
    return -1;
  }

  return p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL) + 
    p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
}

int AcStopBeaconing::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  bound_flag = true;

  return dec_len;
}

void AcStopBeaconing_template::copy_template(const AcStopBeaconing_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AcStopBeaconing_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
break;
}
}

AcStopBeaconing_template::AcStopBeaconing_template()
{
}

AcStopBeaconing_template::AcStopBeaconing_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AcStopBeaconing_template::AcStopBeaconing_template(null_type)
 : Base_Template(SPECIFIC_VALUE)
{
}

AcStopBeaconing_template::AcStopBeaconing_template(const AcStopBeaconing& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
other_value.must_bound("Creating a template from an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
}

AcStopBeaconing_template::AcStopBeaconing_template(const OPTIONAL<AcStopBeaconing>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing from an unbound optional field.");
}
}

AcStopBeaconing_template::AcStopBeaconing_template(const AcStopBeaconing_template& other_value)
: Base_Template(){
copy_template(other_value);
}

AcStopBeaconing_template::~AcStopBeaconing_template()
{
clean_up();
}

void AcStopBeaconing_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST)
delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

AcStopBeaconing_template& AcStopBeaconing_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AcStopBeaconing_template& AcStopBeaconing_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

AcStopBeaconing_template& AcStopBeaconing_template::operator=(const AcStopBeaconing& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

AcStopBeaconing_template& AcStopBeaconing_template::operator=(const OPTIONAL<AcStopBeaconing>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
}
return *this;
}

AcStopBeaconing_template& AcStopBeaconing_template::operator=(const AcStopBeaconing_template& other_value)
{
if (&other_value != this) {
clean_up();
set_selection(other_value);
}
return *this;
}

boolean AcStopBeaconing_template::match(null_type other_value,boolean) const
{
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
return TRUE;
case OMIT_VALUE:
return FALSE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
}
return FALSE;
}

boolean AcStopBeaconing_template::match(const AcStopBeaconing& other_value, boolean) const
{
if (!other_value.is_bound()) return FALSE;return match(NULL_VALUE);
}

AcStopBeaconing AcStopBeaconing_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
return NULL_VALUE;
}

void AcStopBeaconing_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AcStopBeaconing_template[list_length];
}

AcStopBeaconing_template& AcStopBeaconing_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
return value_list.list_value[list_index];
}

void AcStopBeaconing_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AcStopBeaconing_template::log_match(const AcStopBeaconing& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void AcStopBeaconing_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
}
}

void AcStopBeaconing_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AcStopBeaconing_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
}
}

void AcStopBeaconing_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "empty record/set template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AcStopBeaconing_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()>0) param.type_error("empty record/set template", "@LibItsGeoNetworking_TypesAndValues.AcStopBeaconing");
    *this = NULL_VALUE;
    break;
  default:
    param.type_error("empty record/set template", "@LibItsGeoNetworking_TypesAndValues.AcStopBeaconing");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AcStopBeaconing_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Value_List();
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AcStopBeaconing_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcStopBeaconing");
}

boolean AcStopBeaconing_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AcStopBeaconing_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

AcStartPassBeaconing::AcStartPassBeaconing()
{
  bound_flag = FALSE;
}

AcStartPassBeaconing::AcStartPassBeaconing(const BeaconHeader& par_beaconHeader)
  :   field_beaconHeader(par_beaconHeader)
{
  bound_flag = TRUE;
}

AcStartPassBeaconing::AcStartPassBeaconing(const AcStartPassBeaconing& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing.");
bound_flag = TRUE;
if (other_value.beaconHeader().is_bound()) field_beaconHeader = other_value.beaconHeader();
else field_beaconHeader.clean_up();
}

void AcStartPassBeaconing::clean_up()
{
field_beaconHeader.clean_up();
bound_flag = FALSE;
}

AcStartPassBeaconing& AcStartPassBeaconing::operator=(const AcStartPassBeaconing& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing.");
  bound_flag = TRUE;
  if (other_value.beaconHeader().is_bound()) field_beaconHeader = other_value.beaconHeader();
  else field_beaconHeader.clean_up();
}
return *this;
}

boolean AcStartPassBeaconing::operator==(const AcStartPassBeaconing& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_beaconHeader==other_value.field_beaconHeader;
}

boolean AcStartPassBeaconing::is_bound() const
{
if (bound_flag) return TRUE;
if(field_beaconHeader.is_bound()) return TRUE;
return FALSE;
}
boolean AcStartPassBeaconing::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_beaconHeader.is_value()) return FALSE;
return TRUE;
}
int AcStartPassBeaconing::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing");
  return 1;
}

void AcStartPassBeaconing::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ beaconHeader := ");
field_beaconHeader.log();
TTCN_Logger::log_event_str(" }");
}

void AcStartPassBeaconing::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing'");
    }
    if (strcmp("beaconHeader", param_field) == 0) {
      beaconHeader().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) beaconHeader().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "beaconHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          beaconHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing");
  }
}

Module_Param* AcStartPassBeaconing::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing'");
    }
    if (strcmp("beaconHeader", param_field) == 0) {
      return beaconHeader().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_beaconHeader = field_beaconHeader.get_param(param_name);
  mp_field_beaconHeader->set_id(new Module_Param_FieldName(mcopystr("beaconHeader")));
  mp->add_elem(mp_field_beaconHeader);
  return mp;
  }

void AcStartPassBeaconing::set_implicit_omit()
{
if (beaconHeader().is_bound()) beaconHeader().set_implicit_omit();
}

void AcStartPassBeaconing::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing.");
field_beaconHeader.encode_text(text_buf);
}

void AcStartPassBeaconing::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_beaconHeader.decode_text(text_buf);
}

void AcStartPassBeaconing::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AcStartPassBeaconing::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AcStartPassBeaconing::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_beaconHeader.RAW_decode(BeaconHeader_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int AcStartPassBeaconing::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, BeaconHeader_descr_.raw);
  encoded_length += field_beaconHeader.RAW_encode(BeaconHeader_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int AcStartPassBeaconing::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "beaconHeader");
    enc_len += field_beaconHeader.JSON_encode(BeaconHeader_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AcStartPassBeaconing::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "beaconHeader", name_len)) {
         int ret_val = field_beaconHeader.JSON_decode(BeaconHeader_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "beaconHeader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_beaconHeader.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "beaconHeader");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct AcStartPassBeaconing_template::single_value_struct {
BeaconHeader_template field_beaconHeader;
};

void AcStartPassBeaconing_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_beaconHeader = ANY_VALUE;
}
}
}

void AcStartPassBeaconing_template::copy_value(const AcStartPassBeaconing& other_value)
{
single_value = new single_value_struct;
if (other_value.beaconHeader().is_bound()) {
  single_value->field_beaconHeader = other_value.beaconHeader();
} else {
  single_value->field_beaconHeader.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void AcStartPassBeaconing_template::copy_template(const AcStartPassBeaconing_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.beaconHeader().get_selection()) {
single_value->field_beaconHeader = other_value.beaconHeader();
} else {
single_value->field_beaconHeader.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AcStartPassBeaconing_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing.");
break;
}
set_selection(other_value);
}

AcStartPassBeaconing_template::AcStartPassBeaconing_template()
{
}

AcStartPassBeaconing_template::AcStartPassBeaconing_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AcStartPassBeaconing_template::AcStartPassBeaconing_template(const AcStartPassBeaconing& other_value)
{
copy_value(other_value);
}

AcStartPassBeaconing_template::AcStartPassBeaconing_template(const OPTIONAL<AcStartPassBeaconing>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcStartPassBeaconing&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing from an unbound optional field.");
}
}

AcStartPassBeaconing_template::AcStartPassBeaconing_template(const AcStartPassBeaconing_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

AcStartPassBeaconing_template::~AcStartPassBeaconing_template()
{
clean_up();
}

AcStartPassBeaconing_template& AcStartPassBeaconing_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AcStartPassBeaconing_template& AcStartPassBeaconing_template::operator=(const AcStartPassBeaconing& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AcStartPassBeaconing_template& AcStartPassBeaconing_template::operator=(const OPTIONAL<AcStartPassBeaconing>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcStartPassBeaconing&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing.");
}
return *this;
}

AcStartPassBeaconing_template& AcStartPassBeaconing_template::operator=(const AcStartPassBeaconing_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AcStartPassBeaconing_template::match(const AcStartPassBeaconing& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.beaconHeader().is_bound()) return FALSE;
if(!single_value->field_beaconHeader.match(other_value.beaconHeader(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing.");
}
return FALSE;
}

boolean AcStartPassBeaconing_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_beaconHeader.is_bound()) return TRUE;
return FALSE;
}

boolean AcStartPassBeaconing_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_beaconHeader.is_value()) return FALSE;
return TRUE;
}

void AcStartPassBeaconing_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AcStartPassBeaconing AcStartPassBeaconing_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing.");
AcStartPassBeaconing ret_val;
if (single_value->field_beaconHeader.is_bound()) {
ret_val.beaconHeader() = single_value->field_beaconHeader.valueof();
}
return ret_val;
}

void AcStartPassBeaconing_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AcStartPassBeaconing_template[list_length];
}

AcStartPassBeaconing_template& AcStartPassBeaconing_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing.");
return value_list.list_value[list_index];
}

BeaconHeader_template& AcStartPassBeaconing_template::beaconHeader()
{
set_specific();
return single_value->field_beaconHeader;
}

const BeaconHeader_template& AcStartPassBeaconing_template::beaconHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field beaconHeader of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing.");
return single_value->field_beaconHeader;
}

int AcStartPassBeaconing_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing.");
  }
  return 0;
}

void AcStartPassBeaconing_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ beaconHeader := ");
single_value->field_beaconHeader.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AcStartPassBeaconing_template::log_match(const AcStartPassBeaconing& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_beaconHeader.match(match_value.beaconHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".beaconHeader");
single_value->field_beaconHeader.log_match(match_value.beaconHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ beaconHeader := ");
single_value->field_beaconHeader.log_match(match_value.beaconHeader(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AcStartPassBeaconing_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_beaconHeader.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing.");
}
}

void AcStartPassBeaconing_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_beaconHeader.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AcStartPassBeaconing_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing.");
}
}

void AcStartPassBeaconing_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing'");
    }
    if (strcmp("beaconHeader", param_field) == 0) {
      beaconHeader().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AcStartPassBeaconing_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) beaconHeader().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "beaconHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          beaconHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AcStartPassBeaconing_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing'");
    }
    if (strcmp("beaconHeader", param_field) == 0) {
      return beaconHeader().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_beaconHeader = single_value->field_beaconHeader.get_param(param_name);
    mp_field_beaconHeader->set_id(new Module_Param_FieldName(mcopystr("beaconHeader")));
    mp->add_elem(mp_field_beaconHeader);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AcStartPassBeaconing_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_beaconHeader.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcStartPassBeaconing");
}

boolean AcStartPassBeaconing_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AcStartPassBeaconing_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

AcStopPassBeaconing::AcStopPassBeaconing()
{
bound_flag = FALSE;
}

AcStopPassBeaconing::AcStopPassBeaconing(null_type)
{
bound_flag = TRUE;
}

AcStopPassBeaconing::AcStopPassBeaconing(const AcStopPassBeaconing& other_value)
{
other_value.must_bound("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
bound_flag = TRUE;
}

AcStopPassBeaconing& AcStopPassBeaconing::operator=(null_type)
{
bound_flag = TRUE;
return *this;
}

AcStopPassBeaconing& AcStopPassBeaconing::operator=(const AcStopPassBeaconing& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
bound_flag = TRUE;
return *this;
}

boolean AcStopPassBeaconing::operator==(null_type) const
{
must_bound("Comparison of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
return TRUE;
}

boolean AcStopPassBeaconing::operator==(const AcStopPassBeaconing& other_value) const
{
must_bound("Comparison of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
other_value.must_bound("Comparison of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
return TRUE;
}

void AcStopPassBeaconing::log() const
{
if (bound_flag) TTCN_Logger::log_event_str("{ }");
else TTCN_Logger::log_event_unbound();
}

void AcStopPassBeaconing::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "empty record/set value (i.e. { })");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Value_List || mp->get_size()>0) {
    param.type_error("empty record/set value (i.e. { })", "@LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing");
  }
  bound_flag = TRUE;
}

Module_Param* AcStopPassBeaconing::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Value_List();
}

void AcStopPassBeaconing::encode_text(Text_Buf& /*text_buf*/) const
{
must_bound("Text encoder: Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
}

void AcStopPassBeaconing::decode_text(Text_Buf& /*text_buf*/)
{
bound_flag = TRUE;
}

void AcStopPassBeaconing::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AcStopPassBeaconing::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AcStopPassBeaconing::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& /*myleaf*/) const
{
if (!bound_flag) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value of type %s.", p_td.name);
return 0;
}

int AcStopPassBeaconing::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int, raw_order_t, boolean, int, boolean)
{
bound_flag = TRUE;
return p_buf.increase_pos_padd(p_td.raw->prepadding) + p_buf.increase_pos_padd(p_td.raw->padding);
}

int AcStopPassBeaconing::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
    return -1;
  }

  return p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL) + 
    p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
}

int AcStopPassBeaconing::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  bound_flag = true;

  return dec_len;
}

void AcStopPassBeaconing_template::copy_template(const AcStopPassBeaconing_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AcStopPassBeaconing_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
break;
}
}

AcStopPassBeaconing_template::AcStopPassBeaconing_template()
{
}

AcStopPassBeaconing_template::AcStopPassBeaconing_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AcStopPassBeaconing_template::AcStopPassBeaconing_template(null_type)
 : Base_Template(SPECIFIC_VALUE)
{
}

AcStopPassBeaconing_template::AcStopPassBeaconing_template(const AcStopPassBeaconing& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
other_value.must_bound("Creating a template from an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
}

AcStopPassBeaconing_template::AcStopPassBeaconing_template(const OPTIONAL<AcStopPassBeaconing>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing from an unbound optional field.");
}
}

AcStopPassBeaconing_template::AcStopPassBeaconing_template(const AcStopPassBeaconing_template& other_value)
: Base_Template(){
copy_template(other_value);
}

AcStopPassBeaconing_template::~AcStopPassBeaconing_template()
{
clean_up();
}

void AcStopPassBeaconing_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST)
delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

AcStopPassBeaconing_template& AcStopPassBeaconing_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AcStopPassBeaconing_template& AcStopPassBeaconing_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

AcStopPassBeaconing_template& AcStopPassBeaconing_template::operator=(const AcStopPassBeaconing& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

AcStopPassBeaconing_template& AcStopPassBeaconing_template::operator=(const OPTIONAL<AcStopPassBeaconing>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
}
return *this;
}

AcStopPassBeaconing_template& AcStopPassBeaconing_template::operator=(const AcStopPassBeaconing_template& other_value)
{
if (&other_value != this) {
clean_up();
set_selection(other_value);
}
return *this;
}

boolean AcStopPassBeaconing_template::match(null_type other_value,boolean) const
{
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
return TRUE;
case OMIT_VALUE:
return FALSE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
}
return FALSE;
}

boolean AcStopPassBeaconing_template::match(const AcStopPassBeaconing& other_value, boolean) const
{
if (!other_value.is_bound()) return FALSE;return match(NULL_VALUE);
}

AcStopPassBeaconing AcStopPassBeaconing_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
return NULL_VALUE;
}

void AcStopPassBeaconing_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AcStopPassBeaconing_template[list_length];
}

AcStopPassBeaconing_template& AcStopPassBeaconing_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
return value_list.list_value[list_index];
}

void AcStopPassBeaconing_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AcStopPassBeaconing_template::log_match(const AcStopPassBeaconing& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void AcStopPassBeaconing_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
}
}

void AcStopPassBeaconing_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AcStopPassBeaconing_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
}
}

void AcStopPassBeaconing_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "empty record/set template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AcStopPassBeaconing_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()>0) param.type_error("empty record/set template", "@LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing");
    *this = NULL_VALUE;
    break;
  default:
    param.type_error("empty record/set template", "@LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AcStopPassBeaconing_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Value_List();
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AcStopPassBeaconing_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing");
}

boolean AcStopPassBeaconing_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AcStopPassBeaconing_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

AcStartBeaconingMultipleNeighbour::AcStartBeaconingMultipleNeighbour()
{
  bound_flag = FALSE;
}

AcStartBeaconingMultipleNeighbour::AcStartBeaconingMultipleNeighbour(const GeoNetworkingPdu& par_beaconPacket,
    const INTEGER& par_numberOfNeighbour)
  :   field_beaconPacket(par_beaconPacket),
  field_numberOfNeighbour(par_numberOfNeighbour)
{
  bound_flag = TRUE;
}

AcStartBeaconingMultipleNeighbour::AcStartBeaconingMultipleNeighbour(const AcStartBeaconingMultipleNeighbour& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour.");
bound_flag = TRUE;
if (other_value.beaconPacket().is_bound()) field_beaconPacket = other_value.beaconPacket();
else field_beaconPacket.clean_up();
if (other_value.numberOfNeighbour().is_bound()) field_numberOfNeighbour = other_value.numberOfNeighbour();
else field_numberOfNeighbour.clean_up();
}

void AcStartBeaconingMultipleNeighbour::clean_up()
{
field_beaconPacket.clean_up();
field_numberOfNeighbour.clean_up();
bound_flag = FALSE;
}

AcStartBeaconingMultipleNeighbour& AcStartBeaconingMultipleNeighbour::operator=(const AcStartBeaconingMultipleNeighbour& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour.");
  bound_flag = TRUE;
  if (other_value.beaconPacket().is_bound()) field_beaconPacket = other_value.beaconPacket();
  else field_beaconPacket.clean_up();
  if (other_value.numberOfNeighbour().is_bound()) field_numberOfNeighbour = other_value.numberOfNeighbour();
  else field_numberOfNeighbour.clean_up();
}
return *this;
}

boolean AcStartBeaconingMultipleNeighbour::operator==(const AcStartBeaconingMultipleNeighbour& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_beaconPacket==other_value.field_beaconPacket
  && field_numberOfNeighbour==other_value.field_numberOfNeighbour;
}

boolean AcStartBeaconingMultipleNeighbour::is_bound() const
{
if (bound_flag) return TRUE;
if(field_beaconPacket.is_bound()) return TRUE;
if(field_numberOfNeighbour.is_bound()) return TRUE;
return FALSE;
}
boolean AcStartBeaconingMultipleNeighbour::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_beaconPacket.is_value()) return FALSE;
if(!field_numberOfNeighbour.is_value()) return FALSE;
return TRUE;
}
int AcStartBeaconingMultipleNeighbour::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour");
  return 2;
}

void AcStartBeaconingMultipleNeighbour::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ beaconPacket := ");
field_beaconPacket.log();
TTCN_Logger::log_event_str(", numberOfNeighbour := ");
field_numberOfNeighbour.log();
TTCN_Logger::log_event_str(" }");
}

void AcStartBeaconingMultipleNeighbour::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour'");
    }
    if (strcmp("beaconPacket", param_field) == 0) {
      beaconPacket().set_param(param);
      return;
    } else if (strcmp("numberOfNeighbour", param_field) == 0) {
      numberOfNeighbour().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) beaconPacket().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) numberOfNeighbour().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "beaconPacket")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          beaconPacket().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "numberOfNeighbour")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          numberOfNeighbour().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour");
  }
}

Module_Param* AcStartBeaconingMultipleNeighbour::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour'");
    }
    if (strcmp("beaconPacket", param_field) == 0) {
      return beaconPacket().get_param(param_name);
    } else if (strcmp("numberOfNeighbour", param_field) == 0) {
      return numberOfNeighbour().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_beaconPacket = field_beaconPacket.get_param(param_name);
  mp_field_beaconPacket->set_id(new Module_Param_FieldName(mcopystr("beaconPacket")));
  mp->add_elem(mp_field_beaconPacket);
  Module_Param* mp_field_numberOfNeighbour = field_numberOfNeighbour.get_param(param_name);
  mp_field_numberOfNeighbour->set_id(new Module_Param_FieldName(mcopystr("numberOfNeighbour")));
  mp->add_elem(mp_field_numberOfNeighbour);
  return mp;
  }

void AcStartBeaconingMultipleNeighbour::set_implicit_omit()
{
if (beaconPacket().is_bound()) beaconPacket().set_implicit_omit();
if (numberOfNeighbour().is_bound()) numberOfNeighbour().set_implicit_omit();
}

void AcStartBeaconingMultipleNeighbour::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour.");
field_beaconPacket.encode_text(text_buf);
field_numberOfNeighbour.encode_text(text_buf);
}

void AcStartBeaconingMultipleNeighbour::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_beaconPacket.decode_text(text_buf);
field_numberOfNeighbour.decode_text(text_buf);
}

void AcStartBeaconingMultipleNeighbour::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AcStartBeaconingMultipleNeighbour::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AcStartBeaconingMultipleNeighbour::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_beaconPacket.RAW_decode(GeoNetworkingPdu_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_numberOfNeighbour.RAW_decode(INTEGER_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int AcStartBeaconingMultipleNeighbour::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, GeoNetworkingPdu_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, INTEGER_descr_.raw);
  encoded_length += field_beaconPacket.RAW_encode(GeoNetworkingPdu_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_numberOfNeighbour.RAW_encode(INTEGER_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int AcStartBeaconingMultipleNeighbour::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "beaconPacket");
    enc_len += field_beaconPacket.JSON_encode(GeoNetworkingPdu_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "numberOfNeighbour");
    enc_len += field_numberOfNeighbour.JSON_encode(INTEGER_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AcStartBeaconingMultipleNeighbour::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "beaconPacket", name_len)) {
         int ret_val = field_beaconPacket.JSON_decode(GeoNetworkingPdu_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "beaconPacket");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "numberOfNeighbour", name_len)) {
         int ret_val = field_numberOfNeighbour.JSON_decode(INTEGER_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "numberOfNeighbour");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_beaconPacket.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "beaconPacket");
    return JSON_ERROR_FATAL;
  }
if (!field_numberOfNeighbour.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "numberOfNeighbour");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct AcStartBeaconingMultipleNeighbour_template::single_value_struct {
GeoNetworkingPdu_template field_beaconPacket;
INTEGER_template field_numberOfNeighbour;
};

void AcStartBeaconingMultipleNeighbour_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_beaconPacket = ANY_VALUE;
single_value->field_numberOfNeighbour = ANY_VALUE;
}
}
}

void AcStartBeaconingMultipleNeighbour_template::copy_value(const AcStartBeaconingMultipleNeighbour& other_value)
{
single_value = new single_value_struct;
if (other_value.beaconPacket().is_bound()) {
  single_value->field_beaconPacket = other_value.beaconPacket();
} else {
  single_value->field_beaconPacket.clean_up();
}
if (other_value.numberOfNeighbour().is_bound()) {
  single_value->field_numberOfNeighbour = other_value.numberOfNeighbour();
} else {
  single_value->field_numberOfNeighbour.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void AcStartBeaconingMultipleNeighbour_template::copy_template(const AcStartBeaconingMultipleNeighbour_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.beaconPacket().get_selection()) {
single_value->field_beaconPacket = other_value.beaconPacket();
} else {
single_value->field_beaconPacket.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.numberOfNeighbour().get_selection()) {
single_value->field_numberOfNeighbour = other_value.numberOfNeighbour();
} else {
single_value->field_numberOfNeighbour.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AcStartBeaconingMultipleNeighbour_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour.");
break;
}
set_selection(other_value);
}

AcStartBeaconingMultipleNeighbour_template::AcStartBeaconingMultipleNeighbour_template()
{
}

AcStartBeaconingMultipleNeighbour_template::AcStartBeaconingMultipleNeighbour_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AcStartBeaconingMultipleNeighbour_template::AcStartBeaconingMultipleNeighbour_template(const AcStartBeaconingMultipleNeighbour& other_value)
{
copy_value(other_value);
}

AcStartBeaconingMultipleNeighbour_template::AcStartBeaconingMultipleNeighbour_template(const OPTIONAL<AcStartBeaconingMultipleNeighbour>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcStartBeaconingMultipleNeighbour&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour from an unbound optional field.");
}
}

AcStartBeaconingMultipleNeighbour_template::AcStartBeaconingMultipleNeighbour_template(const AcStartBeaconingMultipleNeighbour_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

AcStartBeaconingMultipleNeighbour_template::~AcStartBeaconingMultipleNeighbour_template()
{
clean_up();
}

AcStartBeaconingMultipleNeighbour_template& AcStartBeaconingMultipleNeighbour_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AcStartBeaconingMultipleNeighbour_template& AcStartBeaconingMultipleNeighbour_template::operator=(const AcStartBeaconingMultipleNeighbour& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AcStartBeaconingMultipleNeighbour_template& AcStartBeaconingMultipleNeighbour_template::operator=(const OPTIONAL<AcStartBeaconingMultipleNeighbour>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcStartBeaconingMultipleNeighbour&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour.");
}
return *this;
}

AcStartBeaconingMultipleNeighbour_template& AcStartBeaconingMultipleNeighbour_template::operator=(const AcStartBeaconingMultipleNeighbour_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AcStartBeaconingMultipleNeighbour_template::match(const AcStartBeaconingMultipleNeighbour& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.beaconPacket().is_bound()) return FALSE;
if(!single_value->field_beaconPacket.match(other_value.beaconPacket(), legacy))return FALSE;
if(!other_value.numberOfNeighbour().is_bound()) return FALSE;
if(!single_value->field_numberOfNeighbour.match(other_value.numberOfNeighbour(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour.");
}
return FALSE;
}

boolean AcStartBeaconingMultipleNeighbour_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_beaconPacket.is_bound()) return TRUE;
if (single_value->field_numberOfNeighbour.is_bound()) return TRUE;
return FALSE;
}

boolean AcStartBeaconingMultipleNeighbour_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_beaconPacket.is_value()) return FALSE;
if (!single_value->field_numberOfNeighbour.is_value()) return FALSE;
return TRUE;
}

void AcStartBeaconingMultipleNeighbour_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AcStartBeaconingMultipleNeighbour AcStartBeaconingMultipleNeighbour_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour.");
AcStartBeaconingMultipleNeighbour ret_val;
if (single_value->field_beaconPacket.is_bound()) {
ret_val.beaconPacket() = single_value->field_beaconPacket.valueof();
}
if (single_value->field_numberOfNeighbour.is_bound()) {
ret_val.numberOfNeighbour() = single_value->field_numberOfNeighbour.valueof();
}
return ret_val;
}

void AcStartBeaconingMultipleNeighbour_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AcStartBeaconingMultipleNeighbour_template[list_length];
}

AcStartBeaconingMultipleNeighbour_template& AcStartBeaconingMultipleNeighbour_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour.");
return value_list.list_value[list_index];
}

GeoNetworkingPdu_template& AcStartBeaconingMultipleNeighbour_template::beaconPacket()
{
set_specific();
return single_value->field_beaconPacket;
}

const GeoNetworkingPdu_template& AcStartBeaconingMultipleNeighbour_template::beaconPacket() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field beaconPacket of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour.");
return single_value->field_beaconPacket;
}

INTEGER_template& AcStartBeaconingMultipleNeighbour_template::numberOfNeighbour()
{
set_specific();
return single_value->field_numberOfNeighbour;
}

const INTEGER_template& AcStartBeaconingMultipleNeighbour_template::numberOfNeighbour() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field numberOfNeighbour of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour.");
return single_value->field_numberOfNeighbour;
}

int AcStartBeaconingMultipleNeighbour_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour.");
  }
  return 0;
}

void AcStartBeaconingMultipleNeighbour_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ beaconPacket := ");
single_value->field_beaconPacket.log();
TTCN_Logger::log_event_str(", numberOfNeighbour := ");
single_value->field_numberOfNeighbour.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AcStartBeaconingMultipleNeighbour_template::log_match(const AcStartBeaconingMultipleNeighbour& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_beaconPacket.match(match_value.beaconPacket(), legacy)){
TTCN_Logger::log_logmatch_info(".beaconPacket");
single_value->field_beaconPacket.log_match(match_value.beaconPacket(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_numberOfNeighbour.match(match_value.numberOfNeighbour(), legacy)){
TTCN_Logger::log_logmatch_info(".numberOfNeighbour");
single_value->field_numberOfNeighbour.log_match(match_value.numberOfNeighbour(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ beaconPacket := ");
single_value->field_beaconPacket.log_match(match_value.beaconPacket(), legacy);
TTCN_Logger::log_event_str(", numberOfNeighbour := ");
single_value->field_numberOfNeighbour.log_match(match_value.numberOfNeighbour(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AcStartBeaconingMultipleNeighbour_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_beaconPacket.encode_text(text_buf);
single_value->field_numberOfNeighbour.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour.");
}
}

void AcStartBeaconingMultipleNeighbour_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_beaconPacket.decode_text(text_buf);
single_value->field_numberOfNeighbour.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AcStartBeaconingMultipleNeighbour_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour.");
}
}

void AcStartBeaconingMultipleNeighbour_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour'");
    }
    if (strcmp("beaconPacket", param_field) == 0) {
      beaconPacket().set_param(param);
      return;
    } else if (strcmp("numberOfNeighbour", param_field) == 0) {
      numberOfNeighbour().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AcStartBeaconingMultipleNeighbour_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) beaconPacket().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) numberOfNeighbour().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "beaconPacket")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          beaconPacket().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "numberOfNeighbour")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          numberOfNeighbour().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AcStartBeaconingMultipleNeighbour_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour'");
    }
    if (strcmp("beaconPacket", param_field) == 0) {
      return beaconPacket().get_param(param_name);
    } else if (strcmp("numberOfNeighbour", param_field) == 0) {
      return numberOfNeighbour().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_beaconPacket = single_value->field_beaconPacket.get_param(param_name);
    mp_field_beaconPacket->set_id(new Module_Param_FieldName(mcopystr("beaconPacket")));
    mp->add_elem(mp_field_beaconPacket);
    Module_Param* mp_field_numberOfNeighbour = single_value->field_numberOfNeighbour.get_param(param_name);
    mp_field_numberOfNeighbour->set_id(new Module_Param_FieldName(mcopystr("numberOfNeighbour")));
    mp->add_elem(mp_field_numberOfNeighbour);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AcStartBeaconingMultipleNeighbour_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_beaconPacket.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour");
single_value->field_numberOfNeighbour.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcStartBeaconingMultipleNeighbour");
}

boolean AcStartBeaconingMultipleNeighbour_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AcStartBeaconingMultipleNeighbour_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

AcStopBeaconingMultipleNeighbour::AcStopBeaconingMultipleNeighbour()
{
bound_flag = FALSE;
}

AcStopBeaconingMultipleNeighbour::AcStopBeaconingMultipleNeighbour(null_type)
{
bound_flag = TRUE;
}

AcStopBeaconingMultipleNeighbour::AcStopBeaconingMultipleNeighbour(const AcStopBeaconingMultipleNeighbour& other_value)
{
other_value.must_bound("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
bound_flag = TRUE;
}

AcStopBeaconingMultipleNeighbour& AcStopBeaconingMultipleNeighbour::operator=(null_type)
{
bound_flag = TRUE;
return *this;
}

AcStopBeaconingMultipleNeighbour& AcStopBeaconingMultipleNeighbour::operator=(const AcStopBeaconingMultipleNeighbour& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
bound_flag = TRUE;
return *this;
}

boolean AcStopBeaconingMultipleNeighbour::operator==(null_type) const
{
must_bound("Comparison of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
return TRUE;
}

boolean AcStopBeaconingMultipleNeighbour::operator==(const AcStopBeaconingMultipleNeighbour& other_value) const
{
must_bound("Comparison of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
other_value.must_bound("Comparison of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
return TRUE;
}

void AcStopBeaconingMultipleNeighbour::log() const
{
if (bound_flag) TTCN_Logger::log_event_str("{ }");
else TTCN_Logger::log_event_unbound();
}

void AcStopBeaconingMultipleNeighbour::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "empty record/set value (i.e. { })");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Value_List || mp->get_size()>0) {
    param.type_error("empty record/set value (i.e. { })", "@LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour");
  }
  bound_flag = TRUE;
}

Module_Param* AcStopBeaconingMultipleNeighbour::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Value_List();
}

void AcStopBeaconingMultipleNeighbour::encode_text(Text_Buf& /*text_buf*/) const
{
must_bound("Text encoder: Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
}

void AcStopBeaconingMultipleNeighbour::decode_text(Text_Buf& /*text_buf*/)
{
bound_flag = TRUE;
}

void AcStopBeaconingMultipleNeighbour::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AcStopBeaconingMultipleNeighbour::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AcStopBeaconingMultipleNeighbour::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& /*myleaf*/) const
{
if (!bound_flag) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value of type %s.", p_td.name);
return 0;
}

int AcStopBeaconingMultipleNeighbour::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int, raw_order_t, boolean, int, boolean)
{
bound_flag = TRUE;
return p_buf.increase_pos_padd(p_td.raw->prepadding) + p_buf.increase_pos_padd(p_td.raw->padding);
}

int AcStopBeaconingMultipleNeighbour::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
    return -1;
  }

  return p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL) + 
    p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
}

int AcStopBeaconingMultipleNeighbour::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  bound_flag = true;

  return dec_len;
}

void AcStopBeaconingMultipleNeighbour_template::copy_template(const AcStopBeaconingMultipleNeighbour_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AcStopBeaconingMultipleNeighbour_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
break;
}
}

AcStopBeaconingMultipleNeighbour_template::AcStopBeaconingMultipleNeighbour_template()
{
}

AcStopBeaconingMultipleNeighbour_template::AcStopBeaconingMultipleNeighbour_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AcStopBeaconingMultipleNeighbour_template::AcStopBeaconingMultipleNeighbour_template(null_type)
 : Base_Template(SPECIFIC_VALUE)
{
}

AcStopBeaconingMultipleNeighbour_template::AcStopBeaconingMultipleNeighbour_template(const AcStopBeaconingMultipleNeighbour& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
other_value.must_bound("Creating a template from an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
}

AcStopBeaconingMultipleNeighbour_template::AcStopBeaconingMultipleNeighbour_template(const OPTIONAL<AcStopBeaconingMultipleNeighbour>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour from an unbound optional field.");
}
}

AcStopBeaconingMultipleNeighbour_template::AcStopBeaconingMultipleNeighbour_template(const AcStopBeaconingMultipleNeighbour_template& other_value)
: Base_Template(){
copy_template(other_value);
}

AcStopBeaconingMultipleNeighbour_template::~AcStopBeaconingMultipleNeighbour_template()
{
clean_up();
}

void AcStopBeaconingMultipleNeighbour_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST)
delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

AcStopBeaconingMultipleNeighbour_template& AcStopBeaconingMultipleNeighbour_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AcStopBeaconingMultipleNeighbour_template& AcStopBeaconingMultipleNeighbour_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

AcStopBeaconingMultipleNeighbour_template& AcStopBeaconingMultipleNeighbour_template::operator=(const AcStopBeaconingMultipleNeighbour& other_value)
{
other_value.must_bound("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
return *this;
}

AcStopBeaconingMultipleNeighbour_template& AcStopBeaconingMultipleNeighbour_template::operator=(const OPTIONAL<AcStopBeaconingMultipleNeighbour>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
}
return *this;
}

AcStopBeaconingMultipleNeighbour_template& AcStopBeaconingMultipleNeighbour_template::operator=(const AcStopBeaconingMultipleNeighbour_template& other_value)
{
if (&other_value != this) {
clean_up();
set_selection(other_value);
}
return *this;
}

boolean AcStopBeaconingMultipleNeighbour_template::match(null_type other_value,boolean) const
{
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
return TRUE;
case OMIT_VALUE:
return FALSE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
}
return FALSE;
}

boolean AcStopBeaconingMultipleNeighbour_template::match(const AcStopBeaconingMultipleNeighbour& other_value, boolean) const
{
if (!other_value.is_bound()) return FALSE;return match(NULL_VALUE);
}

AcStopBeaconingMultipleNeighbour AcStopBeaconingMultipleNeighbour_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
return NULL_VALUE;
}

void AcStopBeaconingMultipleNeighbour_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AcStopBeaconingMultipleNeighbour_template[list_length];
}

AcStopBeaconingMultipleNeighbour_template& AcStopBeaconingMultipleNeighbour_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
return value_list.list_value[list_index];
}

void AcStopBeaconingMultipleNeighbour_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AcStopBeaconingMultipleNeighbour_template::log_match(const AcStopBeaconingMultipleNeighbour& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void AcStopBeaconingMultipleNeighbour_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
}
}

void AcStopBeaconingMultipleNeighbour_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
case SPECIFIC_VALUE:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AcStopBeaconingMultipleNeighbour_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
}
}

void AcStopBeaconingMultipleNeighbour_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "empty record/set template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AcStopBeaconingMultipleNeighbour_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()>0) param.type_error("empty record/set template", "@LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour");
    *this = NULL_VALUE;
    break;
  default:
    param.type_error("empty record/set template", "@LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AcStopBeaconingMultipleNeighbour_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Value_List();
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AcStopBeaconingMultipleNeighbour_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour");
}

boolean AcStopBeaconingMultipleNeighbour_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AcStopBeaconingMultipleNeighbour_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

AcGetLongPosVector::AcGetLongPosVector()
{
  bound_flag = FALSE;
}

AcGetLongPosVector::AcGetLongPosVector(const GN__Address& par_gnAddress)
  :   field_gnAddress(par_gnAddress)
{
  bound_flag = TRUE;
}

AcGetLongPosVector::AcGetLongPosVector(const AcGetLongPosVector& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector.");
bound_flag = TRUE;
if (other_value.gnAddress().is_bound()) field_gnAddress = other_value.gnAddress();
else field_gnAddress.clean_up();
}

void AcGetLongPosVector::clean_up()
{
field_gnAddress.clean_up();
bound_flag = FALSE;
}

AcGetLongPosVector& AcGetLongPosVector::operator=(const AcGetLongPosVector& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector.");
  bound_flag = TRUE;
  if (other_value.gnAddress().is_bound()) field_gnAddress = other_value.gnAddress();
  else field_gnAddress.clean_up();
}
return *this;
}

boolean AcGetLongPosVector::operator==(const AcGetLongPosVector& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_gnAddress==other_value.field_gnAddress;
}

boolean AcGetLongPosVector::is_bound() const
{
if (bound_flag) return TRUE;
if(field_gnAddress.is_bound()) return TRUE;
return FALSE;
}
boolean AcGetLongPosVector::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_gnAddress.is_value()) return FALSE;
return TRUE;
}
int AcGetLongPosVector::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector");
  return 1;
}

void AcGetLongPosVector::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ gnAddress := ");
field_gnAddress.log();
TTCN_Logger::log_event_str(" }");
}

void AcGetLongPosVector::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector'");
    }
    if (strcmp("gnAddress", param_field) == 0) {
      gnAddress().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) gnAddress().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnAddress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnAddress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector");
  }
}

Module_Param* AcGetLongPosVector::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector'");
    }
    if (strcmp("gnAddress", param_field) == 0) {
      return gnAddress().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_gnAddress = field_gnAddress.get_param(param_name);
  mp_field_gnAddress->set_id(new Module_Param_FieldName(mcopystr("gnAddress")));
  mp->add_elem(mp_field_gnAddress);
  return mp;
  }

void AcGetLongPosVector::set_implicit_omit()
{
if (gnAddress().is_bound()) gnAddress().set_implicit_omit();
}

void AcGetLongPosVector::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector.");
field_gnAddress.encode_text(text_buf);
}

void AcGetLongPosVector::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_gnAddress.decode_text(text_buf);
}

void AcGetLongPosVector::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AcGetLongPosVector::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AcGetLongPosVector::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_gnAddress.RAW_decode(GN__Address_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int AcGetLongPosVector::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, GN__Address_descr_.raw);
  encoded_length += field_gnAddress.RAW_encode(GN__Address_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int AcGetLongPosVector::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "gnAddress");
    enc_len += field_gnAddress.JSON_encode(GN__Address_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AcGetLongPosVector::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (9 == name_len && 0 == strncmp(fld_name, "gnAddress", name_len)) {
         int ret_val = field_gnAddress.JSON_decode(GN__Address_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "gnAddress");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_gnAddress.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "gnAddress");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct AcGetLongPosVector_template::single_value_struct {
GN__Address_template field_gnAddress;
};

void AcGetLongPosVector_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_gnAddress = ANY_VALUE;
}
}
}

void AcGetLongPosVector_template::copy_value(const AcGetLongPosVector& other_value)
{
single_value = new single_value_struct;
if (other_value.gnAddress().is_bound()) {
  single_value->field_gnAddress = other_value.gnAddress();
} else {
  single_value->field_gnAddress.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void AcGetLongPosVector_template::copy_template(const AcGetLongPosVector_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.gnAddress().get_selection()) {
single_value->field_gnAddress = other_value.gnAddress();
} else {
single_value->field_gnAddress.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AcGetLongPosVector_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector.");
break;
}
set_selection(other_value);
}

AcGetLongPosVector_template::AcGetLongPosVector_template()
{
}

AcGetLongPosVector_template::AcGetLongPosVector_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AcGetLongPosVector_template::AcGetLongPosVector_template(const AcGetLongPosVector& other_value)
{
copy_value(other_value);
}

AcGetLongPosVector_template::AcGetLongPosVector_template(const OPTIONAL<AcGetLongPosVector>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcGetLongPosVector&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector from an unbound optional field.");
}
}

AcGetLongPosVector_template::AcGetLongPosVector_template(const AcGetLongPosVector_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

AcGetLongPosVector_template::~AcGetLongPosVector_template()
{
clean_up();
}

AcGetLongPosVector_template& AcGetLongPosVector_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AcGetLongPosVector_template& AcGetLongPosVector_template::operator=(const AcGetLongPosVector& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AcGetLongPosVector_template& AcGetLongPosVector_template::operator=(const OPTIONAL<AcGetLongPosVector>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcGetLongPosVector&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector.");
}
return *this;
}

AcGetLongPosVector_template& AcGetLongPosVector_template::operator=(const AcGetLongPosVector_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AcGetLongPosVector_template::match(const AcGetLongPosVector& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.gnAddress().is_bound()) return FALSE;
if(!single_value->field_gnAddress.match(other_value.gnAddress(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector.");
}
return FALSE;
}

boolean AcGetLongPosVector_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_gnAddress.is_bound()) return TRUE;
return FALSE;
}

boolean AcGetLongPosVector_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_gnAddress.is_value()) return FALSE;
return TRUE;
}

void AcGetLongPosVector_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AcGetLongPosVector AcGetLongPosVector_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector.");
AcGetLongPosVector ret_val;
if (single_value->field_gnAddress.is_bound()) {
ret_val.gnAddress() = single_value->field_gnAddress.valueof();
}
return ret_val;
}

void AcGetLongPosVector_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AcGetLongPosVector_template[list_length];
}

AcGetLongPosVector_template& AcGetLongPosVector_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector.");
return value_list.list_value[list_index];
}

GN__Address_template& AcGetLongPosVector_template::gnAddress()
{
set_specific();
return single_value->field_gnAddress;
}

const GN__Address_template& AcGetLongPosVector_template::gnAddress() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnAddress of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector.");
return single_value->field_gnAddress;
}

int AcGetLongPosVector_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector.");
  }
  return 0;
}

void AcGetLongPosVector_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ gnAddress := ");
single_value->field_gnAddress.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AcGetLongPosVector_template::log_match(const AcGetLongPosVector& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_gnAddress.match(match_value.gnAddress(), legacy)){
TTCN_Logger::log_logmatch_info(".gnAddress");
single_value->field_gnAddress.log_match(match_value.gnAddress(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ gnAddress := ");
single_value->field_gnAddress.log_match(match_value.gnAddress(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AcGetLongPosVector_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_gnAddress.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector.");
}
}

void AcGetLongPosVector_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_gnAddress.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AcGetLongPosVector_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector.");
}
}

void AcGetLongPosVector_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector'");
    }
    if (strcmp("gnAddress", param_field) == 0) {
      gnAddress().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AcGetLongPosVector_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) gnAddress().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnAddress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnAddress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AcGetLongPosVector_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector'");
    }
    if (strcmp("gnAddress", param_field) == 0) {
      return gnAddress().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_gnAddress = single_value->field_gnAddress.get_param(param_name);
    mp_field_gnAddress->set_id(new Module_Param_FieldName(mcopystr("gnAddress")));
    mp->add_elem(mp_field_gnAddress);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AcGetLongPosVector_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_gnAddress.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcGetLongPosVector");
}

boolean AcGetLongPosVector_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AcGetLongPosVector_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void AcGnResponse::copy_value(const AcGnResponse& other_value)
{
switch (other_value.union_selection) {
case ALT_getLongPosVector:
field_getLongPosVector = new LongPosVector(*other_value.field_getLongPosVector);
break;
case ALT_failure:
field_failure = new AcGnResponseFailure(*other_value.field_failure);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
}
union_selection = other_value.union_selection;
}

AcGnResponse::AcGnResponse()
{
union_selection = UNBOUND_VALUE;
}

AcGnResponse::AcGnResponse(const AcGnResponse& other_value)
: Base_Type(){
copy_value(other_value);
}

AcGnResponse::~AcGnResponse()
{
clean_up();
}

AcGnResponse& AcGnResponse::operator=(const AcGnResponse& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean AcGnResponse::operator==(const AcGnResponse& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_getLongPosVector:
return *field_getLongPosVector == *other_value.field_getLongPosVector;
case ALT_failure:
return *field_failure == *other_value.field_failure;
default:
return FALSE;
}
}

LongPosVector& AcGnResponse::getLongPosVector()
{
if (union_selection != ALT_getLongPosVector) {
clean_up();
field_getLongPosVector = new LongPosVector;
union_selection = ALT_getLongPosVector;
}
return *field_getLongPosVector;
}

const LongPosVector& AcGnResponse::getLongPosVector() const
{
if (union_selection != ALT_getLongPosVector) TTCN_error("Using non-selected field getLongPosVector in a value of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
return *field_getLongPosVector;
}

AcGnResponseFailure& AcGnResponse::failure()
{
if (union_selection != ALT_failure) {
clean_up();
field_failure = new AcGnResponseFailure;
union_selection = ALT_failure;
}
return *field_failure;
}

const AcGnResponseFailure& AcGnResponse::failure() const
{
if (union_selection != ALT_failure) TTCN_error("Using non-selected field failure in a value of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
return *field_failure;
}

boolean AcGnResponse::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
return union_selection == checked_selection;
}

boolean AcGnResponse::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean AcGnResponse::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_getLongPosVector: return field_getLongPosVector->is_value();
case ALT_failure: return field_failure->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void AcGnResponse::clean_up()
{
switch (union_selection) {
case ALT_getLongPosVector:
  delete field_getLongPosVector;
  break;
case ALT_failure:
  delete field_failure;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void AcGnResponse::log() const
{
switch (union_selection) {
case ALT_getLongPosVector:
TTCN_Logger::log_event_str("{ getLongPosVector := ");
field_getLongPosVector->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_failure:
TTCN_Logger::log_event_str("{ failure := ");
field_failure->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void AcGnResponse::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsGeoNetworking_TypesAndValues.AcGnResponse'");
    }
    if (strcmp("getLongPosVector", param_field) == 0) {
      getLongPosVector().set_param(param);
      return;
    } else if (strcmp("failure", param_field) == 0) {
      failure().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsGeoNetworking_TypesAndValues.AcGnResponse'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "getLongPosVector")) {
    getLongPosVector().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "failure")) {
    failure().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.", mp_last->get_id()->get_name());
}

Module_Param* AcGnResponse::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsGeoNetworking_TypesAndValues.AcGnResponse'");
    }
    if (strcmp("getLongPosVector", param_field) == 0) {
      return getLongPosVector().get_param(param_name);
    } else if (strcmp("failure", param_field) == 0) {
      return failure().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `AcGnResponse'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_getLongPosVector:
    mp_field = field_getLongPosVector->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("getLongPosVector")));
    break;
  case ALT_failure:
    mp_field = field_failure->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("failure")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void AcGnResponse::set_implicit_omit()
{
switch (union_selection) {
case ALT_getLongPosVector:
field_getLongPosVector->set_implicit_omit(); break;
case ALT_failure:
field_failure->set_implicit_omit(); break;
default: break;
}
}

void AcGnResponse::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_getLongPosVector:
field_getLongPosVector->encode_text(text_buf);
break;
case ALT_failure:
field_failure->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
}
}

void AcGnResponse::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_getLongPosVector:
getLongPosVector().decode_text(text_buf);
break;
case ALT_failure:
failure().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
}
}

void AcGnResponse::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AcGnResponse::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AcGnResponse::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = getLongPosVector().RAW_decode(LongPosVector_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = failure().RAW_decode(AcGnResponseFailure_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = getLongPosVector().RAW_decode(LongPosVector_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = failure().RAW_decode(AcGnResponseFailure_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int AcGnResponse::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  memset(myleaf.body.node.nodes, 0, 2 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_getLongPosVector:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, LongPosVector_descr_.raw);
    encoded_length = field_getLongPosVector->RAW_encode(LongPosVector_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &LongPosVector_descr_;
    break;
  case ALT_failure:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, AcGnResponseFailure_descr_.raw);
    encoded_length = field_failure->RAW_encode(AcGnResponseFailure_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &AcGnResponseFailure_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int AcGnResponse::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_getLongPosVector:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "getLongPosVector");
    enc_len += field_getLongPosVector->JSON_encode(LongPosVector_descr_, p_tok);
    break;
  case ALT_failure:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "failure");
    enc_len += field_failure->JSON_encode(AcGnResponseFailure_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AcGnResponse::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "getLongPosVector", name_len)) {
      int ret_val = getLongPosVector().JSON_decode(LongPosVector_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "getLongPosVector");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "failure", name_len)) {
      int ret_val = failure().JSON_decode(AcGnResponseFailure_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "failure");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void AcGnResponse_template::copy_value(const AcGnResponse& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case AcGnResponse::ALT_getLongPosVector:
single_value.field_getLongPosVector = new LongPosVector_template(other_value.getLongPosVector());
break;
case AcGnResponse::ALT_failure:
single_value.field_failure = new AcGnResponseFailure_template(other_value.failure());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
}
set_selection(SPECIFIC_VALUE);
}

void AcGnResponse_template::copy_template(const AcGnResponse_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case AcGnResponse::ALT_getLongPosVector:
single_value.field_getLongPosVector = new LongPosVector_template(*other_value.single_value.field_getLongPosVector);
break;
case AcGnResponse::ALT_failure:
single_value.field_failure = new AcGnResponseFailure_template(*other_value.single_value.field_failure);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AcGnResponse_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
}
set_selection(other_value);
}

AcGnResponse_template::AcGnResponse_template()
{
}

AcGnResponse_template::AcGnResponse_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AcGnResponse_template::AcGnResponse_template(const AcGnResponse& other_value)
{
copy_value(other_value);
}

AcGnResponse_template::AcGnResponse_template(const OPTIONAL<AcGnResponse>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcGnResponse&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse from an unbound optional field.");
}
}

AcGnResponse_template::AcGnResponse_template(const AcGnResponse_template& other_value)
: Base_Template(){
copy_template(other_value);
}

AcGnResponse_template::~AcGnResponse_template()
{
clean_up();
}

void AcGnResponse_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case AcGnResponse::ALT_getLongPosVector:
delete single_value.field_getLongPosVector;
break;
case AcGnResponse::ALT_failure:
delete single_value.field_failure;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AcGnResponse_template& AcGnResponse_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AcGnResponse_template& AcGnResponse_template::operator=(const AcGnResponse& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AcGnResponse_template& AcGnResponse_template::operator=(const OPTIONAL<AcGnResponse>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcGnResponse&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
}
return *this;
}

AcGnResponse_template& AcGnResponse_template::operator=(const AcGnResponse_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AcGnResponse_template::match(const AcGnResponse& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
AcGnResponse::union_selection_type value_selection = other_value.get_selection();
if (value_selection == AcGnResponse::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case AcGnResponse::ALT_getLongPosVector:
return single_value.field_getLongPosVector->match(other_value.getLongPosVector(), legacy);
case AcGnResponse::ALT_failure:
return single_value.field_failure->match(other_value.failure(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
}
return FALSE;
}

boolean AcGnResponse_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case AcGnResponse::ALT_getLongPosVector:
return single_value.field_getLongPosVector->is_value();
case AcGnResponse::ALT_failure:
return single_value.field_failure->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
}
}

AcGnResponse AcGnResponse_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
AcGnResponse ret_val;
switch (single_value.union_selection) {
case AcGnResponse::ALT_getLongPosVector:
ret_val.getLongPosVector() = single_value.field_getLongPosVector->valueof();
break;
case AcGnResponse::ALT_failure:
ret_val.failure() = single_value.field_failure->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
}
return ret_val;
}

AcGnResponse_template& AcGnResponse_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
return value_list.list_value[list_index];
}
void AcGnResponse_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AcGnResponse_template[list_length];
}

LongPosVector_template& AcGnResponse_template::getLongPosVector()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != AcGnResponse::ALT_getLongPosVector) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_getLongPosVector = new LongPosVector_template(ANY_VALUE);
else single_value.field_getLongPosVector = new LongPosVector_template;
single_value.union_selection = AcGnResponse::ALT_getLongPosVector;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_getLongPosVector;
}

const LongPosVector_template& AcGnResponse_template::getLongPosVector() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field getLongPosVector in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
if (single_value.union_selection != AcGnResponse::ALT_getLongPosVector) TTCN_error("Accessing non-selected field getLongPosVector in a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
return *single_value.field_getLongPosVector;
}

AcGnResponseFailure_template& AcGnResponse_template::failure()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != AcGnResponse::ALT_failure) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_failure = new AcGnResponseFailure_template(ANY_VALUE);
else single_value.field_failure = new AcGnResponseFailure_template;
single_value.union_selection = AcGnResponse::ALT_failure;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_failure;
}

const AcGnResponseFailure_template& AcGnResponse_template::failure() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field failure in a non-specific template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
if (single_value.union_selection != AcGnResponse::ALT_failure) TTCN_error("Accessing non-selected field failure in a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
return *single_value.field_failure;
}

boolean AcGnResponse_template::ischosen(AcGnResponse::union_selection_type checked_selection) const
{
if (checked_selection == AcGnResponse::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == AcGnResponse::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse");
}
return FALSE;
}

void AcGnResponse_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case AcGnResponse::ALT_getLongPosVector:
TTCN_Logger::log_event_str("{ getLongPosVector := ");
single_value.field_getLongPosVector->log();
TTCN_Logger::log_event_str(" }");
break;
case AcGnResponse::ALT_failure:
TTCN_Logger::log_event_str("{ failure := ");
single_value.field_failure->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AcGnResponse_template::log_match(const AcGnResponse& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case AcGnResponse::ALT_getLongPosVector:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".getLongPosVector");
single_value.field_getLongPosVector->log_match(match_value.getLongPosVector(), legacy);
} else {
TTCN_Logger::log_event_str("{ getLongPosVector := ");
single_value.field_getLongPosVector->log_match(match_value.getLongPosVector(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case AcGnResponse::ALT_failure:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".failure");
single_value.field_failure->log_match(match_value.failure(), legacy);
} else {
TTCN_Logger::log_event_str("{ failure := ");
single_value.field_failure->log_match(match_value.failure(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AcGnResponse_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case AcGnResponse::ALT_getLongPosVector:
single_value.field_getLongPosVector->encode_text(text_buf);
break;
case AcGnResponse::ALT_failure:
single_value.field_failure->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
}
}

void AcGnResponse_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = AcGnResponse::UNBOUND_VALUE;
AcGnResponse::union_selection_type new_selection = (AcGnResponse::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case AcGnResponse::ALT_getLongPosVector:
single_value.field_getLongPosVector = new LongPosVector_template;
single_value.field_getLongPosVector->decode_text(text_buf);
break;
case AcGnResponse::ALT_failure:
single_value.field_failure = new AcGnResponseFailure_template;
single_value.field_failure->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AcGnResponse_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
}
}

boolean AcGnResponse_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AcGnResponse_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void AcGnResponse_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsGeoNetworking_TypesAndValues.AcGnResponse'");
    }
    if (strcmp("getLongPosVector", param_field) == 0) {
      getLongPosVector().set_param(param);
      return;
    } else if (strcmp("failure", param_field) == 0) {
      failure().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsGeoNetworking_TypesAndValues.AcGnResponse'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AcGnResponse_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsGeoNetworking_TypesAndValues.AcGnResponse");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "getLongPosVector")) {
      getLongPosVector().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "failure")) {
      failure().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsGeoNetworking_TypesAndValues.AcGnResponse");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AcGnResponse_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsGeoNetworking_TypesAndValues.AcGnResponse'");
    }
    if (strcmp("getLongPosVector", param_field) == 0) {
      return getLongPosVector().get_param(param_name);
    } else if (strcmp("failure", param_field) == 0) {
      return failure().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `AcGnResponse'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case AcGnResponse::ALT_getLongPosVector:
      mp_field = single_value.field_getLongPosVector->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("getLongPosVector")));
      break;
    case AcGnResponse::ALT_failure:
      mp_field = single_value.field_failure->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("failure")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AcGnResponse_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case AcGnResponse::ALT_getLongPosVector:
single_value.field_getLongPosVector->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcGnResponse");
return;
case AcGnResponse::ALT_failure:
single_value.field_failure->check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcGnResponse");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsGeoNetworking_TypesAndValues.AcGnResponse.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcGnResponse");
}

AcGnResponseFailure::AcGnResponseFailure()
{
  bound_flag = FALSE;
}

AcGnResponseFailure::AcGnResponseFailure(const BOOLEAN& par_failure)
  :   field_failure(par_failure)
{
  bound_flag = TRUE;
}

AcGnResponseFailure::AcGnResponseFailure(const AcGnResponseFailure& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure.");
bound_flag = TRUE;
if (other_value.failure().is_bound()) field_failure = other_value.failure();
else field_failure.clean_up();
}

void AcGnResponseFailure::clean_up()
{
field_failure.clean_up();
bound_flag = FALSE;
}

AcGnResponseFailure& AcGnResponseFailure::operator=(const AcGnResponseFailure& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure.");
  bound_flag = TRUE;
  if (other_value.failure().is_bound()) field_failure = other_value.failure();
  else field_failure.clean_up();
}
return *this;
}

boolean AcGnResponseFailure::operator==(const AcGnResponseFailure& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_failure==other_value.field_failure;
}

boolean AcGnResponseFailure::is_bound() const
{
if (bound_flag) return TRUE;
if(field_failure.is_bound()) return TRUE;
return FALSE;
}
boolean AcGnResponseFailure::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_failure.is_value()) return FALSE;
return TRUE;
}
int AcGnResponseFailure::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure");
  return 1;
}

void AcGnResponseFailure::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ failure := ");
field_failure.log();
TTCN_Logger::log_event_str(" }");
}

void AcGnResponseFailure::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure'");
    }
    if (strcmp("failure", param_field) == 0) {
      failure().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) failure().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "failure")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          failure().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure");
  }
}

Module_Param* AcGnResponseFailure::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure'");
    }
    if (strcmp("failure", param_field) == 0) {
      return failure().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_failure = field_failure.get_param(param_name);
  mp_field_failure->set_id(new Module_Param_FieldName(mcopystr("failure")));
  mp->add_elem(mp_field_failure);
  return mp;
  }

void AcGnResponseFailure::set_implicit_omit()
{
if (failure().is_bound()) failure().set_implicit_omit();
}

void AcGnResponseFailure::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure.");
field_failure.encode_text(text_buf);
}

void AcGnResponseFailure::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_failure.decode_text(text_buf);
}

void AcGnResponseFailure::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AcGnResponseFailure::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AcGnResponseFailure::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_failure.RAW_decode(BOOLEAN_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int AcGnResponseFailure::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, BOOLEAN_descr_.raw);
  encoded_length += field_failure.RAW_encode(BOOLEAN_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int AcGnResponseFailure::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "failure");
    enc_len += field_failure.JSON_encode(BOOLEAN_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AcGnResponseFailure::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (7 == name_len && 0 == strncmp(fld_name, "failure", name_len)) {
         int ret_val = field_failure.JSON_decode(BOOLEAN_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "failure");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_failure.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "failure");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct AcGnResponseFailure_template::single_value_struct {
BOOLEAN_template field_failure;
};

void AcGnResponseFailure_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_failure = ANY_VALUE;
}
}
}

void AcGnResponseFailure_template::copy_value(const AcGnResponseFailure& other_value)
{
single_value = new single_value_struct;
if (other_value.failure().is_bound()) {
  single_value->field_failure = other_value.failure();
} else {
  single_value->field_failure.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void AcGnResponseFailure_template::copy_template(const AcGnResponseFailure_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.failure().get_selection()) {
single_value->field_failure = other_value.failure();
} else {
single_value->field_failure.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AcGnResponseFailure_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure.");
break;
}
set_selection(other_value);
}

AcGnResponseFailure_template::AcGnResponseFailure_template()
{
}

AcGnResponseFailure_template::AcGnResponseFailure_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AcGnResponseFailure_template::AcGnResponseFailure_template(const AcGnResponseFailure& other_value)
{
copy_value(other_value);
}

AcGnResponseFailure_template::AcGnResponseFailure_template(const OPTIONAL<AcGnResponseFailure>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcGnResponseFailure&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure from an unbound optional field.");
}
}

AcGnResponseFailure_template::AcGnResponseFailure_template(const AcGnResponseFailure_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

AcGnResponseFailure_template::~AcGnResponseFailure_template()
{
clean_up();
}

AcGnResponseFailure_template& AcGnResponseFailure_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AcGnResponseFailure_template& AcGnResponseFailure_template::operator=(const AcGnResponseFailure& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AcGnResponseFailure_template& AcGnResponseFailure_template::operator=(const OPTIONAL<AcGnResponseFailure>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcGnResponseFailure&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure.");
}
return *this;
}

AcGnResponseFailure_template& AcGnResponseFailure_template::operator=(const AcGnResponseFailure_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AcGnResponseFailure_template::match(const AcGnResponseFailure& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.failure().is_bound()) return FALSE;
if(!single_value->field_failure.match(other_value.failure(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure.");
}
return FALSE;
}

boolean AcGnResponseFailure_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_failure.is_bound()) return TRUE;
return FALSE;
}

boolean AcGnResponseFailure_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_failure.is_value()) return FALSE;
return TRUE;
}

void AcGnResponseFailure_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AcGnResponseFailure AcGnResponseFailure_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure.");
AcGnResponseFailure ret_val;
if (single_value->field_failure.is_bound()) {
ret_val.failure() = single_value->field_failure.valueof();
}
return ret_val;
}

void AcGnResponseFailure_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AcGnResponseFailure_template[list_length];
}

AcGnResponseFailure_template& AcGnResponseFailure_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure.");
return value_list.list_value[list_index];
}

BOOLEAN_template& AcGnResponseFailure_template::failure()
{
set_specific();
return single_value->field_failure;
}

const BOOLEAN_template& AcGnResponseFailure_template::failure() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field failure of a non-specific template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure.");
return single_value->field_failure;
}

int AcGnResponseFailure_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure.");
  }
  return 0;
}

void AcGnResponseFailure_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ failure := ");
single_value->field_failure.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AcGnResponseFailure_template::log_match(const AcGnResponseFailure& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_failure.match(match_value.failure(), legacy)){
TTCN_Logger::log_logmatch_info(".failure");
single_value->field_failure.log_match(match_value.failure(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ failure := ");
single_value->field_failure.log_match(match_value.failure(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AcGnResponseFailure_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_failure.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure.");
}
}

void AcGnResponseFailure_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_failure.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AcGnResponseFailure_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure.");
}
}

void AcGnResponseFailure_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure'");
    }
    if (strcmp("failure", param_field) == 0) {
      failure().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AcGnResponseFailure_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) failure().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "failure")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          failure().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AcGnResponseFailure_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure'");
    }
    if (strcmp("failure", param_field) == 0) {
      return failure().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_failure = single_value->field_failure.get_param(param_name);
    mp_field_failure->set_id(new Module_Param_FieldName(mcopystr("failure")));
    mp->add_elem(mp_field_failure);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AcGnResponseFailure_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_failure.check_restriction(t_res, t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsGeoNetworking_TypesAndValues.AcGnResponseFailure");
}

boolean AcGnResponseFailure_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AcGnResponseFailure_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


/* Bodies of functions, altsteps and testcases */

boolean operator==(null_type, const PositionTable& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsGeoNetworking_TypesAndValues.PositionTable.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const GeoAreaTable& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsGeoNetworking_TypesAndValues.GeoAreaTable.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const UtGnEventIndList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsGeoNetworking_TypesAndValues.UtGnEventIndList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const AcStopBeaconing& other_value)
{
other_value.must_bound("Comparison of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconing.");
return TRUE;
}

boolean operator==(null_type, const AcStopPassBeaconing& other_value)
{
other_value.must_bound("Comparison of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopPassBeaconing.");
return TRUE;
}

boolean operator==(null_type, const AcStopBeaconingMultipleNeighbour& other_value)
{
other_value.must_bound("Comparison of an unbound value of type @LibItsGeoNetworking_TypesAndValues.AcStopBeaconingMultipleNeighbour.");
return TRUE;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("LibItsGeoNetworking_TypesAndValues.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "LibItsGeoNetworking_TypesAndValues");
LibItsCommon__TypesAndValues::module_object.pre_init_module();
LibItsBtp__TypesAndValues::module_object.pre_init_module();
LibItsIpv6OverGeoNetworking__TypesAndValues::module_object.pre_init_module();
LibItsSecurity__TypesAndValues::module_object.pre_init_module();
current_location.update_lineno(29);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 29 */
const_c__compIut = cs_0;
current_location.update_lineno(30);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 30 */
const_c__compMTC = cs_1;
current_location.update_lineno(31);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 31 */
const_c__compNodeA = cs_2;
current_location.update_lineno(32);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 32 */
const_c__compNodeB = cs_3;
current_location.update_lineno(33);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 33 */
const_c__compNodeC = cs_4;
current_location.update_lineno(34);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 34 */
const_c__compNodeD = cs_5;
current_location.update_lineno(35);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 35 */
const_c__compNodeE = cs_6;
current_location.update_lineno(36);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 36 */
const_c__compNodeF = cs_7;
current_location.update_lineno(38);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 38 */
const_c__area1 = cs_8;
current_location.update_lineno(39);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 39 */
const_c__area2 = cs_9;
current_location.update_lineno(41);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 41 */
const_c__latitudeFactorNodeA = 10;
current_location.update_lineno(42);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 42 */
const_c__latitudeFactorNodeB = 2;
current_location.update_lineno(43);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 43 */
const_c__latitudeFactorNodeC = -6;
current_location.update_lineno(44);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 44 */
const_c__latitudeFactorNodeD = 1;
current_location.update_lineno(45);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 45 */
const_c__latitudeFactorNodeE = -1;
current_location.update_lineno(46);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 46 */
const_c__latitudeFactorNodeF = 2;
current_location.update_lineno(47);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 47 */
const_c__longitudeFactorNodeA = 0;
current_location.update_lineno(48);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 48 */
const_c__longitudeFactorNodeB = 0;
current_location.update_lineno(49);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 49 */
const_c__longitudeFactorNodeC = 0;
current_location.update_lineno(50);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 50 */
const_c__longitudeFactorNodeD = 0;
current_location.update_lineno(51);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 51 */
const_c__longitudeFactorNodeE = 0;
current_location.update_lineno(52);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 52 */
const_c__longitudeFactorNodeF = -3;
current_location.update_lineno(57);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 57 */
const_c__msgSent = cs_10;
current_location.update_lineno(63);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 63 */
const_c__defaultLifetime = 10;
current_location.update_lineno(64);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 64 */
const_c__lifetime = 10000;
current_location.update_lineno(70);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 70 */
const_c__squareKm = 1.0e6;
current_location.update_lineno(168);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 168 */
const_c__geoNwProtocolVersion = 0;
current_location.update_lineno(170);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 170 */
const_c__hopLimit1 = 1;
current_location.update_lineno(171);
/* LibItsGeoNetworking_TypesAndValues.ttcn, line 171 */
const_c__defaultHopLimit = 10;
}

static void post_init_module()
{
TTCN_Location current_location("LibItsGeoNetworking_TypesAndValues.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "LibItsGeoNetworking_TypesAndValues");
LibItsCommon__TypesAndValues::module_object.post_init_module();
LibItsBtp__TypesAndValues::module_object.post_init_module();
LibItsIpv6OverGeoNetworking__TypesAndValues::module_object.post_init_module();
LibItsSecurity__TypesAndValues::module_object.post_init_module();
}


} /* end of namespace */
