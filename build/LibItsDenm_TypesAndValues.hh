// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef LibItsDenm__TypesAndValues_HH
#define LibItsDenm__TypesAndValues_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "DENM_PDU_Descriptions.hh"

#if TTCN3_VERSION != 50400
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef LibItsDenm__TypesAndValues_HH
#endif

namespace LibItsDenm__TypesAndValues {

/* Forward declarations of classes */

class Trigger;
class Trigger_template;
class SituationContainerList;
class SituationContainerList_template;
class ActionIDList;
class ActionIDList_template;
class UtDenmTrigger;
class UtDenmTrigger_template;
class UtDenmTriggerResult;
class UtDenmTriggerResult_template;
class UtDenmUpdate;
class UtDenmUpdate_template;
class UtDenmUpdateResult;
class UtDenmUpdateResult_template;
class UtDenmTermination;
class UtDenmTermination_template;
class UtDenmEventInd;
class UtDenmEventInd_template;
class UtDenmEventIndList;
class UtDenmEventIndList_template;
class UtDenmActionIDList;
class UtDenmActionIDList_template;

} /* end of namespace */

#ifndef LibItsDenm__TypesAndValues_HH
#define LibItsDenm__TypesAndValues_HH

namespace LibItsDenm__TypesAndValues {

/* Type definitions */

typedef BOOLEAN UtDenmTerminationResult;
typedef BOOLEAN_template UtDenmTerminationResult_template;

/* Class definitions */

class Trigger : public Base_Type { // enum
friend class Trigger_template;
public:
enum enum_type { e__ets = 0, e__iut = 1, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
Trigger();
Trigger(int other_value);
Trigger(enum_type other_value);
Trigger(const Trigger& other_value);

Trigger& operator=(int other_value);
Trigger& operator=(enum_type other_value);
Trigger& operator=(const Trigger& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Trigger& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Trigger& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Trigger& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Trigger& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Trigger& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Trigger& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Trigger& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class Trigger_template : public Base_Template {
union {
Trigger::enum_type single_value;
struct {
unsigned int n_values;
Trigger_template *list_value;
} value_list;
};

void copy_template(const Trigger_template& other_value);

public:
Trigger_template();
Trigger_template(template_sel other_value);
Trigger_template(int other_value);
Trigger_template(Trigger::enum_type other_value);
Trigger_template(const Trigger& other_value);
Trigger_template(const OPTIONAL<Trigger>& other_value);
Trigger_template(const Trigger_template& other_value);
~Trigger_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Trigger_template& operator=(template_sel other_value);
Trigger_template& operator=(int other_value);
Trigger_template& operator=(Trigger::enum_type other_value);
Trigger_template& operator=(const Trigger& other_value);
Trigger_template& operator=(const OPTIONAL<Trigger>& other_value);
Trigger_template& operator=(const Trigger_template& other_value);

boolean match(Trigger::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const Trigger& other_value, boolean legacy = FALSE) const;
Trigger::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Trigger_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Trigger& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SituationContainerList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
DENM__PDU__Descriptions::SituationContainer **value_elements;
} *val_ptr;

static const DENM__PDU__Descriptions::SituationContainer UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const SituationContainerList& other_value);

public:
  typedef DENM__PDU__Descriptions::SituationContainer of_type;
SituationContainerList();
SituationContainerList(null_type other_value);
SituationContainerList(const SituationContainerList& other_value);
~SituationContainerList();

void clean_up();
SituationContainerList& operator=(null_type other_value);
SituationContainerList& operator=(const SituationContainerList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const SituationContainerList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SituationContainerList& other_value) const { return !(*this == other_value); }

DENM__PDU__Descriptions::SituationContainer& operator[](int index_value);
DENM__PDU__Descriptions::SituationContainer& operator[](const INTEGER& index_value);
const DENM__PDU__Descriptions::SituationContainer& operator[](int index_value) const;
const DENM__PDU__Descriptions::SituationContainer& operator[](const INTEGER& index_value) const;

SituationContainerList operator<<=(int rotate_count) const;
SituationContainerList operator<<=(const INTEGER& rotate_count) const;
SituationContainerList operator>>=(int rotate_count) const;
SituationContainerList operator>>=(const INTEGER& rotate_count) const;

SituationContainerList operator+(const SituationContainerList& other_value) const;

SituationContainerList substr(int index, int returncount) const;

SituationContainerList replace(int index, int len, const SituationContainerList& repl) const;

SituationContainerList replace(int index, int len, const SituationContainerList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SituationContainerList_template : public Record_Of_Template {
union {
struct {
int n_elements;
DENM__PDU__Descriptions::SituationContainer_template **value_elements;
} single_value;
struct {
unsigned int n_values;
SituationContainerList_template *list_value;
} value_list;
};
void copy_value(const SituationContainerList& other_value);
void copy_template(const SituationContainerList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
SituationContainerList_template();
SituationContainerList_template(template_sel other_value);
SituationContainerList_template(null_type other_value);
SituationContainerList_template(const SituationContainerList& other_value);
SituationContainerList_template(const OPTIONAL<SituationContainerList>& other_value);
SituationContainerList_template(const SituationContainerList_template& other_value);
~SituationContainerList_template();

void clean_up();
SituationContainerList_template& operator=(template_sel other_value);
SituationContainerList_template& operator=(null_type other_value);
SituationContainerList_template& operator=(const SituationContainerList& other_value);
SituationContainerList_template& operator=(const OPTIONAL<SituationContainerList>& other_value);
SituationContainerList_template& operator=(const SituationContainerList_template& other_value);

DENM__PDU__Descriptions::SituationContainer_template& operator[](int index_value);
DENM__PDU__Descriptions::SituationContainer_template& operator[](const INTEGER& index_value);
const DENM__PDU__Descriptions::SituationContainer_template& operator[](int index_value) const;
const DENM__PDU__Descriptions::SituationContainer_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const SituationContainerList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
SituationContainerList valueof() const;
SituationContainerList substr(int index, int returncount) const;

SituationContainerList replace(int index, int len, const SituationContainerList_template& repl) const;

SituationContainerList replace(int index, int len, const SituationContainerList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
SituationContainerList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SituationContainerList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ActionIDList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ITS__Container::ActionID **value_elements;
} *val_ptr;

static const ITS__Container::ActionID UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ActionIDList& other_value);

public:
  typedef ITS__Container::ActionID of_type;
ActionIDList();
ActionIDList(null_type other_value);
ActionIDList(const ActionIDList& other_value);
~ActionIDList();

void clean_up();
ActionIDList& operator=(null_type other_value);
ActionIDList& operator=(const ActionIDList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ActionIDList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ActionIDList& other_value) const { return !(*this == other_value); }

ITS__Container::ActionID& operator[](int index_value);
ITS__Container::ActionID& operator[](const INTEGER& index_value);
const ITS__Container::ActionID& operator[](int index_value) const;
const ITS__Container::ActionID& operator[](const INTEGER& index_value) const;

ActionIDList operator<<=(int rotate_count) const;
ActionIDList operator<<=(const INTEGER& rotate_count) const;
ActionIDList operator>>=(int rotate_count) const;
ActionIDList operator>>=(const INTEGER& rotate_count) const;

ActionIDList operator+(const ActionIDList& other_value) const;

ActionIDList substr(int index, int returncount) const;

ActionIDList replace(int index, int len, const ActionIDList& repl) const;

ActionIDList replace(int index, int len, const ActionIDList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ActionIDList_template : public Record_Of_Template {
union {
struct {
int n_elements;
ITS__Container::ActionID_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ActionIDList_template *list_value;
} value_list;
};
void copy_value(const ActionIDList& other_value);
void copy_template(const ActionIDList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ActionIDList_template();
ActionIDList_template(template_sel other_value);
ActionIDList_template(null_type other_value);
ActionIDList_template(const ActionIDList& other_value);
ActionIDList_template(const OPTIONAL<ActionIDList>& other_value);
ActionIDList_template(const ActionIDList_template& other_value);
~ActionIDList_template();

void clean_up();
ActionIDList_template& operator=(template_sel other_value);
ActionIDList_template& operator=(null_type other_value);
ActionIDList_template& operator=(const ActionIDList& other_value);
ActionIDList_template& operator=(const OPTIONAL<ActionIDList>& other_value);
ActionIDList_template& operator=(const ActionIDList_template& other_value);

ITS__Container::ActionID_template& operator[](int index_value);
ITS__Container::ActionID_template& operator[](const INTEGER& index_value);
const ITS__Container::ActionID_template& operator[](int index_value) const;
const ITS__Container::ActionID_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ActionIDList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ActionIDList valueof() const;
ActionIDList substr(int index, int returncount) const;

ActionIDList replace(int index, int len, const ActionIDList_template& repl) const;

ActionIDList replace(int index, int len, const ActionIDList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ActionIDList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ActionIDList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class UtDenmTrigger : public Base_Type {
  INTEGER field_detectionTime;
  OPTIONAL<INTEGER> field_validityDuration;
  OPTIONAL<INTEGER> field_repetitionDuration;
  DENM__PDU__Descriptions::SituationContainer field_situation;
  ITS__Container::RelevanceDistance field_relevanceDistance;
  ITS__Container::RelevanceTrafficDirection field_relevanceTrafficDirection;
  OPTIONAL<INTEGER> field_transmissionInterval;
  OPTIONAL<INTEGER> field_repetitionInterval;
  OPTIONAL<DENM__PDU__Descriptions::AlacarteContainer> field_alacarte;
  boolean bound_flag;
public:
  UtDenmTrigger();
  UtDenmTrigger(const INTEGER& par_detectionTime,
    const OPTIONAL<INTEGER>& par_validityDuration,
    const OPTIONAL<INTEGER>& par_repetitionDuration,
    const DENM__PDU__Descriptions::SituationContainer& par_situation,
    const ITS__Container::RelevanceDistance& par_relevanceDistance,
    const ITS__Container::RelevanceTrafficDirection& par_relevanceTrafficDirection,
    const OPTIONAL<INTEGER>& par_transmissionInterval,
    const OPTIONAL<INTEGER>& par_repetitionInterval,
    const OPTIONAL<DENM__PDU__Descriptions::AlacarteContainer>& par_alacarte);
  UtDenmTrigger(const UtDenmTrigger& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtDenmTrigger& operator=(const UtDenmTrigger& other_value);
  boolean operator==(const UtDenmTrigger& other_value) const;
  inline boolean operator!=(const UtDenmTrigger& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& detectionTime()
    {return field_detectionTime;}
  inline const INTEGER& detectionTime() const
    {return field_detectionTime;}
  inline OPTIONAL<INTEGER>& validityDuration()
    {return field_validityDuration;}
  inline const OPTIONAL<INTEGER>& validityDuration() const
    {return field_validityDuration;}
  inline OPTIONAL<INTEGER>& repetitionDuration()
    {return field_repetitionDuration;}
  inline const OPTIONAL<INTEGER>& repetitionDuration() const
    {return field_repetitionDuration;}
  inline DENM__PDU__Descriptions::SituationContainer& situation()
    {return field_situation;}
  inline const DENM__PDU__Descriptions::SituationContainer& situation() const
    {return field_situation;}
  inline ITS__Container::RelevanceDistance& relevanceDistance()
    {return field_relevanceDistance;}
  inline const ITS__Container::RelevanceDistance& relevanceDistance() const
    {return field_relevanceDistance;}
  inline ITS__Container::RelevanceTrafficDirection& relevanceTrafficDirection()
    {return field_relevanceTrafficDirection;}
  inline const ITS__Container::RelevanceTrafficDirection& relevanceTrafficDirection() const
    {return field_relevanceTrafficDirection;}
  inline OPTIONAL<INTEGER>& transmissionInterval()
    {return field_transmissionInterval;}
  inline const OPTIONAL<INTEGER>& transmissionInterval() const
    {return field_transmissionInterval;}
  inline OPTIONAL<INTEGER>& repetitionInterval()
    {return field_repetitionInterval;}
  inline const OPTIONAL<INTEGER>& repetitionInterval() const
    {return field_repetitionInterval;}
  inline OPTIONAL<DENM__PDU__Descriptions::AlacarteContainer>& alacarte()
    {return field_alacarte;}
  inline const OPTIONAL<DENM__PDU__Descriptions::AlacarteContainer>& alacarte() const
    {return field_alacarte;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtDenmTrigger_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtDenmTrigger_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtDenmTrigger& other_value);
void copy_template(const UtDenmTrigger_template& other_value);

public:
UtDenmTrigger_template();
UtDenmTrigger_template(template_sel other_value);
UtDenmTrigger_template(const UtDenmTrigger& other_value);
UtDenmTrigger_template(const OPTIONAL<UtDenmTrigger>& other_value);
UtDenmTrigger_template(const UtDenmTrigger_template& other_value);
~UtDenmTrigger_template();
UtDenmTrigger_template& operator=(template_sel other_value);
UtDenmTrigger_template& operator=(const UtDenmTrigger& other_value);
UtDenmTrigger_template& operator=(const OPTIONAL<UtDenmTrigger>& other_value);
UtDenmTrigger_template& operator=(const UtDenmTrigger_template& other_value);
boolean match(const UtDenmTrigger& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtDenmTrigger valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtDenmTrigger_template& list_item(unsigned int list_index) const;
INTEGER_template& detectionTime();
const INTEGER_template& detectionTime() const;
INTEGER_template& validityDuration();
const INTEGER_template& validityDuration() const;
INTEGER_template& repetitionDuration();
const INTEGER_template& repetitionDuration() const;
DENM__PDU__Descriptions::SituationContainer_template& situation();
const DENM__PDU__Descriptions::SituationContainer_template& situation() const;
ITS__Container::RelevanceDistance_template& relevanceDistance();
const ITS__Container::RelevanceDistance_template& relevanceDistance() const;
ITS__Container::RelevanceTrafficDirection_template& relevanceTrafficDirection();
const ITS__Container::RelevanceTrafficDirection_template& relevanceTrafficDirection() const;
INTEGER_template& transmissionInterval();
const INTEGER_template& transmissionInterval() const;
INTEGER_template& repetitionInterval();
const INTEGER_template& repetitionInterval() const;
DENM__PDU__Descriptions::AlacarteContainer_template& alacarte();
const DENM__PDU__Descriptions::AlacarteContainer_template& alacarte() const;
int size_of() const;
void log() const;
void log_match(const UtDenmTrigger& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtDenmTriggerResult : public Base_Type {
  BOOLEAN field_result;
  ITS__Container::ActionID field_actionId;
  boolean bound_flag;
public:
  UtDenmTriggerResult();
  UtDenmTriggerResult(const BOOLEAN& par_result,
    const ITS__Container::ActionID& par_actionId);
  UtDenmTriggerResult(const UtDenmTriggerResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtDenmTriggerResult& operator=(const UtDenmTriggerResult& other_value);
  boolean operator==(const UtDenmTriggerResult& other_value) const;
  inline boolean operator!=(const UtDenmTriggerResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BOOLEAN& result()
    {return field_result;}
  inline const BOOLEAN& result() const
    {return field_result;}
  inline ITS__Container::ActionID& actionId()
    {return field_actionId;}
  inline const ITS__Container::ActionID& actionId() const
    {return field_actionId;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtDenmTriggerResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtDenmTriggerResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtDenmTriggerResult& other_value);
void copy_template(const UtDenmTriggerResult_template& other_value);

public:
UtDenmTriggerResult_template();
UtDenmTriggerResult_template(template_sel other_value);
UtDenmTriggerResult_template(const UtDenmTriggerResult& other_value);
UtDenmTriggerResult_template(const OPTIONAL<UtDenmTriggerResult>& other_value);
UtDenmTriggerResult_template(const UtDenmTriggerResult_template& other_value);
~UtDenmTriggerResult_template();
UtDenmTriggerResult_template& operator=(template_sel other_value);
UtDenmTriggerResult_template& operator=(const UtDenmTriggerResult& other_value);
UtDenmTriggerResult_template& operator=(const OPTIONAL<UtDenmTriggerResult>& other_value);
UtDenmTriggerResult_template& operator=(const UtDenmTriggerResult_template& other_value);
boolean match(const UtDenmTriggerResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtDenmTriggerResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtDenmTriggerResult_template& list_item(unsigned int list_index) const;
BOOLEAN_template& result();
const BOOLEAN_template& result() const;
ITS__Container::ActionID_template& actionId();
const ITS__Container::ActionID_template& actionId() const;
int size_of() const;
void log() const;
void log_match(const UtDenmTriggerResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtDenmUpdate : public Base_Type {
  ITS__Container::ActionID field_actionId;
  INTEGER field_detectionTime;
  OPTIONAL<INTEGER> field_validityDuration;
  OPTIONAL<DENM__PDU__Descriptions::SituationContainer> field_situation;
  OPTIONAL<DENM__PDU__Descriptions::LocationContainer> field_location;
  OPTIONAL<ITS__Container::RelevanceDistance> field_relevanceDistance;
  OPTIONAL<ITS__Container::RelevanceTrafficDirection> field_relevanceTrafficDirection;
  OPTIONAL<INTEGER> field_transmissionInterval;
  OPTIONAL<INTEGER> field_repetitionInterval;
  OPTIONAL<DENM__PDU__Descriptions::AlacarteContainer> field_alacarte;
  boolean bound_flag;
public:
  UtDenmUpdate();
  UtDenmUpdate(const ITS__Container::ActionID& par_actionId,
    const INTEGER& par_detectionTime,
    const OPTIONAL<INTEGER>& par_validityDuration,
    const OPTIONAL<DENM__PDU__Descriptions::SituationContainer>& par_situation,
    const OPTIONAL<DENM__PDU__Descriptions::LocationContainer>& par_location,
    const OPTIONAL<ITS__Container::RelevanceDistance>& par_relevanceDistance,
    const OPTIONAL<ITS__Container::RelevanceTrafficDirection>& par_relevanceTrafficDirection,
    const OPTIONAL<INTEGER>& par_transmissionInterval,
    const OPTIONAL<INTEGER>& par_repetitionInterval,
    const OPTIONAL<DENM__PDU__Descriptions::AlacarteContainer>& par_alacarte);
  UtDenmUpdate(const UtDenmUpdate& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtDenmUpdate& operator=(const UtDenmUpdate& other_value);
  boolean operator==(const UtDenmUpdate& other_value) const;
  inline boolean operator!=(const UtDenmUpdate& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ITS__Container::ActionID& actionId()
    {return field_actionId;}
  inline const ITS__Container::ActionID& actionId() const
    {return field_actionId;}
  inline INTEGER& detectionTime()
    {return field_detectionTime;}
  inline const INTEGER& detectionTime() const
    {return field_detectionTime;}
  inline OPTIONAL<INTEGER>& validityDuration()
    {return field_validityDuration;}
  inline const OPTIONAL<INTEGER>& validityDuration() const
    {return field_validityDuration;}
  inline OPTIONAL<DENM__PDU__Descriptions::SituationContainer>& situation()
    {return field_situation;}
  inline const OPTIONAL<DENM__PDU__Descriptions::SituationContainer>& situation() const
    {return field_situation;}
  inline OPTIONAL<DENM__PDU__Descriptions::LocationContainer>& location()
    {return field_location;}
  inline const OPTIONAL<DENM__PDU__Descriptions::LocationContainer>& location() const
    {return field_location;}
  inline OPTIONAL<ITS__Container::RelevanceDistance>& relevanceDistance()
    {return field_relevanceDistance;}
  inline const OPTIONAL<ITS__Container::RelevanceDistance>& relevanceDistance() const
    {return field_relevanceDistance;}
  inline OPTIONAL<ITS__Container::RelevanceTrafficDirection>& relevanceTrafficDirection()
    {return field_relevanceTrafficDirection;}
  inline const OPTIONAL<ITS__Container::RelevanceTrafficDirection>& relevanceTrafficDirection() const
    {return field_relevanceTrafficDirection;}
  inline OPTIONAL<INTEGER>& transmissionInterval()
    {return field_transmissionInterval;}
  inline const OPTIONAL<INTEGER>& transmissionInterval() const
    {return field_transmissionInterval;}
  inline OPTIONAL<INTEGER>& repetitionInterval()
    {return field_repetitionInterval;}
  inline const OPTIONAL<INTEGER>& repetitionInterval() const
    {return field_repetitionInterval;}
  inline OPTIONAL<DENM__PDU__Descriptions::AlacarteContainer>& alacarte()
    {return field_alacarte;}
  inline const OPTIONAL<DENM__PDU__Descriptions::AlacarteContainer>& alacarte() const
    {return field_alacarte;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtDenmUpdate_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtDenmUpdate_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtDenmUpdate& other_value);
void copy_template(const UtDenmUpdate_template& other_value);

public:
UtDenmUpdate_template();
UtDenmUpdate_template(template_sel other_value);
UtDenmUpdate_template(const UtDenmUpdate& other_value);
UtDenmUpdate_template(const OPTIONAL<UtDenmUpdate>& other_value);
UtDenmUpdate_template(const UtDenmUpdate_template& other_value);
~UtDenmUpdate_template();
UtDenmUpdate_template& operator=(template_sel other_value);
UtDenmUpdate_template& operator=(const UtDenmUpdate& other_value);
UtDenmUpdate_template& operator=(const OPTIONAL<UtDenmUpdate>& other_value);
UtDenmUpdate_template& operator=(const UtDenmUpdate_template& other_value);
boolean match(const UtDenmUpdate& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtDenmUpdate valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtDenmUpdate_template& list_item(unsigned int list_index) const;
ITS__Container::ActionID_template& actionId();
const ITS__Container::ActionID_template& actionId() const;
INTEGER_template& detectionTime();
const INTEGER_template& detectionTime() const;
INTEGER_template& validityDuration();
const INTEGER_template& validityDuration() const;
DENM__PDU__Descriptions::SituationContainer_template& situation();
const DENM__PDU__Descriptions::SituationContainer_template& situation() const;
DENM__PDU__Descriptions::LocationContainer_template& location();
const DENM__PDU__Descriptions::LocationContainer_template& location() const;
ITS__Container::RelevanceDistance_template& relevanceDistance();
const ITS__Container::RelevanceDistance_template& relevanceDistance() const;
ITS__Container::RelevanceTrafficDirection_template& relevanceTrafficDirection();
const ITS__Container::RelevanceTrafficDirection_template& relevanceTrafficDirection() const;
INTEGER_template& transmissionInterval();
const INTEGER_template& transmissionInterval() const;
INTEGER_template& repetitionInterval();
const INTEGER_template& repetitionInterval() const;
DENM__PDU__Descriptions::AlacarteContainer_template& alacarte();
const DENM__PDU__Descriptions::AlacarteContainer_template& alacarte() const;
int size_of() const;
void log() const;
void log_match(const UtDenmUpdate& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtDenmUpdateResult : public Base_Type {
  BOOLEAN field_result;
  ITS__Container::ActionID field_actionId;
  boolean bound_flag;
public:
  UtDenmUpdateResult();
  UtDenmUpdateResult(const BOOLEAN& par_result,
    const ITS__Container::ActionID& par_actionId);
  UtDenmUpdateResult(const UtDenmUpdateResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtDenmUpdateResult& operator=(const UtDenmUpdateResult& other_value);
  boolean operator==(const UtDenmUpdateResult& other_value) const;
  inline boolean operator!=(const UtDenmUpdateResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BOOLEAN& result()
    {return field_result;}
  inline const BOOLEAN& result() const
    {return field_result;}
  inline ITS__Container::ActionID& actionId()
    {return field_actionId;}
  inline const ITS__Container::ActionID& actionId() const
    {return field_actionId;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtDenmUpdateResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtDenmUpdateResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtDenmUpdateResult& other_value);
void copy_template(const UtDenmUpdateResult_template& other_value);

public:
UtDenmUpdateResult_template();
UtDenmUpdateResult_template(template_sel other_value);
UtDenmUpdateResult_template(const UtDenmUpdateResult& other_value);
UtDenmUpdateResult_template(const OPTIONAL<UtDenmUpdateResult>& other_value);
UtDenmUpdateResult_template(const UtDenmUpdateResult_template& other_value);
~UtDenmUpdateResult_template();
UtDenmUpdateResult_template& operator=(template_sel other_value);
UtDenmUpdateResult_template& operator=(const UtDenmUpdateResult& other_value);
UtDenmUpdateResult_template& operator=(const OPTIONAL<UtDenmUpdateResult>& other_value);
UtDenmUpdateResult_template& operator=(const UtDenmUpdateResult_template& other_value);
boolean match(const UtDenmUpdateResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtDenmUpdateResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtDenmUpdateResult_template& list_item(unsigned int list_index) const;
BOOLEAN_template& result();
const BOOLEAN_template& result() const;
ITS__Container::ActionID_template& actionId();
const ITS__Container::ActionID_template& actionId() const;
int size_of() const;
void log() const;
void log_match(const UtDenmUpdateResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtDenmTermination : public Base_Type {
  ITS__Container::ActionID field_actionId;
  boolean bound_flag;
public:
  UtDenmTermination();
  UtDenmTermination(const ITS__Container::ActionID& par_actionId);
  UtDenmTermination(const UtDenmTermination& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtDenmTermination& operator=(const UtDenmTermination& other_value);
  boolean operator==(const UtDenmTermination& other_value) const;
  inline boolean operator!=(const UtDenmTermination& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ITS__Container::ActionID& actionId()
    {return field_actionId;}
  inline const ITS__Container::ActionID& actionId() const
    {return field_actionId;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtDenmTermination_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtDenmTermination_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtDenmTermination& other_value);
void copy_template(const UtDenmTermination_template& other_value);

public:
UtDenmTermination_template();
UtDenmTermination_template(template_sel other_value);
UtDenmTermination_template(const UtDenmTermination& other_value);
UtDenmTermination_template(const OPTIONAL<UtDenmTermination>& other_value);
UtDenmTermination_template(const UtDenmTermination_template& other_value);
~UtDenmTermination_template();
UtDenmTermination_template& operator=(template_sel other_value);
UtDenmTermination_template& operator=(const UtDenmTermination& other_value);
UtDenmTermination_template& operator=(const OPTIONAL<UtDenmTermination>& other_value);
UtDenmTermination_template& operator=(const UtDenmTermination_template& other_value);
boolean match(const UtDenmTermination& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtDenmTermination valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtDenmTermination_template& list_item(unsigned int list_index) const;
ITS__Container::ActionID_template& actionId();
const ITS__Container::ActionID_template& actionId() const;
int size_of() const;
void log() const;
void log_match(const UtDenmTermination& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtDenmEventInd : public Base_Type {
  DENM__PDU__Descriptions::DENM field_denMsg;
  boolean bound_flag;
public:
  UtDenmEventInd();
  UtDenmEventInd(const DENM__PDU__Descriptions::DENM& par_denMsg);
  UtDenmEventInd(const UtDenmEventInd& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtDenmEventInd& operator=(const UtDenmEventInd& other_value);
  boolean operator==(const UtDenmEventInd& other_value) const;
  inline boolean operator!=(const UtDenmEventInd& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline DENM__PDU__Descriptions::DENM& denMsg()
    {return field_denMsg;}
  inline const DENM__PDU__Descriptions::DENM& denMsg() const
    {return field_denMsg;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtDenmEventInd_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtDenmEventInd_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtDenmEventInd& other_value);
void copy_template(const UtDenmEventInd_template& other_value);

public:
UtDenmEventInd_template();
UtDenmEventInd_template(template_sel other_value);
UtDenmEventInd_template(const UtDenmEventInd& other_value);
UtDenmEventInd_template(const OPTIONAL<UtDenmEventInd>& other_value);
UtDenmEventInd_template(const UtDenmEventInd_template& other_value);
~UtDenmEventInd_template();
UtDenmEventInd_template& operator=(template_sel other_value);
UtDenmEventInd_template& operator=(const UtDenmEventInd& other_value);
UtDenmEventInd_template& operator=(const OPTIONAL<UtDenmEventInd>& other_value);
UtDenmEventInd_template& operator=(const UtDenmEventInd_template& other_value);
boolean match(const UtDenmEventInd& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtDenmEventInd valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtDenmEventInd_template& list_item(unsigned int list_index) const;
DENM__PDU__Descriptions::DENM_template& denMsg();
const DENM__PDU__Descriptions::DENM_template& denMsg() const;
int size_of() const;
void log() const;
void log_match(const UtDenmEventInd& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtDenmEventIndList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
UtDenmEventInd **value_elements;
} *val_ptr;

static const UtDenmEventInd UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const UtDenmEventIndList& other_value);

public:
  typedef UtDenmEventInd of_type;
UtDenmEventIndList();
UtDenmEventIndList(null_type other_value);
UtDenmEventIndList(const UtDenmEventIndList& other_value);
~UtDenmEventIndList();

void clean_up();
UtDenmEventIndList& operator=(null_type other_value);
UtDenmEventIndList& operator=(const UtDenmEventIndList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const UtDenmEventIndList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const UtDenmEventIndList& other_value) const { return !(*this == other_value); }

UtDenmEventInd& operator[](int index_value);
UtDenmEventInd& operator[](const INTEGER& index_value);
const UtDenmEventInd& operator[](int index_value) const;
const UtDenmEventInd& operator[](const INTEGER& index_value) const;

UtDenmEventIndList operator<<=(int rotate_count) const;
UtDenmEventIndList operator<<=(const INTEGER& rotate_count) const;
UtDenmEventIndList operator>>=(int rotate_count) const;
UtDenmEventIndList operator>>=(const INTEGER& rotate_count) const;

UtDenmEventIndList operator+(const UtDenmEventIndList& other_value) const;

UtDenmEventIndList substr(int index, int returncount) const;

UtDenmEventIndList replace(int index, int len, const UtDenmEventIndList& repl) const;

UtDenmEventIndList replace(int index, int len, const UtDenmEventIndList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class UtDenmEventIndList_template : public Record_Of_Template {
union {
struct {
int n_elements;
UtDenmEventInd_template **value_elements;
} single_value;
struct {
unsigned int n_values;
UtDenmEventIndList_template *list_value;
} value_list;
};
void copy_value(const UtDenmEventIndList& other_value);
void copy_template(const UtDenmEventIndList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
UtDenmEventIndList_template();
UtDenmEventIndList_template(template_sel other_value);
UtDenmEventIndList_template(null_type other_value);
UtDenmEventIndList_template(const UtDenmEventIndList& other_value);
UtDenmEventIndList_template(const OPTIONAL<UtDenmEventIndList>& other_value);
UtDenmEventIndList_template(const UtDenmEventIndList_template& other_value);
~UtDenmEventIndList_template();

void clean_up();
UtDenmEventIndList_template& operator=(template_sel other_value);
UtDenmEventIndList_template& operator=(null_type other_value);
UtDenmEventIndList_template& operator=(const UtDenmEventIndList& other_value);
UtDenmEventIndList_template& operator=(const OPTIONAL<UtDenmEventIndList>& other_value);
UtDenmEventIndList_template& operator=(const UtDenmEventIndList_template& other_value);

UtDenmEventInd_template& operator[](int index_value);
UtDenmEventInd_template& operator[](const INTEGER& index_value);
const UtDenmEventInd_template& operator[](int index_value) const;
const UtDenmEventInd_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const UtDenmEventIndList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
UtDenmEventIndList valueof() const;
UtDenmEventIndList substr(int index, int returncount) const;

UtDenmEventIndList replace(int index, int len, const UtDenmEventIndList_template& repl) const;

UtDenmEventIndList replace(int index, int len, const UtDenmEventIndList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
UtDenmEventIndList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const UtDenmEventIndList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class UtDenmActionIDList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ITS__Container::ActionID **value_elements;
} *val_ptr;

static const ITS__Container::ActionID UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const UtDenmActionIDList& other_value);

public:
  typedef ITS__Container::ActionID of_type;
UtDenmActionIDList();
UtDenmActionIDList(null_type other_value);
UtDenmActionIDList(const UtDenmActionIDList& other_value);
~UtDenmActionIDList();

void clean_up();
UtDenmActionIDList& operator=(null_type other_value);
UtDenmActionIDList& operator=(const UtDenmActionIDList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const UtDenmActionIDList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const UtDenmActionIDList& other_value) const { return !(*this == other_value); }

ITS__Container::ActionID& operator[](int index_value);
ITS__Container::ActionID& operator[](const INTEGER& index_value);
const ITS__Container::ActionID& operator[](int index_value) const;
const ITS__Container::ActionID& operator[](const INTEGER& index_value) const;

UtDenmActionIDList operator<<=(int rotate_count) const;
UtDenmActionIDList operator<<=(const INTEGER& rotate_count) const;
UtDenmActionIDList operator>>=(int rotate_count) const;
UtDenmActionIDList operator>>=(const INTEGER& rotate_count) const;

UtDenmActionIDList operator+(const UtDenmActionIDList& other_value) const;

UtDenmActionIDList substr(int index, int returncount) const;

UtDenmActionIDList replace(int index, int len, const UtDenmActionIDList& repl) const;

UtDenmActionIDList replace(int index, int len, const UtDenmActionIDList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class UtDenmActionIDList_template : public Record_Of_Template {
union {
struct {
int n_elements;
ITS__Container::ActionID_template **value_elements;
} single_value;
struct {
unsigned int n_values;
UtDenmActionIDList_template *list_value;
} value_list;
};
void copy_value(const UtDenmActionIDList& other_value);
void copy_template(const UtDenmActionIDList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
UtDenmActionIDList_template();
UtDenmActionIDList_template(template_sel other_value);
UtDenmActionIDList_template(null_type other_value);
UtDenmActionIDList_template(const UtDenmActionIDList& other_value);
UtDenmActionIDList_template(const OPTIONAL<UtDenmActionIDList>& other_value);
UtDenmActionIDList_template(const UtDenmActionIDList_template& other_value);
~UtDenmActionIDList_template();

void clean_up();
UtDenmActionIDList_template& operator=(template_sel other_value);
UtDenmActionIDList_template& operator=(null_type other_value);
UtDenmActionIDList_template& operator=(const UtDenmActionIDList& other_value);
UtDenmActionIDList_template& operator=(const OPTIONAL<UtDenmActionIDList>& other_value);
UtDenmActionIDList_template& operator=(const UtDenmActionIDList_template& other_value);

ITS__Container::ActionID_template& operator[](int index_value);
ITS__Container::ActionID_template& operator[](const INTEGER& index_value);
const ITS__Container::ActionID_template& operator[](int index_value) const;
const ITS__Container::ActionID_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const UtDenmActionIDList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
UtDenmActionIDList valueof() const;
UtDenmActionIDList substr(int index, int returncount) const;

UtDenmActionIDList replace(int index, int len, const UtDenmActionIDList_template& repl) const;

UtDenmActionIDList replace(int index, int len, const UtDenmActionIDList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
UtDenmActionIDList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const UtDenmActionIDList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const SituationContainerList& other_value);
inline boolean operator!=(null_type null_value, const SituationContainerList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ActionIDList& other_value);
inline boolean operator!=(null_type null_value, const ActionIDList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const UtDenmEventIndList& other_value);
inline boolean operator!=(null_type null_value, const UtDenmEventIndList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const UtDenmActionIDList& other_value);
inline boolean operator!=(null_type null_value, const UtDenmActionIDList& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const TTCN_RAWdescriptor_t Trigger_raw_;
extern const TTCN_Typedescriptor_t Trigger_descr_;
extern const TTCN_RAWdescriptor_t SituationContainerList_raw_;
extern const TTCN_Typedescriptor_t SituationContainerList_descr_;
extern const TTCN_RAWdescriptor_t ActionIDList_raw_;
extern const TTCN_Typedescriptor_t ActionIDList_descr_;
extern const INTEGER& c__protocolVersionDenm;
extern const INTEGER& c__messageIdDenm;
extern const INTEGER& c__duration__2sec;
extern const INTEGER& c__duration__5sec;
extern const INTEGER& c__duration__10sec;
extern const INTEGER& c__interval__1sec;
extern const INTEGER& c__interval__2sec;
extern const INTEGER& c__interval__4sec;
extern const INTEGER& c__interval__5sec;
extern const INTEGER& c__interval__10sec;
extern const TTCN_RAWdescriptor_t UtDenmTrigger_raw_;
extern const TTCN_JSONdescriptor_t UtDenmTrigger_json_;
extern const TTCN_Typedescriptor_t UtDenmTrigger_descr_;
extern const TTCN_RAWdescriptor_t UtDenmTriggerResult_result_raw_;
extern const XERdescriptor_t UtDenmTriggerResult_result_xer_;
extern const TTCN_Typedescriptor_t UtDenmTriggerResult_result_descr_;
extern const TTCN_RAWdescriptor_t UtDenmTriggerResult_actionId_raw_;
extern const TTCN_Typedescriptor_t UtDenmTriggerResult_actionId_descr_;
extern const TTCN_RAWdescriptor_t UtDenmTriggerResult_raw_;
extern const TTCN_JSONdescriptor_t UtDenmTriggerResult_json_;
extern const TTCN_Typedescriptor_t UtDenmTriggerResult_descr_;
extern const TTCN_RAWdescriptor_t UtDenmUpdate_raw_;
extern const TTCN_JSONdescriptor_t UtDenmUpdate_json_;
extern const TTCN_Typedescriptor_t UtDenmUpdate_descr_;
extern const TTCN_RAWdescriptor_t UtDenmUpdateResult_result_raw_;
extern const XERdescriptor_t UtDenmUpdateResult_result_xer_;
extern const TTCN_Typedescriptor_t UtDenmUpdateResult_result_descr_;
extern const TTCN_RAWdescriptor_t UtDenmUpdateResult_actionId_raw_;
extern const TTCN_Typedescriptor_t UtDenmUpdateResult_actionId_descr_;
extern const TTCN_RAWdescriptor_t UtDenmUpdateResult_raw_;
extern const TTCN_JSONdescriptor_t UtDenmUpdateResult_json_;
extern const TTCN_Typedescriptor_t UtDenmUpdateResult_descr_;
extern const TTCN_RAWdescriptor_t UtDenmTermination_raw_;
extern const TTCN_JSONdescriptor_t UtDenmTermination_json_;
extern const TTCN_Typedescriptor_t UtDenmTermination_descr_;
extern const TTCN_RAWdescriptor_t UtDenmTerminationResult_raw_;
extern const XERdescriptor_t UtDenmTerminationResult_xer_;
extern const TTCN_Typedescriptor_t UtDenmTerminationResult_descr_;
extern const TTCN_RAWdescriptor_t UtDenmEventInd_raw_;
extern const TTCN_JSONdescriptor_t UtDenmEventInd_json_;
extern const TTCN_Typedescriptor_t UtDenmEventInd_descr_;
extern const TTCN_RAWdescriptor_t UtDenmEventIndList_raw_;
extern const TTCN_Typedescriptor_t UtDenmEventIndList_descr_;
extern const TTCN_RAWdescriptor_t UtDenmActionIDList_raw_;
extern const TTCN_Typedescriptor_t UtDenmActionIDList_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
