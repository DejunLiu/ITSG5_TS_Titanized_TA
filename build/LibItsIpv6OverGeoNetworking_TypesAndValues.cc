// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "LibItsIpv6OverGeoNetworking_TypesAndValues.hh"

namespace LibItsIpv6OverGeoNetworking__TypesAndValues {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();

/* Literal string constants */

static const unsigned char bs_0_bits[] = { 95 };
static const BITSTRING bs_0(7, bs_0_bits);
static const unsigned char os_9_octets[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
os_3_octets[] = { 0, 1 },
os_4_octets[] = { 0, 2 },
os_0_octets[] = { 51, 51, 0, 0, 0, 1 },
os_6_octets[] = { 126 },
os_2_octets[] = { 254, 128 },
os_1_octets[] = { 255, 2 },
os_7_octets[] = { 255, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
os_8_octets[] = { 255, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2 },
os_5_octets[] = { 255, 255 };
static const OCTETSTRING os_9(16, os_9_octets),
os_3(2, os_3_octets),
os_4(2, os_4_octets),
os_0(6, os_0_octets),
os_6(1, os_6_octets),
os_2(2, os_2_octets),
os_1(2, os_1_octets),
os_7(16, os_7_octets),
os_8(16, os_8_octets),
os_5(2, os_5_octets);
static const CHARSTRING cs_0(4, "GVL1"),
cs_1(4, "GVL2"),
cs_2(4, "GVL3"),
cs_3(9, "GVL_AREA1"),
cs_4(9, "GVL_AREA2"),
cs_5(9, "GVL_AREA3");
static const unsigned char module_checksum[] = { 0x2e, 0x3c, 0xf0, 0x3e, 0x6f, 0xd2, 0x42, 0x8e, 0x93, 0x59, 0x9d, 0x03, 0x65, 0x8c, 0xf0, 0xe8 };

/* Global variable definitions */

const XERdescriptor_t       GvlTableEntry_key_xer_ = { {"key>\n", "key>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GvlTableEntry_key_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.key", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &GvlTableEntry_key_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GvlTableEntry_prefix_xer_ = { {"prefix>\n", "prefix>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GvlTableEntry_prefix_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.prefix", &OCTETSTRING_ber_, &LibCommon__DataStrings::Oct16_raw_, &OCTETSTRING_text_, &GvlTableEntry_prefix_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GvlTableEntry_prefixLength_xer_ = { {"prefixLength>\n", "prefixLength>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GvlTableEntry_prefixLength_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.prefixLength", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &GvlTableEntry_prefixLength_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GvlTableEntry_area_xer_ = { {"area>\n", "area>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GvlTableEntry_area_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.area", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &GvlTableEntry_area_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GvlTableEntry_interface_xer_ = { {"interface>\n", "interface>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GvlTableEntry_interface_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.interface", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &GvlTableEntry_interface_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GvlTableEntry_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GvlTableEntry
const TTCN_JSONdescriptor_t GvlTableEntry_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GvlTableEntry_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry", NULL, &GvlTableEntry_raw_, NULL, NULL, &GvlTableEntry_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GvlTable_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GvlTable
const TTCN_Typedescriptor_t GvlTable_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable", NULL, &GvlTable_raw_, NULL, NULL, NULL, &GvlTableEntry_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       AddressTableEntry_key_xer_ = { {"key>\n", "key>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t AddressTableEntry_key_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.key", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &AddressTableEntry_key_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       AddressTableEntry_macAddress_xer_ = { {"macAddress>\n", "macAddress>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t AddressTableEntry_macAddress_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.macAddress", &OCTETSTRING_ber_, &LibCommon__DataStrings::Oct6_raw_, &OCTETSTRING_text_, &AddressTableEntry_macAddress_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       AddressTableEntry_macSolNodeMca_xer_ = { {"macSolNodeMca>\n", "macSolNodeMca>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t AddressTableEntry_macSolNodeMca_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.macSolNodeMca", &OCTETSTRING_ber_, &LibCommon__DataStrings::Oct6_raw_, &OCTETSTRING_text_, &AddressTableEntry_macSolNodeMca_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t Ipv6Address_raw_ = {128,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,16};
const XERdescriptor_t       Ipv6Address_xer_ = { {"Ipv6Address>\n", "Ipv6Address>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Ipv6Address_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Address", &OCTETSTRING_ber_, &Ipv6Address_raw_, &OCTETSTRING_text_, &Ipv6Address_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       AddressTableEntry_lla_xer_ = { {"lla>\n", "lla>\n"}, {5, 5}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t AddressTableEntry_lla_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.lla", &OCTETSTRING_ber_, &Ipv6Address_raw_, &OCTETSTRING_text_, &AddressTableEntry_lla_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       AddressTableEntry_solNodeMca_xer_ = { {"solNodeMca>\n", "solNodeMca>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t AddressTableEntry_solNodeMca_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.solNodeMca", &OCTETSTRING_ber_, &Ipv6Address_raw_, &OCTETSTRING_text_, &AddressTableEntry_solNodeMca_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AddressTableEntry_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AddressTableEntry
const TTCN_JSONdescriptor_t AddressTableEntry_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AddressTableEntry_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry", NULL, &AddressTableEntry_raw_, NULL, NULL, &AddressTableEntry_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AddressTable_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AddressTable
const TTCN_Typedescriptor_t AddressTable_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable", NULL, &AddressTable_raw_, NULL, NULL, NULL, &AddressTableEntry_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GvlIdxList_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GvlIdxList
const TTCN_Typedescriptor_t GvlIdxList_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlIdxList", NULL, &GvlIdxList_raw_, NULL, NULL, NULL, &INTEGER_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GvlIdxList_0_xer_ = { {"INTEGER>\n", "INTEGER>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GvlIdxList_0_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlIdxList.INTEGER", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &GvlIdxList_0_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t UInt32List_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for UInt32List
const TTCN_Typedescriptor_t UInt32List_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.UInt32List", NULL, &UInt32List_raw_, NULL, NULL, NULL, &LibCommon__BasicTypesAndValues::UInt32_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       UInt32List_0_xer_ = { {"UInt32>\n", "UInt32>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t UInt32List_0_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.UInt32List.<oftype>", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt32_raw_, &INTEGER_text_, &UInt32List_0_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static INTEGER const_c__gvl1;
const INTEGER& c__gvl1 = const_c__gvl1;
static INTEGER const_c__gvl2;
const INTEGER& c__gvl2 = const_c__gvl2;
static INTEGER const_c__gvl3;
const INTEGER& c__gvl3 = const_c__gvl3;
static CHARSTRING const_c__gvl1__name;
const CHARSTRING& c__gvl1__name = const_c__gvl1__name;
static CHARSTRING const_c__gvl2__name;
const CHARSTRING& c__gvl2__name = const_c__gvl2__name;
static CHARSTRING const_c__gvl3__name;
const CHARSTRING& c__gvl3__name = const_c__gvl3__name;
static CHARSTRING const_c__gvlArea1;
const CHARSTRING& c__gvlArea1 = const_c__gvlArea1;
static CHARSTRING const_c__gvlArea2;
const CHARSTRING& c__gvlArea2 = const_c__gvlArea2;
static CHARSTRING const_c__gvlArea3;
const CHARSTRING& c__gvlArea3 = const_c__gvlArea3;
static OCTETSTRING const_c__macBroadcastAddr;
const OCTETSTRING& c__macBroadcastAddr = const_c__macBroadcastAddr;
const XERdescriptor_t       Ipv6Header_version_xer_ = { {"version>\n", "version>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Ipv6Header_version_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.version", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt4_raw_, &INTEGER_text_, &Ipv6Header_version_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Ipv6Header_trafficClass_xer_ = { {"trafficClass>\n", "trafficClass>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Ipv6Header_trafficClass_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.trafficClass", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &Ipv6Header_trafficClass_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Ipv6Header_flowLabel_xer_ = { {"flowLabel>\n", "flowLabel>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Ipv6Header_flowLabel_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.flowLabel", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt20_raw_, &INTEGER_text_, &Ipv6Header_flowLabel_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Ipv6Header_payloadLength_xer_ = { {"payloadLength>\n", "payloadLength>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Ipv6Header_payloadLength_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.payloadLength", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &Ipv6Header_payloadLength_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Ipv6Header_nextHeader_xer_ = { {"nextHeader>\n", "nextHeader>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Ipv6Header_nextHeader_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.nextHeader", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &Ipv6Header_nextHeader_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Ipv6Header_hopLimit_xer_ = { {"hopLimit>\n", "hopLimit>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Ipv6Header_hopLimit_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.hopLimit", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &Ipv6Header_hopLimit_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Ipv6Header_sourceAddress_xer_ = { {"sourceAddress>\n", "sourceAddress>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Ipv6Header_sourceAddress_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.sourceAddress", &OCTETSTRING_ber_, &Ipv6Address_raw_, &OCTETSTRING_text_, &Ipv6Header_sourceAddress_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Ipv6Header_destinationAddress_xer_ = { {"destinationAddress>\n", "destinationAddress>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Ipv6Header_destinationAddress_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.destinationAddress", &OCTETSTRING_ber_, &Ipv6Address_raw_, &OCTETSTRING_text_, &Ipv6Header_destinationAddress_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t Ipv6Header_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for Ipv6Header
const TTCN_JSONdescriptor_t Ipv6Header_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Ipv6Header_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header", NULL, &Ipv6Header_raw_, NULL, NULL, &Ipv6Header_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t Ipv6Packet_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for Ipv6Packet
const TTCN_JSONdescriptor_t Ipv6Packet_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Ipv6Packet_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet", NULL, &Ipv6Packet_raw_, NULL, NULL, &Ipv6Packet_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ExtensionHeaderList_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       ExtensionHeaderList_xer_ = { {"ExtensionHeaderList>\n", "ExtensionHeaderList>\n"}, {21, 21}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ExtensionHeaderList_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.ExtensionHeaderList", &OCTETSTRING_ber_, &ExtensionHeaderList_raw_, &OCTETSTRING_text_, &ExtensionHeaderList_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Ipv6Packet_extHdrList_xer_ = { {"extHdrList>\n", "extHdrList>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Ipv6Packet_extHdrList_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.extHdrList", &OCTETSTRING_ber_, &ExtensionHeaderList_raw_, &OCTETSTRING_text_, &Ipv6Packet_extHdrList_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t Ipv6Payload_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for Ipv6Payload
const TTCN_JSONdescriptor_t Ipv6Payload_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Ipv6Payload_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload", NULL, &Ipv6Payload_raw_, NULL, NULL, &Ipv6Payload_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       RouterAdvertisementMsg_icmpType_xer_ = { {"icmpType>\n", "icmpType>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t RouterAdvertisementMsg_icmpType_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.icmpType", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &RouterAdvertisementMsg_icmpType_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       RouterAdvertisementMsg_icmpCode_xer_ = { {"icmpCode>\n", "icmpCode>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t RouterAdvertisementMsg_icmpCode_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.icmpCode", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &RouterAdvertisementMsg_icmpCode_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       RouterAdvertisementMsg_checksum_xer_ = { {"checksum>\n", "checksum>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t RouterAdvertisementMsg_checksum_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.checksum", &OCTETSTRING_ber_, &LibCommon__DataStrings::Oct2_raw_, &OCTETSTRING_text_, &RouterAdvertisementMsg_checksum_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       RouterAdvertisementMsg_curHopLimit_xer_ = { {"curHopLimit>\n", "curHopLimit>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t RouterAdvertisementMsg_curHopLimit_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.curHopLimit", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &RouterAdvertisementMsg_curHopLimit_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       RouterAdvertisementMsg_managedConfigFlag_xer_ = { {"managedConfigFlag>\n", "managedConfigFlag>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t RouterAdvertisementMsg_managedConfigFlag_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.managedConfigFlag", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt1_raw_, &INTEGER_text_, &RouterAdvertisementMsg_managedConfigFlag_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       RouterAdvertisementMsg_otherConfigFlag_xer_ = { {"otherConfigFlag>\n", "otherConfigFlag>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t RouterAdvertisementMsg_otherConfigFlag_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.otherConfigFlag", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt1_raw_, &INTEGER_text_, &RouterAdvertisementMsg_otherConfigFlag_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       RouterAdvertisementMsg_homeAgentFlag_xer_ = { {"homeAgentFlag>\n", "homeAgentFlag>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t RouterAdvertisementMsg_homeAgentFlag_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.homeAgentFlag", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt1_raw_, &INTEGER_text_, &RouterAdvertisementMsg_homeAgentFlag_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       RouterAdvertisementMsg_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t RouterAdvertisementMsg_reserved_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.reserved", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt5_raw_, &INTEGER_text_, &RouterAdvertisementMsg_reserved_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       RouterAdvertisementMsg_routerLifetime_xer_ = { {"routerLifetime>\n", "routerLifetime>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t RouterAdvertisementMsg_routerLifetime_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.routerLifetime", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &RouterAdvertisementMsg_routerLifetime_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       RouterAdvertisementMsg_reachableTime_xer_ = { {"reachableTime>\n", "reachableTime>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t RouterAdvertisementMsg_reachableTime_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.reachableTime", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt32_raw_, &INTEGER_text_, &RouterAdvertisementMsg_reachableTime_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       RouterAdvertisementMsg_retransTimer_xer_ = { {"retransTimer>\n", "retransTimer>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t RouterAdvertisementMsg_retransTimer_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.retransTimer", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt32_raw_, &INTEGER_text_, &RouterAdvertisementMsg_retransTimer_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t RouterAdvertisementMsg_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for RouterAdvertisementMsg
const TTCN_JSONdescriptor_t RouterAdvertisementMsg_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RouterAdvertisementMsg_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg", NULL, &RouterAdvertisementMsg_raw_, NULL, NULL, &RouterAdvertisementMsg_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t RtAdvOptions_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for RtAdvOptions
const TTCN_JSONdescriptor_t RtAdvOptions_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RtAdvOptions_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions", NULL, &RtAdvOptions_raw_, NULL, NULL, &RtAdvOptions_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SrcLinkLayerAddress_icmpType_xer_ = { {"icmpType>\n", "icmpType>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SrcLinkLayerAddress_icmpType_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.icmpType", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &SrcLinkLayerAddress_icmpType_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SrcLinkLayerAddress_optionLength_xer_ = { {"optionLength>\n", "optionLength>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SrcLinkLayerAddress_optionLength_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.optionLength", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &SrcLinkLayerAddress_optionLength_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SrcLinkLayerAddress_linkLayerAddr_xer_ = { {"linkLayerAddr>\n", "linkLayerAddr>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SrcLinkLayerAddress_linkLayerAddr_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.linkLayerAddr", &OCTETSTRING_ber_, &LibCommon__DataStrings::Oct6to15_raw_, &OCTETSTRING_text_, &SrcLinkLayerAddress_linkLayerAddr_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SrcLinkLayerAddress_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SrcLinkLayerAddress
const TTCN_JSONdescriptor_t SrcLinkLayerAddress_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SrcLinkLayerAddress_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress", NULL, &SrcLinkLayerAddress_raw_, NULL, NULL, &SrcLinkLayerAddress_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t PrefixInfoList_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for PrefixInfoList
const TTCN_JSONdescriptor_t PrefixInfoList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t PrefixInfoList_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList", NULL, &PrefixInfoList_raw_, NULL, NULL, &PrefixInfoList_json_, &PrefixInfo_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       PrefixInfo_icmpType_xer_ = { {"icmpType>\n", "icmpType>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t PrefixInfo_icmpType_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.icmpType", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &PrefixInfo_icmpType_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       PrefixInfo_optionLength_xer_ = { {"optionLength>\n", "optionLength>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t PrefixInfo_optionLength_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.optionLength", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &PrefixInfo_optionLength_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       PrefixInfo_prefixLength_xer_ = { {"prefixLength>\n", "prefixLength>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t PrefixInfo_prefixLength_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.prefixLength", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &PrefixInfo_prefixLength_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       PrefixInfo_linkFlag_xer_ = { {"linkFlag>\n", "linkFlag>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t PrefixInfo_linkFlag_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.linkFlag", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt1_raw_, &INTEGER_text_, &PrefixInfo_linkFlag_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       PrefixInfo_autoConfigFlag_xer_ = { {"autoConfigFlag>\n", "autoConfigFlag>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t PrefixInfo_autoConfigFlag_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.autoConfigFlag", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt1_raw_, &INTEGER_text_, &PrefixInfo_autoConfigFlag_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       PrefixInfo_rtAddrFlag_xer_ = { {"rtAddrFlag>\n", "rtAddrFlag>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t PrefixInfo_rtAddrFlag_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.rtAddrFlag", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt1_raw_, &INTEGER_text_, &PrefixInfo_rtAddrFlag_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       PrefixInfo_reserved1_xer_ = { {"reserved1>\n", "reserved1>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t PrefixInfo_reserved1_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.reserved1", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt5_raw_, &INTEGER_text_, &PrefixInfo_reserved1_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       PrefixInfo_validLifetime_xer_ = { {"validLifetime>\n", "validLifetime>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t PrefixInfo_validLifetime_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.validLifetime", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt32_raw_, &INTEGER_text_, &PrefixInfo_validLifetime_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       PrefixInfo_preferredLifetime_xer_ = { {"preferredLifetime>\n", "preferredLifetime>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t PrefixInfo_preferredLifetime_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.preferredLifetime", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt32_raw_, &INTEGER_text_, &PrefixInfo_preferredLifetime_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       PrefixInfo_reserved2_xer_ = { {"reserved2>\n", "reserved2>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t PrefixInfo_reserved2_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.reserved2", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt32_raw_, &INTEGER_text_, &PrefixInfo_reserved2_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t Prefix_raw_ = {128,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,16};
const XERdescriptor_t       Prefix_xer_ = { {"Prefix>\n", "Prefix>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Prefix_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.Prefix", &OCTETSTRING_ber_, &Prefix_raw_, &OCTETSTRING_text_, &Prefix_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       PrefixInfo_prefix_xer_ = { {"prefix>\n", "prefix>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t PrefixInfo_prefix_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.prefix", &OCTETSTRING_ber_, &Prefix_raw_, &OCTETSTRING_text_, &PrefixInfo_prefix_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t PrefixInfo_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for PrefixInfo
const TTCN_JSONdescriptor_t PrefixInfo_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t PrefixInfo_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo", NULL, &PrefixInfo_raw_, NULL, NULL, &PrefixInfo_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       RtAdvOptions_otherOption_xer_ = { {"otherOption>\n", "otherOption>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t RtAdvOptions_otherOption_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.otherOption", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &RtAdvOptions_otherOption_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Ipv6Payload_octetstringMsg_xer_ = { {"octetstringMsg>\n", "octetstringMsg>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Ipv6Payload_octetstringMsg_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.octetstringMsg", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &Ipv6Payload_octetstringMsg_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static INTEGER const_c__hopHdr;
const INTEGER& c__hopHdr = const_c__hopHdr;
static INTEGER const_c__tcpHdr;
const INTEGER& c__tcpHdr = const_c__tcpHdr;
static INTEGER const_c__udpHdr;
const INTEGER& c__udpHdr = const_c__udpHdr;
static INTEGER const_c__tunneledIpHdr;
const INTEGER& c__tunneledIpHdr = const_c__tunneledIpHdr;
static INTEGER const_c__routeHdr;
const INTEGER& c__routeHdr = const_c__routeHdr;
static INTEGER const_c__fragHdr;
const INTEGER& c__fragHdr = const_c__fragHdr;
static INTEGER const_c__espHdr;
const INTEGER& c__espHdr = const_c__espHdr;
static INTEGER const_c__authHdr;
const INTEGER& c__authHdr = const_c__authHdr;
static INTEGER const_c__icmpHdr;
const INTEGER& c__icmpHdr = const_c__icmpHdr;
static INTEGER const_c__noNextHdr;
const INTEGER& c__noNextHdr = const_c__noNextHdr;
static INTEGER const_c__dstHdr;
const INTEGER& c__dstHdr = const_c__dstHdr;
static INTEGER const_c__mobileHdr;
const INTEGER& c__mobileHdr = const_c__mobileHdr;
static INTEGER const_c__prefixInfo;
const INTEGER& c__prefixInfo = const_c__prefixInfo;
static INTEGER const_c__rtAdvMsg;
const INTEGER& c__rtAdvMsg = const_c__rtAdvMsg;
static OCTETSTRING const_c__llaMcaPrefix;
const OCTETSTRING& c__llaMcaPrefix = const_c__llaMcaPrefix;
static OCTETSTRING const_c__llaPrefix;
const OCTETSTRING& c__llaPrefix = const_c__llaPrefix;
static OCTETSTRING const_c__allNodesMcaPostfix;
const OCTETSTRING& c__allNodesMcaPostfix = const_c__allNodesMcaPostfix;
static OCTETSTRING const_c__allRoutersMcaPostfix;
const OCTETSTRING& c__allRoutersMcaPostfix = const_c__allRoutersMcaPostfix;
static OCTETSTRING const_c__anycastPostfix;
const OCTETSTRING& c__anycastPostfix = const_c__anycastPostfix;
static OCTETSTRING const_c__haAnycastPostfix;
const OCTETSTRING& c__haAnycastPostfix = const_c__haAnycastPostfix;
static OCTETSTRING const_c__allNodesMca;
const OCTETSTRING& c__allNodesMca = const_c__allNodesMca;
static OCTETSTRING const_c__allRoutersMca;
const OCTETSTRING& c__allRoutersMca = const_c__allRoutersMca;
static OCTETSTRING const_c__unspecified;
const OCTETSTRING& c__unspecified = const_c__unspecified;
static BITSTRING const_c__itsGn6aslGeoAnycastID;
const BITSTRING& c__itsGn6aslGeoAnycastID = const_c__itsGn6aslGeoAnycastID;
static INTEGER const_c__maxNrPrefixInfo;
const INTEGER& c__maxNrPrefixInfo = const_c__maxNrPrefixInfo;
static INTEGER const_c__rtAddrFlag0;
const INTEGER& c__rtAddrFlag0 = const_c__rtAddrFlag0;
static INTEGER const_c__aFlag0;
const INTEGER& c__aFlag0 = const_c__aFlag0;
static INTEGER const_c__aFlag1;
const INTEGER& c__aFlag1 = const_c__aFlag1;
static INTEGER const_c__rFlag0;
const INTEGER& c__rFlag0 = const_c__rFlag0;
static INTEGER const_c__rFlag1;
const INTEGER& c__rFlag1 = const_c__rFlag1;
static INTEGER const_c__sFlag0;
const INTEGER& c__sFlag0 = const_c__sFlag0;
static INTEGER const_c__sFlag1;
const INTEGER& c__sFlag1 = const_c__sFlag1;
static INTEGER const_c__oFlag0;
const INTEGER& c__oFlag0 = const_c__oFlag0;
static INTEGER const_c__oFlag1;
const INTEGER& c__oFlag1 = const_c__oFlag1;
static INTEGER const_c__mFlag0;
const INTEGER& c__mFlag0 = const_c__mFlag0;
static INTEGER const_c__mFlag1;
const INTEGER& c__mFlag1 = const_c__mFlag1;
static INTEGER const_c__lFlag0;
const INTEGER& c__lFlag0 = const_c__lFlag0;
static INTEGER const_c__lFlag1;
const INTEGER& c__lFlag1 = const_c__lFlag1;
static INTEGER const_c__zeroLifetime;
const INTEGER& c__zeroLifetime = const_c__zeroLifetime;
static INTEGER const_c__validLifetime20s;
const INTEGER& c__validLifetime20s = const_c__validLifetime20s;
static INTEGER const_c__validLifetime30s;
const INTEGER& c__validLifetime30s = const_c__validLifetime30s;
static INTEGER const_c__preferredLifetime30s;
const INTEGER& c__preferredLifetime30s = const_c__preferredLifetime30s;
static INTEGER const_c__srcLinkLayerAddress;
const INTEGER& c__srcLinkLayerAddress = const_c__srcLinkLayerAddress;
static INTEGER const_c__prefixInfoLen;
const INTEGER& c__prefixInfoLen = const_c__prefixInfoLen;
const TTCN_RAWdescriptor_t AcGn6Primitive_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AcGn6Primitive
const TTCN_JSONdescriptor_t AcGn6Primitive_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AcGn6Primitive_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive", NULL, &AcGn6Primitive_raw_, NULL, NULL, &AcGn6Primitive_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       AcGn6Primitive_getInterfaceInfos_xer_ = { {"getInterfaceInfos>\n", "getInterfaceInfos>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t AcGn6Primitive_getInterfaceInfos_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.getInterfaceInfos", &INTEGER_ber_, &INTEGER_raw_, &INTEGER_text_, &AcGn6Primitive_getInterfaceInfos_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AcGn6Response_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AcGn6Response
const TTCN_JSONdescriptor_t AcGn6Response_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AcGn6Response_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response", NULL, &AcGn6Response_raw_, NULL, NULL, &AcGn6Response_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AcGn6InterfaceInfoList_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AcGn6InterfaceInfoList
const TTCN_JSONdescriptor_t AcGn6InterfaceInfoList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AcGn6InterfaceInfoList_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList", NULL, &AcGn6InterfaceInfoList_raw_, NULL, NULL, &AcGn6InterfaceInfoList_json_, &AcGn6InterfaceInfo_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       AcGn6InterfaceInfo_interfaceName_xer_ = { {"interfaceName>\n", "interfaceName>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t AcGn6InterfaceInfo_interfaceName_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo.interfaceName", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &AcGn6InterfaceInfo_interfaceName_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t Ipv6AddressList_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for Ipv6AddressList
const TTCN_JSONdescriptor_t Ipv6AddressList_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Ipv6AddressList_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6AddressList", NULL, &Ipv6AddressList_raw_, NULL, NULL, &Ipv6AddressList_json_, &Ipv6Address_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Ipv6AddressList_0_xer_ = { {"Ipv6Address>\n", "Ipv6Address>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Ipv6AddressList_0_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6AddressList.<oftype>", &OCTETSTRING_ber_, &Ipv6Address_raw_, &OCTETSTRING_text_, &Ipv6AddressList_0_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AcGn6InterfaceInfo_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AcGn6InterfaceInfo
const TTCN_JSONdescriptor_t AcGn6InterfaceInfo_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AcGn6InterfaceInfo_descr_ = { "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo", NULL, &AcGn6InterfaceInfo_raw_, NULL, NULL, &AcGn6InterfaceInfo_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const size_t num_namespaces = 0;
TTCN_Module module_object("LibItsIpv6OverGeoNetworking_TypesAndValues", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_5,
  current_runtime_version.requires_minor_version_4,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

GvlTableEntry::GvlTableEntry()
{
  bound_flag = FALSE;
}

GvlTableEntry::GvlTableEntry(const CHARSTRING& par_key,
    const OCTETSTRING& par_prefix,
    const INTEGER& par_prefixLength,
    const CHARSTRING& par_area,
    const CHARSTRING& par_interface)
  :   field_key(par_key),
  field_prefix(par_prefix),
  field_prefixLength(par_prefixLength),
  field_area(par_area),
  field_interface(par_interface)
{
  bound_flag = TRUE;
}

GvlTableEntry::GvlTableEntry(const GvlTableEntry& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
bound_flag = TRUE;
if (other_value.key().is_bound()) field_key = other_value.key();
else field_key.clean_up();
if (other_value.prefix().is_bound()) field_prefix = other_value.prefix();
else field_prefix.clean_up();
if (other_value.prefixLength().is_bound()) field_prefixLength = other_value.prefixLength();
else field_prefixLength.clean_up();
if (other_value.area().is_bound()) field_area = other_value.area();
else field_area.clean_up();
if (other_value.interface().is_bound()) field_interface = other_value.interface();
else field_interface.clean_up();
}

void GvlTableEntry::clean_up()
{
field_key.clean_up();
field_prefix.clean_up();
field_prefixLength.clean_up();
field_area.clean_up();
field_interface.clean_up();
bound_flag = FALSE;
}

GvlTableEntry& GvlTableEntry::operator=(const GvlTableEntry& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
  bound_flag = TRUE;
  if (other_value.key().is_bound()) field_key = other_value.key();
  else field_key.clean_up();
  if (other_value.prefix().is_bound()) field_prefix = other_value.prefix();
  else field_prefix.clean_up();
  if (other_value.prefixLength().is_bound()) field_prefixLength = other_value.prefixLength();
  else field_prefixLength.clean_up();
  if (other_value.area().is_bound()) field_area = other_value.area();
  else field_area.clean_up();
  if (other_value.interface().is_bound()) field_interface = other_value.interface();
  else field_interface.clean_up();
}
return *this;
}

boolean GvlTableEntry::operator==(const GvlTableEntry& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_key==other_value.field_key
  && field_prefix==other_value.field_prefix
  && field_prefixLength==other_value.field_prefixLength
  && field_area==other_value.field_area
  && field_interface==other_value.field_interface;
}

boolean GvlTableEntry::is_bound() const
{
if (bound_flag) return TRUE;
if(field_key.is_bound()) return TRUE;
if(field_prefix.is_bound()) return TRUE;
if(field_prefixLength.is_bound()) return TRUE;
if(field_area.is_bound()) return TRUE;
if(field_interface.is_bound()) return TRUE;
return FALSE;
}
boolean GvlTableEntry::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_key.is_value()) return FALSE;
if(!field_prefix.is_value()) return FALSE;
if(!field_prefixLength.is_value()) return FALSE;
if(!field_area.is_value()) return FALSE;
if(!field_interface.is_value()) return FALSE;
return TRUE;
}
int GvlTableEntry::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry");
  return 5;
}

void GvlTableEntry::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ key := ");
field_key.log();
TTCN_Logger::log_event_str(", prefix := ");
field_prefix.log();
TTCN_Logger::log_event_str(", prefixLength := ");
field_prefixLength.log();
TTCN_Logger::log_event_str(", area := ");
field_area.log();
TTCN_Logger::log_event_str(", interface := ");
field_interface.log();
TTCN_Logger::log_event_str(" }");
}

void GvlTableEntry::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry'");
    }
    if (strcmp("key", param_field) == 0) {
      key().set_param(param);
      return;
    } else if (strcmp("prefix", param_field) == 0) {
      prefix().set_param(param);
      return;
    } else if (strcmp("prefixLength", param_field) == 0) {
      prefixLength().set_param(param);
      return;
    } else if (strcmp("area", param_field) == 0) {
      area().set_param(param);
      return;
    } else if (strcmp("interface", param_field) == 0) {
      interface().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) key().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) prefix().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) prefixLength().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) area().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) interface().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "prefix")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          prefix().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "prefixLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          prefixLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "area")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          area().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "interface")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          interface().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry");
  }
}

Module_Param* GvlTableEntry::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry'");
    }
    if (strcmp("key", param_field) == 0) {
      return key().get_param(param_name);
    } else if (strcmp("prefix", param_field) == 0) {
      return prefix().get_param(param_name);
    } else if (strcmp("prefixLength", param_field) == 0) {
      return prefixLength().get_param(param_name);
    } else if (strcmp("area", param_field) == 0) {
      return area().get_param(param_name);
    } else if (strcmp("interface", param_field) == 0) {
      return interface().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_key = field_key.get_param(param_name);
  mp_field_key->set_id(new Module_Param_FieldName(mcopystr("key")));
  mp->add_elem(mp_field_key);
  Module_Param* mp_field_prefix = field_prefix.get_param(param_name);
  mp_field_prefix->set_id(new Module_Param_FieldName(mcopystr("prefix")));
  mp->add_elem(mp_field_prefix);
  Module_Param* mp_field_prefixLength = field_prefixLength.get_param(param_name);
  mp_field_prefixLength->set_id(new Module_Param_FieldName(mcopystr("prefixLength")));
  mp->add_elem(mp_field_prefixLength);
  Module_Param* mp_field_area = field_area.get_param(param_name);
  mp_field_area->set_id(new Module_Param_FieldName(mcopystr("area")));
  mp->add_elem(mp_field_area);
  Module_Param* mp_field_interface = field_interface.get_param(param_name);
  mp_field_interface->set_id(new Module_Param_FieldName(mcopystr("interface")));
  mp->add_elem(mp_field_interface);
  return mp;
  }

void GvlTableEntry::set_implicit_omit()
{
if (key().is_bound()) key().set_implicit_omit();
if (prefix().is_bound()) prefix().set_implicit_omit();
if (prefixLength().is_bound()) prefixLength().set_implicit_omit();
if (area().is_bound()) area().set_implicit_omit();
if (interface().is_bound()) interface().set_implicit_omit();
}

void GvlTableEntry::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
field_key.encode_text(text_buf);
field_prefix.encode_text(text_buf);
field_prefixLength.encode_text(text_buf);
field_area.encode_text(text_buf);
field_interface.encode_text(text_buf);
}

void GvlTableEntry::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_key.decode_text(text_buf);
field_prefix.decode_text(text_buf);
field_prefixLength.decode_text(text_buf);
field_area.decode_text(text_buf);
field_interface.decode_text(text_buf);
}

void GvlTableEntry::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GvlTableEntry::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GvlTableEntry::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_key.RAW_decode(CHARSTRING_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_prefix.RAW_decode(LibCommon__DataStrings::Oct16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_prefixLength.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_area.RAW_decode(CHARSTRING_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_interface.RAW_decode(CHARSTRING_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GvlTableEntry::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 5;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(5);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, CHARSTRING_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__DataStrings::Oct16_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, CHARSTRING_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, CHARSTRING_descr_.raw);
  encoded_length += field_key.RAW_encode(CHARSTRING_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_prefix.RAW_encode(LibCommon__DataStrings::Oct16_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_prefixLength.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_area.RAW_encode(CHARSTRING_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_interface.RAW_encode(CHARSTRING_descr_, *myleaf.body.node.nodes[4]);
  return myleaf.length = encoded_length;
}

int GvlTableEntry::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "key");
    enc_len += field_key.JSON_encode(CHARSTRING_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "prefix");
    enc_len += field_prefix.JSON_encode(LibCommon__DataStrings::Oct16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "prefixLength");
    enc_len += field_prefixLength.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "area");
    enc_len += field_area.JSON_encode(CHARSTRING_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "interface");
    enc_len += field_interface.JSON_encode(CHARSTRING_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GvlTableEntry::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (3 == name_len && 0 == strncmp(fld_name, "key", name_len)) {
         int ret_val = field_key.JSON_decode(CHARSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "key");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "prefix", name_len)) {
         int ret_val = field_prefix.JSON_decode(LibCommon__DataStrings::Oct16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "prefix");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "prefixLength", name_len)) {
         int ret_val = field_prefixLength.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "prefixLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (4 == name_len && 0 == strncmp(fld_name, "area", name_len)) {
         int ret_val = field_area.JSON_decode(CHARSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "area");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "interface", name_len)) {
         int ret_val = field_interface.JSON_decode(CHARSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "interface");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_key.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "key");
    return JSON_ERROR_FATAL;
  }
if (!field_prefix.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "prefix");
    return JSON_ERROR_FATAL;
  }
if (!field_prefixLength.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "prefixLength");
    return JSON_ERROR_FATAL;
  }
if (!field_area.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "area");
    return JSON_ERROR_FATAL;
  }
if (!field_interface.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "interface");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct GvlTableEntry_template::single_value_struct {
CHARSTRING_template field_key;
OCTETSTRING_template field_prefix;
INTEGER_template field_prefixLength;
CHARSTRING_template field_area;
CHARSTRING_template field_interface;
};

void GvlTableEntry_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_key = ANY_VALUE;
single_value->field_prefix = ANY_VALUE;
single_value->field_prefixLength = ANY_VALUE;
single_value->field_area = ANY_VALUE;
single_value->field_interface = ANY_VALUE;
}
}
}

void GvlTableEntry_template::copy_value(const GvlTableEntry& other_value)
{
single_value = new single_value_struct;
if (other_value.key().is_bound()) {
  single_value->field_key = other_value.key();
} else {
  single_value->field_key.clean_up();
}
if (other_value.prefix().is_bound()) {
  single_value->field_prefix = other_value.prefix();
} else {
  single_value->field_prefix.clean_up();
}
if (other_value.prefixLength().is_bound()) {
  single_value->field_prefixLength = other_value.prefixLength();
} else {
  single_value->field_prefixLength.clean_up();
}
if (other_value.area().is_bound()) {
  single_value->field_area = other_value.area();
} else {
  single_value->field_area.clean_up();
}
if (other_value.interface().is_bound()) {
  single_value->field_interface = other_value.interface();
} else {
  single_value->field_interface.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GvlTableEntry_template::copy_template(const GvlTableEntry_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.key().get_selection()) {
single_value->field_key = other_value.key();
} else {
single_value->field_key.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.prefix().get_selection()) {
single_value->field_prefix = other_value.prefix();
} else {
single_value->field_prefix.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.prefixLength().get_selection()) {
single_value->field_prefixLength = other_value.prefixLength();
} else {
single_value->field_prefixLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.area().get_selection()) {
single_value->field_area = other_value.area();
} else {
single_value->field_area.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.interface().get_selection()) {
single_value->field_interface = other_value.interface();
} else {
single_value->field_interface.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GvlTableEntry_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
break;
}
set_selection(other_value);
}

GvlTableEntry_template::GvlTableEntry_template()
{
}

GvlTableEntry_template::GvlTableEntry_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GvlTableEntry_template::GvlTableEntry_template(const GvlTableEntry& other_value)
{
copy_value(other_value);
}

GvlTableEntry_template::GvlTableEntry_template(const OPTIONAL<GvlTableEntry>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GvlTableEntry&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry from an unbound optional field.");
}
}

GvlTableEntry_template::GvlTableEntry_template(const GvlTableEntry_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GvlTableEntry_template::~GvlTableEntry_template()
{
clean_up();
}

GvlTableEntry_template& GvlTableEntry_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GvlTableEntry_template& GvlTableEntry_template::operator=(const GvlTableEntry& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GvlTableEntry_template& GvlTableEntry_template::operator=(const OPTIONAL<GvlTableEntry>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GvlTableEntry&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
}
return *this;
}

GvlTableEntry_template& GvlTableEntry_template::operator=(const GvlTableEntry_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GvlTableEntry_template::match(const GvlTableEntry& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.key().is_bound()) return FALSE;
if(!single_value->field_key.match(other_value.key(), legacy))return FALSE;
if(!other_value.prefix().is_bound()) return FALSE;
if(!single_value->field_prefix.match(other_value.prefix(), legacy))return FALSE;
if(!other_value.prefixLength().is_bound()) return FALSE;
if(!single_value->field_prefixLength.match(other_value.prefixLength(), legacy))return FALSE;
if(!other_value.area().is_bound()) return FALSE;
if(!single_value->field_area.match(other_value.area(), legacy))return FALSE;
if(!other_value.interface().is_bound()) return FALSE;
if(!single_value->field_interface.match(other_value.interface(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
}
return FALSE;
}

boolean GvlTableEntry_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_key.is_bound()) return TRUE;
if (single_value->field_prefix.is_bound()) return TRUE;
if (single_value->field_prefixLength.is_bound()) return TRUE;
if (single_value->field_area.is_bound()) return TRUE;
if (single_value->field_interface.is_bound()) return TRUE;
return FALSE;
}

boolean GvlTableEntry_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_key.is_value()) return FALSE;
if (!single_value->field_prefix.is_value()) return FALSE;
if (!single_value->field_prefixLength.is_value()) return FALSE;
if (!single_value->field_area.is_value()) return FALSE;
if (!single_value->field_interface.is_value()) return FALSE;
return TRUE;
}

void GvlTableEntry_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GvlTableEntry GvlTableEntry_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
GvlTableEntry ret_val;
if (single_value->field_key.is_bound()) {
ret_val.key() = single_value->field_key.valueof();
}
if (single_value->field_prefix.is_bound()) {
ret_val.prefix() = single_value->field_prefix.valueof();
}
if (single_value->field_prefixLength.is_bound()) {
ret_val.prefixLength() = single_value->field_prefixLength.valueof();
}
if (single_value->field_area.is_bound()) {
ret_val.area() = single_value->field_area.valueof();
}
if (single_value->field_interface.is_bound()) {
ret_val.interface() = single_value->field_interface.valueof();
}
return ret_val;
}

void GvlTableEntry_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GvlTableEntry_template[list_length];
}

GvlTableEntry_template& GvlTableEntry_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
return value_list.list_value[list_index];
}

CHARSTRING_template& GvlTableEntry_template::key()
{
set_specific();
return single_value->field_key;
}

const CHARSTRING_template& GvlTableEntry_template::key() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field key of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
return single_value->field_key;
}

OCTETSTRING_template& GvlTableEntry_template::prefix()
{
set_specific();
return single_value->field_prefix;
}

const OCTETSTRING_template& GvlTableEntry_template::prefix() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field prefix of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
return single_value->field_prefix;
}

INTEGER_template& GvlTableEntry_template::prefixLength()
{
set_specific();
return single_value->field_prefixLength;
}

const INTEGER_template& GvlTableEntry_template::prefixLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field prefixLength of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
return single_value->field_prefixLength;
}

CHARSTRING_template& GvlTableEntry_template::area()
{
set_specific();
return single_value->field_area;
}

const CHARSTRING_template& GvlTableEntry_template::area() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field area of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
return single_value->field_area;
}

CHARSTRING_template& GvlTableEntry_template::interface()
{
set_specific();
return single_value->field_interface;
}

const CHARSTRING_template& GvlTableEntry_template::interface() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field interface of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
return single_value->field_interface;
}

int GvlTableEntry_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 5;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
  }
  return 0;
}

void GvlTableEntry_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ key := ");
single_value->field_key.log();
TTCN_Logger::log_event_str(", prefix := ");
single_value->field_prefix.log();
TTCN_Logger::log_event_str(", prefixLength := ");
single_value->field_prefixLength.log();
TTCN_Logger::log_event_str(", area := ");
single_value->field_area.log();
TTCN_Logger::log_event_str(", interface := ");
single_value->field_interface.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GvlTableEntry_template::log_match(const GvlTableEntry& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_key.match(match_value.key(), legacy)){
TTCN_Logger::log_logmatch_info(".key");
single_value->field_key.log_match(match_value.key(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_prefix.match(match_value.prefix(), legacy)){
TTCN_Logger::log_logmatch_info(".prefix");
single_value->field_prefix.log_match(match_value.prefix(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_prefixLength.match(match_value.prefixLength(), legacy)){
TTCN_Logger::log_logmatch_info(".prefixLength");
single_value->field_prefixLength.log_match(match_value.prefixLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_area.match(match_value.area(), legacy)){
TTCN_Logger::log_logmatch_info(".area");
single_value->field_area.log_match(match_value.area(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_interface.match(match_value.interface(), legacy)){
TTCN_Logger::log_logmatch_info(".interface");
single_value->field_interface.log_match(match_value.interface(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ key := ");
single_value->field_key.log_match(match_value.key(), legacy);
TTCN_Logger::log_event_str(", prefix := ");
single_value->field_prefix.log_match(match_value.prefix(), legacy);
TTCN_Logger::log_event_str(", prefixLength := ");
single_value->field_prefixLength.log_match(match_value.prefixLength(), legacy);
TTCN_Logger::log_event_str(", area := ");
single_value->field_area.log_match(match_value.area(), legacy);
TTCN_Logger::log_event_str(", interface := ");
single_value->field_interface.log_match(match_value.interface(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GvlTableEntry_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_key.encode_text(text_buf);
single_value->field_prefix.encode_text(text_buf);
single_value->field_prefixLength.encode_text(text_buf);
single_value->field_area.encode_text(text_buf);
single_value->field_interface.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
}
}

void GvlTableEntry_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_key.decode_text(text_buf);
single_value->field_prefix.decode_text(text_buf);
single_value->field_prefixLength.decode_text(text_buf);
single_value->field_area.decode_text(text_buf);
single_value->field_interface.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GvlTableEntry_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry.");
}
}

void GvlTableEntry_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry'");
    }
    if (strcmp("key", param_field) == 0) {
      key().set_param(param);
      return;
    } else if (strcmp("prefix", param_field) == 0) {
      prefix().set_param(param);
      return;
    } else if (strcmp("prefixLength", param_field) == 0) {
      prefixLength().set_param(param);
      return;
    } else if (strcmp("area", param_field) == 0) {
      area().set_param(param);
      return;
    } else if (strcmp("interface", param_field) == 0) {
      interface().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GvlTableEntry_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) key().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) prefix().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) prefixLength().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) area().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) interface().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "prefix")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          prefix().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "prefixLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          prefixLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "area")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          area().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "interface")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          interface().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GvlTableEntry_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry'");
    }
    if (strcmp("key", param_field) == 0) {
      return key().get_param(param_name);
    } else if (strcmp("prefix", param_field) == 0) {
      return prefix().get_param(param_name);
    } else if (strcmp("prefixLength", param_field) == 0) {
      return prefixLength().get_param(param_name);
    } else if (strcmp("area", param_field) == 0) {
      return area().get_param(param_name);
    } else if (strcmp("interface", param_field) == 0) {
      return interface().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_key = single_value->field_key.get_param(param_name);
    mp_field_key->set_id(new Module_Param_FieldName(mcopystr("key")));
    mp->add_elem(mp_field_key);
    Module_Param* mp_field_prefix = single_value->field_prefix.get_param(param_name);
    mp_field_prefix->set_id(new Module_Param_FieldName(mcopystr("prefix")));
    mp->add_elem(mp_field_prefix);
    Module_Param* mp_field_prefixLength = single_value->field_prefixLength.get_param(param_name);
    mp_field_prefixLength->set_id(new Module_Param_FieldName(mcopystr("prefixLength")));
    mp->add_elem(mp_field_prefixLength);
    Module_Param* mp_field_area = single_value->field_area.get_param(param_name);
    mp_field_area->set_id(new Module_Param_FieldName(mcopystr("area")));
    mp->add_elem(mp_field_area);
    Module_Param* mp_field_interface = single_value->field_interface.get_param(param_name);
    mp_field_interface->set_id(new Module_Param_FieldName(mcopystr("interface")));
    mp->add_elem(mp_field_interface);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GvlTableEntry_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_key.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry");
single_value->field_prefix.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry");
single_value->field_prefixLength.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry");
single_value->field_area.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry");
single_value->field_interface.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTableEntry");
}

boolean GvlTableEntry_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GvlTableEntry_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const GvlTableEntry GvlTable::UNBOUND_ELEM;
GvlTable::GvlTable()
{
val_ptr = NULL;
}

GvlTable::GvlTable(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

GvlTable::GvlTable(const GvlTable& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

GvlTable::~GvlTable()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void GvlTable::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

GvlTable& GvlTable::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

GvlTable& GvlTable::operator=(const GvlTable& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean GvlTable::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
return val_ptr->n_elements == 0 ;
}

boolean GvlTable::operator==(const GvlTable& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

GvlTableEntry& GvlTable::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (GvlTableEntry**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new GvlTableEntry(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new GvlTableEntry;
}
return *val_ptr->value_elements[index_value];
}

GvlTableEntry& GvlTable::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
return (*this)[(int)index_value];
}

const GvlTableEntry& GvlTable::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const GvlTableEntry& GvlTable::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
return (*this)[(int)index_value];
}

GvlTable GvlTable::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

GvlTable GvlTable::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

GvlTable GvlTable::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

GvlTable GvlTable::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
GvlTable ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new GvlTableEntry(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

GvlTable GvlTable::operator+(const GvlTable& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
GvlTable ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new GvlTableEntry(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new GvlTableEntry(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

GvlTable GvlTable::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable","element");
GvlTable ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new GvlTableEntry(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

GvlTable GvlTable::replace(int index, int len, const GvlTable& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable","element");
GvlTable ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new GvlTableEntry(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new GvlTableEntry(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new GvlTableEntry(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

GvlTable GvlTable::replace(int index, int len, const GvlTable_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void GvlTable::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (GvlTableEntry**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new GvlTableEntry(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (GvlTableEntry**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (GvlTableEntry**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean GvlTable::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int GvlTable::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
return val_ptr->n_elements;
}

int GvlTable::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void GvlTable::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void GvlTable::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* GvlTable::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void GvlTable::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void GvlTable::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void GvlTable::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
val_ptr->value_elements = (GvlTableEntry**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new GvlTableEntry;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void GvlTable::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GvlTable::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GvlTable::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int GvlTable::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

void GvlTable_template::copy_value(const GvlTable& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (GvlTableEntry_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new GvlTableEntry_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new GvlTableEntry_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void GvlTable_template::copy_template(const GvlTable_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (GvlTableEntry_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new GvlTableEntry_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new GvlTableEntry_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GvlTable_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
break;
}
set_selection(other_value);
}

boolean GvlTable_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const GvlTable_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const GvlTable*)value_ptr)[value_index], legacy);
else return ((const GvlTable_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

GvlTable_template::GvlTable_template()
{
}

GvlTable_template::GvlTable_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

GvlTable_template::GvlTable_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

GvlTable_template::GvlTable_template(const GvlTable& other_value)
{
copy_value(other_value);
}

GvlTable_template::GvlTable_template(const OPTIONAL<GvlTable>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GvlTable&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable from an unbound optional field.");
}
}

GvlTable_template::GvlTable_template(const GvlTable_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

GvlTable_template::~GvlTable_template()
{
clean_up();
}

void GvlTable_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GvlTable_template& GvlTable_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GvlTable_template& GvlTable_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

GvlTable_template& GvlTable_template::operator=(const GvlTable& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GvlTable_template& GvlTable_template::operator=(const OPTIONAL<GvlTable>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GvlTable&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
}
return *this;
}

GvlTable_template& GvlTable_template::operator=(const GvlTable_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

GvlTableEntry_template& GvlTable_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
    break;
}
return *single_value.value_elements[index_value];
}

GvlTableEntry_template& GvlTable_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
return (*this)[(int)index_value];
}

const GvlTableEntry_template& GvlTable_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const GvlTableEntry_template& GvlTable_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
return (*this)[(int)index_value];
}

void GvlTable_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (GvlTableEntry_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new GvlTableEntry_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new GvlTableEntry_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (GvlTableEntry_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int GvlTable_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int GvlTable_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable");
}

boolean GvlTable_template::match(const GvlTable& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
}
return FALSE;
}

boolean GvlTable_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

GvlTable GvlTable_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
GvlTable ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

GvlTable GvlTable_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

GvlTable GvlTable_template::replace(int index, int len, const GvlTable_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

GvlTable GvlTable_template::replace(int index, int len, const GvlTable& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void GvlTable_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new GvlTable_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
}
set_selection(template_type);
}

GvlTable_template& GvlTable_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
return value_list.list_value[list_index];
}

void GvlTable_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void GvlTable_template::log_match(const GvlTable& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GvlTable_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
}
}

void GvlTable_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
single_value.value_elements = (GvlTableEntry_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new GvlTableEntry_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GvlTable_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
}
}

boolean GvlTable_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GvlTable_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GvlTable_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GvlTable_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* GvlTable_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void GvlTable_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable");
}

AddressTableEntry::AddressTableEntry()
{
  bound_flag = FALSE;
}

AddressTableEntry::AddressTableEntry(const CHARSTRING& par_key,
    const OCTETSTRING& par_macAddress,
    const OCTETSTRING& par_macSolNodeMca,
    const OCTETSTRING& par_lla,
    const OCTETSTRING& par_solNodeMca)
  :   field_key(par_key),
  field_macAddress(par_macAddress),
  field_macSolNodeMca(par_macSolNodeMca),
  field_lla(par_lla),
  field_solNodeMca(par_solNodeMca)
{
  bound_flag = TRUE;
}

AddressTableEntry::AddressTableEntry(const AddressTableEntry& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
bound_flag = TRUE;
if (other_value.key().is_bound()) field_key = other_value.key();
else field_key.clean_up();
if (other_value.macAddress().is_bound()) field_macAddress = other_value.macAddress();
else field_macAddress.clean_up();
if (other_value.macSolNodeMca().is_bound()) field_macSolNodeMca = other_value.macSolNodeMca();
else field_macSolNodeMca.clean_up();
if (other_value.lla().is_bound()) field_lla = other_value.lla();
else field_lla.clean_up();
if (other_value.solNodeMca().is_bound()) field_solNodeMca = other_value.solNodeMca();
else field_solNodeMca.clean_up();
}

void AddressTableEntry::clean_up()
{
field_key.clean_up();
field_macAddress.clean_up();
field_macSolNodeMca.clean_up();
field_lla.clean_up();
field_solNodeMca.clean_up();
bound_flag = FALSE;
}

AddressTableEntry& AddressTableEntry::operator=(const AddressTableEntry& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
  bound_flag = TRUE;
  if (other_value.key().is_bound()) field_key = other_value.key();
  else field_key.clean_up();
  if (other_value.macAddress().is_bound()) field_macAddress = other_value.macAddress();
  else field_macAddress.clean_up();
  if (other_value.macSolNodeMca().is_bound()) field_macSolNodeMca = other_value.macSolNodeMca();
  else field_macSolNodeMca.clean_up();
  if (other_value.lla().is_bound()) field_lla = other_value.lla();
  else field_lla.clean_up();
  if (other_value.solNodeMca().is_bound()) field_solNodeMca = other_value.solNodeMca();
  else field_solNodeMca.clean_up();
}
return *this;
}

boolean AddressTableEntry::operator==(const AddressTableEntry& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_key==other_value.field_key
  && field_macAddress==other_value.field_macAddress
  && field_macSolNodeMca==other_value.field_macSolNodeMca
  && field_lla==other_value.field_lla
  && field_solNodeMca==other_value.field_solNodeMca;
}

boolean AddressTableEntry::is_bound() const
{
if (bound_flag) return TRUE;
if(field_key.is_bound()) return TRUE;
if(field_macAddress.is_bound()) return TRUE;
if(field_macSolNodeMca.is_bound()) return TRUE;
if(field_lla.is_bound()) return TRUE;
if(field_solNodeMca.is_bound()) return TRUE;
return FALSE;
}
boolean AddressTableEntry::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_key.is_value()) return FALSE;
if(!field_macAddress.is_value()) return FALSE;
if(!field_macSolNodeMca.is_value()) return FALSE;
if(!field_lla.is_value()) return FALSE;
if(!field_solNodeMca.is_value()) return FALSE;
return TRUE;
}
int AddressTableEntry::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry");
  return 5;
}

void AddressTableEntry::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ key := ");
field_key.log();
TTCN_Logger::log_event_str(", macAddress := ");
field_macAddress.log();
TTCN_Logger::log_event_str(", macSolNodeMca := ");
field_macSolNodeMca.log();
TTCN_Logger::log_event_str(", lla := ");
field_lla.log();
TTCN_Logger::log_event_str(", solNodeMca := ");
field_solNodeMca.log();
TTCN_Logger::log_event_str(" }");
}

void AddressTableEntry::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry'");
    }
    if (strcmp("key", param_field) == 0) {
      key().set_param(param);
      return;
    } else if (strcmp("macAddress", param_field) == 0) {
      macAddress().set_param(param);
      return;
    } else if (strcmp("macSolNodeMca", param_field) == 0) {
      macSolNodeMca().set_param(param);
      return;
    } else if (strcmp("lla", param_field) == 0) {
      lla().set_param(param);
      return;
    } else if (strcmp("solNodeMca", param_field) == 0) {
      solNodeMca().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) key().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) macAddress().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) macSolNodeMca().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) lla().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) solNodeMca().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "macAddress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          macAddress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "macSolNodeMca")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          macSolNodeMca().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lla")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lla().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "solNodeMca")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          solNodeMca().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry");
  }
}

Module_Param* AddressTableEntry::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry'");
    }
    if (strcmp("key", param_field) == 0) {
      return key().get_param(param_name);
    } else if (strcmp("macAddress", param_field) == 0) {
      return macAddress().get_param(param_name);
    } else if (strcmp("macSolNodeMca", param_field) == 0) {
      return macSolNodeMca().get_param(param_name);
    } else if (strcmp("lla", param_field) == 0) {
      return lla().get_param(param_name);
    } else if (strcmp("solNodeMca", param_field) == 0) {
      return solNodeMca().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_key = field_key.get_param(param_name);
  mp_field_key->set_id(new Module_Param_FieldName(mcopystr("key")));
  mp->add_elem(mp_field_key);
  Module_Param* mp_field_macAddress = field_macAddress.get_param(param_name);
  mp_field_macAddress->set_id(new Module_Param_FieldName(mcopystr("macAddress")));
  mp->add_elem(mp_field_macAddress);
  Module_Param* mp_field_macSolNodeMca = field_macSolNodeMca.get_param(param_name);
  mp_field_macSolNodeMca->set_id(new Module_Param_FieldName(mcopystr("macSolNodeMca")));
  mp->add_elem(mp_field_macSolNodeMca);
  Module_Param* mp_field_lla = field_lla.get_param(param_name);
  mp_field_lla->set_id(new Module_Param_FieldName(mcopystr("lla")));
  mp->add_elem(mp_field_lla);
  Module_Param* mp_field_solNodeMca = field_solNodeMca.get_param(param_name);
  mp_field_solNodeMca->set_id(new Module_Param_FieldName(mcopystr("solNodeMca")));
  mp->add_elem(mp_field_solNodeMca);
  return mp;
  }

void AddressTableEntry::set_implicit_omit()
{
if (key().is_bound()) key().set_implicit_omit();
if (macAddress().is_bound()) macAddress().set_implicit_omit();
if (macSolNodeMca().is_bound()) macSolNodeMca().set_implicit_omit();
if (lla().is_bound()) lla().set_implicit_omit();
if (solNodeMca().is_bound()) solNodeMca().set_implicit_omit();
}

void AddressTableEntry::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
field_key.encode_text(text_buf);
field_macAddress.encode_text(text_buf);
field_macSolNodeMca.encode_text(text_buf);
field_lla.encode_text(text_buf);
field_solNodeMca.encode_text(text_buf);
}

void AddressTableEntry::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_key.decode_text(text_buf);
field_macAddress.decode_text(text_buf);
field_macSolNodeMca.decode_text(text_buf);
field_lla.decode_text(text_buf);
field_solNodeMca.decode_text(text_buf);
}

void AddressTableEntry::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AddressTableEntry::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AddressTableEntry::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_key.RAW_decode(CHARSTRING_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_macAddress.RAW_decode(LibItsExternal__TypesAndValues::MacAddress_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_macSolNodeMca.RAW_decode(LibItsExternal__TypesAndValues::MacAddress_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_lla.RAW_decode(Ipv6Address_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_solNodeMca.RAW_decode(Ipv6Address_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int AddressTableEntry::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 5;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(5);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, CHARSTRING_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibItsExternal__TypesAndValues::MacAddress_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibItsExternal__TypesAndValues::MacAddress_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, Ipv6Address_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, Ipv6Address_descr_.raw);
  encoded_length += field_key.RAW_encode(CHARSTRING_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_macAddress.RAW_encode(LibItsExternal__TypesAndValues::MacAddress_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_macSolNodeMca.RAW_encode(LibItsExternal__TypesAndValues::MacAddress_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_lla.RAW_encode(Ipv6Address_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_solNodeMca.RAW_encode(Ipv6Address_descr_, *myleaf.body.node.nodes[4]);
  return myleaf.length = encoded_length;
}

int AddressTableEntry::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "key");
    enc_len += field_key.JSON_encode(CHARSTRING_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "macAddress");
    enc_len += field_macAddress.JSON_encode(LibItsExternal__TypesAndValues::MacAddress_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "macSolNodeMca");
    enc_len += field_macSolNodeMca.JSON_encode(LibItsExternal__TypesAndValues::MacAddress_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "lla");
    enc_len += field_lla.JSON_encode(Ipv6Address_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "solNodeMca");
    enc_len += field_solNodeMca.JSON_encode(Ipv6Address_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AddressTableEntry::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (3 == name_len && 0 == strncmp(fld_name, "key", name_len)) {
         int ret_val = field_key.JSON_decode(CHARSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "key");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "macAddress", name_len)) {
         int ret_val = field_macAddress.JSON_decode(LibItsExternal__TypesAndValues::MacAddress_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "macAddress");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "macSolNodeMca", name_len)) {
         int ret_val = field_macSolNodeMca.JSON_decode(LibItsExternal__TypesAndValues::MacAddress_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "macSolNodeMca");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (3 == name_len && 0 == strncmp(fld_name, "lla", name_len)) {
         int ret_val = field_lla.JSON_decode(Ipv6Address_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "lla");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "solNodeMca", name_len)) {
         int ret_val = field_solNodeMca.JSON_decode(Ipv6Address_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "solNodeMca");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_key.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "key");
    return JSON_ERROR_FATAL;
  }
if (!field_macAddress.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "macAddress");
    return JSON_ERROR_FATAL;
  }
if (!field_macSolNodeMca.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "macSolNodeMca");
    return JSON_ERROR_FATAL;
  }
if (!field_lla.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "lla");
    return JSON_ERROR_FATAL;
  }
if (!field_solNodeMca.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "solNodeMca");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct AddressTableEntry_template::single_value_struct {
CHARSTRING_template field_key;
OCTETSTRING_template field_macAddress;
OCTETSTRING_template field_macSolNodeMca;
OCTETSTRING_template field_lla;
OCTETSTRING_template field_solNodeMca;
};

void AddressTableEntry_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_key = ANY_VALUE;
single_value->field_macAddress = ANY_VALUE;
single_value->field_macSolNodeMca = ANY_VALUE;
single_value->field_lla = ANY_VALUE;
single_value->field_solNodeMca = ANY_VALUE;
}
}
}

void AddressTableEntry_template::copy_value(const AddressTableEntry& other_value)
{
single_value = new single_value_struct;
if (other_value.key().is_bound()) {
  single_value->field_key = other_value.key();
} else {
  single_value->field_key.clean_up();
}
if (other_value.macAddress().is_bound()) {
  single_value->field_macAddress = other_value.macAddress();
} else {
  single_value->field_macAddress.clean_up();
}
if (other_value.macSolNodeMca().is_bound()) {
  single_value->field_macSolNodeMca = other_value.macSolNodeMca();
} else {
  single_value->field_macSolNodeMca.clean_up();
}
if (other_value.lla().is_bound()) {
  single_value->field_lla = other_value.lla();
} else {
  single_value->field_lla.clean_up();
}
if (other_value.solNodeMca().is_bound()) {
  single_value->field_solNodeMca = other_value.solNodeMca();
} else {
  single_value->field_solNodeMca.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void AddressTableEntry_template::copy_template(const AddressTableEntry_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.key().get_selection()) {
single_value->field_key = other_value.key();
} else {
single_value->field_key.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.macAddress().get_selection()) {
single_value->field_macAddress = other_value.macAddress();
} else {
single_value->field_macAddress.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.macSolNodeMca().get_selection()) {
single_value->field_macSolNodeMca = other_value.macSolNodeMca();
} else {
single_value->field_macSolNodeMca.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.lla().get_selection()) {
single_value->field_lla = other_value.lla();
} else {
single_value->field_lla.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.solNodeMca().get_selection()) {
single_value->field_solNodeMca = other_value.solNodeMca();
} else {
single_value->field_solNodeMca.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AddressTableEntry_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
break;
}
set_selection(other_value);
}

AddressTableEntry_template::AddressTableEntry_template()
{
}

AddressTableEntry_template::AddressTableEntry_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AddressTableEntry_template::AddressTableEntry_template(const AddressTableEntry& other_value)
{
copy_value(other_value);
}

AddressTableEntry_template::AddressTableEntry_template(const OPTIONAL<AddressTableEntry>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AddressTableEntry&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry from an unbound optional field.");
}
}

AddressTableEntry_template::AddressTableEntry_template(const AddressTableEntry_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

AddressTableEntry_template::~AddressTableEntry_template()
{
clean_up();
}

AddressTableEntry_template& AddressTableEntry_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AddressTableEntry_template& AddressTableEntry_template::operator=(const AddressTableEntry& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AddressTableEntry_template& AddressTableEntry_template::operator=(const OPTIONAL<AddressTableEntry>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AddressTableEntry&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
}
return *this;
}

AddressTableEntry_template& AddressTableEntry_template::operator=(const AddressTableEntry_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AddressTableEntry_template::match(const AddressTableEntry& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.key().is_bound()) return FALSE;
if(!single_value->field_key.match(other_value.key(), legacy))return FALSE;
if(!other_value.macAddress().is_bound()) return FALSE;
if(!single_value->field_macAddress.match(other_value.macAddress(), legacy))return FALSE;
if(!other_value.macSolNodeMca().is_bound()) return FALSE;
if(!single_value->field_macSolNodeMca.match(other_value.macSolNodeMca(), legacy))return FALSE;
if(!other_value.lla().is_bound()) return FALSE;
if(!single_value->field_lla.match(other_value.lla(), legacy))return FALSE;
if(!other_value.solNodeMca().is_bound()) return FALSE;
if(!single_value->field_solNodeMca.match(other_value.solNodeMca(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
}
return FALSE;
}

boolean AddressTableEntry_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_key.is_bound()) return TRUE;
if (single_value->field_macAddress.is_bound()) return TRUE;
if (single_value->field_macSolNodeMca.is_bound()) return TRUE;
if (single_value->field_lla.is_bound()) return TRUE;
if (single_value->field_solNodeMca.is_bound()) return TRUE;
return FALSE;
}

boolean AddressTableEntry_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_key.is_value()) return FALSE;
if (!single_value->field_macAddress.is_value()) return FALSE;
if (!single_value->field_macSolNodeMca.is_value()) return FALSE;
if (!single_value->field_lla.is_value()) return FALSE;
if (!single_value->field_solNodeMca.is_value()) return FALSE;
return TRUE;
}

void AddressTableEntry_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AddressTableEntry AddressTableEntry_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
AddressTableEntry ret_val;
if (single_value->field_key.is_bound()) {
ret_val.key() = single_value->field_key.valueof();
}
if (single_value->field_macAddress.is_bound()) {
ret_val.macAddress() = single_value->field_macAddress.valueof();
}
if (single_value->field_macSolNodeMca.is_bound()) {
ret_val.macSolNodeMca() = single_value->field_macSolNodeMca.valueof();
}
if (single_value->field_lla.is_bound()) {
ret_val.lla() = single_value->field_lla.valueof();
}
if (single_value->field_solNodeMca.is_bound()) {
ret_val.solNodeMca() = single_value->field_solNodeMca.valueof();
}
return ret_val;
}

void AddressTableEntry_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AddressTableEntry_template[list_length];
}

AddressTableEntry_template& AddressTableEntry_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
return value_list.list_value[list_index];
}

CHARSTRING_template& AddressTableEntry_template::key()
{
set_specific();
return single_value->field_key;
}

const CHARSTRING_template& AddressTableEntry_template::key() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field key of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
return single_value->field_key;
}

OCTETSTRING_template& AddressTableEntry_template::macAddress()
{
set_specific();
return single_value->field_macAddress;
}

const OCTETSTRING_template& AddressTableEntry_template::macAddress() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field macAddress of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
return single_value->field_macAddress;
}

OCTETSTRING_template& AddressTableEntry_template::macSolNodeMca()
{
set_specific();
return single_value->field_macSolNodeMca;
}

const OCTETSTRING_template& AddressTableEntry_template::macSolNodeMca() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field macSolNodeMca of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
return single_value->field_macSolNodeMca;
}

OCTETSTRING_template& AddressTableEntry_template::lla()
{
set_specific();
return single_value->field_lla;
}

const OCTETSTRING_template& AddressTableEntry_template::lla() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field lla of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
return single_value->field_lla;
}

OCTETSTRING_template& AddressTableEntry_template::solNodeMca()
{
set_specific();
return single_value->field_solNodeMca;
}

const OCTETSTRING_template& AddressTableEntry_template::solNodeMca() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field solNodeMca of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
return single_value->field_solNodeMca;
}

int AddressTableEntry_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 5;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
  }
  return 0;
}

void AddressTableEntry_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ key := ");
single_value->field_key.log();
TTCN_Logger::log_event_str(", macAddress := ");
single_value->field_macAddress.log();
TTCN_Logger::log_event_str(", macSolNodeMca := ");
single_value->field_macSolNodeMca.log();
TTCN_Logger::log_event_str(", lla := ");
single_value->field_lla.log();
TTCN_Logger::log_event_str(", solNodeMca := ");
single_value->field_solNodeMca.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AddressTableEntry_template::log_match(const AddressTableEntry& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_key.match(match_value.key(), legacy)){
TTCN_Logger::log_logmatch_info(".key");
single_value->field_key.log_match(match_value.key(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_macAddress.match(match_value.macAddress(), legacy)){
TTCN_Logger::log_logmatch_info(".macAddress");
single_value->field_macAddress.log_match(match_value.macAddress(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_macSolNodeMca.match(match_value.macSolNodeMca(), legacy)){
TTCN_Logger::log_logmatch_info(".macSolNodeMca");
single_value->field_macSolNodeMca.log_match(match_value.macSolNodeMca(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_lla.match(match_value.lla(), legacy)){
TTCN_Logger::log_logmatch_info(".lla");
single_value->field_lla.log_match(match_value.lla(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_solNodeMca.match(match_value.solNodeMca(), legacy)){
TTCN_Logger::log_logmatch_info(".solNodeMca");
single_value->field_solNodeMca.log_match(match_value.solNodeMca(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ key := ");
single_value->field_key.log_match(match_value.key(), legacy);
TTCN_Logger::log_event_str(", macAddress := ");
single_value->field_macAddress.log_match(match_value.macAddress(), legacy);
TTCN_Logger::log_event_str(", macSolNodeMca := ");
single_value->field_macSolNodeMca.log_match(match_value.macSolNodeMca(), legacy);
TTCN_Logger::log_event_str(", lla := ");
single_value->field_lla.log_match(match_value.lla(), legacy);
TTCN_Logger::log_event_str(", solNodeMca := ");
single_value->field_solNodeMca.log_match(match_value.solNodeMca(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AddressTableEntry_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_key.encode_text(text_buf);
single_value->field_macAddress.encode_text(text_buf);
single_value->field_macSolNodeMca.encode_text(text_buf);
single_value->field_lla.encode_text(text_buf);
single_value->field_solNodeMca.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
}
}

void AddressTableEntry_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_key.decode_text(text_buf);
single_value->field_macAddress.decode_text(text_buf);
single_value->field_macSolNodeMca.decode_text(text_buf);
single_value->field_lla.decode_text(text_buf);
single_value->field_solNodeMca.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AddressTableEntry_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry.");
}
}

void AddressTableEntry_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry'");
    }
    if (strcmp("key", param_field) == 0) {
      key().set_param(param);
      return;
    } else if (strcmp("macAddress", param_field) == 0) {
      macAddress().set_param(param);
      return;
    } else if (strcmp("macSolNodeMca", param_field) == 0) {
      macSolNodeMca().set_param(param);
      return;
    } else if (strcmp("lla", param_field) == 0) {
      lla().set_param(param);
      return;
    } else if (strcmp("solNodeMca", param_field) == 0) {
      solNodeMca().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AddressTableEntry_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) key().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) macAddress().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) macSolNodeMca().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) lla().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) solNodeMca().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "macAddress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          macAddress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "macSolNodeMca")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          macSolNodeMca().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "lla")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          lla().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "solNodeMca")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          solNodeMca().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AddressTableEntry_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry'");
    }
    if (strcmp("key", param_field) == 0) {
      return key().get_param(param_name);
    } else if (strcmp("macAddress", param_field) == 0) {
      return macAddress().get_param(param_name);
    } else if (strcmp("macSolNodeMca", param_field) == 0) {
      return macSolNodeMca().get_param(param_name);
    } else if (strcmp("lla", param_field) == 0) {
      return lla().get_param(param_name);
    } else if (strcmp("solNodeMca", param_field) == 0) {
      return solNodeMca().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_key = single_value->field_key.get_param(param_name);
    mp_field_key->set_id(new Module_Param_FieldName(mcopystr("key")));
    mp->add_elem(mp_field_key);
    Module_Param* mp_field_macAddress = single_value->field_macAddress.get_param(param_name);
    mp_field_macAddress->set_id(new Module_Param_FieldName(mcopystr("macAddress")));
    mp->add_elem(mp_field_macAddress);
    Module_Param* mp_field_macSolNodeMca = single_value->field_macSolNodeMca.get_param(param_name);
    mp_field_macSolNodeMca->set_id(new Module_Param_FieldName(mcopystr("macSolNodeMca")));
    mp->add_elem(mp_field_macSolNodeMca);
    Module_Param* mp_field_lla = single_value->field_lla.get_param(param_name);
    mp_field_lla->set_id(new Module_Param_FieldName(mcopystr("lla")));
    mp->add_elem(mp_field_lla);
    Module_Param* mp_field_solNodeMca = single_value->field_solNodeMca.get_param(param_name);
    mp_field_solNodeMca->set_id(new Module_Param_FieldName(mcopystr("solNodeMca")));
    mp->add_elem(mp_field_solNodeMca);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AddressTableEntry_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_key.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry");
single_value->field_macAddress.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry");
single_value->field_macSolNodeMca.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry");
single_value->field_lla.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry");
single_value->field_solNodeMca.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTableEntry");
}

boolean AddressTableEntry_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AddressTableEntry_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const AddressTableEntry AddressTable::UNBOUND_ELEM;
AddressTable::AddressTable()
{
val_ptr = NULL;
}

AddressTable::AddressTable(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

AddressTable::AddressTable(const AddressTable& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

AddressTable::~AddressTable()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void AddressTable::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

AddressTable& AddressTable::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

AddressTable& AddressTable::operator=(const AddressTable& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean AddressTable::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
return val_ptr->n_elements == 0 ;
}

boolean AddressTable::operator==(const AddressTable& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

AddressTableEntry& AddressTable::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (AddressTableEntry**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new AddressTableEntry(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new AddressTableEntry;
}
return *val_ptr->value_elements[index_value];
}

AddressTableEntry& AddressTable::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
return (*this)[(int)index_value];
}

const AddressTableEntry& AddressTable::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const AddressTableEntry& AddressTable::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
return (*this)[(int)index_value];
}

AddressTable AddressTable::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

AddressTable AddressTable::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

AddressTable AddressTable::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

AddressTable AddressTable::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
AddressTable ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new AddressTableEntry(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

AddressTable AddressTable::operator+(const AddressTable& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
AddressTable ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new AddressTableEntry(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new AddressTableEntry(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

AddressTable AddressTable::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable","element");
AddressTable ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new AddressTableEntry(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

AddressTable AddressTable::replace(int index, int len, const AddressTable& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable","element");
AddressTable ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new AddressTableEntry(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new AddressTableEntry(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new AddressTableEntry(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

AddressTable AddressTable::replace(int index, int len, const AddressTable_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void AddressTable::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (AddressTableEntry**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new AddressTableEntry(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (AddressTableEntry**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (AddressTableEntry**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean AddressTable::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int AddressTable::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
return val_ptr->n_elements;
}

int AddressTable::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void AddressTable::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void AddressTable::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* AddressTable::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void AddressTable::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void AddressTable::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void AddressTable::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
val_ptr->value_elements = (AddressTableEntry**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new AddressTableEntry;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void AddressTable::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AddressTable::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AddressTable::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int AddressTable::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

void AddressTable_template::copy_value(const AddressTable& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (AddressTableEntry_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new AddressTableEntry_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new AddressTableEntry_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void AddressTable_template::copy_template(const AddressTable_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (AddressTableEntry_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new AddressTableEntry_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new AddressTableEntry_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AddressTable_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
break;
}
set_selection(other_value);
}

boolean AddressTable_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const AddressTable_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const AddressTable*)value_ptr)[value_index], legacy);
else return ((const AddressTable_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

AddressTable_template::AddressTable_template()
{
}

AddressTable_template::AddressTable_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

AddressTable_template::AddressTable_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

AddressTable_template::AddressTable_template(const AddressTable& other_value)
{
copy_value(other_value);
}

AddressTable_template::AddressTable_template(const OPTIONAL<AddressTable>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AddressTable&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable from an unbound optional field.");
}
}

AddressTable_template::AddressTable_template(const AddressTable_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

AddressTable_template::~AddressTable_template()
{
clean_up();
}

void AddressTable_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AddressTable_template& AddressTable_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AddressTable_template& AddressTable_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

AddressTable_template& AddressTable_template::operator=(const AddressTable& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AddressTable_template& AddressTable_template::operator=(const OPTIONAL<AddressTable>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AddressTable&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
}
return *this;
}

AddressTable_template& AddressTable_template::operator=(const AddressTable_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

AddressTableEntry_template& AddressTable_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
    break;
}
return *single_value.value_elements[index_value];
}

AddressTableEntry_template& AddressTable_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
return (*this)[(int)index_value];
}

const AddressTableEntry_template& AddressTable_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const AddressTableEntry_template& AddressTable_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
return (*this)[(int)index_value];
}

void AddressTable_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (AddressTableEntry_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new AddressTableEntry_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new AddressTableEntry_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (AddressTableEntry_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int AddressTable_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int AddressTable_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable");
}

boolean AddressTable_template::match(const AddressTable& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
}
return FALSE;
}

boolean AddressTable_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

AddressTable AddressTable_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
AddressTable ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

AddressTable AddressTable_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

AddressTable AddressTable_template::replace(int index, int len, const AddressTable_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

AddressTable AddressTable_template::replace(int index, int len, const AddressTable& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void AddressTable_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new AddressTable_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
}
set_selection(template_type);
}

AddressTable_template& AddressTable_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
return value_list.list_value[list_index];
}

void AddressTable_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void AddressTable_template::log_match(const AddressTable& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AddressTable_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
}
}

void AddressTable_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
single_value.value_elements = (AddressTableEntry_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new AddressTableEntry_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AddressTable_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
}
}

boolean AddressTable_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AddressTable_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void AddressTable_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AddressTable_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* AddressTable_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void AddressTable_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable");
}

Ipv6Header::Ipv6Header()
{
  bound_flag = FALSE;
}

Ipv6Header::Ipv6Header(const INTEGER& par_version,
    const INTEGER& par_trafficClass,
    const INTEGER& par_flowLabel,
    const INTEGER& par_payloadLength,
    const INTEGER& par_nextHeader,
    const INTEGER& par_hopLimit,
    const OCTETSTRING& par_sourceAddress,
    const OCTETSTRING& par_destinationAddress)
  :   field_version(par_version),
  field_trafficClass(par_trafficClass),
  field_flowLabel(par_flowLabel),
  field_payloadLength(par_payloadLength),
  field_nextHeader(par_nextHeader),
  field_hopLimit(par_hopLimit),
  field_sourceAddress(par_sourceAddress),
  field_destinationAddress(par_destinationAddress)
{
  bound_flag = TRUE;
}

Ipv6Header::Ipv6Header(const Ipv6Header& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
bound_flag = TRUE;
if (other_value.version().is_bound()) field_version = other_value.version();
else field_version.clean_up();
if (other_value.trafficClass().is_bound()) field_trafficClass = other_value.trafficClass();
else field_trafficClass.clean_up();
if (other_value.flowLabel().is_bound()) field_flowLabel = other_value.flowLabel();
else field_flowLabel.clean_up();
if (other_value.payloadLength().is_bound()) field_payloadLength = other_value.payloadLength();
else field_payloadLength.clean_up();
if (other_value.nextHeader().is_bound()) field_nextHeader = other_value.nextHeader();
else field_nextHeader.clean_up();
if (other_value.hopLimit().is_bound()) field_hopLimit = other_value.hopLimit();
else field_hopLimit.clean_up();
if (other_value.sourceAddress().is_bound()) field_sourceAddress = other_value.sourceAddress();
else field_sourceAddress.clean_up();
if (other_value.destinationAddress().is_bound()) field_destinationAddress = other_value.destinationAddress();
else field_destinationAddress.clean_up();
}

void Ipv6Header::clean_up()
{
field_version.clean_up();
field_trafficClass.clean_up();
field_flowLabel.clean_up();
field_payloadLength.clean_up();
field_nextHeader.clean_up();
field_hopLimit.clean_up();
field_sourceAddress.clean_up();
field_destinationAddress.clean_up();
bound_flag = FALSE;
}

Ipv6Header& Ipv6Header::operator=(const Ipv6Header& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
  bound_flag = TRUE;
  if (other_value.version().is_bound()) field_version = other_value.version();
  else field_version.clean_up();
  if (other_value.trafficClass().is_bound()) field_trafficClass = other_value.trafficClass();
  else field_trafficClass.clean_up();
  if (other_value.flowLabel().is_bound()) field_flowLabel = other_value.flowLabel();
  else field_flowLabel.clean_up();
  if (other_value.payloadLength().is_bound()) field_payloadLength = other_value.payloadLength();
  else field_payloadLength.clean_up();
  if (other_value.nextHeader().is_bound()) field_nextHeader = other_value.nextHeader();
  else field_nextHeader.clean_up();
  if (other_value.hopLimit().is_bound()) field_hopLimit = other_value.hopLimit();
  else field_hopLimit.clean_up();
  if (other_value.sourceAddress().is_bound()) field_sourceAddress = other_value.sourceAddress();
  else field_sourceAddress.clean_up();
  if (other_value.destinationAddress().is_bound()) field_destinationAddress = other_value.destinationAddress();
  else field_destinationAddress.clean_up();
}
return *this;
}

boolean Ipv6Header::operator==(const Ipv6Header& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_version==other_value.field_version
  && field_trafficClass==other_value.field_trafficClass
  && field_flowLabel==other_value.field_flowLabel
  && field_payloadLength==other_value.field_payloadLength
  && field_nextHeader==other_value.field_nextHeader
  && field_hopLimit==other_value.field_hopLimit
  && field_sourceAddress==other_value.field_sourceAddress
  && field_destinationAddress==other_value.field_destinationAddress;
}

boolean Ipv6Header::is_bound() const
{
if (bound_flag) return TRUE;
if(field_version.is_bound()) return TRUE;
if(field_trafficClass.is_bound()) return TRUE;
if(field_flowLabel.is_bound()) return TRUE;
if(field_payloadLength.is_bound()) return TRUE;
if(field_nextHeader.is_bound()) return TRUE;
if(field_hopLimit.is_bound()) return TRUE;
if(field_sourceAddress.is_bound()) return TRUE;
if(field_destinationAddress.is_bound()) return TRUE;
return FALSE;
}
boolean Ipv6Header::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_version.is_value()) return FALSE;
if(!field_trafficClass.is_value()) return FALSE;
if(!field_flowLabel.is_value()) return FALSE;
if(!field_payloadLength.is_value()) return FALSE;
if(!field_nextHeader.is_value()) return FALSE;
if(!field_hopLimit.is_value()) return FALSE;
if(!field_sourceAddress.is_value()) return FALSE;
if(!field_destinationAddress.is_value()) return FALSE;
return TRUE;
}
int Ipv6Header::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header");
  return 8;
}

void Ipv6Header::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ version := ");
field_version.log();
TTCN_Logger::log_event_str(", trafficClass := ");
field_trafficClass.log();
TTCN_Logger::log_event_str(", flowLabel := ");
field_flowLabel.log();
TTCN_Logger::log_event_str(", payloadLength := ");
field_payloadLength.log();
TTCN_Logger::log_event_str(", nextHeader := ");
field_nextHeader.log();
TTCN_Logger::log_event_str(", hopLimit := ");
field_hopLimit.log();
TTCN_Logger::log_event_str(", sourceAddress := ");
field_sourceAddress.log();
TTCN_Logger::log_event_str(", destinationAddress := ");
field_destinationAddress.log();
TTCN_Logger::log_event_str(" }");
}

void Ipv6Header::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header'");
    }
    if (strcmp("version", param_field) == 0) {
      version().set_param(param);
      return;
    } else if (strcmp("trafficClass", param_field) == 0) {
      trafficClass().set_param(param);
      return;
    } else if (strcmp("flowLabel", param_field) == 0) {
      flowLabel().set_param(param);
      return;
    } else if (strcmp("payloadLength", param_field) == 0) {
      payloadLength().set_param(param);
      return;
    } else if (strcmp("nextHeader", param_field) == 0) {
      nextHeader().set_param(param);
      return;
    } else if (strcmp("hopLimit", param_field) == 0) {
      hopLimit().set_param(param);
      return;
    } else if (strcmp("sourceAddress", param_field) == 0) {
      sourceAddress().set_param(param);
      return;
    } else if (strcmp("destinationAddress", param_field) == 0) {
      destinationAddress().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (8<mp->get_size()) {
      param.error("record value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header has 8 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) trafficClass().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) flowLabel().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) payloadLength().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) nextHeader().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) hopLimit().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) sourceAddress().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) destinationAddress().set_param(*mp->get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "flowLabel")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          flowLabel().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payloadLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payloadLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hopLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hopLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sourceAddress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sourceAddress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "destinationAddress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          destinationAddress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header");
  }
}

Module_Param* Ipv6Header::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header'");
    }
    if (strcmp("version", param_field) == 0) {
      return version().get_param(param_name);
    } else if (strcmp("trafficClass", param_field) == 0) {
      return trafficClass().get_param(param_name);
    } else if (strcmp("flowLabel", param_field) == 0) {
      return flowLabel().get_param(param_name);
    } else if (strcmp("payloadLength", param_field) == 0) {
      return payloadLength().get_param(param_name);
    } else if (strcmp("nextHeader", param_field) == 0) {
      return nextHeader().get_param(param_name);
    } else if (strcmp("hopLimit", param_field) == 0) {
      return hopLimit().get_param(param_name);
    } else if (strcmp("sourceAddress", param_field) == 0) {
      return sourceAddress().get_param(param_name);
    } else if (strcmp("destinationAddress", param_field) == 0) {
      return destinationAddress().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_version = field_version.get_param(param_name);
  mp_field_version->set_id(new Module_Param_FieldName(mcopystr("version")));
  mp->add_elem(mp_field_version);
  Module_Param* mp_field_trafficClass = field_trafficClass.get_param(param_name);
  mp_field_trafficClass->set_id(new Module_Param_FieldName(mcopystr("trafficClass")));
  mp->add_elem(mp_field_trafficClass);
  Module_Param* mp_field_flowLabel = field_flowLabel.get_param(param_name);
  mp_field_flowLabel->set_id(new Module_Param_FieldName(mcopystr("flowLabel")));
  mp->add_elem(mp_field_flowLabel);
  Module_Param* mp_field_payloadLength = field_payloadLength.get_param(param_name);
  mp_field_payloadLength->set_id(new Module_Param_FieldName(mcopystr("payloadLength")));
  mp->add_elem(mp_field_payloadLength);
  Module_Param* mp_field_nextHeader = field_nextHeader.get_param(param_name);
  mp_field_nextHeader->set_id(new Module_Param_FieldName(mcopystr("nextHeader")));
  mp->add_elem(mp_field_nextHeader);
  Module_Param* mp_field_hopLimit = field_hopLimit.get_param(param_name);
  mp_field_hopLimit->set_id(new Module_Param_FieldName(mcopystr("hopLimit")));
  mp->add_elem(mp_field_hopLimit);
  Module_Param* mp_field_sourceAddress = field_sourceAddress.get_param(param_name);
  mp_field_sourceAddress->set_id(new Module_Param_FieldName(mcopystr("sourceAddress")));
  mp->add_elem(mp_field_sourceAddress);
  Module_Param* mp_field_destinationAddress = field_destinationAddress.get_param(param_name);
  mp_field_destinationAddress->set_id(new Module_Param_FieldName(mcopystr("destinationAddress")));
  mp->add_elem(mp_field_destinationAddress);
  return mp;
  }

void Ipv6Header::set_implicit_omit()
{
if (version().is_bound()) version().set_implicit_omit();
if (trafficClass().is_bound()) trafficClass().set_implicit_omit();
if (flowLabel().is_bound()) flowLabel().set_implicit_omit();
if (payloadLength().is_bound()) payloadLength().set_implicit_omit();
if (nextHeader().is_bound()) nextHeader().set_implicit_omit();
if (hopLimit().is_bound()) hopLimit().set_implicit_omit();
if (sourceAddress().is_bound()) sourceAddress().set_implicit_omit();
if (destinationAddress().is_bound()) destinationAddress().set_implicit_omit();
}

void Ipv6Header::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
field_version.encode_text(text_buf);
field_trafficClass.encode_text(text_buf);
field_flowLabel.encode_text(text_buf);
field_payloadLength.encode_text(text_buf);
field_nextHeader.encode_text(text_buf);
field_hopLimit.encode_text(text_buf);
field_sourceAddress.encode_text(text_buf);
field_destinationAddress.encode_text(text_buf);
}

void Ipv6Header::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_version.decode_text(text_buf);
field_trafficClass.decode_text(text_buf);
field_flowLabel.decode_text(text_buf);
field_payloadLength.decode_text(text_buf);
field_nextHeader.decode_text(text_buf);
field_hopLimit.decode_text(text_buf);
field_sourceAddress.decode_text(text_buf);
field_destinationAddress.decode_text(text_buf);
}

void Ipv6Header::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Ipv6Header::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int Ipv6Header::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_version.RAW_decode(LibCommon__BasicTypesAndValues::UInt4_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_trafficClass.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_flowLabel.RAW_decode(LibCommon__BasicTypesAndValues::UInt20_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_payloadLength.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_nextHeader.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_hopLimit.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_sourceAddress.RAW_decode(Ipv6Address_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_destinationAddress.RAW_decode(Ipv6Address_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int Ipv6Header::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 8;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(8);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt4_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__BasicTypesAndValues::UInt20_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, Ipv6Address_descr_.raw);
  myleaf.body.node.nodes[7] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 7, Ipv6Address_descr_.raw);
  encoded_length += field_version.RAW_encode(LibCommon__BasicTypesAndValues::UInt4_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_trafficClass.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_flowLabel.RAW_encode(LibCommon__BasicTypesAndValues::UInt20_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_payloadLength.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_nextHeader.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_hopLimit.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_sourceAddress.RAW_encode(Ipv6Address_descr_, *myleaf.body.node.nodes[6]);
  encoded_length += field_destinationAddress.RAW_encode(Ipv6Address_descr_, *myleaf.body.node.nodes[7]);
  return myleaf.length = encoded_length;
}

int Ipv6Header::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "version");
    enc_len += field_version.JSON_encode(LibCommon__BasicTypesAndValues::UInt4_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "trafficClass");
    enc_len += field_trafficClass.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "flowLabel");
    enc_len += field_flowLabel.JSON_encode(LibCommon__BasicTypesAndValues::UInt20_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payloadLength");
    enc_len += field_payloadLength.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "nextHeader");
    enc_len += field_nextHeader.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "hopLimit");
    enc_len += field_hopLimit.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "sourceAddress");
    enc_len += field_sourceAddress.JSON_encode(Ipv6Address_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "destinationAddress");
    enc_len += field_destinationAddress.JSON_encode(Ipv6Address_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Ipv6Header::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (7 == name_len && 0 == strncmp(fld_name, "version", name_len)) {
         int ret_val = field_version.JSON_decode(LibCommon__BasicTypesAndValues::UInt4_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "version");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "trafficClass", name_len)) {
         int ret_val = field_trafficClass.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "trafficClass");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "flowLabel", name_len)) {
         int ret_val = field_flowLabel.JSON_decode(LibCommon__BasicTypesAndValues::UInt20_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "flowLabel");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "payloadLength", name_len)) {
         int ret_val = field_payloadLength.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "payloadLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "nextHeader", name_len)) {
         int ret_val = field_nextHeader.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "nextHeader");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "hopLimit", name_len)) {
         int ret_val = field_hopLimit.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "hopLimit");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "sourceAddress", name_len)) {
         int ret_val = field_sourceAddress.JSON_decode(Ipv6Address_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "sourceAddress");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "destinationAddress", name_len)) {
         int ret_val = field_destinationAddress.JSON_decode(Ipv6Address_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "destinationAddress");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_version.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "version");
    return JSON_ERROR_FATAL;
  }
if (!field_trafficClass.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "trafficClass");
    return JSON_ERROR_FATAL;
  }
if (!field_flowLabel.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "flowLabel");
    return JSON_ERROR_FATAL;
  }
if (!field_payloadLength.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "payloadLength");
    return JSON_ERROR_FATAL;
  }
if (!field_nextHeader.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "nextHeader");
    return JSON_ERROR_FATAL;
  }
if (!field_hopLimit.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "hopLimit");
    return JSON_ERROR_FATAL;
  }
if (!field_sourceAddress.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "sourceAddress");
    return JSON_ERROR_FATAL;
  }
if (!field_destinationAddress.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "destinationAddress");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct Ipv6Header_template::single_value_struct {
INTEGER_template field_version;
INTEGER_template field_trafficClass;
INTEGER_template field_flowLabel;
INTEGER_template field_payloadLength;
INTEGER_template field_nextHeader;
INTEGER_template field_hopLimit;
OCTETSTRING_template field_sourceAddress;
OCTETSTRING_template field_destinationAddress;
};

void Ipv6Header_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_version = ANY_VALUE;
single_value->field_trafficClass = ANY_VALUE;
single_value->field_flowLabel = ANY_VALUE;
single_value->field_payloadLength = ANY_VALUE;
single_value->field_nextHeader = ANY_VALUE;
single_value->field_hopLimit = ANY_VALUE;
single_value->field_sourceAddress = ANY_VALUE;
single_value->field_destinationAddress = ANY_VALUE;
}
}
}

void Ipv6Header_template::copy_value(const Ipv6Header& other_value)
{
single_value = new single_value_struct;
if (other_value.version().is_bound()) {
  single_value->field_version = other_value.version();
} else {
  single_value->field_version.clean_up();
}
if (other_value.trafficClass().is_bound()) {
  single_value->field_trafficClass = other_value.trafficClass();
} else {
  single_value->field_trafficClass.clean_up();
}
if (other_value.flowLabel().is_bound()) {
  single_value->field_flowLabel = other_value.flowLabel();
} else {
  single_value->field_flowLabel.clean_up();
}
if (other_value.payloadLength().is_bound()) {
  single_value->field_payloadLength = other_value.payloadLength();
} else {
  single_value->field_payloadLength.clean_up();
}
if (other_value.nextHeader().is_bound()) {
  single_value->field_nextHeader = other_value.nextHeader();
} else {
  single_value->field_nextHeader.clean_up();
}
if (other_value.hopLimit().is_bound()) {
  single_value->field_hopLimit = other_value.hopLimit();
} else {
  single_value->field_hopLimit.clean_up();
}
if (other_value.sourceAddress().is_bound()) {
  single_value->field_sourceAddress = other_value.sourceAddress();
} else {
  single_value->field_sourceAddress.clean_up();
}
if (other_value.destinationAddress().is_bound()) {
  single_value->field_destinationAddress = other_value.destinationAddress();
} else {
  single_value->field_destinationAddress.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Ipv6Header_template::copy_template(const Ipv6Header_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.version().get_selection()) {
single_value->field_version = other_value.version();
} else {
single_value->field_version.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trafficClass().get_selection()) {
single_value->field_trafficClass = other_value.trafficClass();
} else {
single_value->field_trafficClass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.flowLabel().get_selection()) {
single_value->field_flowLabel = other_value.flowLabel();
} else {
single_value->field_flowLabel.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payloadLength().get_selection()) {
single_value->field_payloadLength = other_value.payloadLength();
} else {
single_value->field_payloadLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.nextHeader().get_selection()) {
single_value->field_nextHeader = other_value.nextHeader();
} else {
single_value->field_nextHeader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.hopLimit().get_selection()) {
single_value->field_hopLimit = other_value.hopLimit();
} else {
single_value->field_hopLimit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sourceAddress().get_selection()) {
single_value->field_sourceAddress = other_value.sourceAddress();
} else {
single_value->field_sourceAddress.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.destinationAddress().get_selection()) {
single_value->field_destinationAddress = other_value.destinationAddress();
} else {
single_value->field_destinationAddress.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Ipv6Header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
break;
}
set_selection(other_value);
}

Ipv6Header_template::Ipv6Header_template()
{
}

Ipv6Header_template::Ipv6Header_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Ipv6Header_template::Ipv6Header_template(const Ipv6Header& other_value)
{
copy_value(other_value);
}

Ipv6Header_template::Ipv6Header_template(const OPTIONAL<Ipv6Header>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Ipv6Header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header from an unbound optional field.");
}
}

Ipv6Header_template::Ipv6Header_template(const Ipv6Header_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Ipv6Header_template::~Ipv6Header_template()
{
clean_up();
}

Ipv6Header_template& Ipv6Header_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Ipv6Header_template& Ipv6Header_template::operator=(const Ipv6Header& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Ipv6Header_template& Ipv6Header_template::operator=(const OPTIONAL<Ipv6Header>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Ipv6Header&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
}
return *this;
}

Ipv6Header_template& Ipv6Header_template::operator=(const Ipv6Header_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Ipv6Header_template::match(const Ipv6Header& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.version().is_bound()) return FALSE;
if(!single_value->field_version.match(other_value.version(), legacy))return FALSE;
if(!other_value.trafficClass().is_bound()) return FALSE;
if(!single_value->field_trafficClass.match(other_value.trafficClass(), legacy))return FALSE;
if(!other_value.flowLabel().is_bound()) return FALSE;
if(!single_value->field_flowLabel.match(other_value.flowLabel(), legacy))return FALSE;
if(!other_value.payloadLength().is_bound()) return FALSE;
if(!single_value->field_payloadLength.match(other_value.payloadLength(), legacy))return FALSE;
if(!other_value.nextHeader().is_bound()) return FALSE;
if(!single_value->field_nextHeader.match(other_value.nextHeader(), legacy))return FALSE;
if(!other_value.hopLimit().is_bound()) return FALSE;
if(!single_value->field_hopLimit.match(other_value.hopLimit(), legacy))return FALSE;
if(!other_value.sourceAddress().is_bound()) return FALSE;
if(!single_value->field_sourceAddress.match(other_value.sourceAddress(), legacy))return FALSE;
if(!other_value.destinationAddress().is_bound()) return FALSE;
if(!single_value->field_destinationAddress.match(other_value.destinationAddress(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
}
return FALSE;
}

boolean Ipv6Header_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_version.is_bound()) return TRUE;
if (single_value->field_trafficClass.is_bound()) return TRUE;
if (single_value->field_flowLabel.is_bound()) return TRUE;
if (single_value->field_payloadLength.is_bound()) return TRUE;
if (single_value->field_nextHeader.is_bound()) return TRUE;
if (single_value->field_hopLimit.is_bound()) return TRUE;
if (single_value->field_sourceAddress.is_bound()) return TRUE;
if (single_value->field_destinationAddress.is_bound()) return TRUE;
return FALSE;
}

boolean Ipv6Header_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_version.is_value()) return FALSE;
if (!single_value->field_trafficClass.is_value()) return FALSE;
if (!single_value->field_flowLabel.is_value()) return FALSE;
if (!single_value->field_payloadLength.is_value()) return FALSE;
if (!single_value->field_nextHeader.is_value()) return FALSE;
if (!single_value->field_hopLimit.is_value()) return FALSE;
if (!single_value->field_sourceAddress.is_value()) return FALSE;
if (!single_value->field_destinationAddress.is_value()) return FALSE;
return TRUE;
}

void Ipv6Header_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Ipv6Header Ipv6Header_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
Ipv6Header ret_val;
if (single_value->field_version.is_bound()) {
ret_val.version() = single_value->field_version.valueof();
}
if (single_value->field_trafficClass.is_bound()) {
ret_val.trafficClass() = single_value->field_trafficClass.valueof();
}
if (single_value->field_flowLabel.is_bound()) {
ret_val.flowLabel() = single_value->field_flowLabel.valueof();
}
if (single_value->field_payloadLength.is_bound()) {
ret_val.payloadLength() = single_value->field_payloadLength.valueof();
}
if (single_value->field_nextHeader.is_bound()) {
ret_val.nextHeader() = single_value->field_nextHeader.valueof();
}
if (single_value->field_hopLimit.is_bound()) {
ret_val.hopLimit() = single_value->field_hopLimit.valueof();
}
if (single_value->field_sourceAddress.is_bound()) {
ret_val.sourceAddress() = single_value->field_sourceAddress.valueof();
}
if (single_value->field_destinationAddress.is_bound()) {
ret_val.destinationAddress() = single_value->field_destinationAddress.valueof();
}
return ret_val;
}

void Ipv6Header_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Ipv6Header_template[list_length];
}

Ipv6Header_template& Ipv6Header_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
return value_list.list_value[list_index];
}

INTEGER_template& Ipv6Header_template::version()
{
set_specific();
return single_value->field_version;
}

const INTEGER_template& Ipv6Header_template::version() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field version of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
return single_value->field_version;
}

INTEGER_template& Ipv6Header_template::trafficClass()
{
set_specific();
return single_value->field_trafficClass;
}

const INTEGER_template& Ipv6Header_template::trafficClass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trafficClass of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
return single_value->field_trafficClass;
}

INTEGER_template& Ipv6Header_template::flowLabel()
{
set_specific();
return single_value->field_flowLabel;
}

const INTEGER_template& Ipv6Header_template::flowLabel() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field flowLabel of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
return single_value->field_flowLabel;
}

INTEGER_template& Ipv6Header_template::payloadLength()
{
set_specific();
return single_value->field_payloadLength;
}

const INTEGER_template& Ipv6Header_template::payloadLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payloadLength of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
return single_value->field_payloadLength;
}

INTEGER_template& Ipv6Header_template::nextHeader()
{
set_specific();
return single_value->field_nextHeader;
}

const INTEGER_template& Ipv6Header_template::nextHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field nextHeader of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
return single_value->field_nextHeader;
}

INTEGER_template& Ipv6Header_template::hopLimit()
{
set_specific();
return single_value->field_hopLimit;
}

const INTEGER_template& Ipv6Header_template::hopLimit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field hopLimit of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
return single_value->field_hopLimit;
}

OCTETSTRING_template& Ipv6Header_template::sourceAddress()
{
set_specific();
return single_value->field_sourceAddress;
}

const OCTETSTRING_template& Ipv6Header_template::sourceAddress() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sourceAddress of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
return single_value->field_sourceAddress;
}

OCTETSTRING_template& Ipv6Header_template::destinationAddress()
{
set_specific();
return single_value->field_destinationAddress;
}

const OCTETSTRING_template& Ipv6Header_template::destinationAddress() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field destinationAddress of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
return single_value->field_destinationAddress;
}

int Ipv6Header_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 8;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
  }
  return 0;
}

void Ipv6Header_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log();
TTCN_Logger::log_event_str(", trafficClass := ");
single_value->field_trafficClass.log();
TTCN_Logger::log_event_str(", flowLabel := ");
single_value->field_flowLabel.log();
TTCN_Logger::log_event_str(", payloadLength := ");
single_value->field_payloadLength.log();
TTCN_Logger::log_event_str(", nextHeader := ");
single_value->field_nextHeader.log();
TTCN_Logger::log_event_str(", hopLimit := ");
single_value->field_hopLimit.log();
TTCN_Logger::log_event_str(", sourceAddress := ");
single_value->field_sourceAddress.log();
TTCN_Logger::log_event_str(", destinationAddress := ");
single_value->field_destinationAddress.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Ipv6Header_template::log_match(const Ipv6Header& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_version.match(match_value.version(), legacy)){
TTCN_Logger::log_logmatch_info(".version");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_trafficClass.match(match_value.trafficClass(), legacy)){
TTCN_Logger::log_logmatch_info(".trafficClass");
single_value->field_trafficClass.log_match(match_value.trafficClass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_flowLabel.match(match_value.flowLabel(), legacy)){
TTCN_Logger::log_logmatch_info(".flowLabel");
single_value->field_flowLabel.log_match(match_value.flowLabel(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_payloadLength.match(match_value.payloadLength(), legacy)){
TTCN_Logger::log_logmatch_info(".payloadLength");
single_value->field_payloadLength.log_match(match_value.payloadLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_nextHeader.match(match_value.nextHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".nextHeader");
single_value->field_nextHeader.log_match(match_value.nextHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_hopLimit.match(match_value.hopLimit(), legacy)){
TTCN_Logger::log_logmatch_info(".hopLimit");
single_value->field_hopLimit.log_match(match_value.hopLimit(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_sourceAddress.match(match_value.sourceAddress(), legacy)){
TTCN_Logger::log_logmatch_info(".sourceAddress");
single_value->field_sourceAddress.log_match(match_value.sourceAddress(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_destinationAddress.match(match_value.destinationAddress(), legacy)){
TTCN_Logger::log_logmatch_info(".destinationAddress");
single_value->field_destinationAddress.log_match(match_value.destinationAddress(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::log_event_str(", trafficClass := ");
single_value->field_trafficClass.log_match(match_value.trafficClass(), legacy);
TTCN_Logger::log_event_str(", flowLabel := ");
single_value->field_flowLabel.log_match(match_value.flowLabel(), legacy);
TTCN_Logger::log_event_str(", payloadLength := ");
single_value->field_payloadLength.log_match(match_value.payloadLength(), legacy);
TTCN_Logger::log_event_str(", nextHeader := ");
single_value->field_nextHeader.log_match(match_value.nextHeader(), legacy);
TTCN_Logger::log_event_str(", hopLimit := ");
single_value->field_hopLimit.log_match(match_value.hopLimit(), legacy);
TTCN_Logger::log_event_str(", sourceAddress := ");
single_value->field_sourceAddress.log_match(match_value.sourceAddress(), legacy);
TTCN_Logger::log_event_str(", destinationAddress := ");
single_value->field_destinationAddress.log_match(match_value.destinationAddress(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Ipv6Header_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_version.encode_text(text_buf);
single_value->field_trafficClass.encode_text(text_buf);
single_value->field_flowLabel.encode_text(text_buf);
single_value->field_payloadLength.encode_text(text_buf);
single_value->field_nextHeader.encode_text(text_buf);
single_value->field_hopLimit.encode_text(text_buf);
single_value->field_sourceAddress.encode_text(text_buf);
single_value->field_destinationAddress.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
}
}

void Ipv6Header_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_version.decode_text(text_buf);
single_value->field_trafficClass.decode_text(text_buf);
single_value->field_flowLabel.decode_text(text_buf);
single_value->field_payloadLength.decode_text(text_buf);
single_value->field_nextHeader.decode_text(text_buf);
single_value->field_hopLimit.decode_text(text_buf);
single_value->field_sourceAddress.decode_text(text_buf);
single_value->field_destinationAddress.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Ipv6Header_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header.");
}
}

void Ipv6Header_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header'");
    }
    if (strcmp("version", param_field) == 0) {
      version().set_param(param);
      return;
    } else if (strcmp("trafficClass", param_field) == 0) {
      trafficClass().set_param(param);
      return;
    } else if (strcmp("flowLabel", param_field) == 0) {
      flowLabel().set_param(param);
      return;
    } else if (strcmp("payloadLength", param_field) == 0) {
      payloadLength().set_param(param);
      return;
    } else if (strcmp("nextHeader", param_field) == 0) {
      nextHeader().set_param(param);
      return;
    } else if (strcmp("hopLimit", param_field) == 0) {
      hopLimit().set_param(param);
      return;
    } else if (strcmp("sourceAddress", param_field) == 0) {
      sourceAddress().set_param(param);
      return;
    } else if (strcmp("destinationAddress", param_field) == 0) {
      destinationAddress().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Ipv6Header_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (8<mp->get_size()) {
      param.error("record template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header has 8 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) trafficClass().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) flowLabel().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) payloadLength().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) nextHeader().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) hopLimit().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) sourceAddress().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) destinationAddress().set_param(*mp->get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "flowLabel")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          flowLabel().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payloadLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payloadLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "nextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          nextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hopLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hopLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sourceAddress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sourceAddress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "destinationAddress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          destinationAddress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Ipv6Header_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header'");
    }
    if (strcmp("version", param_field) == 0) {
      return version().get_param(param_name);
    } else if (strcmp("trafficClass", param_field) == 0) {
      return trafficClass().get_param(param_name);
    } else if (strcmp("flowLabel", param_field) == 0) {
      return flowLabel().get_param(param_name);
    } else if (strcmp("payloadLength", param_field) == 0) {
      return payloadLength().get_param(param_name);
    } else if (strcmp("nextHeader", param_field) == 0) {
      return nextHeader().get_param(param_name);
    } else if (strcmp("hopLimit", param_field) == 0) {
      return hopLimit().get_param(param_name);
    } else if (strcmp("sourceAddress", param_field) == 0) {
      return sourceAddress().get_param(param_name);
    } else if (strcmp("destinationAddress", param_field) == 0) {
      return destinationAddress().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_version = single_value->field_version.get_param(param_name);
    mp_field_version->set_id(new Module_Param_FieldName(mcopystr("version")));
    mp->add_elem(mp_field_version);
    Module_Param* mp_field_trafficClass = single_value->field_trafficClass.get_param(param_name);
    mp_field_trafficClass->set_id(new Module_Param_FieldName(mcopystr("trafficClass")));
    mp->add_elem(mp_field_trafficClass);
    Module_Param* mp_field_flowLabel = single_value->field_flowLabel.get_param(param_name);
    mp_field_flowLabel->set_id(new Module_Param_FieldName(mcopystr("flowLabel")));
    mp->add_elem(mp_field_flowLabel);
    Module_Param* mp_field_payloadLength = single_value->field_payloadLength.get_param(param_name);
    mp_field_payloadLength->set_id(new Module_Param_FieldName(mcopystr("payloadLength")));
    mp->add_elem(mp_field_payloadLength);
    Module_Param* mp_field_nextHeader = single_value->field_nextHeader.get_param(param_name);
    mp_field_nextHeader->set_id(new Module_Param_FieldName(mcopystr("nextHeader")));
    mp->add_elem(mp_field_nextHeader);
    Module_Param* mp_field_hopLimit = single_value->field_hopLimit.get_param(param_name);
    mp_field_hopLimit->set_id(new Module_Param_FieldName(mcopystr("hopLimit")));
    mp->add_elem(mp_field_hopLimit);
    Module_Param* mp_field_sourceAddress = single_value->field_sourceAddress.get_param(param_name);
    mp_field_sourceAddress->set_id(new Module_Param_FieldName(mcopystr("sourceAddress")));
    mp->add_elem(mp_field_sourceAddress);
    Module_Param* mp_field_destinationAddress = single_value->field_destinationAddress.get_param(param_name);
    mp_field_destinationAddress->set_id(new Module_Param_FieldName(mcopystr("destinationAddress")));
    mp->add_elem(mp_field_destinationAddress);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Ipv6Header_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_version.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header");
single_value->field_trafficClass.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header");
single_value->field_flowLabel.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header");
single_value->field_payloadLength.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header");
single_value->field_nextHeader.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header");
single_value->field_hopLimit.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header");
single_value->field_sourceAddress.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header");
single_value->field_destinationAddress.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Header");
}

boolean Ipv6Header_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Ipv6Header_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

Ipv6Packet::Ipv6Packet()
{
  bound_flag = FALSE;
}

Ipv6Packet::Ipv6Packet(const Ipv6Header& par_ipv6Hdr,
    const OPTIONAL<OCTETSTRING>& par_extHdrList,
    const OPTIONAL<Ipv6Payload>& par_ipv6Payload)
  :   field_ipv6Hdr(par_ipv6Hdr),
  field_extHdrList(par_extHdrList),
  field_ipv6Payload(par_ipv6Payload)
{
  bound_flag = TRUE;
}

Ipv6Packet::Ipv6Packet(const Ipv6Packet& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.");
bound_flag = TRUE;
if (other_value.ipv6Hdr().is_bound()) field_ipv6Hdr = other_value.ipv6Hdr();
else field_ipv6Hdr.clean_up();
if (other_value.extHdrList().is_bound()) field_extHdrList = other_value.extHdrList();
else field_extHdrList.clean_up();
if (other_value.ipv6Payload().is_bound()) field_ipv6Payload = other_value.ipv6Payload();
else field_ipv6Payload.clean_up();
}

void Ipv6Packet::clean_up()
{
field_ipv6Hdr.clean_up();
field_extHdrList.clean_up();
field_ipv6Payload.clean_up();
bound_flag = FALSE;
}

Ipv6Packet& Ipv6Packet::operator=(const Ipv6Packet& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.");
  bound_flag = TRUE;
  if (other_value.ipv6Hdr().is_bound()) field_ipv6Hdr = other_value.ipv6Hdr();
  else field_ipv6Hdr.clean_up();
  if (other_value.extHdrList().is_bound()) field_extHdrList = other_value.extHdrList();
  else field_extHdrList.clean_up();
  if (other_value.ipv6Payload().is_bound()) field_ipv6Payload = other_value.ipv6Payload();
  else field_ipv6Payload.clean_up();
}
return *this;
}

boolean Ipv6Packet::operator==(const Ipv6Packet& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_ipv6Hdr==other_value.field_ipv6Hdr
  && field_extHdrList==other_value.field_extHdrList
  && field_ipv6Payload==other_value.field_ipv6Payload;
}

boolean Ipv6Packet::is_bound() const
{
if (bound_flag) return TRUE;
if(field_ipv6Hdr.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_extHdrList.get_selection() || field_extHdrList.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_ipv6Payload.get_selection() || field_ipv6Payload.is_bound()) return TRUE;
return FALSE;
}
boolean Ipv6Packet::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_ipv6Hdr.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_extHdrList.get_selection() && !field_extHdrList.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_ipv6Payload.get_selection() && !field_ipv6Payload.is_value()) return FALSE;
return TRUE;
}
int Ipv6Packet::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet");
  int ret_val = 1;
  if (field_extHdrList.ispresent()) ret_val++;
  if (field_ipv6Payload.ispresent()) ret_val++;
  return ret_val;
}

void Ipv6Packet::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ ipv6Hdr := ");
field_ipv6Hdr.log();
TTCN_Logger::log_event_str(", extHdrList := ");
field_extHdrList.log();
TTCN_Logger::log_event_str(", ipv6Payload := ");
field_ipv6Payload.log();
TTCN_Logger::log_event_str(" }");
}

void Ipv6Packet::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet'");
    }
    if (strcmp("ipv6Hdr", param_field) == 0) {
      ipv6Hdr().set_param(param);
      return;
    } else if (strcmp("extHdrList", param_field) == 0) {
      extHdrList().set_param(param);
      return;
    } else if (strcmp("ipv6Payload", param_field) == 0) {
      ipv6Payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) ipv6Hdr().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) extHdrList().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) ipv6Payload().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ipv6Hdr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ipv6Hdr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "extHdrList")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          extHdrList().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ipv6Payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ipv6Payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet");
  }
}

Module_Param* Ipv6Packet::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet'");
    }
    if (strcmp("ipv6Hdr", param_field) == 0) {
      return ipv6Hdr().get_param(param_name);
    } else if (strcmp("extHdrList", param_field) == 0) {
      return extHdrList().get_param(param_name);
    } else if (strcmp("ipv6Payload", param_field) == 0) {
      return ipv6Payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_ipv6Hdr = field_ipv6Hdr.get_param(param_name);
  mp_field_ipv6Hdr->set_id(new Module_Param_FieldName(mcopystr("ipv6Hdr")));
  mp->add_elem(mp_field_ipv6Hdr);
  Module_Param* mp_field_extHdrList = field_extHdrList.get_param(param_name);
  mp_field_extHdrList->set_id(new Module_Param_FieldName(mcopystr("extHdrList")));
  mp->add_elem(mp_field_extHdrList);
  Module_Param* mp_field_ipv6Payload = field_ipv6Payload.get_param(param_name);
  mp_field_ipv6Payload->set_id(new Module_Param_FieldName(mcopystr("ipv6Payload")));
  mp->add_elem(mp_field_ipv6Payload);
  return mp;
  }

void Ipv6Packet::set_implicit_omit()
{
if (ipv6Hdr().is_bound()) ipv6Hdr().set_implicit_omit();
if (!extHdrList().is_bound()) extHdrList() = OMIT_VALUE;
else extHdrList().set_implicit_omit();
if (!ipv6Payload().is_bound()) ipv6Payload() = OMIT_VALUE;
else ipv6Payload().set_implicit_omit();
}

void Ipv6Packet::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.");
field_ipv6Hdr.encode_text(text_buf);
field_extHdrList.encode_text(text_buf);
field_ipv6Payload.encode_text(text_buf);
}

void Ipv6Packet::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_ipv6Hdr.decode_text(text_buf);
field_extHdrList.decode_text(text_buf);
field_ipv6Payload.decode_text(text_buf);
}

void Ipv6Packet::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Ipv6Packet::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int Ipv6Packet::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_ipv6Hdr.RAW_decode(Ipv6Header_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_extHdrList().RAW_decode(ExtensionHeaderList_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_extHdrList = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_extHdrList=OMIT_VALUE;
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_ipv6Payload().RAW_decode(Ipv6Payload_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_ipv6Payload = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_ipv6Payload=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int Ipv6Packet::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, Ipv6Header_descr_.raw);
  if (field_extHdrList.ispresent()) {
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, ExtensionHeaderList_descr_.raw);
  }
  else myleaf.body.node.nodes[1] = NULL;
  if (field_ipv6Payload.ispresent()) {
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, Ipv6Payload_descr_.raw);
  }
  else myleaf.body.node.nodes[2] = NULL;
  encoded_length += field_ipv6Hdr.RAW_encode(Ipv6Header_descr_, *myleaf.body.node.nodes[0]);
  if (field_extHdrList.ispresent()) {
  encoded_length += field_extHdrList().RAW_encode(ExtensionHeaderList_descr_, *myleaf.body.node.nodes[1]);
  }
  if (field_ipv6Payload.ispresent()) {
  encoded_length += field_ipv6Payload().RAW_encode(Ipv6Payload_descr_, *myleaf.body.node.nodes[2]);
  }
  return myleaf.length = encoded_length;
}

int Ipv6Packet::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ipv6Hdr");
    enc_len += field_ipv6Hdr.JSON_encode(Ipv6Header_descr_, p_tok);
  }

  if (field_extHdrList.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "extHdrList");
    enc_len += field_extHdrList.JSON_encode(ExtensionHeaderList_descr_, p_tok);
  }

  if (field_ipv6Payload.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ipv6Payload");
    enc_len += field_ipv6Payload.JSON_encode(Ipv6Payload_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Ipv6Packet::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (7 == name_len && 0 == strncmp(fld_name, "ipv6Hdr", name_len)) {
         int ret_val = field_ipv6Hdr.JSON_decode(Ipv6Header_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ipv6Hdr");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "extHdrList", name_len)) {
         int ret_val = field_extHdrList.JSON_decode(ExtensionHeaderList_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "extHdrList");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "ipv6Payload", name_len)) {
         int ret_val = field_ipv6Payload.JSON_decode(Ipv6Payload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ipv6Payload");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_ipv6Hdr.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "ipv6Hdr");
    return JSON_ERROR_FATAL;
  }
if (!field_extHdrList.is_bound()) {
    field_extHdrList = OMIT_VALUE;
  }
if (!field_ipv6Payload.is_bound()) {
    field_ipv6Payload = OMIT_VALUE;
  }

  return dec_len;
}

struct Ipv6Packet_template::single_value_struct {
Ipv6Header_template field_ipv6Hdr;
OCTETSTRING_template field_extHdrList;
Ipv6Payload_template field_ipv6Payload;
};

void Ipv6Packet_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_ipv6Hdr = ANY_VALUE;
single_value->field_extHdrList = ANY_OR_OMIT;
single_value->field_ipv6Payload = ANY_OR_OMIT;
}
}
}

void Ipv6Packet_template::copy_value(const Ipv6Packet& other_value)
{
single_value = new single_value_struct;
if (other_value.ipv6Hdr().is_bound()) {
  single_value->field_ipv6Hdr = other_value.ipv6Hdr();
} else {
  single_value->field_ipv6Hdr.clean_up();
}
if (other_value.extHdrList().is_bound()) {
  if (other_value.extHdrList().ispresent()) single_value->field_extHdrList = other_value.extHdrList()();
  else single_value->field_extHdrList = OMIT_VALUE;
} else {
  single_value->field_extHdrList.clean_up();
}
if (other_value.ipv6Payload().is_bound()) {
  if (other_value.ipv6Payload().ispresent()) single_value->field_ipv6Payload = other_value.ipv6Payload()();
  else single_value->field_ipv6Payload = OMIT_VALUE;
} else {
  single_value->field_ipv6Payload.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Ipv6Packet_template::copy_template(const Ipv6Packet_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.ipv6Hdr().get_selection()) {
single_value->field_ipv6Hdr = other_value.ipv6Hdr();
} else {
single_value->field_ipv6Hdr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.extHdrList().get_selection()) {
single_value->field_extHdrList = other_value.extHdrList();
} else {
single_value->field_extHdrList.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ipv6Payload().get_selection()) {
single_value->field_ipv6Payload = other_value.ipv6Payload();
} else {
single_value->field_ipv6Payload.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Ipv6Packet_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.");
break;
}
set_selection(other_value);
}

Ipv6Packet_template::Ipv6Packet_template()
{
}

Ipv6Packet_template::Ipv6Packet_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Ipv6Packet_template::Ipv6Packet_template(const Ipv6Packet& other_value)
{
copy_value(other_value);
}

Ipv6Packet_template::Ipv6Packet_template(const OPTIONAL<Ipv6Packet>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Ipv6Packet&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet from an unbound optional field.");
}
}

Ipv6Packet_template::Ipv6Packet_template(const Ipv6Packet_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Ipv6Packet_template::~Ipv6Packet_template()
{
clean_up();
}

Ipv6Packet_template& Ipv6Packet_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Ipv6Packet_template& Ipv6Packet_template::operator=(const Ipv6Packet& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Ipv6Packet_template& Ipv6Packet_template::operator=(const OPTIONAL<Ipv6Packet>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Ipv6Packet&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.");
}
return *this;
}

Ipv6Packet_template& Ipv6Packet_template::operator=(const Ipv6Packet_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Ipv6Packet_template::match(const Ipv6Packet& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.ipv6Hdr().is_bound()) return FALSE;
if(!single_value->field_ipv6Hdr.match(other_value.ipv6Hdr(), legacy))return FALSE;
if(!other_value.extHdrList().is_bound()) return FALSE;
if((other_value.extHdrList().ispresent() ? !single_value->field_extHdrList.match((const OCTETSTRING&)other_value.extHdrList(), legacy) : !single_value->field_extHdrList.match_omit(legacy)))return FALSE;
if(!other_value.ipv6Payload().is_bound()) return FALSE;
if((other_value.ipv6Payload().ispresent() ? !single_value->field_ipv6Payload.match((const Ipv6Payload&)other_value.ipv6Payload(), legacy) : !single_value->field_ipv6Payload.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.");
}
return FALSE;
}

boolean Ipv6Packet_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_ipv6Hdr.is_bound()) return TRUE;
if (single_value->field_extHdrList.is_omit() || single_value->field_extHdrList.is_bound()) return TRUE;
if (single_value->field_ipv6Payload.is_omit() || single_value->field_ipv6Payload.is_bound()) return TRUE;
return FALSE;
}

boolean Ipv6Packet_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_ipv6Hdr.is_value()) return FALSE;
if (!single_value->field_extHdrList.is_omit() && !single_value->field_extHdrList.is_value()) return FALSE;
if (!single_value->field_ipv6Payload.is_omit() && !single_value->field_ipv6Payload.is_value()) return FALSE;
return TRUE;
}

void Ipv6Packet_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Ipv6Packet Ipv6Packet_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.");
Ipv6Packet ret_val;
if (single_value->field_ipv6Hdr.is_bound()) {
ret_val.ipv6Hdr() = single_value->field_ipv6Hdr.valueof();
}
if (single_value->field_extHdrList.is_omit()) ret_val.extHdrList() = OMIT_VALUE;
else if (single_value->field_extHdrList.is_bound()) {
ret_val.extHdrList() = single_value->field_extHdrList.valueof();
}
if (single_value->field_ipv6Payload.is_omit()) ret_val.ipv6Payload() = OMIT_VALUE;
else if (single_value->field_ipv6Payload.is_bound()) {
ret_val.ipv6Payload() = single_value->field_ipv6Payload.valueof();
}
return ret_val;
}

void Ipv6Packet_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Ipv6Packet_template[list_length];
}

Ipv6Packet_template& Ipv6Packet_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.");
return value_list.list_value[list_index];
}

Ipv6Header_template& Ipv6Packet_template::ipv6Hdr()
{
set_specific();
return single_value->field_ipv6Hdr;
}

const Ipv6Header_template& Ipv6Packet_template::ipv6Hdr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ipv6Hdr of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.");
return single_value->field_ipv6Hdr;
}

OCTETSTRING_template& Ipv6Packet_template::extHdrList()
{
set_specific();
return single_value->field_extHdrList;
}

const OCTETSTRING_template& Ipv6Packet_template::extHdrList() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field extHdrList of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.");
return single_value->field_extHdrList;
}

Ipv6Payload_template& Ipv6Packet_template::ipv6Payload()
{
set_specific();
return single_value->field_ipv6Payload;
}

const Ipv6Payload_template& Ipv6Packet_template::ipv6Payload() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ipv6Payload of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.");
return single_value->field_ipv6Payload;
}

int Ipv6Packet_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_extHdrList.is_present()) ret_val++;
      if (single_value->field_ipv6Payload.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.");
  }
  return 0;
}

void Ipv6Packet_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ ipv6Hdr := ");
single_value->field_ipv6Hdr.log();
TTCN_Logger::log_event_str(", extHdrList := ");
single_value->field_extHdrList.log();
TTCN_Logger::log_event_str(", ipv6Payload := ");
single_value->field_ipv6Payload.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Ipv6Packet_template::log_match(const Ipv6Packet& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_ipv6Hdr.match(match_value.ipv6Hdr(), legacy)){
TTCN_Logger::log_logmatch_info(".ipv6Hdr");
single_value->field_ipv6Hdr.log_match(match_value.ipv6Hdr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.extHdrList().ispresent()){
if(!single_value->field_extHdrList.match(match_value.extHdrList(), legacy)){
TTCN_Logger::log_logmatch_info(".extHdrList");
single_value->field_extHdrList.log_match(match_value.extHdrList(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_extHdrList.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".extHdrList := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_extHdrList.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.ipv6Payload().ispresent()){
if(!single_value->field_ipv6Payload.match(match_value.ipv6Payload(), legacy)){
TTCN_Logger::log_logmatch_info(".ipv6Payload");
single_value->field_ipv6Payload.log_match(match_value.ipv6Payload(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_ipv6Payload.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".ipv6Payload := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_ipv6Payload.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ ipv6Hdr := ");
single_value->field_ipv6Hdr.log_match(match_value.ipv6Hdr(), legacy);
TTCN_Logger::log_event_str(", extHdrList := ");
if (match_value.extHdrList().ispresent()) single_value->field_extHdrList.log_match(match_value.extHdrList(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_extHdrList.log();
if (single_value->field_extHdrList.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", ipv6Payload := ");
if (match_value.ipv6Payload().ispresent()) single_value->field_ipv6Payload.log_match(match_value.ipv6Payload(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_ipv6Payload.log();
if (single_value->field_ipv6Payload.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Ipv6Packet_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_ipv6Hdr.encode_text(text_buf);
single_value->field_extHdrList.encode_text(text_buf);
single_value->field_ipv6Payload.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.");
}
}

void Ipv6Packet_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_ipv6Hdr.decode_text(text_buf);
single_value->field_extHdrList.decode_text(text_buf);
single_value->field_ipv6Payload.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Ipv6Packet_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet.");
}
}

void Ipv6Packet_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet'");
    }
    if (strcmp("ipv6Hdr", param_field) == 0) {
      ipv6Hdr().set_param(param);
      return;
    } else if (strcmp("extHdrList", param_field) == 0) {
      extHdrList().set_param(param);
      return;
    } else if (strcmp("ipv6Payload", param_field) == 0) {
      ipv6Payload().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Ipv6Packet_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) ipv6Hdr().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) extHdrList().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) ipv6Payload().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ipv6Hdr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ipv6Hdr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "extHdrList")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          extHdrList().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ipv6Payload")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ipv6Payload().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Ipv6Packet_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet'");
    }
    if (strcmp("ipv6Hdr", param_field) == 0) {
      return ipv6Hdr().get_param(param_name);
    } else if (strcmp("extHdrList", param_field) == 0) {
      return extHdrList().get_param(param_name);
    } else if (strcmp("ipv6Payload", param_field) == 0) {
      return ipv6Payload().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_ipv6Hdr = single_value->field_ipv6Hdr.get_param(param_name);
    mp_field_ipv6Hdr->set_id(new Module_Param_FieldName(mcopystr("ipv6Hdr")));
    mp->add_elem(mp_field_ipv6Hdr);
    Module_Param* mp_field_extHdrList = single_value->field_extHdrList.get_param(param_name);
    mp_field_extHdrList->set_id(new Module_Param_FieldName(mcopystr("extHdrList")));
    mp->add_elem(mp_field_extHdrList);
    Module_Param* mp_field_ipv6Payload = single_value->field_ipv6Payload.get_param(param_name);
    mp_field_ipv6Payload->set_id(new Module_Param_FieldName(mcopystr("ipv6Payload")));
    mp->add_elem(mp_field_ipv6Payload);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Ipv6Packet_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_ipv6Hdr.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet");
single_value->field_extHdrList.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet");
single_value->field_ipv6Payload.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Packet");
}

boolean Ipv6Packet_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Ipv6Packet_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void Ipv6Payload::copy_value(const Ipv6Payload& other_value)
{
switch (other_value.union_selection) {
case ALT_routerAdvMsg:
field_routerAdvMsg = new RouterAdvertisementMsg(*other_value.field_routerAdvMsg);
break;
case ALT_octetstringMsg:
field_octetstringMsg = new OCTETSTRING(*other_value.field_octetstringMsg);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
}
union_selection = other_value.union_selection;
}

Ipv6Payload::Ipv6Payload()
{
union_selection = UNBOUND_VALUE;
}

Ipv6Payload::Ipv6Payload(const Ipv6Payload& other_value)
: Base_Type(){
copy_value(other_value);
}

Ipv6Payload::~Ipv6Payload()
{
clean_up();
}

Ipv6Payload& Ipv6Payload::operator=(const Ipv6Payload& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean Ipv6Payload::operator==(const Ipv6Payload& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_routerAdvMsg:
return *field_routerAdvMsg == *other_value.field_routerAdvMsg;
case ALT_octetstringMsg:
return *field_octetstringMsg == *other_value.field_octetstringMsg;
default:
return FALSE;
}
}

RouterAdvertisementMsg& Ipv6Payload::routerAdvMsg()
{
if (union_selection != ALT_routerAdvMsg) {
clean_up();
field_routerAdvMsg = new RouterAdvertisementMsg;
union_selection = ALT_routerAdvMsg;
}
return *field_routerAdvMsg;
}

const RouterAdvertisementMsg& Ipv6Payload::routerAdvMsg() const
{
if (union_selection != ALT_routerAdvMsg) TTCN_error("Using non-selected field routerAdvMsg in a value of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
return *field_routerAdvMsg;
}

OCTETSTRING& Ipv6Payload::octetstringMsg()
{
if (union_selection != ALT_octetstringMsg) {
clean_up();
field_octetstringMsg = new OCTETSTRING;
union_selection = ALT_octetstringMsg;
}
return *field_octetstringMsg;
}

const OCTETSTRING& Ipv6Payload::octetstringMsg() const
{
if (union_selection != ALT_octetstringMsg) TTCN_error("Using non-selected field octetstringMsg in a value of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
return *field_octetstringMsg;
}

boolean Ipv6Payload::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
return union_selection == checked_selection;
}

boolean Ipv6Payload::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean Ipv6Payload::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_routerAdvMsg: return field_routerAdvMsg->is_value();
case ALT_octetstringMsg: return field_octetstringMsg->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void Ipv6Payload::clean_up()
{
switch (union_selection) {
case ALT_routerAdvMsg:
  delete field_routerAdvMsg;
  break;
case ALT_octetstringMsg:
  delete field_octetstringMsg;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void Ipv6Payload::log() const
{
switch (union_selection) {
case ALT_routerAdvMsg:
TTCN_Logger::log_event_str("{ routerAdvMsg := ");
field_routerAdvMsg->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_octetstringMsg:
TTCN_Logger::log_event_str("{ octetstringMsg := ");
field_octetstringMsg->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void Ipv6Payload::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload'");
    }
    if (strcmp("routerAdvMsg", param_field) == 0) {
      routerAdvMsg().set_param(param);
      return;
    } else if (strcmp("octetstringMsg", param_field) == 0) {
      octetstringMsg().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "routerAdvMsg")) {
    routerAdvMsg().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "octetstringMsg")) {
    octetstringMsg().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.", mp_last->get_id()->get_name());
}

Module_Param* Ipv6Payload::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload'");
    }
    if (strcmp("routerAdvMsg", param_field) == 0) {
      return routerAdvMsg().get_param(param_name);
    } else if (strcmp("octetstringMsg", param_field) == 0) {
      return octetstringMsg().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `Ipv6Payload'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_routerAdvMsg:
    mp_field = field_routerAdvMsg->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("routerAdvMsg")));
    break;
  case ALT_octetstringMsg:
    mp_field = field_octetstringMsg->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("octetstringMsg")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void Ipv6Payload::set_implicit_omit()
{
switch (union_selection) {
case ALT_routerAdvMsg:
field_routerAdvMsg->set_implicit_omit(); break;
case ALT_octetstringMsg:
field_octetstringMsg->set_implicit_omit(); break;
default: break;
}
}

void Ipv6Payload::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_routerAdvMsg:
field_routerAdvMsg->encode_text(text_buf);
break;
case ALT_octetstringMsg:
field_octetstringMsg->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
}
}

void Ipv6Payload::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_routerAdvMsg:
routerAdvMsg().decode_text(text_buf);
break;
case ALT_octetstringMsg:
octetstringMsg().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
}
}

void Ipv6Payload::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Ipv6Payload::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int Ipv6Payload::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = routerAdvMsg().RAW_decode(RouterAdvertisementMsg_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = octetstringMsg().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = routerAdvMsg().RAW_decode(RouterAdvertisementMsg_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = octetstringMsg().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int Ipv6Payload::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  memset(myleaf.body.node.nodes, 0, 2 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_routerAdvMsg:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, RouterAdvertisementMsg_descr_.raw);
    encoded_length = field_routerAdvMsg->RAW_encode(RouterAdvertisementMsg_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &RouterAdvertisementMsg_descr_;
    break;
  case ALT_octetstringMsg:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, OCTETSTRING_descr_.raw);
    encoded_length = field_octetstringMsg->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &OCTETSTRING_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int Ipv6Payload::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_routerAdvMsg:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "routerAdvMsg");
    enc_len += field_routerAdvMsg->JSON_encode(RouterAdvertisementMsg_descr_, p_tok);
    break;
  case ALT_octetstringMsg:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "octetstringMsg");
    enc_len += field_octetstringMsg->JSON_encode(OCTETSTRING_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Ipv6Payload::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "routerAdvMsg", name_len)) {
      int ret_val = routerAdvMsg().JSON_decode(RouterAdvertisementMsg_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "routerAdvMsg");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "octetstringMsg", name_len)) {
      int ret_val = octetstringMsg().JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "octetstringMsg");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void Ipv6Payload_template::copy_value(const Ipv6Payload& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case Ipv6Payload::ALT_routerAdvMsg:
single_value.field_routerAdvMsg = new RouterAdvertisementMsg_template(other_value.routerAdvMsg());
break;
case Ipv6Payload::ALT_octetstringMsg:
single_value.field_octetstringMsg = new OCTETSTRING_template(other_value.octetstringMsg());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
}
set_selection(SPECIFIC_VALUE);
}

void Ipv6Payload_template::copy_template(const Ipv6Payload_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case Ipv6Payload::ALT_routerAdvMsg:
single_value.field_routerAdvMsg = new RouterAdvertisementMsg_template(*other_value.single_value.field_routerAdvMsg);
break;
case Ipv6Payload::ALT_octetstringMsg:
single_value.field_octetstringMsg = new OCTETSTRING_template(*other_value.single_value.field_octetstringMsg);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Ipv6Payload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
}
set_selection(other_value);
}

Ipv6Payload_template::Ipv6Payload_template()
{
}

Ipv6Payload_template::Ipv6Payload_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Ipv6Payload_template::Ipv6Payload_template(const Ipv6Payload& other_value)
{
copy_value(other_value);
}

Ipv6Payload_template::Ipv6Payload_template(const OPTIONAL<Ipv6Payload>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Ipv6Payload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload from an unbound optional field.");
}
}

Ipv6Payload_template::Ipv6Payload_template(const Ipv6Payload_template& other_value)
: Base_Template(){
copy_template(other_value);
}

Ipv6Payload_template::~Ipv6Payload_template()
{
clean_up();
}

void Ipv6Payload_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case Ipv6Payload::ALT_routerAdvMsg:
delete single_value.field_routerAdvMsg;
break;
case Ipv6Payload::ALT_octetstringMsg:
delete single_value.field_octetstringMsg;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Ipv6Payload_template& Ipv6Payload_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Ipv6Payload_template& Ipv6Payload_template::operator=(const Ipv6Payload& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Ipv6Payload_template& Ipv6Payload_template::operator=(const OPTIONAL<Ipv6Payload>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Ipv6Payload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
}
return *this;
}

Ipv6Payload_template& Ipv6Payload_template::operator=(const Ipv6Payload_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Ipv6Payload_template::match(const Ipv6Payload& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
Ipv6Payload::union_selection_type value_selection = other_value.get_selection();
if (value_selection == Ipv6Payload::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case Ipv6Payload::ALT_routerAdvMsg:
return single_value.field_routerAdvMsg->match(other_value.routerAdvMsg(), legacy);
case Ipv6Payload::ALT_octetstringMsg:
return single_value.field_octetstringMsg->match(other_value.octetstringMsg(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
}
return FALSE;
}

boolean Ipv6Payload_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case Ipv6Payload::ALT_routerAdvMsg:
return single_value.field_routerAdvMsg->is_value();
case Ipv6Payload::ALT_octetstringMsg:
return single_value.field_octetstringMsg->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
}
}

Ipv6Payload Ipv6Payload_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
Ipv6Payload ret_val;
switch (single_value.union_selection) {
case Ipv6Payload::ALT_routerAdvMsg:
ret_val.routerAdvMsg() = single_value.field_routerAdvMsg->valueof();
break;
case Ipv6Payload::ALT_octetstringMsg:
ret_val.octetstringMsg() = single_value.field_octetstringMsg->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
}
return ret_val;
}

Ipv6Payload_template& Ipv6Payload_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
return value_list.list_value[list_index];
}
void Ipv6Payload_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Ipv6Payload_template[list_length];
}

RouterAdvertisementMsg_template& Ipv6Payload_template::routerAdvMsg()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != Ipv6Payload::ALT_routerAdvMsg) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_routerAdvMsg = new RouterAdvertisementMsg_template(ANY_VALUE);
else single_value.field_routerAdvMsg = new RouterAdvertisementMsg_template;
single_value.union_selection = Ipv6Payload::ALT_routerAdvMsg;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_routerAdvMsg;
}

const RouterAdvertisementMsg_template& Ipv6Payload_template::routerAdvMsg() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field routerAdvMsg in a non-specific template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
if (single_value.union_selection != Ipv6Payload::ALT_routerAdvMsg) TTCN_error("Accessing non-selected field routerAdvMsg in a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
return *single_value.field_routerAdvMsg;
}

OCTETSTRING_template& Ipv6Payload_template::octetstringMsg()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != Ipv6Payload::ALT_octetstringMsg) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_octetstringMsg = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_octetstringMsg = new OCTETSTRING_template;
single_value.union_selection = Ipv6Payload::ALT_octetstringMsg;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_octetstringMsg;
}

const OCTETSTRING_template& Ipv6Payload_template::octetstringMsg() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field octetstringMsg in a non-specific template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
if (single_value.union_selection != Ipv6Payload::ALT_octetstringMsg) TTCN_error("Accessing non-selected field octetstringMsg in a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
return *single_value.field_octetstringMsg;
}

boolean Ipv6Payload_template::ischosen(Ipv6Payload::union_selection_type checked_selection) const
{
if (checked_selection == Ipv6Payload::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == Ipv6Payload::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload");
}
return FALSE;
}

void Ipv6Payload_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case Ipv6Payload::ALT_routerAdvMsg:
TTCN_Logger::log_event_str("{ routerAdvMsg := ");
single_value.field_routerAdvMsg->log();
TTCN_Logger::log_event_str(" }");
break;
case Ipv6Payload::ALT_octetstringMsg:
TTCN_Logger::log_event_str("{ octetstringMsg := ");
single_value.field_octetstringMsg->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Ipv6Payload_template::log_match(const Ipv6Payload& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case Ipv6Payload::ALT_routerAdvMsg:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".routerAdvMsg");
single_value.field_routerAdvMsg->log_match(match_value.routerAdvMsg(), legacy);
} else {
TTCN_Logger::log_event_str("{ routerAdvMsg := ");
single_value.field_routerAdvMsg->log_match(match_value.routerAdvMsg(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case Ipv6Payload::ALT_octetstringMsg:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".octetstringMsg");
single_value.field_octetstringMsg->log_match(match_value.octetstringMsg(), legacy);
} else {
TTCN_Logger::log_event_str("{ octetstringMsg := ");
single_value.field_octetstringMsg->log_match(match_value.octetstringMsg(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Ipv6Payload_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case Ipv6Payload::ALT_routerAdvMsg:
single_value.field_routerAdvMsg->encode_text(text_buf);
break;
case Ipv6Payload::ALT_octetstringMsg:
single_value.field_octetstringMsg->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
}
}

void Ipv6Payload_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = Ipv6Payload::UNBOUND_VALUE;
Ipv6Payload::union_selection_type new_selection = (Ipv6Payload::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case Ipv6Payload::ALT_routerAdvMsg:
single_value.field_routerAdvMsg = new RouterAdvertisementMsg_template;
single_value.field_routerAdvMsg->decode_text(text_buf);
break;
case Ipv6Payload::ALT_octetstringMsg:
single_value.field_octetstringMsg = new OCTETSTRING_template;
single_value.field_octetstringMsg->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Ipv6Payload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
}
}

boolean Ipv6Payload_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Ipv6Payload_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void Ipv6Payload_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload'");
    }
    if (strcmp("routerAdvMsg", param_field) == 0) {
      routerAdvMsg().set_param(param);
      return;
    } else if (strcmp("octetstringMsg", param_field) == 0) {
      octetstringMsg().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Ipv6Payload_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "routerAdvMsg")) {
      routerAdvMsg().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "octetstringMsg")) {
      octetstringMsg().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Ipv6Payload_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload'");
    }
    if (strcmp("routerAdvMsg", param_field) == 0) {
      return routerAdvMsg().get_param(param_name);
    } else if (strcmp("octetstringMsg", param_field) == 0) {
      return octetstringMsg().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `Ipv6Payload'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case Ipv6Payload::ALT_routerAdvMsg:
      mp_field = single_value.field_routerAdvMsg->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("routerAdvMsg")));
      break;
    case Ipv6Payload::ALT_octetstringMsg:
      mp_field = single_value.field_octetstringMsg->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("octetstringMsg")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Ipv6Payload_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case Ipv6Payload::ALT_routerAdvMsg:
single_value.field_routerAdvMsg->check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload");
return;
case Ipv6Payload::ALT_octetstringMsg:
single_value.field_octetstringMsg->check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.Ipv6Payload");
}

RouterAdvertisementMsg::RouterAdvertisementMsg()
{
  bound_flag = FALSE;
}

RouterAdvertisementMsg::RouterAdvertisementMsg(const INTEGER& par_icmpType,
    const INTEGER& par_icmpCode,
    const OCTETSTRING& par_checksum,
    const INTEGER& par_curHopLimit,
    const INTEGER& par_managedConfigFlag,
    const INTEGER& par_otherConfigFlag,
    const INTEGER& par_homeAgentFlag,
    const INTEGER& par_reserved,
    const INTEGER& par_routerLifetime,
    const INTEGER& par_reachableTime,
    const INTEGER& par_retransTimer,
    const OPTIONAL<RtAdvOptions>& par_rtAdvOptions)
  :   field_icmpType(par_icmpType),
  field_icmpCode(par_icmpCode),
  field_checksum(par_checksum),
  field_curHopLimit(par_curHopLimit),
  field_managedConfigFlag(par_managedConfigFlag),
  field_otherConfigFlag(par_otherConfigFlag),
  field_homeAgentFlag(par_homeAgentFlag),
  field_reserved(par_reserved),
  field_routerLifetime(par_routerLifetime),
  field_reachableTime(par_reachableTime),
  field_retransTimer(par_retransTimer),
  field_rtAdvOptions(par_rtAdvOptions)
{
  bound_flag = TRUE;
}

RouterAdvertisementMsg::RouterAdvertisementMsg(const RouterAdvertisementMsg& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
bound_flag = TRUE;
if (other_value.icmpType().is_bound()) field_icmpType = other_value.icmpType();
else field_icmpType.clean_up();
if (other_value.icmpCode().is_bound()) field_icmpCode = other_value.icmpCode();
else field_icmpCode.clean_up();
if (other_value.checksum().is_bound()) field_checksum = other_value.checksum();
else field_checksum.clean_up();
if (other_value.curHopLimit().is_bound()) field_curHopLimit = other_value.curHopLimit();
else field_curHopLimit.clean_up();
if (other_value.managedConfigFlag().is_bound()) field_managedConfigFlag = other_value.managedConfigFlag();
else field_managedConfigFlag.clean_up();
if (other_value.otherConfigFlag().is_bound()) field_otherConfigFlag = other_value.otherConfigFlag();
else field_otherConfigFlag.clean_up();
if (other_value.homeAgentFlag().is_bound()) field_homeAgentFlag = other_value.homeAgentFlag();
else field_homeAgentFlag.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
if (other_value.routerLifetime().is_bound()) field_routerLifetime = other_value.routerLifetime();
else field_routerLifetime.clean_up();
if (other_value.reachableTime().is_bound()) field_reachableTime = other_value.reachableTime();
else field_reachableTime.clean_up();
if (other_value.retransTimer().is_bound()) field_retransTimer = other_value.retransTimer();
else field_retransTimer.clean_up();
if (other_value.rtAdvOptions().is_bound()) field_rtAdvOptions = other_value.rtAdvOptions();
else field_rtAdvOptions.clean_up();
}

void RouterAdvertisementMsg::clean_up()
{
field_icmpType.clean_up();
field_icmpCode.clean_up();
field_checksum.clean_up();
field_curHopLimit.clean_up();
field_managedConfigFlag.clean_up();
field_otherConfigFlag.clean_up();
field_homeAgentFlag.clean_up();
field_reserved.clean_up();
field_routerLifetime.clean_up();
field_reachableTime.clean_up();
field_retransTimer.clean_up();
field_rtAdvOptions.clean_up();
bound_flag = FALSE;
}

RouterAdvertisementMsg& RouterAdvertisementMsg::operator=(const RouterAdvertisementMsg& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
  bound_flag = TRUE;
  if (other_value.icmpType().is_bound()) field_icmpType = other_value.icmpType();
  else field_icmpType.clean_up();
  if (other_value.icmpCode().is_bound()) field_icmpCode = other_value.icmpCode();
  else field_icmpCode.clean_up();
  if (other_value.checksum().is_bound()) field_checksum = other_value.checksum();
  else field_checksum.clean_up();
  if (other_value.curHopLimit().is_bound()) field_curHopLimit = other_value.curHopLimit();
  else field_curHopLimit.clean_up();
  if (other_value.managedConfigFlag().is_bound()) field_managedConfigFlag = other_value.managedConfigFlag();
  else field_managedConfigFlag.clean_up();
  if (other_value.otherConfigFlag().is_bound()) field_otherConfigFlag = other_value.otherConfigFlag();
  else field_otherConfigFlag.clean_up();
  if (other_value.homeAgentFlag().is_bound()) field_homeAgentFlag = other_value.homeAgentFlag();
  else field_homeAgentFlag.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
  if (other_value.routerLifetime().is_bound()) field_routerLifetime = other_value.routerLifetime();
  else field_routerLifetime.clean_up();
  if (other_value.reachableTime().is_bound()) field_reachableTime = other_value.reachableTime();
  else field_reachableTime.clean_up();
  if (other_value.retransTimer().is_bound()) field_retransTimer = other_value.retransTimer();
  else field_retransTimer.clean_up();
  if (other_value.rtAdvOptions().is_bound()) field_rtAdvOptions = other_value.rtAdvOptions();
  else field_rtAdvOptions.clean_up();
}
return *this;
}

boolean RouterAdvertisementMsg::operator==(const RouterAdvertisementMsg& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_icmpType==other_value.field_icmpType
  && field_icmpCode==other_value.field_icmpCode
  && field_checksum==other_value.field_checksum
  && field_curHopLimit==other_value.field_curHopLimit
  && field_managedConfigFlag==other_value.field_managedConfigFlag
  && field_otherConfigFlag==other_value.field_otherConfigFlag
  && field_homeAgentFlag==other_value.field_homeAgentFlag
  && field_reserved==other_value.field_reserved
  && field_routerLifetime==other_value.field_routerLifetime
  && field_reachableTime==other_value.field_reachableTime
  && field_retransTimer==other_value.field_retransTimer
  && field_rtAdvOptions==other_value.field_rtAdvOptions;
}

boolean RouterAdvertisementMsg::is_bound() const
{
if (bound_flag) return TRUE;
if(field_icmpType.is_bound()) return TRUE;
if(field_icmpCode.is_bound()) return TRUE;
if(field_checksum.is_bound()) return TRUE;
if(field_curHopLimit.is_bound()) return TRUE;
if(field_managedConfigFlag.is_bound()) return TRUE;
if(field_otherConfigFlag.is_bound()) return TRUE;
if(field_homeAgentFlag.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
if(field_routerLifetime.is_bound()) return TRUE;
if(field_reachableTime.is_bound()) return TRUE;
if(field_retransTimer.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_rtAdvOptions.get_selection() || field_rtAdvOptions.is_bound()) return TRUE;
return FALSE;
}
boolean RouterAdvertisementMsg::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_icmpType.is_value()) return FALSE;
if(!field_icmpCode.is_value()) return FALSE;
if(!field_checksum.is_value()) return FALSE;
if(!field_curHopLimit.is_value()) return FALSE;
if(!field_managedConfigFlag.is_value()) return FALSE;
if(!field_otherConfigFlag.is_value()) return FALSE;
if(!field_homeAgentFlag.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
if(!field_routerLifetime.is_value()) return FALSE;
if(!field_reachableTime.is_value()) return FALSE;
if(!field_retransTimer.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_rtAdvOptions.get_selection() && !field_rtAdvOptions.is_value()) return FALSE;
return TRUE;
}
int RouterAdvertisementMsg::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg");
  int ret_val = 11;
  if (field_rtAdvOptions.ispresent()) ret_val++;
  return ret_val;
}

void RouterAdvertisementMsg::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ icmpType := ");
field_icmpType.log();
TTCN_Logger::log_event_str(", icmpCode := ");
field_icmpCode.log();
TTCN_Logger::log_event_str(", checksum := ");
field_checksum.log();
TTCN_Logger::log_event_str(", curHopLimit := ");
field_curHopLimit.log();
TTCN_Logger::log_event_str(", managedConfigFlag := ");
field_managedConfigFlag.log();
TTCN_Logger::log_event_str(", otherConfigFlag := ");
field_otherConfigFlag.log();
TTCN_Logger::log_event_str(", homeAgentFlag := ");
field_homeAgentFlag.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(", routerLifetime := ");
field_routerLifetime.log();
TTCN_Logger::log_event_str(", reachableTime := ");
field_reachableTime.log();
TTCN_Logger::log_event_str(", retransTimer := ");
field_retransTimer.log();
TTCN_Logger::log_event_str(", rtAdvOptions := ");
field_rtAdvOptions.log();
TTCN_Logger::log_event_str(" }");
}

void RouterAdvertisementMsg::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg'");
    }
    if (strcmp("icmpType", param_field) == 0) {
      icmpType().set_param(param);
      return;
    } else if (strcmp("icmpCode", param_field) == 0) {
      icmpCode().set_param(param);
      return;
    } else if (strcmp("checksum", param_field) == 0) {
      checksum().set_param(param);
      return;
    } else if (strcmp("curHopLimit", param_field) == 0) {
      curHopLimit().set_param(param);
      return;
    } else if (strcmp("managedConfigFlag", param_field) == 0) {
      managedConfigFlag().set_param(param);
      return;
    } else if (strcmp("otherConfigFlag", param_field) == 0) {
      otherConfigFlag().set_param(param);
      return;
    } else if (strcmp("homeAgentFlag", param_field) == 0) {
      homeAgentFlag().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("routerLifetime", param_field) == 0) {
      routerLifetime().set_param(param);
      return;
    } else if (strcmp("reachableTime", param_field) == 0) {
      reachableTime().set_param(param);
      return;
    } else if (strcmp("retransTimer", param_field) == 0) {
      retransTimer().set_param(param);
      return;
    } else if (strcmp("rtAdvOptions", param_field) == 0) {
      rtAdvOptions().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (12<mp->get_size()) {
      param.error("record value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg has 12 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) icmpType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) icmpCode().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) checksum().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) curHopLimit().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) managedConfigFlag().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) otherConfigFlag().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) homeAgentFlag().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) routerLifetime().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) reachableTime().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) retransTimer().set_param(*mp->get_elem(10));
    if (mp->get_size()>11 && mp->get_elem(11)->get_type()!=Module_Param::MP_NotUsed) rtAdvOptions().set_param(*mp->get_elem(11));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "icmpType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          icmpType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "icmpCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          icmpCode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "checksum")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          checksum().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "curHopLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          curHopLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "managedConfigFlag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          managedConfigFlag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "otherConfigFlag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          otherConfigFlag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "homeAgentFlag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          homeAgentFlag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "routerLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          routerLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reachableTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reachableTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "retransTimer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          retransTimer().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rtAdvOptions")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rtAdvOptions().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg");
  }
}

Module_Param* RouterAdvertisementMsg::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg'");
    }
    if (strcmp("icmpType", param_field) == 0) {
      return icmpType().get_param(param_name);
    } else if (strcmp("icmpCode", param_field) == 0) {
      return icmpCode().get_param(param_name);
    } else if (strcmp("checksum", param_field) == 0) {
      return checksum().get_param(param_name);
    } else if (strcmp("curHopLimit", param_field) == 0) {
      return curHopLimit().get_param(param_name);
    } else if (strcmp("managedConfigFlag", param_field) == 0) {
      return managedConfigFlag().get_param(param_name);
    } else if (strcmp("otherConfigFlag", param_field) == 0) {
      return otherConfigFlag().get_param(param_name);
    } else if (strcmp("homeAgentFlag", param_field) == 0) {
      return homeAgentFlag().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("routerLifetime", param_field) == 0) {
      return routerLifetime().get_param(param_name);
    } else if (strcmp("reachableTime", param_field) == 0) {
      return reachableTime().get_param(param_name);
    } else if (strcmp("retransTimer", param_field) == 0) {
      return retransTimer().get_param(param_name);
    } else if (strcmp("rtAdvOptions", param_field) == 0) {
      return rtAdvOptions().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_icmpType = field_icmpType.get_param(param_name);
  mp_field_icmpType->set_id(new Module_Param_FieldName(mcopystr("icmpType")));
  mp->add_elem(mp_field_icmpType);
  Module_Param* mp_field_icmpCode = field_icmpCode.get_param(param_name);
  mp_field_icmpCode->set_id(new Module_Param_FieldName(mcopystr("icmpCode")));
  mp->add_elem(mp_field_icmpCode);
  Module_Param* mp_field_checksum = field_checksum.get_param(param_name);
  mp_field_checksum->set_id(new Module_Param_FieldName(mcopystr("checksum")));
  mp->add_elem(mp_field_checksum);
  Module_Param* mp_field_curHopLimit = field_curHopLimit.get_param(param_name);
  mp_field_curHopLimit->set_id(new Module_Param_FieldName(mcopystr("curHopLimit")));
  mp->add_elem(mp_field_curHopLimit);
  Module_Param* mp_field_managedConfigFlag = field_managedConfigFlag.get_param(param_name);
  mp_field_managedConfigFlag->set_id(new Module_Param_FieldName(mcopystr("managedConfigFlag")));
  mp->add_elem(mp_field_managedConfigFlag);
  Module_Param* mp_field_otherConfigFlag = field_otherConfigFlag.get_param(param_name);
  mp_field_otherConfigFlag->set_id(new Module_Param_FieldName(mcopystr("otherConfigFlag")));
  mp->add_elem(mp_field_otherConfigFlag);
  Module_Param* mp_field_homeAgentFlag = field_homeAgentFlag.get_param(param_name);
  mp_field_homeAgentFlag->set_id(new Module_Param_FieldName(mcopystr("homeAgentFlag")));
  mp->add_elem(mp_field_homeAgentFlag);
  Module_Param* mp_field_reserved = field_reserved.get_param(param_name);
  mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
  mp->add_elem(mp_field_reserved);
  Module_Param* mp_field_routerLifetime = field_routerLifetime.get_param(param_name);
  mp_field_routerLifetime->set_id(new Module_Param_FieldName(mcopystr("routerLifetime")));
  mp->add_elem(mp_field_routerLifetime);
  Module_Param* mp_field_reachableTime = field_reachableTime.get_param(param_name);
  mp_field_reachableTime->set_id(new Module_Param_FieldName(mcopystr("reachableTime")));
  mp->add_elem(mp_field_reachableTime);
  Module_Param* mp_field_retransTimer = field_retransTimer.get_param(param_name);
  mp_field_retransTimer->set_id(new Module_Param_FieldName(mcopystr("retransTimer")));
  mp->add_elem(mp_field_retransTimer);
  Module_Param* mp_field_rtAdvOptions = field_rtAdvOptions.get_param(param_name);
  mp_field_rtAdvOptions->set_id(new Module_Param_FieldName(mcopystr("rtAdvOptions")));
  mp->add_elem(mp_field_rtAdvOptions);
  return mp;
  }

void RouterAdvertisementMsg::set_implicit_omit()
{
if (icmpType().is_bound()) icmpType().set_implicit_omit();
if (icmpCode().is_bound()) icmpCode().set_implicit_omit();
if (checksum().is_bound()) checksum().set_implicit_omit();
if (curHopLimit().is_bound()) curHopLimit().set_implicit_omit();
if (managedConfigFlag().is_bound()) managedConfigFlag().set_implicit_omit();
if (otherConfigFlag().is_bound()) otherConfigFlag().set_implicit_omit();
if (homeAgentFlag().is_bound()) homeAgentFlag().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
if (routerLifetime().is_bound()) routerLifetime().set_implicit_omit();
if (reachableTime().is_bound()) reachableTime().set_implicit_omit();
if (retransTimer().is_bound()) retransTimer().set_implicit_omit();
if (!rtAdvOptions().is_bound()) rtAdvOptions() = OMIT_VALUE;
else rtAdvOptions().set_implicit_omit();
}

void RouterAdvertisementMsg::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
field_icmpType.encode_text(text_buf);
field_icmpCode.encode_text(text_buf);
field_checksum.encode_text(text_buf);
field_curHopLimit.encode_text(text_buf);
field_managedConfigFlag.encode_text(text_buf);
field_otherConfigFlag.encode_text(text_buf);
field_homeAgentFlag.encode_text(text_buf);
field_reserved.encode_text(text_buf);
field_routerLifetime.encode_text(text_buf);
field_reachableTime.encode_text(text_buf);
field_retransTimer.encode_text(text_buf);
field_rtAdvOptions.encode_text(text_buf);
}

void RouterAdvertisementMsg::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_icmpType.decode_text(text_buf);
field_icmpCode.decode_text(text_buf);
field_checksum.decode_text(text_buf);
field_curHopLimit.decode_text(text_buf);
field_managedConfigFlag.decode_text(text_buf);
field_otherConfigFlag.decode_text(text_buf);
field_homeAgentFlag.decode_text(text_buf);
field_reserved.decode_text(text_buf);
field_routerLifetime.decode_text(text_buf);
field_reachableTime.decode_text(text_buf);
field_retransTimer.decode_text(text_buf);
field_rtAdvOptions.decode_text(text_buf);
}

void RouterAdvertisementMsg::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RouterAdvertisementMsg::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int RouterAdvertisementMsg::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_icmpType.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_icmpCode.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_checksum.RAW_decode(LibCommon__DataStrings::Oct2_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_curHopLimit.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_managedConfigFlag.RAW_decode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_otherConfigFlag.RAW_decode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_homeAgentFlag.RAW_decode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved.RAW_decode(LibCommon__BasicTypesAndValues::UInt5_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_routerLifetime.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reachableTime.RAW_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_retransTimer.RAW_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_rtAdvOptions().RAW_decode(RtAdvOptions_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_rtAdvOptions = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_rtAdvOptions=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int RouterAdvertisementMsg::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 12;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(12);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__DataStrings::Oct2_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, LibCommon__BasicTypesAndValues::UInt1_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, LibCommon__BasicTypesAndValues::UInt1_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, LibCommon__BasicTypesAndValues::UInt1_descr_.raw);
  myleaf.body.node.nodes[7] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 7, LibCommon__BasicTypesAndValues::UInt5_descr_.raw);
  myleaf.body.node.nodes[8] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 8, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[9] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 9, LibCommon__BasicTypesAndValues::UInt32_descr_.raw);
  myleaf.body.node.nodes[10] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 10, LibCommon__BasicTypesAndValues::UInt32_descr_.raw);
  if (field_rtAdvOptions.ispresent()) {
  myleaf.body.node.nodes[11] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 11, RtAdvOptions_descr_.raw);
  }
  else myleaf.body.node.nodes[11] = NULL;
  encoded_length += field_icmpType.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_icmpCode.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_checksum.RAW_encode(LibCommon__DataStrings::Oct2_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_curHopLimit.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_managedConfigFlag.RAW_encode(LibCommon__BasicTypesAndValues::UInt1_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_otherConfigFlag.RAW_encode(LibCommon__BasicTypesAndValues::UInt1_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_homeAgentFlag.RAW_encode(LibCommon__BasicTypesAndValues::UInt1_descr_, *myleaf.body.node.nodes[6]);
  encoded_length += field_reserved.RAW_encode(LibCommon__BasicTypesAndValues::UInt5_descr_, *myleaf.body.node.nodes[7]);
  encoded_length += field_routerLifetime.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[8]);
  encoded_length += field_reachableTime.RAW_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, *myleaf.body.node.nodes[9]);
  encoded_length += field_retransTimer.RAW_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, *myleaf.body.node.nodes[10]);
  if (field_rtAdvOptions.ispresent()) {
  encoded_length += field_rtAdvOptions().RAW_encode(RtAdvOptions_descr_, *myleaf.body.node.nodes[11]);
  }
  return myleaf.length = encoded_length;
}

int RouterAdvertisementMsg::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "icmpType");
    enc_len += field_icmpType.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "icmpCode");
    enc_len += field_icmpCode.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "checksum");
    enc_len += field_checksum.JSON_encode(LibCommon__DataStrings::Oct2_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "curHopLimit");
    enc_len += field_curHopLimit.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "managedConfigFlag");
    enc_len += field_managedConfigFlag.JSON_encode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "otherConfigFlag");
    enc_len += field_otherConfigFlag.JSON_encode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "homeAgentFlag");
    enc_len += field_homeAgentFlag.JSON_encode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(LibCommon__BasicTypesAndValues::UInt5_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "routerLifetime");
    enc_len += field_routerLifetime.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reachableTime");
    enc_len += field_reachableTime.JSON_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "retransTimer");
    enc_len += field_retransTimer.JSON_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok);
  }

  if (field_rtAdvOptions.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "rtAdvOptions");
    enc_len += field_rtAdvOptions.JSON_encode(RtAdvOptions_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int RouterAdvertisementMsg::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (8 == name_len && 0 == strncmp(fld_name, "icmpType", name_len)) {
         int ret_val = field_icmpType.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "icmpType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "icmpCode", name_len)) {
         int ret_val = field_icmpCode.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "icmpCode");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "checksum", name_len)) {
         int ret_val = field_checksum.JSON_decode(LibCommon__DataStrings::Oct2_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "checksum");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "curHopLimit", name_len)) {
         int ret_val = field_curHopLimit.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "curHopLimit");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "managedConfigFlag", name_len)) {
         int ret_val = field_managedConfigFlag.JSON_decode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "managedConfigFlag");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "otherConfigFlag", name_len)) {
         int ret_val = field_otherConfigFlag.JSON_decode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "otherConfigFlag");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "homeAgentFlag", name_len)) {
         int ret_val = field_homeAgentFlag.JSON_decode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "homeAgentFlag");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
         int ret_val = field_reserved.JSON_decode(LibCommon__BasicTypesAndValues::UInt5_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "routerLifetime", name_len)) {
         int ret_val = field_routerLifetime.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "routerLifetime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "reachableTime", name_len)) {
         int ret_val = field_reachableTime.JSON_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reachableTime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "retransTimer", name_len)) {
         int ret_val = field_retransTimer.JSON_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "retransTimer");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "rtAdvOptions", name_len)) {
         int ret_val = field_rtAdvOptions.JSON_decode(RtAdvOptions_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "rtAdvOptions");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_icmpType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "icmpType");
    return JSON_ERROR_FATAL;
  }
if (!field_icmpCode.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "icmpCode");
    return JSON_ERROR_FATAL;
  }
if (!field_checksum.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "checksum");
    return JSON_ERROR_FATAL;
  }
if (!field_curHopLimit.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "curHopLimit");
    return JSON_ERROR_FATAL;
  }
if (!field_managedConfigFlag.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "managedConfigFlag");
    return JSON_ERROR_FATAL;
  }
if (!field_otherConfigFlag.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "otherConfigFlag");
    return JSON_ERROR_FATAL;
  }
if (!field_homeAgentFlag.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "homeAgentFlag");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }
if (!field_routerLifetime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "routerLifetime");
    return JSON_ERROR_FATAL;
  }
if (!field_reachableTime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reachableTime");
    return JSON_ERROR_FATAL;
  }
if (!field_retransTimer.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "retransTimer");
    return JSON_ERROR_FATAL;
  }
if (!field_rtAdvOptions.is_bound()) {
    field_rtAdvOptions = OMIT_VALUE;
  }

  return dec_len;
}

struct RouterAdvertisementMsg_template::single_value_struct {
INTEGER_template field_icmpType;
INTEGER_template field_icmpCode;
OCTETSTRING_template field_checksum;
INTEGER_template field_curHopLimit;
INTEGER_template field_managedConfigFlag;
INTEGER_template field_otherConfigFlag;
INTEGER_template field_homeAgentFlag;
INTEGER_template field_reserved;
INTEGER_template field_routerLifetime;
INTEGER_template field_reachableTime;
INTEGER_template field_retransTimer;
RtAdvOptions_template field_rtAdvOptions;
};

void RouterAdvertisementMsg_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_icmpType = ANY_VALUE;
single_value->field_icmpCode = ANY_VALUE;
single_value->field_checksum = ANY_VALUE;
single_value->field_curHopLimit = ANY_VALUE;
single_value->field_managedConfigFlag = ANY_VALUE;
single_value->field_otherConfigFlag = ANY_VALUE;
single_value->field_homeAgentFlag = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
single_value->field_routerLifetime = ANY_VALUE;
single_value->field_reachableTime = ANY_VALUE;
single_value->field_retransTimer = ANY_VALUE;
single_value->field_rtAdvOptions = ANY_OR_OMIT;
}
}
}

void RouterAdvertisementMsg_template::copy_value(const RouterAdvertisementMsg& other_value)
{
single_value = new single_value_struct;
if (other_value.icmpType().is_bound()) {
  single_value->field_icmpType = other_value.icmpType();
} else {
  single_value->field_icmpType.clean_up();
}
if (other_value.icmpCode().is_bound()) {
  single_value->field_icmpCode = other_value.icmpCode();
} else {
  single_value->field_icmpCode.clean_up();
}
if (other_value.checksum().is_bound()) {
  single_value->field_checksum = other_value.checksum();
} else {
  single_value->field_checksum.clean_up();
}
if (other_value.curHopLimit().is_bound()) {
  single_value->field_curHopLimit = other_value.curHopLimit();
} else {
  single_value->field_curHopLimit.clean_up();
}
if (other_value.managedConfigFlag().is_bound()) {
  single_value->field_managedConfigFlag = other_value.managedConfigFlag();
} else {
  single_value->field_managedConfigFlag.clean_up();
}
if (other_value.otherConfigFlag().is_bound()) {
  single_value->field_otherConfigFlag = other_value.otherConfigFlag();
} else {
  single_value->field_otherConfigFlag.clean_up();
}
if (other_value.homeAgentFlag().is_bound()) {
  single_value->field_homeAgentFlag = other_value.homeAgentFlag();
} else {
  single_value->field_homeAgentFlag.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
if (other_value.routerLifetime().is_bound()) {
  single_value->field_routerLifetime = other_value.routerLifetime();
} else {
  single_value->field_routerLifetime.clean_up();
}
if (other_value.reachableTime().is_bound()) {
  single_value->field_reachableTime = other_value.reachableTime();
} else {
  single_value->field_reachableTime.clean_up();
}
if (other_value.retransTimer().is_bound()) {
  single_value->field_retransTimer = other_value.retransTimer();
} else {
  single_value->field_retransTimer.clean_up();
}
if (other_value.rtAdvOptions().is_bound()) {
  if (other_value.rtAdvOptions().ispresent()) single_value->field_rtAdvOptions = other_value.rtAdvOptions()();
  else single_value->field_rtAdvOptions = OMIT_VALUE;
} else {
  single_value->field_rtAdvOptions.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void RouterAdvertisementMsg_template::copy_template(const RouterAdvertisementMsg_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.icmpType().get_selection()) {
single_value->field_icmpType = other_value.icmpType();
} else {
single_value->field_icmpType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.icmpCode().get_selection()) {
single_value->field_icmpCode = other_value.icmpCode();
} else {
single_value->field_icmpCode.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.checksum().get_selection()) {
single_value->field_checksum = other_value.checksum();
} else {
single_value->field_checksum.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.curHopLimit().get_selection()) {
single_value->field_curHopLimit = other_value.curHopLimit();
} else {
single_value->field_curHopLimit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.managedConfigFlag().get_selection()) {
single_value->field_managedConfigFlag = other_value.managedConfigFlag();
} else {
single_value->field_managedConfigFlag.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.otherConfigFlag().get_selection()) {
single_value->field_otherConfigFlag = other_value.otherConfigFlag();
} else {
single_value->field_otherConfigFlag.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.homeAgentFlag().get_selection()) {
single_value->field_homeAgentFlag = other_value.homeAgentFlag();
} else {
single_value->field_homeAgentFlag.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.routerLifetime().get_selection()) {
single_value->field_routerLifetime = other_value.routerLifetime();
} else {
single_value->field_routerLifetime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reachableTime().get_selection()) {
single_value->field_reachableTime = other_value.reachableTime();
} else {
single_value->field_reachableTime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.retransTimer().get_selection()) {
single_value->field_retransTimer = other_value.retransTimer();
} else {
single_value->field_retransTimer.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rtAdvOptions().get_selection()) {
single_value->field_rtAdvOptions = other_value.rtAdvOptions();
} else {
single_value->field_rtAdvOptions.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RouterAdvertisementMsg_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
break;
}
set_selection(other_value);
}

RouterAdvertisementMsg_template::RouterAdvertisementMsg_template()
{
}

RouterAdvertisementMsg_template::RouterAdvertisementMsg_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RouterAdvertisementMsg_template::RouterAdvertisementMsg_template(const RouterAdvertisementMsg& other_value)
{
copy_value(other_value);
}

RouterAdvertisementMsg_template::RouterAdvertisementMsg_template(const OPTIONAL<RouterAdvertisementMsg>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RouterAdvertisementMsg&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg from an unbound optional field.");
}
}

RouterAdvertisementMsg_template::RouterAdvertisementMsg_template(const RouterAdvertisementMsg_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

RouterAdvertisementMsg_template::~RouterAdvertisementMsg_template()
{
clean_up();
}

RouterAdvertisementMsg_template& RouterAdvertisementMsg_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RouterAdvertisementMsg_template& RouterAdvertisementMsg_template::operator=(const RouterAdvertisementMsg& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RouterAdvertisementMsg_template& RouterAdvertisementMsg_template::operator=(const OPTIONAL<RouterAdvertisementMsg>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RouterAdvertisementMsg&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
}
return *this;
}

RouterAdvertisementMsg_template& RouterAdvertisementMsg_template::operator=(const RouterAdvertisementMsg_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RouterAdvertisementMsg_template::match(const RouterAdvertisementMsg& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.icmpType().is_bound()) return FALSE;
if(!single_value->field_icmpType.match(other_value.icmpType(), legacy))return FALSE;
if(!other_value.icmpCode().is_bound()) return FALSE;
if(!single_value->field_icmpCode.match(other_value.icmpCode(), legacy))return FALSE;
if(!other_value.checksum().is_bound()) return FALSE;
if(!single_value->field_checksum.match(other_value.checksum(), legacy))return FALSE;
if(!other_value.curHopLimit().is_bound()) return FALSE;
if(!single_value->field_curHopLimit.match(other_value.curHopLimit(), legacy))return FALSE;
if(!other_value.managedConfigFlag().is_bound()) return FALSE;
if(!single_value->field_managedConfigFlag.match(other_value.managedConfigFlag(), legacy))return FALSE;
if(!other_value.otherConfigFlag().is_bound()) return FALSE;
if(!single_value->field_otherConfigFlag.match(other_value.otherConfigFlag(), legacy))return FALSE;
if(!other_value.homeAgentFlag().is_bound()) return FALSE;
if(!single_value->field_homeAgentFlag.match(other_value.homeAgentFlag(), legacy))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved(), legacy))return FALSE;
if(!other_value.routerLifetime().is_bound()) return FALSE;
if(!single_value->field_routerLifetime.match(other_value.routerLifetime(), legacy))return FALSE;
if(!other_value.reachableTime().is_bound()) return FALSE;
if(!single_value->field_reachableTime.match(other_value.reachableTime(), legacy))return FALSE;
if(!other_value.retransTimer().is_bound()) return FALSE;
if(!single_value->field_retransTimer.match(other_value.retransTimer(), legacy))return FALSE;
if(!other_value.rtAdvOptions().is_bound()) return FALSE;
if((other_value.rtAdvOptions().ispresent() ? !single_value->field_rtAdvOptions.match((const RtAdvOptions&)other_value.rtAdvOptions(), legacy) : !single_value->field_rtAdvOptions.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
}
return FALSE;
}

boolean RouterAdvertisementMsg_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_icmpType.is_bound()) return TRUE;
if (single_value->field_icmpCode.is_bound()) return TRUE;
if (single_value->field_checksum.is_bound()) return TRUE;
if (single_value->field_curHopLimit.is_bound()) return TRUE;
if (single_value->field_managedConfigFlag.is_bound()) return TRUE;
if (single_value->field_otherConfigFlag.is_bound()) return TRUE;
if (single_value->field_homeAgentFlag.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
if (single_value->field_routerLifetime.is_bound()) return TRUE;
if (single_value->field_reachableTime.is_bound()) return TRUE;
if (single_value->field_retransTimer.is_bound()) return TRUE;
if (single_value->field_rtAdvOptions.is_omit() || single_value->field_rtAdvOptions.is_bound()) return TRUE;
return FALSE;
}

boolean RouterAdvertisementMsg_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_icmpType.is_value()) return FALSE;
if (!single_value->field_icmpCode.is_value()) return FALSE;
if (!single_value->field_checksum.is_value()) return FALSE;
if (!single_value->field_curHopLimit.is_value()) return FALSE;
if (!single_value->field_managedConfigFlag.is_value()) return FALSE;
if (!single_value->field_otherConfigFlag.is_value()) return FALSE;
if (!single_value->field_homeAgentFlag.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
if (!single_value->field_routerLifetime.is_value()) return FALSE;
if (!single_value->field_reachableTime.is_value()) return FALSE;
if (!single_value->field_retransTimer.is_value()) return FALSE;
if (!single_value->field_rtAdvOptions.is_omit() && !single_value->field_rtAdvOptions.is_value()) return FALSE;
return TRUE;
}

void RouterAdvertisementMsg_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RouterAdvertisementMsg RouterAdvertisementMsg_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
RouterAdvertisementMsg ret_val;
if (single_value->field_icmpType.is_bound()) {
ret_val.icmpType() = single_value->field_icmpType.valueof();
}
if (single_value->field_icmpCode.is_bound()) {
ret_val.icmpCode() = single_value->field_icmpCode.valueof();
}
if (single_value->field_checksum.is_bound()) {
ret_val.checksum() = single_value->field_checksum.valueof();
}
if (single_value->field_curHopLimit.is_bound()) {
ret_val.curHopLimit() = single_value->field_curHopLimit.valueof();
}
if (single_value->field_managedConfigFlag.is_bound()) {
ret_val.managedConfigFlag() = single_value->field_managedConfigFlag.valueof();
}
if (single_value->field_otherConfigFlag.is_bound()) {
ret_val.otherConfigFlag() = single_value->field_otherConfigFlag.valueof();
}
if (single_value->field_homeAgentFlag.is_bound()) {
ret_val.homeAgentFlag() = single_value->field_homeAgentFlag.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
if (single_value->field_routerLifetime.is_bound()) {
ret_val.routerLifetime() = single_value->field_routerLifetime.valueof();
}
if (single_value->field_reachableTime.is_bound()) {
ret_val.reachableTime() = single_value->field_reachableTime.valueof();
}
if (single_value->field_retransTimer.is_bound()) {
ret_val.retransTimer() = single_value->field_retransTimer.valueof();
}
if (single_value->field_rtAdvOptions.is_omit()) ret_val.rtAdvOptions() = OMIT_VALUE;
else if (single_value->field_rtAdvOptions.is_bound()) {
ret_val.rtAdvOptions() = single_value->field_rtAdvOptions.valueof();
}
return ret_val;
}

void RouterAdvertisementMsg_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RouterAdvertisementMsg_template[list_length];
}

RouterAdvertisementMsg_template& RouterAdvertisementMsg_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
return value_list.list_value[list_index];
}

INTEGER_template& RouterAdvertisementMsg_template::icmpType()
{
set_specific();
return single_value->field_icmpType;
}

const INTEGER_template& RouterAdvertisementMsg_template::icmpType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field icmpType of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
return single_value->field_icmpType;
}

INTEGER_template& RouterAdvertisementMsg_template::icmpCode()
{
set_specific();
return single_value->field_icmpCode;
}

const INTEGER_template& RouterAdvertisementMsg_template::icmpCode() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field icmpCode of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
return single_value->field_icmpCode;
}

OCTETSTRING_template& RouterAdvertisementMsg_template::checksum()
{
set_specific();
return single_value->field_checksum;
}

const OCTETSTRING_template& RouterAdvertisementMsg_template::checksum() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field checksum of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
return single_value->field_checksum;
}

INTEGER_template& RouterAdvertisementMsg_template::curHopLimit()
{
set_specific();
return single_value->field_curHopLimit;
}

const INTEGER_template& RouterAdvertisementMsg_template::curHopLimit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field curHopLimit of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
return single_value->field_curHopLimit;
}

INTEGER_template& RouterAdvertisementMsg_template::managedConfigFlag()
{
set_specific();
return single_value->field_managedConfigFlag;
}

const INTEGER_template& RouterAdvertisementMsg_template::managedConfigFlag() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field managedConfigFlag of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
return single_value->field_managedConfigFlag;
}

INTEGER_template& RouterAdvertisementMsg_template::otherConfigFlag()
{
set_specific();
return single_value->field_otherConfigFlag;
}

const INTEGER_template& RouterAdvertisementMsg_template::otherConfigFlag() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field otherConfigFlag of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
return single_value->field_otherConfigFlag;
}

INTEGER_template& RouterAdvertisementMsg_template::homeAgentFlag()
{
set_specific();
return single_value->field_homeAgentFlag;
}

const INTEGER_template& RouterAdvertisementMsg_template::homeAgentFlag() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field homeAgentFlag of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
return single_value->field_homeAgentFlag;
}

INTEGER_template& RouterAdvertisementMsg_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const INTEGER_template& RouterAdvertisementMsg_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
return single_value->field_reserved;
}

INTEGER_template& RouterAdvertisementMsg_template::routerLifetime()
{
set_specific();
return single_value->field_routerLifetime;
}

const INTEGER_template& RouterAdvertisementMsg_template::routerLifetime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field routerLifetime of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
return single_value->field_routerLifetime;
}

INTEGER_template& RouterAdvertisementMsg_template::reachableTime()
{
set_specific();
return single_value->field_reachableTime;
}

const INTEGER_template& RouterAdvertisementMsg_template::reachableTime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reachableTime of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
return single_value->field_reachableTime;
}

INTEGER_template& RouterAdvertisementMsg_template::retransTimer()
{
set_specific();
return single_value->field_retransTimer;
}

const INTEGER_template& RouterAdvertisementMsg_template::retransTimer() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field retransTimer of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
return single_value->field_retransTimer;
}

RtAdvOptions_template& RouterAdvertisementMsg_template::rtAdvOptions()
{
set_specific();
return single_value->field_rtAdvOptions;
}

const RtAdvOptions_template& RouterAdvertisementMsg_template::rtAdvOptions() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rtAdvOptions of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
return single_value->field_rtAdvOptions;
}

int RouterAdvertisementMsg_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 11;
      if (single_value->field_rtAdvOptions.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
  }
  return 0;
}

void RouterAdvertisementMsg_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ icmpType := ");
single_value->field_icmpType.log();
TTCN_Logger::log_event_str(", icmpCode := ");
single_value->field_icmpCode.log();
TTCN_Logger::log_event_str(", checksum := ");
single_value->field_checksum.log();
TTCN_Logger::log_event_str(", curHopLimit := ");
single_value->field_curHopLimit.log();
TTCN_Logger::log_event_str(", managedConfigFlag := ");
single_value->field_managedConfigFlag.log();
TTCN_Logger::log_event_str(", otherConfigFlag := ");
single_value->field_otherConfigFlag.log();
TTCN_Logger::log_event_str(", homeAgentFlag := ");
single_value->field_homeAgentFlag.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(", routerLifetime := ");
single_value->field_routerLifetime.log();
TTCN_Logger::log_event_str(", reachableTime := ");
single_value->field_reachableTime.log();
TTCN_Logger::log_event_str(", retransTimer := ");
single_value->field_retransTimer.log();
TTCN_Logger::log_event_str(", rtAdvOptions := ");
single_value->field_rtAdvOptions.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RouterAdvertisementMsg_template::log_match(const RouterAdvertisementMsg& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_icmpType.match(match_value.icmpType(), legacy)){
TTCN_Logger::log_logmatch_info(".icmpType");
single_value->field_icmpType.log_match(match_value.icmpType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_icmpCode.match(match_value.icmpCode(), legacy)){
TTCN_Logger::log_logmatch_info(".icmpCode");
single_value->field_icmpCode.log_match(match_value.icmpCode(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_checksum.match(match_value.checksum(), legacy)){
TTCN_Logger::log_logmatch_info(".checksum");
single_value->field_checksum.log_match(match_value.checksum(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_curHopLimit.match(match_value.curHopLimit(), legacy)){
TTCN_Logger::log_logmatch_info(".curHopLimit");
single_value->field_curHopLimit.log_match(match_value.curHopLimit(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_managedConfigFlag.match(match_value.managedConfigFlag(), legacy)){
TTCN_Logger::log_logmatch_info(".managedConfigFlag");
single_value->field_managedConfigFlag.log_match(match_value.managedConfigFlag(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_otherConfigFlag.match(match_value.otherConfigFlag(), legacy)){
TTCN_Logger::log_logmatch_info(".otherConfigFlag");
single_value->field_otherConfigFlag.log_match(match_value.otherConfigFlag(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_homeAgentFlag.match(match_value.homeAgentFlag(), legacy)){
TTCN_Logger::log_logmatch_info(".homeAgentFlag");
single_value->field_homeAgentFlag.log_match(match_value.homeAgentFlag(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_routerLifetime.match(match_value.routerLifetime(), legacy)){
TTCN_Logger::log_logmatch_info(".routerLifetime");
single_value->field_routerLifetime.log_match(match_value.routerLifetime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reachableTime.match(match_value.reachableTime(), legacy)){
TTCN_Logger::log_logmatch_info(".reachableTime");
single_value->field_reachableTime.log_match(match_value.reachableTime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_retransTimer.match(match_value.retransTimer(), legacy)){
TTCN_Logger::log_logmatch_info(".retransTimer");
single_value->field_retransTimer.log_match(match_value.retransTimer(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.rtAdvOptions().ispresent()){
if(!single_value->field_rtAdvOptions.match(match_value.rtAdvOptions(), legacy)){
TTCN_Logger::log_logmatch_info(".rtAdvOptions");
single_value->field_rtAdvOptions.log_match(match_value.rtAdvOptions(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_rtAdvOptions.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".rtAdvOptions := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_rtAdvOptions.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ icmpType := ");
single_value->field_icmpType.log_match(match_value.icmpType(), legacy);
TTCN_Logger::log_event_str(", icmpCode := ");
single_value->field_icmpCode.log_match(match_value.icmpCode(), legacy);
TTCN_Logger::log_event_str(", checksum := ");
single_value->field_checksum.log_match(match_value.checksum(), legacy);
TTCN_Logger::log_event_str(", curHopLimit := ");
single_value->field_curHopLimit.log_match(match_value.curHopLimit(), legacy);
TTCN_Logger::log_event_str(", managedConfigFlag := ");
single_value->field_managedConfigFlag.log_match(match_value.managedConfigFlag(), legacy);
TTCN_Logger::log_event_str(", otherConfigFlag := ");
single_value->field_otherConfigFlag.log_match(match_value.otherConfigFlag(), legacy);
TTCN_Logger::log_event_str(", homeAgentFlag := ");
single_value->field_homeAgentFlag.log_match(match_value.homeAgentFlag(), legacy);
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::log_event_str(", routerLifetime := ");
single_value->field_routerLifetime.log_match(match_value.routerLifetime(), legacy);
TTCN_Logger::log_event_str(", reachableTime := ");
single_value->field_reachableTime.log_match(match_value.reachableTime(), legacy);
TTCN_Logger::log_event_str(", retransTimer := ");
single_value->field_retransTimer.log_match(match_value.retransTimer(), legacy);
TTCN_Logger::log_event_str(", rtAdvOptions := ");
if (match_value.rtAdvOptions().ispresent()) single_value->field_rtAdvOptions.log_match(match_value.rtAdvOptions(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_rtAdvOptions.log();
if (single_value->field_rtAdvOptions.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RouterAdvertisementMsg_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_icmpType.encode_text(text_buf);
single_value->field_icmpCode.encode_text(text_buf);
single_value->field_checksum.encode_text(text_buf);
single_value->field_curHopLimit.encode_text(text_buf);
single_value->field_managedConfigFlag.encode_text(text_buf);
single_value->field_otherConfigFlag.encode_text(text_buf);
single_value->field_homeAgentFlag.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
single_value->field_routerLifetime.encode_text(text_buf);
single_value->field_reachableTime.encode_text(text_buf);
single_value->field_retransTimer.encode_text(text_buf);
single_value->field_rtAdvOptions.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
}
}

void RouterAdvertisementMsg_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_icmpType.decode_text(text_buf);
single_value->field_icmpCode.decode_text(text_buf);
single_value->field_checksum.decode_text(text_buf);
single_value->field_curHopLimit.decode_text(text_buf);
single_value->field_managedConfigFlag.decode_text(text_buf);
single_value->field_otherConfigFlag.decode_text(text_buf);
single_value->field_homeAgentFlag.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
single_value->field_routerLifetime.decode_text(text_buf);
single_value->field_reachableTime.decode_text(text_buf);
single_value->field_retransTimer.decode_text(text_buf);
single_value->field_rtAdvOptions.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RouterAdvertisementMsg_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg.");
}
}

void RouterAdvertisementMsg_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg'");
    }
    if (strcmp("icmpType", param_field) == 0) {
      icmpType().set_param(param);
      return;
    } else if (strcmp("icmpCode", param_field) == 0) {
      icmpCode().set_param(param);
      return;
    } else if (strcmp("checksum", param_field) == 0) {
      checksum().set_param(param);
      return;
    } else if (strcmp("curHopLimit", param_field) == 0) {
      curHopLimit().set_param(param);
      return;
    } else if (strcmp("managedConfigFlag", param_field) == 0) {
      managedConfigFlag().set_param(param);
      return;
    } else if (strcmp("otherConfigFlag", param_field) == 0) {
      otherConfigFlag().set_param(param);
      return;
    } else if (strcmp("homeAgentFlag", param_field) == 0) {
      homeAgentFlag().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("routerLifetime", param_field) == 0) {
      routerLifetime().set_param(param);
      return;
    } else if (strcmp("reachableTime", param_field) == 0) {
      reachableTime().set_param(param);
      return;
    } else if (strcmp("retransTimer", param_field) == 0) {
      retransTimer().set_param(param);
      return;
    } else if (strcmp("rtAdvOptions", param_field) == 0) {
      rtAdvOptions().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RouterAdvertisementMsg_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (12<mp->get_size()) {
      param.error("record template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg has 12 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) icmpType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) icmpCode().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) checksum().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) curHopLimit().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) managedConfigFlag().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) otherConfigFlag().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) homeAgentFlag().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) routerLifetime().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) reachableTime().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) retransTimer().set_param(*mp->get_elem(10));
    if (mp->get_size()>11 && mp->get_elem(11)->get_type()!=Module_Param::MP_NotUsed) rtAdvOptions().set_param(*mp->get_elem(11));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "icmpType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          icmpType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "icmpCode")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          icmpCode().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "checksum")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          checksum().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "curHopLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          curHopLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "managedConfigFlag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          managedConfigFlag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "otherConfigFlag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          otherConfigFlag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "homeAgentFlag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          homeAgentFlag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "routerLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          routerLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reachableTime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reachableTime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "retransTimer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          retransTimer().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rtAdvOptions")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rtAdvOptions().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RouterAdvertisementMsg_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg'");
    }
    if (strcmp("icmpType", param_field) == 0) {
      return icmpType().get_param(param_name);
    } else if (strcmp("icmpCode", param_field) == 0) {
      return icmpCode().get_param(param_name);
    } else if (strcmp("checksum", param_field) == 0) {
      return checksum().get_param(param_name);
    } else if (strcmp("curHopLimit", param_field) == 0) {
      return curHopLimit().get_param(param_name);
    } else if (strcmp("managedConfigFlag", param_field) == 0) {
      return managedConfigFlag().get_param(param_name);
    } else if (strcmp("otherConfigFlag", param_field) == 0) {
      return otherConfigFlag().get_param(param_name);
    } else if (strcmp("homeAgentFlag", param_field) == 0) {
      return homeAgentFlag().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("routerLifetime", param_field) == 0) {
      return routerLifetime().get_param(param_name);
    } else if (strcmp("reachableTime", param_field) == 0) {
      return reachableTime().get_param(param_name);
    } else if (strcmp("retransTimer", param_field) == 0) {
      return retransTimer().get_param(param_name);
    } else if (strcmp("rtAdvOptions", param_field) == 0) {
      return rtAdvOptions().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_icmpType = single_value->field_icmpType.get_param(param_name);
    mp_field_icmpType->set_id(new Module_Param_FieldName(mcopystr("icmpType")));
    mp->add_elem(mp_field_icmpType);
    Module_Param* mp_field_icmpCode = single_value->field_icmpCode.get_param(param_name);
    mp_field_icmpCode->set_id(new Module_Param_FieldName(mcopystr("icmpCode")));
    mp->add_elem(mp_field_icmpCode);
    Module_Param* mp_field_checksum = single_value->field_checksum.get_param(param_name);
    mp_field_checksum->set_id(new Module_Param_FieldName(mcopystr("checksum")));
    mp->add_elem(mp_field_checksum);
    Module_Param* mp_field_curHopLimit = single_value->field_curHopLimit.get_param(param_name);
    mp_field_curHopLimit->set_id(new Module_Param_FieldName(mcopystr("curHopLimit")));
    mp->add_elem(mp_field_curHopLimit);
    Module_Param* mp_field_managedConfigFlag = single_value->field_managedConfigFlag.get_param(param_name);
    mp_field_managedConfigFlag->set_id(new Module_Param_FieldName(mcopystr("managedConfigFlag")));
    mp->add_elem(mp_field_managedConfigFlag);
    Module_Param* mp_field_otherConfigFlag = single_value->field_otherConfigFlag.get_param(param_name);
    mp_field_otherConfigFlag->set_id(new Module_Param_FieldName(mcopystr("otherConfigFlag")));
    mp->add_elem(mp_field_otherConfigFlag);
    Module_Param* mp_field_homeAgentFlag = single_value->field_homeAgentFlag.get_param(param_name);
    mp_field_homeAgentFlag->set_id(new Module_Param_FieldName(mcopystr("homeAgentFlag")));
    mp->add_elem(mp_field_homeAgentFlag);
    Module_Param* mp_field_reserved = single_value->field_reserved.get_param(param_name);
    mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
    mp->add_elem(mp_field_reserved);
    Module_Param* mp_field_routerLifetime = single_value->field_routerLifetime.get_param(param_name);
    mp_field_routerLifetime->set_id(new Module_Param_FieldName(mcopystr("routerLifetime")));
    mp->add_elem(mp_field_routerLifetime);
    Module_Param* mp_field_reachableTime = single_value->field_reachableTime.get_param(param_name);
    mp_field_reachableTime->set_id(new Module_Param_FieldName(mcopystr("reachableTime")));
    mp->add_elem(mp_field_reachableTime);
    Module_Param* mp_field_retransTimer = single_value->field_retransTimer.get_param(param_name);
    mp_field_retransTimer->set_id(new Module_Param_FieldName(mcopystr("retransTimer")));
    mp->add_elem(mp_field_retransTimer);
    Module_Param* mp_field_rtAdvOptions = single_value->field_rtAdvOptions.get_param(param_name);
    mp_field_rtAdvOptions->set_id(new Module_Param_FieldName(mcopystr("rtAdvOptions")));
    mp->add_elem(mp_field_rtAdvOptions);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RouterAdvertisementMsg_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_icmpType.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg");
single_value->field_icmpCode.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg");
single_value->field_checksum.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg");
single_value->field_curHopLimit.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg");
single_value->field_managedConfigFlag.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg");
single_value->field_otherConfigFlag.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg");
single_value->field_homeAgentFlag.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg");
single_value->field_routerLifetime.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg");
single_value->field_reachableTime.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg");
single_value->field_retransTimer.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg");
single_value->field_rtAdvOptions.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.RouterAdvertisementMsg");
}

boolean RouterAdvertisementMsg_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RouterAdvertisementMsg_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

RtAdvOptions::RtAdvOptions()
{
  bound_flag = FALSE;
}

RtAdvOptions::RtAdvOptions(const OPTIONAL<SrcLinkLayerAddress>& par_srcLinkLayerAddr,
    const OPTIONAL<PrefixInfoList>& par_prefixInfoList,
    const OPTIONAL<OCTETSTRING>& par_otherOption)
  :   field_srcLinkLayerAddr(par_srcLinkLayerAddr),
  field_prefixInfoList(par_prefixInfoList),
  field_otherOption(par_otherOption)
{
  bound_flag = TRUE;
}

RtAdvOptions::RtAdvOptions(const RtAdvOptions& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.");
bound_flag = TRUE;
if (other_value.srcLinkLayerAddr().is_bound()) field_srcLinkLayerAddr = other_value.srcLinkLayerAddr();
else field_srcLinkLayerAddr.clean_up();
if (other_value.prefixInfoList().is_bound()) field_prefixInfoList = other_value.prefixInfoList();
else field_prefixInfoList.clean_up();
if (other_value.otherOption().is_bound()) field_otherOption = other_value.otherOption();
else field_otherOption.clean_up();
}

void RtAdvOptions::clean_up()
{
field_srcLinkLayerAddr.clean_up();
field_prefixInfoList.clean_up();
field_otherOption.clean_up();
bound_flag = FALSE;
}

RtAdvOptions& RtAdvOptions::operator=(const RtAdvOptions& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.");
  bound_flag = TRUE;
  if (other_value.srcLinkLayerAddr().is_bound()) field_srcLinkLayerAddr = other_value.srcLinkLayerAddr();
  else field_srcLinkLayerAddr.clean_up();
  if (other_value.prefixInfoList().is_bound()) field_prefixInfoList = other_value.prefixInfoList();
  else field_prefixInfoList.clean_up();
  if (other_value.otherOption().is_bound()) field_otherOption = other_value.otherOption();
  else field_otherOption.clean_up();
}
return *this;
}

boolean RtAdvOptions::operator==(const RtAdvOptions& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_srcLinkLayerAddr==other_value.field_srcLinkLayerAddr
  && field_prefixInfoList==other_value.field_prefixInfoList
  && field_otherOption==other_value.field_otherOption;
}

boolean RtAdvOptions::is_bound() const
{
if (bound_flag) return TRUE;
if(OPTIONAL_OMIT == field_srcLinkLayerAddr.get_selection() || field_srcLinkLayerAddr.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_prefixInfoList.get_selection() || field_prefixInfoList.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_otherOption.get_selection() || field_otherOption.is_bound()) return TRUE;
return FALSE;
}
boolean RtAdvOptions::is_value() const
{
if (!is_bound()) return FALSE;
if(OPTIONAL_OMIT != field_srcLinkLayerAddr.get_selection() && !field_srcLinkLayerAddr.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_prefixInfoList.get_selection() && !field_prefixInfoList.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_otherOption.get_selection() && !field_otherOption.is_value()) return FALSE;
return TRUE;
}
int RtAdvOptions::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions");
  int ret_val = 0;
  if (field_srcLinkLayerAddr.ispresent()) ret_val++;
  if (field_prefixInfoList.ispresent()) ret_val++;
  if (field_otherOption.ispresent()) ret_val++;
  return ret_val;
}

void RtAdvOptions::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ srcLinkLayerAddr := ");
field_srcLinkLayerAddr.log();
TTCN_Logger::log_event_str(", prefixInfoList := ");
field_prefixInfoList.log();
TTCN_Logger::log_event_str(", otherOption := ");
field_otherOption.log();
TTCN_Logger::log_event_str(" }");
}

void RtAdvOptions::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for set type `@LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions'");
    }
    if (strcmp("srcLinkLayerAddr", param_field) == 0) {
      srcLinkLayerAddr().set_param(param);
      return;
    } else if (strcmp("prefixInfoList", param_field) == 0) {
      prefixInfoList().set_param(param);
      return;
    } else if (strcmp("otherOption", param_field) == 0) {
      otherOption().set_param(param);
      return;
    } else param.error("Field `%s' not found in set type `@LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "set value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) srcLinkLayerAddr().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) prefixInfoList().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) otherOption().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcLinkLayerAddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcLinkLayerAddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "prefixInfoList")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          prefixInfoList().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "otherOption")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          otherOption().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("set value", "@LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions");
  }
}

Module_Param* RtAdvOptions::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for set type `@LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions'");
    }
    if (strcmp("srcLinkLayerAddr", param_field) == 0) {
      return srcLinkLayerAddr().get_param(param_name);
    } else if (strcmp("prefixInfoList", param_field) == 0) {
      return prefixInfoList().get_param(param_name);
    } else if (strcmp("otherOption", param_field) == 0) {
      return otherOption().get_param(param_name);
    } else TTCN_error("Field `%s' not found in set type `@LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_srcLinkLayerAddr = field_srcLinkLayerAddr.get_param(param_name);
  mp_field_srcLinkLayerAddr->set_id(new Module_Param_FieldName(mcopystr("srcLinkLayerAddr")));
  mp->add_elem(mp_field_srcLinkLayerAddr);
  Module_Param* mp_field_prefixInfoList = field_prefixInfoList.get_param(param_name);
  mp_field_prefixInfoList->set_id(new Module_Param_FieldName(mcopystr("prefixInfoList")));
  mp->add_elem(mp_field_prefixInfoList);
  Module_Param* mp_field_otherOption = field_otherOption.get_param(param_name);
  mp_field_otherOption->set_id(new Module_Param_FieldName(mcopystr("otherOption")));
  mp->add_elem(mp_field_otherOption);
  return mp;
  }

void RtAdvOptions::set_implicit_omit()
{
if (!srcLinkLayerAddr().is_bound()) srcLinkLayerAddr() = OMIT_VALUE;
else srcLinkLayerAddr().set_implicit_omit();
if (!prefixInfoList().is_bound()) prefixInfoList() = OMIT_VALUE;
else prefixInfoList().set_implicit_omit();
if (!otherOption().is_bound()) otherOption() = OMIT_VALUE;
else otherOption().set_implicit_omit();
}

void RtAdvOptions::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.");
field_srcLinkLayerAddr.encode_text(text_buf);
field_prefixInfoList.encode_text(text_buf);
field_otherOption.encode_text(text_buf);
}

void RtAdvOptions::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_srcLinkLayerAddr.decode_text(text_buf);
field_prefixInfoList.decode_text(text_buf);
field_otherOption.decode_text(text_buf);
}

void RtAdvOptions::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RtAdvOptions::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int RtAdvOptions::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean, int, boolean)
{
bound_flag = TRUE;
int prepaddlength = p_buf.increase_pos_padd(p_td.raw->prepadding);
limit -= prepaddlength;
int decoded_length = 0;
int field_map[3];
memset(field_map, 0, sizeof(field_map));
field_srcLinkLayerAddr = OMIT_VALUE;
field_prefixInfoList = OMIT_VALUE;
field_otherOption = OMIT_VALUE;
raw_order_t local_top_order;
if (p_td.raw->top_bit_order == TOP_BIT_INHERITED) local_top_order = top_bit_ord;
else if (p_td.raw->top_bit_order == TOP_BIT_RIGHT) local_top_order = ORDER_MSB;
else local_top_order = ORDER_LSB;
while (limit > 0) {
size_t fl_start_pos = p_buf.get_pos_bit();
if (field_map[0] == 0) {
int decoded_field_length = field_srcLinkLayerAddr().RAW_decode(SrcLinkLayerAddress_descr_, p_buf, limit, local_top_order, TRUE);
if (decoded_field_length > 0) {
decoded_length += decoded_field_length;
limit -= decoded_field_length;
field_map[0] = 1;
continue;
} else {
p_buf.set_pos_bit(fl_start_pos);
field_srcLinkLayerAddr = OMIT_VALUE;
}
}
if (field_map[1] == 0) {
int decoded_field_length = field_prefixInfoList().RAW_decode(PrefixInfoList_descr_, p_buf, limit, local_top_order, TRUE);
if (decoded_field_length > 0) {
decoded_length += decoded_field_length;
limit -= decoded_field_length;
field_map[1] = 1;
continue;
} else {
p_buf.set_pos_bit(fl_start_pos);
field_prefixInfoList = OMIT_VALUE;
}
}
if (field_map[2] == 0) {
int decoded_field_length = field_otherOption().RAW_decode(OCTETSTRING_descr_, p_buf, limit, local_top_order, TRUE);
if (decoded_field_length > 0) {
decoded_length += decoded_field_length;
limit -= decoded_field_length;
field_map[2] = 1;
continue;
} else {
p_buf.set_pos_bit(fl_start_pos);
field_otherOption = OMIT_VALUE;
}
}
break;
}
return decoded_length + prepaddlength + p_buf.increase_pos_padd(p_td.raw->padding);
}

int RtAdvOptions::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  if (field_srcLinkLayerAddr.ispresent()) {
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, SrcLinkLayerAddress_descr_.raw);
  }
  else myleaf.body.node.nodes[0] = NULL;
  if (field_prefixInfoList.ispresent()) {
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, PrefixInfoList_descr_.raw);
  }
  else myleaf.body.node.nodes[1] = NULL;
  if (field_otherOption.ispresent()) {
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, OCTETSTRING_descr_.raw);
  }
  else myleaf.body.node.nodes[2] = NULL;
  if (field_srcLinkLayerAddr.ispresent()) {
  encoded_length += field_srcLinkLayerAddr().RAW_encode(SrcLinkLayerAddress_descr_, *myleaf.body.node.nodes[0]);
  }
  if (field_prefixInfoList.ispresent()) {
  encoded_length += field_prefixInfoList().RAW_encode(PrefixInfoList_descr_, *myleaf.body.node.nodes[1]);
  }
  if (field_otherOption.ispresent()) {
  encoded_length += field_otherOption().RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[2]);
  }
  return myleaf.length = encoded_length;
}

int RtAdvOptions::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  if (field_srcLinkLayerAddr.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "srcLinkLayerAddr");
    enc_len += field_srcLinkLayerAddr.JSON_encode(SrcLinkLayerAddress_descr_, p_tok);
  }

  if (field_prefixInfoList.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "prefixInfoList");
    enc_len += field_prefixInfoList.JSON_encode(PrefixInfoList_descr_, p_tok);
  }

  if (field_otherOption.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "otherOption");
    enc_len += field_otherOption.JSON_encode(OCTETSTRING_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int RtAdvOptions::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (16 == name_len && 0 == strncmp(fld_name, "srcLinkLayerAddr", name_len)) {
         int ret_val = field_srcLinkLayerAddr.JSON_decode(SrcLinkLayerAddress_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "srcLinkLayerAddr");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "prefixInfoList", name_len)) {
         int ret_val = field_prefixInfoList.JSON_decode(PrefixInfoList_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "prefixInfoList");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "otherOption", name_len)) {
         int ret_val = field_otherOption.JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "otherOption");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_srcLinkLayerAddr.is_bound()) {
    field_srcLinkLayerAddr = OMIT_VALUE;
  }
if (!field_prefixInfoList.is_bound()) {
    field_prefixInfoList = OMIT_VALUE;
  }
if (!field_otherOption.is_bound()) {
    field_otherOption = OMIT_VALUE;
  }

  return dec_len;
}

struct RtAdvOptions_template::single_value_struct {
SrcLinkLayerAddress_template field_srcLinkLayerAddr;
PrefixInfoList_template field_prefixInfoList;
OCTETSTRING_template field_otherOption;
};

void RtAdvOptions_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_srcLinkLayerAddr = ANY_OR_OMIT;
single_value->field_prefixInfoList = ANY_OR_OMIT;
single_value->field_otherOption = ANY_OR_OMIT;
}
}
}

void RtAdvOptions_template::copy_value(const RtAdvOptions& other_value)
{
single_value = new single_value_struct;
if (other_value.srcLinkLayerAddr().is_bound()) {
  if (other_value.srcLinkLayerAddr().ispresent()) single_value->field_srcLinkLayerAddr = other_value.srcLinkLayerAddr()();
  else single_value->field_srcLinkLayerAddr = OMIT_VALUE;
} else {
  single_value->field_srcLinkLayerAddr.clean_up();
}
if (other_value.prefixInfoList().is_bound()) {
  if (other_value.prefixInfoList().ispresent()) single_value->field_prefixInfoList = other_value.prefixInfoList()();
  else single_value->field_prefixInfoList = OMIT_VALUE;
} else {
  single_value->field_prefixInfoList.clean_up();
}
if (other_value.otherOption().is_bound()) {
  if (other_value.otherOption().ispresent()) single_value->field_otherOption = other_value.otherOption()();
  else single_value->field_otherOption = OMIT_VALUE;
} else {
  single_value->field_otherOption.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void RtAdvOptions_template::copy_template(const RtAdvOptions_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.srcLinkLayerAddr().get_selection()) {
single_value->field_srcLinkLayerAddr = other_value.srcLinkLayerAddr();
} else {
single_value->field_srcLinkLayerAddr.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.prefixInfoList().get_selection()) {
single_value->field_prefixInfoList = other_value.prefixInfoList();
} else {
single_value->field_prefixInfoList.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.otherOption().get_selection()) {
single_value->field_otherOption = other_value.otherOption();
} else {
single_value->field_otherOption.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RtAdvOptions_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.");
break;
}
set_selection(other_value);
}

RtAdvOptions_template::RtAdvOptions_template()
{
}

RtAdvOptions_template::RtAdvOptions_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RtAdvOptions_template::RtAdvOptions_template(const RtAdvOptions& other_value)
{
copy_value(other_value);
}

RtAdvOptions_template::RtAdvOptions_template(const OPTIONAL<RtAdvOptions>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RtAdvOptions&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions from an unbound optional field.");
}
}

RtAdvOptions_template::RtAdvOptions_template(const RtAdvOptions_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

RtAdvOptions_template::~RtAdvOptions_template()
{
clean_up();
}

RtAdvOptions_template& RtAdvOptions_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RtAdvOptions_template& RtAdvOptions_template::operator=(const RtAdvOptions& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RtAdvOptions_template& RtAdvOptions_template::operator=(const OPTIONAL<RtAdvOptions>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RtAdvOptions&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.");
}
return *this;
}

RtAdvOptions_template& RtAdvOptions_template::operator=(const RtAdvOptions_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RtAdvOptions_template::match(const RtAdvOptions& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.srcLinkLayerAddr().is_bound()) return FALSE;
if((other_value.srcLinkLayerAddr().ispresent() ? !single_value->field_srcLinkLayerAddr.match((const SrcLinkLayerAddress&)other_value.srcLinkLayerAddr(), legacy) : !single_value->field_srcLinkLayerAddr.match_omit(legacy)))return FALSE;
if(!other_value.prefixInfoList().is_bound()) return FALSE;
if((other_value.prefixInfoList().ispresent() ? !single_value->field_prefixInfoList.match((const PrefixInfoList&)other_value.prefixInfoList(), legacy) : !single_value->field_prefixInfoList.match_omit(legacy)))return FALSE;
if(!other_value.otherOption().is_bound()) return FALSE;
if((other_value.otherOption().ispresent() ? !single_value->field_otherOption.match((const OCTETSTRING&)other_value.otherOption(), legacy) : !single_value->field_otherOption.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.");
}
return FALSE;
}

boolean RtAdvOptions_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_srcLinkLayerAddr.is_omit() || single_value->field_srcLinkLayerAddr.is_bound()) return TRUE;
if (single_value->field_prefixInfoList.is_omit() || single_value->field_prefixInfoList.is_bound()) return TRUE;
if (single_value->field_otherOption.is_omit() || single_value->field_otherOption.is_bound()) return TRUE;
return FALSE;
}

boolean RtAdvOptions_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_srcLinkLayerAddr.is_omit() && !single_value->field_srcLinkLayerAddr.is_value()) return FALSE;
if (!single_value->field_prefixInfoList.is_omit() && !single_value->field_prefixInfoList.is_value()) return FALSE;
if (!single_value->field_otherOption.is_omit() && !single_value->field_otherOption.is_value()) return FALSE;
return TRUE;
}

void RtAdvOptions_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RtAdvOptions RtAdvOptions_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.");
RtAdvOptions ret_val;
if (single_value->field_srcLinkLayerAddr.is_omit()) ret_val.srcLinkLayerAddr() = OMIT_VALUE;
else if (single_value->field_srcLinkLayerAddr.is_bound()) {
ret_val.srcLinkLayerAddr() = single_value->field_srcLinkLayerAddr.valueof();
}
if (single_value->field_prefixInfoList.is_omit()) ret_val.prefixInfoList() = OMIT_VALUE;
else if (single_value->field_prefixInfoList.is_bound()) {
ret_val.prefixInfoList() = single_value->field_prefixInfoList.valueof();
}
if (single_value->field_otherOption.is_omit()) ret_val.otherOption() = OMIT_VALUE;
else if (single_value->field_otherOption.is_bound()) {
ret_val.otherOption() = single_value->field_otherOption.valueof();
}
return ret_val;
}

void RtAdvOptions_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RtAdvOptions_template[list_length];
}

RtAdvOptions_template& RtAdvOptions_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.");
return value_list.list_value[list_index];
}

SrcLinkLayerAddress_template& RtAdvOptions_template::srcLinkLayerAddr()
{
set_specific();
return single_value->field_srcLinkLayerAddr;
}

const SrcLinkLayerAddress_template& RtAdvOptions_template::srcLinkLayerAddr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field srcLinkLayerAddr of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.");
return single_value->field_srcLinkLayerAddr;
}

PrefixInfoList_template& RtAdvOptions_template::prefixInfoList()
{
set_specific();
return single_value->field_prefixInfoList;
}

const PrefixInfoList_template& RtAdvOptions_template::prefixInfoList() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field prefixInfoList of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.");
return single_value->field_prefixInfoList;
}

OCTETSTRING_template& RtAdvOptions_template::otherOption()
{
set_specific();
return single_value->field_otherOption;
}

const OCTETSTRING_template& RtAdvOptions_template::otherOption() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field otherOption of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.");
return single_value->field_otherOption;
}

int RtAdvOptions_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 0;
      if (single_value->field_srcLinkLayerAddr.is_present()) ret_val++;
      if (single_value->field_prefixInfoList.is_present()) ret_val++;
      if (single_value->field_otherOption.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.");
  }
  return 0;
}

void RtAdvOptions_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ srcLinkLayerAddr := ");
single_value->field_srcLinkLayerAddr.log();
TTCN_Logger::log_event_str(", prefixInfoList := ");
single_value->field_prefixInfoList.log();
TTCN_Logger::log_event_str(", otherOption := ");
single_value->field_otherOption.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RtAdvOptions_template::log_match(const RtAdvOptions& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (match_value.srcLinkLayerAddr().ispresent()){
if(!single_value->field_srcLinkLayerAddr.match(match_value.srcLinkLayerAddr(), legacy)){
TTCN_Logger::log_logmatch_info(".srcLinkLayerAddr");
single_value->field_srcLinkLayerAddr.log_match(match_value.srcLinkLayerAddr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_srcLinkLayerAddr.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".srcLinkLayerAddr := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_srcLinkLayerAddr.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.prefixInfoList().ispresent()){
if(!single_value->field_prefixInfoList.match(match_value.prefixInfoList(), legacy)){
TTCN_Logger::log_logmatch_info(".prefixInfoList");
single_value->field_prefixInfoList.log_match(match_value.prefixInfoList(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_prefixInfoList.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".prefixInfoList := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_prefixInfoList.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.otherOption().ispresent()){
if(!single_value->field_otherOption.match(match_value.otherOption(), legacy)){
TTCN_Logger::log_logmatch_info(".otherOption");
single_value->field_otherOption.log_match(match_value.otherOption(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_otherOption.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".otherOption := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_otherOption.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ srcLinkLayerAddr := ");
if (match_value.srcLinkLayerAddr().ispresent()) single_value->field_srcLinkLayerAddr.log_match(match_value.srcLinkLayerAddr(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_srcLinkLayerAddr.log();
if (single_value->field_srcLinkLayerAddr.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", prefixInfoList := ");
if (match_value.prefixInfoList().ispresent()) single_value->field_prefixInfoList.log_match(match_value.prefixInfoList(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_prefixInfoList.log();
if (single_value->field_prefixInfoList.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", otherOption := ");
if (match_value.otherOption().ispresent()) single_value->field_otherOption.log_match(match_value.otherOption(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_otherOption.log();
if (single_value->field_otherOption.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RtAdvOptions_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_srcLinkLayerAddr.encode_text(text_buf);
single_value->field_prefixInfoList.encode_text(text_buf);
single_value->field_otherOption.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.");
}
}

void RtAdvOptions_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_srcLinkLayerAddr.decode_text(text_buf);
single_value->field_prefixInfoList.decode_text(text_buf);
single_value->field_otherOption.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RtAdvOptions_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions.");
}
}

void RtAdvOptions_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for set template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions'");
    }
    if (strcmp("srcLinkLayerAddr", param_field) == 0) {
      srcLinkLayerAddr().set_param(param);
      return;
    } else if (strcmp("prefixInfoList", param_field) == 0) {
      prefixInfoList().set_param(param);
      return;
    } else if (strcmp("otherOption", param_field) == 0) {
      otherOption().set_param(param);
      return;
    } else param.error("Field `%s' not found in set template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "set template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RtAdvOptions_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("set template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) srcLinkLayerAddr().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) prefixInfoList().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) otherOption().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "srcLinkLayerAddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          srcLinkLayerAddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "prefixInfoList")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          prefixInfoList().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "otherOption")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          otherOption().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("set template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RtAdvOptions_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for set template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions'");
    }
    if (strcmp("srcLinkLayerAddr", param_field) == 0) {
      return srcLinkLayerAddr().get_param(param_name);
    } else if (strcmp("prefixInfoList", param_field) == 0) {
      return prefixInfoList().get_param(param_name);
    } else if (strcmp("otherOption", param_field) == 0) {
      return otherOption().get_param(param_name);
    } else TTCN_error("Field `%s' not found in set type `@LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_srcLinkLayerAddr = single_value->field_srcLinkLayerAddr.get_param(param_name);
    mp_field_srcLinkLayerAddr->set_id(new Module_Param_FieldName(mcopystr("srcLinkLayerAddr")));
    mp->add_elem(mp_field_srcLinkLayerAddr);
    Module_Param* mp_field_prefixInfoList = single_value->field_prefixInfoList.get_param(param_name);
    mp_field_prefixInfoList->set_id(new Module_Param_FieldName(mcopystr("prefixInfoList")));
    mp->add_elem(mp_field_prefixInfoList);
    Module_Param* mp_field_otherOption = single_value->field_otherOption.get_param(param_name);
    mp_field_otherOption->set_id(new Module_Param_FieldName(mcopystr("otherOption")));
    mp->add_elem(mp_field_otherOption);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RtAdvOptions_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_srcLinkLayerAddr.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions");
single_value->field_prefixInfoList.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions");
single_value->field_otherOption.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.RtAdvOptions");
}

boolean RtAdvOptions_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RtAdvOptions_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SrcLinkLayerAddress::SrcLinkLayerAddress()
{
  bound_flag = FALSE;
}

SrcLinkLayerAddress::SrcLinkLayerAddress(const INTEGER& par_icmpType,
    const INTEGER& par_optionLength,
    const OCTETSTRING& par_linkLayerAddr)
  :   field_icmpType(par_icmpType),
  field_optionLength(par_optionLength),
  field_linkLayerAddr(par_linkLayerAddr)
{
  bound_flag = TRUE;
}

SrcLinkLayerAddress::SrcLinkLayerAddress(const SrcLinkLayerAddress& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.");
bound_flag = TRUE;
if (other_value.icmpType().is_bound()) field_icmpType = other_value.icmpType();
else field_icmpType.clean_up();
if (other_value.optionLength().is_bound()) field_optionLength = other_value.optionLength();
else field_optionLength.clean_up();
if (other_value.linkLayerAddr().is_bound()) field_linkLayerAddr = other_value.linkLayerAddr();
else field_linkLayerAddr.clean_up();
}

void SrcLinkLayerAddress::clean_up()
{
field_icmpType.clean_up();
field_optionLength.clean_up();
field_linkLayerAddr.clean_up();
bound_flag = FALSE;
}

SrcLinkLayerAddress& SrcLinkLayerAddress::operator=(const SrcLinkLayerAddress& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.");
  bound_flag = TRUE;
  if (other_value.icmpType().is_bound()) field_icmpType = other_value.icmpType();
  else field_icmpType.clean_up();
  if (other_value.optionLength().is_bound()) field_optionLength = other_value.optionLength();
  else field_optionLength.clean_up();
  if (other_value.linkLayerAddr().is_bound()) field_linkLayerAddr = other_value.linkLayerAddr();
  else field_linkLayerAddr.clean_up();
}
return *this;
}

boolean SrcLinkLayerAddress::operator==(const SrcLinkLayerAddress& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_icmpType==other_value.field_icmpType
  && field_optionLength==other_value.field_optionLength
  && field_linkLayerAddr==other_value.field_linkLayerAddr;
}

boolean SrcLinkLayerAddress::is_bound() const
{
if (bound_flag) return TRUE;
if(field_icmpType.is_bound()) return TRUE;
if(field_optionLength.is_bound()) return TRUE;
if(field_linkLayerAddr.is_bound()) return TRUE;
return FALSE;
}
boolean SrcLinkLayerAddress::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_icmpType.is_value()) return FALSE;
if(!field_optionLength.is_value()) return FALSE;
if(!field_linkLayerAddr.is_value()) return FALSE;
return TRUE;
}
int SrcLinkLayerAddress::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress");
  return 3;
}

void SrcLinkLayerAddress::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ icmpType := ");
field_icmpType.log();
TTCN_Logger::log_event_str(", optionLength := ");
field_optionLength.log();
TTCN_Logger::log_event_str(", linkLayerAddr := ");
field_linkLayerAddr.log();
TTCN_Logger::log_event_str(" }");
}

void SrcLinkLayerAddress::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress'");
    }
    if (strcmp("icmpType", param_field) == 0) {
      icmpType().set_param(param);
      return;
    } else if (strcmp("optionLength", param_field) == 0) {
      optionLength().set_param(param);
      return;
    } else if (strcmp("linkLayerAddr", param_field) == 0) {
      linkLayerAddr().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) icmpType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) optionLength().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) linkLayerAddr().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "icmpType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          icmpType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "optionLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          optionLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "linkLayerAddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          linkLayerAddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress");
  }
}

Module_Param* SrcLinkLayerAddress::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress'");
    }
    if (strcmp("icmpType", param_field) == 0) {
      return icmpType().get_param(param_name);
    } else if (strcmp("optionLength", param_field) == 0) {
      return optionLength().get_param(param_name);
    } else if (strcmp("linkLayerAddr", param_field) == 0) {
      return linkLayerAddr().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_icmpType = field_icmpType.get_param(param_name);
  mp_field_icmpType->set_id(new Module_Param_FieldName(mcopystr("icmpType")));
  mp->add_elem(mp_field_icmpType);
  Module_Param* mp_field_optionLength = field_optionLength.get_param(param_name);
  mp_field_optionLength->set_id(new Module_Param_FieldName(mcopystr("optionLength")));
  mp->add_elem(mp_field_optionLength);
  Module_Param* mp_field_linkLayerAddr = field_linkLayerAddr.get_param(param_name);
  mp_field_linkLayerAddr->set_id(new Module_Param_FieldName(mcopystr("linkLayerAddr")));
  mp->add_elem(mp_field_linkLayerAddr);
  return mp;
  }

void SrcLinkLayerAddress::set_implicit_omit()
{
if (icmpType().is_bound()) icmpType().set_implicit_omit();
if (optionLength().is_bound()) optionLength().set_implicit_omit();
if (linkLayerAddr().is_bound()) linkLayerAddr().set_implicit_omit();
}

void SrcLinkLayerAddress::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.");
field_icmpType.encode_text(text_buf);
field_optionLength.encode_text(text_buf);
field_linkLayerAddr.encode_text(text_buf);
}

void SrcLinkLayerAddress::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_icmpType.decode_text(text_buf);
field_optionLength.decode_text(text_buf);
field_linkLayerAddr.decode_text(text_buf);
}

void SrcLinkLayerAddress::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SrcLinkLayerAddress::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SrcLinkLayerAddress::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_icmpType.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_optionLength.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_linkLayerAddr.RAW_decode(LibCommon__DataStrings::Oct6to15_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int SrcLinkLayerAddress::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__DataStrings::Oct6to15_descr_.raw);
  encoded_length += field_icmpType.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_optionLength.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_linkLayerAddr.RAW_encode(LibCommon__DataStrings::Oct6to15_descr_, *myleaf.body.node.nodes[2]);
  return myleaf.length = encoded_length;
}

int SrcLinkLayerAddress::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "icmpType");
    enc_len += field_icmpType.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "optionLength");
    enc_len += field_optionLength.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "linkLayerAddr");
    enc_len += field_linkLayerAddr.JSON_encode(LibCommon__DataStrings::Oct6to15_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SrcLinkLayerAddress::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (8 == name_len && 0 == strncmp(fld_name, "icmpType", name_len)) {
         int ret_val = field_icmpType.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "icmpType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "optionLength", name_len)) {
         int ret_val = field_optionLength.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "optionLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "linkLayerAddr", name_len)) {
         int ret_val = field_linkLayerAddr.JSON_decode(LibCommon__DataStrings::Oct6to15_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "linkLayerAddr");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_icmpType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "icmpType");
    return JSON_ERROR_FATAL;
  }
if (!field_optionLength.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "optionLength");
    return JSON_ERROR_FATAL;
  }
if (!field_linkLayerAddr.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "linkLayerAddr");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct SrcLinkLayerAddress_template::single_value_struct {
INTEGER_template field_icmpType;
INTEGER_template field_optionLength;
OCTETSTRING_template field_linkLayerAddr;
};

void SrcLinkLayerAddress_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_icmpType = ANY_VALUE;
single_value->field_optionLength = ANY_VALUE;
single_value->field_linkLayerAddr = ANY_VALUE;
}
}
}

void SrcLinkLayerAddress_template::copy_value(const SrcLinkLayerAddress& other_value)
{
single_value = new single_value_struct;
if (other_value.icmpType().is_bound()) {
  single_value->field_icmpType = other_value.icmpType();
} else {
  single_value->field_icmpType.clean_up();
}
if (other_value.optionLength().is_bound()) {
  single_value->field_optionLength = other_value.optionLength();
} else {
  single_value->field_optionLength.clean_up();
}
if (other_value.linkLayerAddr().is_bound()) {
  single_value->field_linkLayerAddr = other_value.linkLayerAddr();
} else {
  single_value->field_linkLayerAddr.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SrcLinkLayerAddress_template::copy_template(const SrcLinkLayerAddress_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.icmpType().get_selection()) {
single_value->field_icmpType = other_value.icmpType();
} else {
single_value->field_icmpType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.optionLength().get_selection()) {
single_value->field_optionLength = other_value.optionLength();
} else {
single_value->field_optionLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.linkLayerAddr().get_selection()) {
single_value->field_linkLayerAddr = other_value.linkLayerAddr();
} else {
single_value->field_linkLayerAddr.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SrcLinkLayerAddress_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.");
break;
}
set_selection(other_value);
}

SrcLinkLayerAddress_template::SrcLinkLayerAddress_template()
{
}

SrcLinkLayerAddress_template::SrcLinkLayerAddress_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SrcLinkLayerAddress_template::SrcLinkLayerAddress_template(const SrcLinkLayerAddress& other_value)
{
copy_value(other_value);
}

SrcLinkLayerAddress_template::SrcLinkLayerAddress_template(const OPTIONAL<SrcLinkLayerAddress>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SrcLinkLayerAddress&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress from an unbound optional field.");
}
}

SrcLinkLayerAddress_template::SrcLinkLayerAddress_template(const SrcLinkLayerAddress_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SrcLinkLayerAddress_template::~SrcLinkLayerAddress_template()
{
clean_up();
}

SrcLinkLayerAddress_template& SrcLinkLayerAddress_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SrcLinkLayerAddress_template& SrcLinkLayerAddress_template::operator=(const SrcLinkLayerAddress& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SrcLinkLayerAddress_template& SrcLinkLayerAddress_template::operator=(const OPTIONAL<SrcLinkLayerAddress>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SrcLinkLayerAddress&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.");
}
return *this;
}

SrcLinkLayerAddress_template& SrcLinkLayerAddress_template::operator=(const SrcLinkLayerAddress_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SrcLinkLayerAddress_template::match(const SrcLinkLayerAddress& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.icmpType().is_bound()) return FALSE;
if(!single_value->field_icmpType.match(other_value.icmpType(), legacy))return FALSE;
if(!other_value.optionLength().is_bound()) return FALSE;
if(!single_value->field_optionLength.match(other_value.optionLength(), legacy))return FALSE;
if(!other_value.linkLayerAddr().is_bound()) return FALSE;
if(!single_value->field_linkLayerAddr.match(other_value.linkLayerAddr(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.");
}
return FALSE;
}

boolean SrcLinkLayerAddress_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_icmpType.is_bound()) return TRUE;
if (single_value->field_optionLength.is_bound()) return TRUE;
if (single_value->field_linkLayerAddr.is_bound()) return TRUE;
return FALSE;
}

boolean SrcLinkLayerAddress_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_icmpType.is_value()) return FALSE;
if (!single_value->field_optionLength.is_value()) return FALSE;
if (!single_value->field_linkLayerAddr.is_value()) return FALSE;
return TRUE;
}

void SrcLinkLayerAddress_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SrcLinkLayerAddress SrcLinkLayerAddress_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.");
SrcLinkLayerAddress ret_val;
if (single_value->field_icmpType.is_bound()) {
ret_val.icmpType() = single_value->field_icmpType.valueof();
}
if (single_value->field_optionLength.is_bound()) {
ret_val.optionLength() = single_value->field_optionLength.valueof();
}
if (single_value->field_linkLayerAddr.is_bound()) {
ret_val.linkLayerAddr() = single_value->field_linkLayerAddr.valueof();
}
return ret_val;
}

void SrcLinkLayerAddress_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SrcLinkLayerAddress_template[list_length];
}

SrcLinkLayerAddress_template& SrcLinkLayerAddress_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.");
return value_list.list_value[list_index];
}

INTEGER_template& SrcLinkLayerAddress_template::icmpType()
{
set_specific();
return single_value->field_icmpType;
}

const INTEGER_template& SrcLinkLayerAddress_template::icmpType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field icmpType of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.");
return single_value->field_icmpType;
}

INTEGER_template& SrcLinkLayerAddress_template::optionLength()
{
set_specific();
return single_value->field_optionLength;
}

const INTEGER_template& SrcLinkLayerAddress_template::optionLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field optionLength of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.");
return single_value->field_optionLength;
}

OCTETSTRING_template& SrcLinkLayerAddress_template::linkLayerAddr()
{
set_specific();
return single_value->field_linkLayerAddr;
}

const OCTETSTRING_template& SrcLinkLayerAddress_template::linkLayerAddr() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field linkLayerAddr of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.");
return single_value->field_linkLayerAddr;
}

int SrcLinkLayerAddress_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.");
  }
  return 0;
}

void SrcLinkLayerAddress_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ icmpType := ");
single_value->field_icmpType.log();
TTCN_Logger::log_event_str(", optionLength := ");
single_value->field_optionLength.log();
TTCN_Logger::log_event_str(", linkLayerAddr := ");
single_value->field_linkLayerAddr.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SrcLinkLayerAddress_template::log_match(const SrcLinkLayerAddress& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_icmpType.match(match_value.icmpType(), legacy)){
TTCN_Logger::log_logmatch_info(".icmpType");
single_value->field_icmpType.log_match(match_value.icmpType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_optionLength.match(match_value.optionLength(), legacy)){
TTCN_Logger::log_logmatch_info(".optionLength");
single_value->field_optionLength.log_match(match_value.optionLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_linkLayerAddr.match(match_value.linkLayerAddr(), legacy)){
TTCN_Logger::log_logmatch_info(".linkLayerAddr");
single_value->field_linkLayerAddr.log_match(match_value.linkLayerAddr(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ icmpType := ");
single_value->field_icmpType.log_match(match_value.icmpType(), legacy);
TTCN_Logger::log_event_str(", optionLength := ");
single_value->field_optionLength.log_match(match_value.optionLength(), legacy);
TTCN_Logger::log_event_str(", linkLayerAddr := ");
single_value->field_linkLayerAddr.log_match(match_value.linkLayerAddr(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SrcLinkLayerAddress_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_icmpType.encode_text(text_buf);
single_value->field_optionLength.encode_text(text_buf);
single_value->field_linkLayerAddr.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.");
}
}

void SrcLinkLayerAddress_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_icmpType.decode_text(text_buf);
single_value->field_optionLength.decode_text(text_buf);
single_value->field_linkLayerAddr.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SrcLinkLayerAddress_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress.");
}
}

void SrcLinkLayerAddress_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress'");
    }
    if (strcmp("icmpType", param_field) == 0) {
      icmpType().set_param(param);
      return;
    } else if (strcmp("optionLength", param_field) == 0) {
      optionLength().set_param(param);
      return;
    } else if (strcmp("linkLayerAddr", param_field) == 0) {
      linkLayerAddr().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SrcLinkLayerAddress_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) icmpType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) optionLength().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) linkLayerAddr().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "icmpType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          icmpType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "optionLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          optionLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "linkLayerAddr")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          linkLayerAddr().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SrcLinkLayerAddress_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress'");
    }
    if (strcmp("icmpType", param_field) == 0) {
      return icmpType().get_param(param_name);
    } else if (strcmp("optionLength", param_field) == 0) {
      return optionLength().get_param(param_name);
    } else if (strcmp("linkLayerAddr", param_field) == 0) {
      return linkLayerAddr().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_icmpType = single_value->field_icmpType.get_param(param_name);
    mp_field_icmpType->set_id(new Module_Param_FieldName(mcopystr("icmpType")));
    mp->add_elem(mp_field_icmpType);
    Module_Param* mp_field_optionLength = single_value->field_optionLength.get_param(param_name);
    mp_field_optionLength->set_id(new Module_Param_FieldName(mcopystr("optionLength")));
    mp->add_elem(mp_field_optionLength);
    Module_Param* mp_field_linkLayerAddr = single_value->field_linkLayerAddr.get_param(param_name);
    mp_field_linkLayerAddr->set_id(new Module_Param_FieldName(mcopystr("linkLayerAddr")));
    mp->add_elem(mp_field_linkLayerAddr);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SrcLinkLayerAddress_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_icmpType.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress");
single_value->field_optionLength.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress");
single_value->field_linkLayerAddr.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.SrcLinkLayerAddress");
}

boolean SrcLinkLayerAddress_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SrcLinkLayerAddress_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const PrefixInfo PrefixInfoList::UNBOUND_ELEM;
boolean PrefixInfoList::compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index)
{
if (((const PrefixInfoList*)left_ptr)->val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
if (((const PrefixInfoList*)right_ptr)->val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
if (((const PrefixInfoList*)left_ptr)->val_ptr->value_elements[left_index] != NULL){
if (((const PrefixInfoList*)right_ptr)->val_ptr->value_elements[right_index] != NULL){
return *((const PrefixInfoList*)left_ptr)->val_ptr->value_elements[left_index] == *((const PrefixInfoList*)right_ptr)->val_ptr->value_elements[right_index];
} else return FALSE;
} else {
return ((const PrefixInfoList*)right_ptr)->val_ptr->value_elements[right_index] == NULL;
}
}

PrefixInfoList::PrefixInfoList()
{
val_ptr = NULL;
}

PrefixInfoList::PrefixInfoList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

PrefixInfoList::PrefixInfoList(const PrefixInfoList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

PrefixInfoList::~PrefixInfoList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void PrefixInfoList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

PrefixInfoList& PrefixInfoList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

PrefixInfoList& PrefixInfoList::operator=(const PrefixInfoList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean PrefixInfoList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
return val_ptr->n_elements == 0 ;
}

boolean PrefixInfoList::operator==(const PrefixInfoList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
if (val_ptr == other_value.val_ptr) return TRUE;
return compare_set_of(this, val_ptr->n_elements, &other_value, (other_value.val_ptr)->n_elements, compare_function);
}

PrefixInfo& PrefixInfoList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (PrefixInfo**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new PrefixInfo(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new PrefixInfo;
}
return *val_ptr->value_elements[index_value];
}

PrefixInfo& PrefixInfoList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
return (*this)[(int)index_value];
}

const PrefixInfo& PrefixInfoList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const PrefixInfo& PrefixInfoList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
return (*this)[(int)index_value];
}

PrefixInfoList PrefixInfoList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

PrefixInfoList PrefixInfoList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

PrefixInfoList PrefixInfoList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

PrefixInfoList PrefixInfoList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
PrefixInfoList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new PrefixInfo(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

PrefixInfoList PrefixInfoList::operator+(const PrefixInfoList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
PrefixInfoList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new PrefixInfo(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new PrefixInfo(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

PrefixInfoList PrefixInfoList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList","element");
PrefixInfoList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new PrefixInfo(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

PrefixInfoList PrefixInfoList::replace(int index, int len, const PrefixInfoList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList","element");
PrefixInfoList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new PrefixInfo(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new PrefixInfo(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new PrefixInfo(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

PrefixInfoList PrefixInfoList::replace(int index, int len, const PrefixInfoList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void PrefixInfoList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (PrefixInfo**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new PrefixInfo(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (PrefixInfo**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (PrefixInfo**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean PrefixInfoList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int PrefixInfoList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
return val_ptr->n_elements;
}

int PrefixInfoList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void PrefixInfoList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void PrefixInfoList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set of type `@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "set of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("set of value", "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("set of value", "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* PrefixInfoList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of type `@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void PrefixInfoList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void PrefixInfoList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void PrefixInfoList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
val_ptr->value_elements = (PrefixInfo**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new PrefixInfo;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void PrefixInfoList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PrefixInfoList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PrefixInfoList::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int PrefixInfoList::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

int PrefixInfoList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int PrefixInfoList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    PrefixInfo* val = new PrefixInfo;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (PrefixInfo**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void PrefixInfoList_template::copy_value(const PrefixInfoList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (PrefixInfo_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new PrefixInfo_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new PrefixInfo_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void PrefixInfoList_template::copy_template(const PrefixInfoList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (PrefixInfo_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new PrefixInfo_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new PrefixInfo_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PrefixInfoList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = other_value.value_set.n_items;
value_set.set_items = new PrefixInfo_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count] = other_value.value_set.set_items[set_count];
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
break;
}
set_selection(other_value);
}

boolean PrefixInfoList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const PrefixInfoList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const PrefixInfoList*)value_ptr)[value_index], legacy);
else return ((const PrefixInfoList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

boolean PrefixInfoList_template::match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const PrefixInfoList_template*)template_ptr)->value_set.set_items[template_index].match((*(const PrefixInfoList*)value_ptr)[value_index], legacy);
else return ((const PrefixInfoList_template*)template_ptr)->value_set.set_items[template_index].is_any_or_omit();
}

void PrefixInfoList_template::log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy)
{
if (value_ptr != NULL && template_ptr != NULL)((const PrefixInfoList_template*)template_ptr)->single_value.value_elements[index_template]->log_match((*(const PrefixInfoList*)value_ptr)[index_value], legacy);
else if (value_ptr != NULL) (*(const PrefixInfoList*)value_ptr)[index_value].log();
else if (template_ptr != NULL) ((const PrefixInfoList_template*)template_ptr)->single_value.value_elements[index_template]->log();
}

PrefixInfoList_template::PrefixInfoList_template()
{
}

PrefixInfoList_template::PrefixInfoList_template(template_sel other_value)
 : Restricted_Length_Template(other_value)
{
check_single_selection(other_value);
}

PrefixInfoList_template::PrefixInfoList_template(null_type)
 : Restricted_Length_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

PrefixInfoList_template::PrefixInfoList_template(const PrefixInfoList& other_value)
{
copy_value(other_value);
}

PrefixInfoList_template::PrefixInfoList_template(const OPTIONAL<PrefixInfoList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PrefixInfoList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList from an unbound optional field.");
}
}

PrefixInfoList_template::PrefixInfoList_template(const PrefixInfoList_template& other_value)
 : Restricted_Length_Template()
{
copy_template(other_value);
}

PrefixInfoList_template::~PrefixInfoList_template()
{
clean_up();
}

void PrefixInfoList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
delete [] value_set.set_items;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PrefixInfoList_template& PrefixInfoList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PrefixInfoList_template& PrefixInfoList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

PrefixInfoList_template& PrefixInfoList_template::operator=(const PrefixInfoList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PrefixInfoList_template& PrefixInfoList_template::operator=(const OPTIONAL<PrefixInfoList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PrefixInfoList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
}
return *this;
}

PrefixInfoList_template& PrefixInfoList_template::operator=(const PrefixInfoList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

PrefixInfo_template& PrefixInfoList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
    break;
}
return *single_value.value_elements[index_value];
}

PrefixInfo_template& PrefixInfoList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
return (*this)[(int)index_value];
}

const PrefixInfo_template& PrefixInfoList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const PrefixInfo_template& PrefixInfoList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
return (*this)[(int)index_value];
}

void PrefixInfoList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (PrefixInfo_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new PrefixInfo_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new PrefixInfo_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (PrefixInfo_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int PrefixInfoList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int PrefixInfoList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case SUPERSET_MATCH:
case SUBSET_MATCH: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = value_set.n_items;
  if (!is_size) { while (elem_count>0 && !value_set.set_items[elem_count-1].is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (value_set.set_items[i].get_selection())
    {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
  if (template_selection==SUPERSET_MATCH) {
    has_any_or_none = TRUE;
   } else {
    int max_size = min_size;
    min_size = 0;
    if (!has_any_or_none) { // [0,max_size]
      switch (length_restriction_type) {
      case NO_LENGTH_RESTRICTION:
        if (max_size==0) return 0;
        TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList with no exact size.", op_name);
      case SINGLE_LENGTH_RESTRICTION:
        if (length_restriction.single_length<=max_size)
          return length_restriction.single_length;
        TTCN_error("Performing %sof() operation on an invalid template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList. The maximum size (%d) contradicts the length restriction (%d).", op_name, max_size, length_restriction.single_length);
      case RANGE_LENGTH_RESTRICTION:
        if (max_size==length_restriction.range_length.min_length) {
          return max_size;
        } else if (max_size>length_restriction.range_length.min_length){
          TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList with no exact size.", op_name);
        } else
          TTCN_error("Performing %sof() operation on an invalid template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList. Maximum size (%d) contradicts the length restriction (%d..%d).", op_name, max_size, length_restriction.range_length.min_length, length_restriction.range_length.max_length);
      default:
        TTCN_error("Internal error: Template has invalid length restriction type.");
      }
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList");
}

boolean PrefixInfoList_template::match(const PrefixInfoList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_set_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case SUPERSET_MATCH:
case SUBSET_MATCH:
return match_set_of(&other_value, value_length, this, value_set.n_items, match_function_set, legacy);
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
}
return FALSE;
}

boolean PrefixInfoList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

PrefixInfoList PrefixInfoList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
PrefixInfoList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

PrefixInfoList PrefixInfoList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

PrefixInfoList PrefixInfoList_template::replace(int index, int len, const PrefixInfoList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

PrefixInfoList PrefixInfoList_template::replace(int index, int len, const PrefixInfoList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void PrefixInfoList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new PrefixInfoList_template[list_length];
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = list_length;
value_set.set_items = new PrefixInfo_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
}
set_selection(template_type);
}

PrefixInfoList_template& PrefixInfoList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
return value_list.list_value[list_index];
}

PrefixInfo_template& PrefixInfoList_template::set_item(unsigned int set_index)
{
if (template_selection != SUPERSET_MATCH && template_selection != SUBSET_MATCH) TTCN_error("Internal error: Accessing a set element of a non-set template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
if (set_index >= value_set.n_items) TTCN_error("Internal error: Index overflow in a set template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
return value_set.set_items[set_index];
}

void PrefixInfoList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log();
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
TTCN_Logger::log_event("%s(", template_selection == SUPERSET_MATCH ? "superset" : "subset");
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++) {
if (set_count > 0) TTCN_Logger::log_event_str(", ");
value_set.set_items[set_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void PrefixInfoList_template::log_match(const PrefixInfoList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (template_selection == SPECIFIC_VALUE)
  log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
else{
if(previous_size != 0){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::set_logmatch_buffer_len(previous_size);
TTCN_Logger::log_event_str(":=");
}
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
return;
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else {
TTCN_Logger::log_event_str(" unmatched");
if (template_selection == SPECIFIC_VALUE) log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
}
}

void PrefixInfoList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
text_buf.push_int(value_set.n_items);
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
}
}

void PrefixInfoList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
single_value.value_elements = (PrefixInfo_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new PrefixInfo_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PrefixInfoList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = text_buf.pull_int().get_val();
value_set.set_items = new PrefixInfo_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
}
}

boolean PrefixInfoList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PrefixInfoList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PrefixInfoList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "set of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PrefixInfoList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    set_size(mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      if (mp->get_elem(p_i)->get_type()!=Module_Param::MP_NotUsed) {
        (*this)[p_i].set_param(*mp->get_elem(p_i));
      }
    }
    break;
  case Module_Param::MP_Superset_Template:
  case Module_Param::MP_Subset_Template:
    set_type(mp->get_type()==Module_Param::MP_Superset_Template ? SUPERSET_MATCH : SUBSET_MATCH, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      set_item(p_i).set_param(*mp->get_elem(p_i));
    }
    break;
  default:
    param.type_error("set of template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* PrefixInfoList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void PrefixInfoList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList");
}

PrefixInfo::PrefixInfo()
{
  bound_flag = FALSE;
}

PrefixInfo::PrefixInfo(const INTEGER& par_icmpType,
    const INTEGER& par_optionLength,
    const INTEGER& par_prefixLength,
    const INTEGER& par_linkFlag,
    const INTEGER& par_autoConfigFlag,
    const INTEGER& par_rtAddrFlag,
    const INTEGER& par_reserved1,
    const INTEGER& par_validLifetime,
    const INTEGER& par_preferredLifetime,
    const INTEGER& par_reserved2,
    const OCTETSTRING& par_prefix)
  :   field_icmpType(par_icmpType),
  field_optionLength(par_optionLength),
  field_prefixLength(par_prefixLength),
  field_linkFlag(par_linkFlag),
  field_autoConfigFlag(par_autoConfigFlag),
  field_rtAddrFlag(par_rtAddrFlag),
  field_reserved1(par_reserved1),
  field_validLifetime(par_validLifetime),
  field_preferredLifetime(par_preferredLifetime),
  field_reserved2(par_reserved2),
  field_prefix(par_prefix)
{
  bound_flag = TRUE;
}

PrefixInfo::PrefixInfo(const PrefixInfo& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
bound_flag = TRUE;
if (other_value.icmpType().is_bound()) field_icmpType = other_value.icmpType();
else field_icmpType.clean_up();
if (other_value.optionLength().is_bound()) field_optionLength = other_value.optionLength();
else field_optionLength.clean_up();
if (other_value.prefixLength().is_bound()) field_prefixLength = other_value.prefixLength();
else field_prefixLength.clean_up();
if (other_value.linkFlag().is_bound()) field_linkFlag = other_value.linkFlag();
else field_linkFlag.clean_up();
if (other_value.autoConfigFlag().is_bound()) field_autoConfigFlag = other_value.autoConfigFlag();
else field_autoConfigFlag.clean_up();
if (other_value.rtAddrFlag().is_bound()) field_rtAddrFlag = other_value.rtAddrFlag();
else field_rtAddrFlag.clean_up();
if (other_value.reserved1().is_bound()) field_reserved1 = other_value.reserved1();
else field_reserved1.clean_up();
if (other_value.validLifetime().is_bound()) field_validLifetime = other_value.validLifetime();
else field_validLifetime.clean_up();
if (other_value.preferredLifetime().is_bound()) field_preferredLifetime = other_value.preferredLifetime();
else field_preferredLifetime.clean_up();
if (other_value.reserved2().is_bound()) field_reserved2 = other_value.reserved2();
else field_reserved2.clean_up();
if (other_value.prefix().is_bound()) field_prefix = other_value.prefix();
else field_prefix.clean_up();
}

void PrefixInfo::clean_up()
{
field_icmpType.clean_up();
field_optionLength.clean_up();
field_prefixLength.clean_up();
field_linkFlag.clean_up();
field_autoConfigFlag.clean_up();
field_rtAddrFlag.clean_up();
field_reserved1.clean_up();
field_validLifetime.clean_up();
field_preferredLifetime.clean_up();
field_reserved2.clean_up();
field_prefix.clean_up();
bound_flag = FALSE;
}

PrefixInfo& PrefixInfo::operator=(const PrefixInfo& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
  bound_flag = TRUE;
  if (other_value.icmpType().is_bound()) field_icmpType = other_value.icmpType();
  else field_icmpType.clean_up();
  if (other_value.optionLength().is_bound()) field_optionLength = other_value.optionLength();
  else field_optionLength.clean_up();
  if (other_value.prefixLength().is_bound()) field_prefixLength = other_value.prefixLength();
  else field_prefixLength.clean_up();
  if (other_value.linkFlag().is_bound()) field_linkFlag = other_value.linkFlag();
  else field_linkFlag.clean_up();
  if (other_value.autoConfigFlag().is_bound()) field_autoConfigFlag = other_value.autoConfigFlag();
  else field_autoConfigFlag.clean_up();
  if (other_value.rtAddrFlag().is_bound()) field_rtAddrFlag = other_value.rtAddrFlag();
  else field_rtAddrFlag.clean_up();
  if (other_value.reserved1().is_bound()) field_reserved1 = other_value.reserved1();
  else field_reserved1.clean_up();
  if (other_value.validLifetime().is_bound()) field_validLifetime = other_value.validLifetime();
  else field_validLifetime.clean_up();
  if (other_value.preferredLifetime().is_bound()) field_preferredLifetime = other_value.preferredLifetime();
  else field_preferredLifetime.clean_up();
  if (other_value.reserved2().is_bound()) field_reserved2 = other_value.reserved2();
  else field_reserved2.clean_up();
  if (other_value.prefix().is_bound()) field_prefix = other_value.prefix();
  else field_prefix.clean_up();
}
return *this;
}

boolean PrefixInfo::operator==(const PrefixInfo& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_icmpType==other_value.field_icmpType
  && field_optionLength==other_value.field_optionLength
  && field_prefixLength==other_value.field_prefixLength
  && field_linkFlag==other_value.field_linkFlag
  && field_autoConfigFlag==other_value.field_autoConfigFlag
  && field_rtAddrFlag==other_value.field_rtAddrFlag
  && field_reserved1==other_value.field_reserved1
  && field_validLifetime==other_value.field_validLifetime
  && field_preferredLifetime==other_value.field_preferredLifetime
  && field_reserved2==other_value.field_reserved2
  && field_prefix==other_value.field_prefix;
}

boolean PrefixInfo::is_bound() const
{
if (bound_flag) return TRUE;
if(field_icmpType.is_bound()) return TRUE;
if(field_optionLength.is_bound()) return TRUE;
if(field_prefixLength.is_bound()) return TRUE;
if(field_linkFlag.is_bound()) return TRUE;
if(field_autoConfigFlag.is_bound()) return TRUE;
if(field_rtAddrFlag.is_bound()) return TRUE;
if(field_reserved1.is_bound()) return TRUE;
if(field_validLifetime.is_bound()) return TRUE;
if(field_preferredLifetime.is_bound()) return TRUE;
if(field_reserved2.is_bound()) return TRUE;
if(field_prefix.is_bound()) return TRUE;
return FALSE;
}
boolean PrefixInfo::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_icmpType.is_value()) return FALSE;
if(!field_optionLength.is_value()) return FALSE;
if(!field_prefixLength.is_value()) return FALSE;
if(!field_linkFlag.is_value()) return FALSE;
if(!field_autoConfigFlag.is_value()) return FALSE;
if(!field_rtAddrFlag.is_value()) return FALSE;
if(!field_reserved1.is_value()) return FALSE;
if(!field_validLifetime.is_value()) return FALSE;
if(!field_preferredLifetime.is_value()) return FALSE;
if(!field_reserved2.is_value()) return FALSE;
if(!field_prefix.is_value()) return FALSE;
return TRUE;
}
int PrefixInfo::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo");
  return 11;
}

void PrefixInfo::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ icmpType := ");
field_icmpType.log();
TTCN_Logger::log_event_str(", optionLength := ");
field_optionLength.log();
TTCN_Logger::log_event_str(", prefixLength := ");
field_prefixLength.log();
TTCN_Logger::log_event_str(", linkFlag := ");
field_linkFlag.log();
TTCN_Logger::log_event_str(", autoConfigFlag := ");
field_autoConfigFlag.log();
TTCN_Logger::log_event_str(", rtAddrFlag := ");
field_rtAddrFlag.log();
TTCN_Logger::log_event_str(", reserved1 := ");
field_reserved1.log();
TTCN_Logger::log_event_str(", validLifetime := ");
field_validLifetime.log();
TTCN_Logger::log_event_str(", preferredLifetime := ");
field_preferredLifetime.log();
TTCN_Logger::log_event_str(", reserved2 := ");
field_reserved2.log();
TTCN_Logger::log_event_str(", prefix := ");
field_prefix.log();
TTCN_Logger::log_event_str(" }");
}

void PrefixInfo::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo'");
    }
    if (strcmp("icmpType", param_field) == 0) {
      icmpType().set_param(param);
      return;
    } else if (strcmp("optionLength", param_field) == 0) {
      optionLength().set_param(param);
      return;
    } else if (strcmp("prefixLength", param_field) == 0) {
      prefixLength().set_param(param);
      return;
    } else if (strcmp("linkFlag", param_field) == 0) {
      linkFlag().set_param(param);
      return;
    } else if (strcmp("autoConfigFlag", param_field) == 0) {
      autoConfigFlag().set_param(param);
      return;
    } else if (strcmp("rtAddrFlag", param_field) == 0) {
      rtAddrFlag().set_param(param);
      return;
    } else if (strcmp("reserved1", param_field) == 0) {
      reserved1().set_param(param);
      return;
    } else if (strcmp("validLifetime", param_field) == 0) {
      validLifetime().set_param(param);
      return;
    } else if (strcmp("preferredLifetime", param_field) == 0) {
      preferredLifetime().set_param(param);
      return;
    } else if (strcmp("reserved2", param_field) == 0) {
      reserved2().set_param(param);
      return;
    } else if (strcmp("prefix", param_field) == 0) {
      prefix().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (11<mp->get_size()) {
      param.error("record value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo has 11 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) icmpType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) optionLength().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) prefixLength().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) linkFlag().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) autoConfigFlag().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) rtAddrFlag().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) reserved1().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) validLifetime().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) preferredLifetime().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) reserved2().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) prefix().set_param(*mp->get_elem(10));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "icmpType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          icmpType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "optionLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          optionLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "prefixLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          prefixLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "linkFlag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          linkFlag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "autoConfigFlag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          autoConfigFlag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rtAddrFlag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rtAddrFlag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved1")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved1().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "validLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          validLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "preferredLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          preferredLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved2().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "prefix")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          prefix().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo");
  }
}

Module_Param* PrefixInfo::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo'");
    }
    if (strcmp("icmpType", param_field) == 0) {
      return icmpType().get_param(param_name);
    } else if (strcmp("optionLength", param_field) == 0) {
      return optionLength().get_param(param_name);
    } else if (strcmp("prefixLength", param_field) == 0) {
      return prefixLength().get_param(param_name);
    } else if (strcmp("linkFlag", param_field) == 0) {
      return linkFlag().get_param(param_name);
    } else if (strcmp("autoConfigFlag", param_field) == 0) {
      return autoConfigFlag().get_param(param_name);
    } else if (strcmp("rtAddrFlag", param_field) == 0) {
      return rtAddrFlag().get_param(param_name);
    } else if (strcmp("reserved1", param_field) == 0) {
      return reserved1().get_param(param_name);
    } else if (strcmp("validLifetime", param_field) == 0) {
      return validLifetime().get_param(param_name);
    } else if (strcmp("preferredLifetime", param_field) == 0) {
      return preferredLifetime().get_param(param_name);
    } else if (strcmp("reserved2", param_field) == 0) {
      return reserved2().get_param(param_name);
    } else if (strcmp("prefix", param_field) == 0) {
      return prefix().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_icmpType = field_icmpType.get_param(param_name);
  mp_field_icmpType->set_id(new Module_Param_FieldName(mcopystr("icmpType")));
  mp->add_elem(mp_field_icmpType);
  Module_Param* mp_field_optionLength = field_optionLength.get_param(param_name);
  mp_field_optionLength->set_id(new Module_Param_FieldName(mcopystr("optionLength")));
  mp->add_elem(mp_field_optionLength);
  Module_Param* mp_field_prefixLength = field_prefixLength.get_param(param_name);
  mp_field_prefixLength->set_id(new Module_Param_FieldName(mcopystr("prefixLength")));
  mp->add_elem(mp_field_prefixLength);
  Module_Param* mp_field_linkFlag = field_linkFlag.get_param(param_name);
  mp_field_linkFlag->set_id(new Module_Param_FieldName(mcopystr("linkFlag")));
  mp->add_elem(mp_field_linkFlag);
  Module_Param* mp_field_autoConfigFlag = field_autoConfigFlag.get_param(param_name);
  mp_field_autoConfigFlag->set_id(new Module_Param_FieldName(mcopystr("autoConfigFlag")));
  mp->add_elem(mp_field_autoConfigFlag);
  Module_Param* mp_field_rtAddrFlag = field_rtAddrFlag.get_param(param_name);
  mp_field_rtAddrFlag->set_id(new Module_Param_FieldName(mcopystr("rtAddrFlag")));
  mp->add_elem(mp_field_rtAddrFlag);
  Module_Param* mp_field_reserved1 = field_reserved1.get_param(param_name);
  mp_field_reserved1->set_id(new Module_Param_FieldName(mcopystr("reserved1")));
  mp->add_elem(mp_field_reserved1);
  Module_Param* mp_field_validLifetime = field_validLifetime.get_param(param_name);
  mp_field_validLifetime->set_id(new Module_Param_FieldName(mcopystr("validLifetime")));
  mp->add_elem(mp_field_validLifetime);
  Module_Param* mp_field_preferredLifetime = field_preferredLifetime.get_param(param_name);
  mp_field_preferredLifetime->set_id(new Module_Param_FieldName(mcopystr("preferredLifetime")));
  mp->add_elem(mp_field_preferredLifetime);
  Module_Param* mp_field_reserved2 = field_reserved2.get_param(param_name);
  mp_field_reserved2->set_id(new Module_Param_FieldName(mcopystr("reserved2")));
  mp->add_elem(mp_field_reserved2);
  Module_Param* mp_field_prefix = field_prefix.get_param(param_name);
  mp_field_prefix->set_id(new Module_Param_FieldName(mcopystr("prefix")));
  mp->add_elem(mp_field_prefix);
  return mp;
  }

void PrefixInfo::set_implicit_omit()
{
if (icmpType().is_bound()) icmpType().set_implicit_omit();
if (optionLength().is_bound()) optionLength().set_implicit_omit();
if (prefixLength().is_bound()) prefixLength().set_implicit_omit();
if (linkFlag().is_bound()) linkFlag().set_implicit_omit();
if (autoConfigFlag().is_bound()) autoConfigFlag().set_implicit_omit();
if (rtAddrFlag().is_bound()) rtAddrFlag().set_implicit_omit();
if (reserved1().is_bound()) reserved1().set_implicit_omit();
if (validLifetime().is_bound()) validLifetime().set_implicit_omit();
if (preferredLifetime().is_bound()) preferredLifetime().set_implicit_omit();
if (reserved2().is_bound()) reserved2().set_implicit_omit();
if (prefix().is_bound()) prefix().set_implicit_omit();
}

void PrefixInfo::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
field_icmpType.encode_text(text_buf);
field_optionLength.encode_text(text_buf);
field_prefixLength.encode_text(text_buf);
field_linkFlag.encode_text(text_buf);
field_autoConfigFlag.encode_text(text_buf);
field_rtAddrFlag.encode_text(text_buf);
field_reserved1.encode_text(text_buf);
field_validLifetime.encode_text(text_buf);
field_preferredLifetime.encode_text(text_buf);
field_reserved2.encode_text(text_buf);
field_prefix.encode_text(text_buf);
}

void PrefixInfo::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_icmpType.decode_text(text_buf);
field_optionLength.decode_text(text_buf);
field_prefixLength.decode_text(text_buf);
field_linkFlag.decode_text(text_buf);
field_autoConfigFlag.decode_text(text_buf);
field_rtAddrFlag.decode_text(text_buf);
field_reserved1.decode_text(text_buf);
field_validLifetime.decode_text(text_buf);
field_preferredLifetime.decode_text(text_buf);
field_reserved2.decode_text(text_buf);
field_prefix.decode_text(text_buf);
}

void PrefixInfo::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PrefixInfo::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PrefixInfo::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_icmpType.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_optionLength.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_prefixLength.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_linkFlag.RAW_decode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_autoConfigFlag.RAW_decode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_rtAddrFlag.RAW_decode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved1.RAW_decode(LibCommon__BasicTypesAndValues::UInt5_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_validLifetime.RAW_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_preferredLifetime.RAW_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved2.RAW_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_prefix.RAW_decode(Prefix_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int PrefixInfo::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 11;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(11);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, LibCommon__BasicTypesAndValues::UInt1_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, LibCommon__BasicTypesAndValues::UInt1_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, LibCommon__BasicTypesAndValues::UInt1_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, LibCommon__BasicTypesAndValues::UInt5_descr_.raw);
  myleaf.body.node.nodes[7] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 7, LibCommon__BasicTypesAndValues::UInt32_descr_.raw);
  myleaf.body.node.nodes[8] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 8, LibCommon__BasicTypesAndValues::UInt32_descr_.raw);
  myleaf.body.node.nodes[9] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 9, LibCommon__BasicTypesAndValues::UInt32_descr_.raw);
  myleaf.body.node.nodes[10] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 10, Prefix_descr_.raw);
  encoded_length += field_icmpType.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_optionLength.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_prefixLength.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_linkFlag.RAW_encode(LibCommon__BasicTypesAndValues::UInt1_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_autoConfigFlag.RAW_encode(LibCommon__BasicTypesAndValues::UInt1_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_rtAddrFlag.RAW_encode(LibCommon__BasicTypesAndValues::UInt1_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_reserved1.RAW_encode(LibCommon__BasicTypesAndValues::UInt5_descr_, *myleaf.body.node.nodes[6]);
  encoded_length += field_validLifetime.RAW_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, *myleaf.body.node.nodes[7]);
  encoded_length += field_preferredLifetime.RAW_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, *myleaf.body.node.nodes[8]);
  encoded_length += field_reserved2.RAW_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, *myleaf.body.node.nodes[9]);
  encoded_length += field_prefix.RAW_encode(Prefix_descr_, *myleaf.body.node.nodes[10]);
  return myleaf.length = encoded_length;
}

int PrefixInfo::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "icmpType");
    enc_len += field_icmpType.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "optionLength");
    enc_len += field_optionLength.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "prefixLength");
    enc_len += field_prefixLength.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "linkFlag");
    enc_len += field_linkFlag.JSON_encode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "autoConfigFlag");
    enc_len += field_autoConfigFlag.JSON_encode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "rtAddrFlag");
    enc_len += field_rtAddrFlag.JSON_encode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved1");
    enc_len += field_reserved1.JSON_encode(LibCommon__BasicTypesAndValues::UInt5_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "validLifetime");
    enc_len += field_validLifetime.JSON_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "preferredLifetime");
    enc_len += field_preferredLifetime.JSON_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved2");
    enc_len += field_reserved2.JSON_encode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "prefix");
    enc_len += field_prefix.JSON_encode(Prefix_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int PrefixInfo::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (8 == name_len && 0 == strncmp(fld_name, "icmpType", name_len)) {
         int ret_val = field_icmpType.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "icmpType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "optionLength", name_len)) {
         int ret_val = field_optionLength.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "optionLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "prefixLength", name_len)) {
         int ret_val = field_prefixLength.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "prefixLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "linkFlag", name_len)) {
         int ret_val = field_linkFlag.JSON_decode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "linkFlag");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "autoConfigFlag", name_len)) {
         int ret_val = field_autoConfigFlag.JSON_decode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "autoConfigFlag");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "rtAddrFlag", name_len)) {
         int ret_val = field_rtAddrFlag.JSON_decode(LibCommon__BasicTypesAndValues::UInt1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "rtAddrFlag");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "reserved1", name_len)) {
         int ret_val = field_reserved1.JSON_decode(LibCommon__BasicTypesAndValues::UInt5_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved1");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "validLifetime", name_len)) {
         int ret_val = field_validLifetime.JSON_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "validLifetime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "preferredLifetime", name_len)) {
         int ret_val = field_preferredLifetime.JSON_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "preferredLifetime");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "reserved2", name_len)) {
         int ret_val = field_reserved2.JSON_decode(LibCommon__BasicTypesAndValues::UInt32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved2");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "prefix", name_len)) {
         int ret_val = field_prefix.JSON_decode(Prefix_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "prefix");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_icmpType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "icmpType");
    return JSON_ERROR_FATAL;
  }
if (!field_optionLength.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "optionLength");
    return JSON_ERROR_FATAL;
  }
if (!field_prefixLength.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "prefixLength");
    return JSON_ERROR_FATAL;
  }
if (!field_linkFlag.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "linkFlag");
    return JSON_ERROR_FATAL;
  }
if (!field_autoConfigFlag.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "autoConfigFlag");
    return JSON_ERROR_FATAL;
  }
if (!field_rtAddrFlag.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "rtAddrFlag");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved1.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved1");
    return JSON_ERROR_FATAL;
  }
if (!field_validLifetime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "validLifetime");
    return JSON_ERROR_FATAL;
  }
if (!field_preferredLifetime.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "preferredLifetime");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved2.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved2");
    return JSON_ERROR_FATAL;
  }
if (!field_prefix.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "prefix");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct PrefixInfo_template::single_value_struct {
INTEGER_template field_icmpType;
INTEGER_template field_optionLength;
INTEGER_template field_prefixLength;
INTEGER_template field_linkFlag;
INTEGER_template field_autoConfigFlag;
INTEGER_template field_rtAddrFlag;
INTEGER_template field_reserved1;
INTEGER_template field_validLifetime;
INTEGER_template field_preferredLifetime;
INTEGER_template field_reserved2;
OCTETSTRING_template field_prefix;
};

void PrefixInfo_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_icmpType = ANY_VALUE;
single_value->field_optionLength = ANY_VALUE;
single_value->field_prefixLength = ANY_VALUE;
single_value->field_linkFlag = ANY_VALUE;
single_value->field_autoConfigFlag = ANY_VALUE;
single_value->field_rtAddrFlag = ANY_VALUE;
single_value->field_reserved1 = ANY_VALUE;
single_value->field_validLifetime = ANY_VALUE;
single_value->field_preferredLifetime = ANY_VALUE;
single_value->field_reserved2 = ANY_VALUE;
single_value->field_prefix = ANY_VALUE;
}
}
}

void PrefixInfo_template::copy_value(const PrefixInfo& other_value)
{
single_value = new single_value_struct;
if (other_value.icmpType().is_bound()) {
  single_value->field_icmpType = other_value.icmpType();
} else {
  single_value->field_icmpType.clean_up();
}
if (other_value.optionLength().is_bound()) {
  single_value->field_optionLength = other_value.optionLength();
} else {
  single_value->field_optionLength.clean_up();
}
if (other_value.prefixLength().is_bound()) {
  single_value->field_prefixLength = other_value.prefixLength();
} else {
  single_value->field_prefixLength.clean_up();
}
if (other_value.linkFlag().is_bound()) {
  single_value->field_linkFlag = other_value.linkFlag();
} else {
  single_value->field_linkFlag.clean_up();
}
if (other_value.autoConfigFlag().is_bound()) {
  single_value->field_autoConfigFlag = other_value.autoConfigFlag();
} else {
  single_value->field_autoConfigFlag.clean_up();
}
if (other_value.rtAddrFlag().is_bound()) {
  single_value->field_rtAddrFlag = other_value.rtAddrFlag();
} else {
  single_value->field_rtAddrFlag.clean_up();
}
if (other_value.reserved1().is_bound()) {
  single_value->field_reserved1 = other_value.reserved1();
} else {
  single_value->field_reserved1.clean_up();
}
if (other_value.validLifetime().is_bound()) {
  single_value->field_validLifetime = other_value.validLifetime();
} else {
  single_value->field_validLifetime.clean_up();
}
if (other_value.preferredLifetime().is_bound()) {
  single_value->field_preferredLifetime = other_value.preferredLifetime();
} else {
  single_value->field_preferredLifetime.clean_up();
}
if (other_value.reserved2().is_bound()) {
  single_value->field_reserved2 = other_value.reserved2();
} else {
  single_value->field_reserved2.clean_up();
}
if (other_value.prefix().is_bound()) {
  single_value->field_prefix = other_value.prefix();
} else {
  single_value->field_prefix.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PrefixInfo_template::copy_template(const PrefixInfo_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.icmpType().get_selection()) {
single_value->field_icmpType = other_value.icmpType();
} else {
single_value->field_icmpType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.optionLength().get_selection()) {
single_value->field_optionLength = other_value.optionLength();
} else {
single_value->field_optionLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.prefixLength().get_selection()) {
single_value->field_prefixLength = other_value.prefixLength();
} else {
single_value->field_prefixLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.linkFlag().get_selection()) {
single_value->field_linkFlag = other_value.linkFlag();
} else {
single_value->field_linkFlag.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.autoConfigFlag().get_selection()) {
single_value->field_autoConfigFlag = other_value.autoConfigFlag();
} else {
single_value->field_autoConfigFlag.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rtAddrFlag().get_selection()) {
single_value->field_rtAddrFlag = other_value.rtAddrFlag();
} else {
single_value->field_rtAddrFlag.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved1().get_selection()) {
single_value->field_reserved1 = other_value.reserved1();
} else {
single_value->field_reserved1.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.validLifetime().get_selection()) {
single_value->field_validLifetime = other_value.validLifetime();
} else {
single_value->field_validLifetime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.preferredLifetime().get_selection()) {
single_value->field_preferredLifetime = other_value.preferredLifetime();
} else {
single_value->field_preferredLifetime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved2().get_selection()) {
single_value->field_reserved2 = other_value.reserved2();
} else {
single_value->field_reserved2.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.prefix().get_selection()) {
single_value->field_prefix = other_value.prefix();
} else {
single_value->field_prefix.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PrefixInfo_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
break;
}
set_selection(other_value);
}

PrefixInfo_template::PrefixInfo_template()
{
}

PrefixInfo_template::PrefixInfo_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PrefixInfo_template::PrefixInfo_template(const PrefixInfo& other_value)
{
copy_value(other_value);
}

PrefixInfo_template::PrefixInfo_template(const OPTIONAL<PrefixInfo>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PrefixInfo&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo from an unbound optional field.");
}
}

PrefixInfo_template::PrefixInfo_template(const PrefixInfo_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PrefixInfo_template::~PrefixInfo_template()
{
clean_up();
}

PrefixInfo_template& PrefixInfo_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PrefixInfo_template& PrefixInfo_template::operator=(const PrefixInfo& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PrefixInfo_template& PrefixInfo_template::operator=(const OPTIONAL<PrefixInfo>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PrefixInfo&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
}
return *this;
}

PrefixInfo_template& PrefixInfo_template::operator=(const PrefixInfo_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PrefixInfo_template::match(const PrefixInfo& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.icmpType().is_bound()) return FALSE;
if(!single_value->field_icmpType.match(other_value.icmpType(), legacy))return FALSE;
if(!other_value.optionLength().is_bound()) return FALSE;
if(!single_value->field_optionLength.match(other_value.optionLength(), legacy))return FALSE;
if(!other_value.prefixLength().is_bound()) return FALSE;
if(!single_value->field_prefixLength.match(other_value.prefixLength(), legacy))return FALSE;
if(!other_value.linkFlag().is_bound()) return FALSE;
if(!single_value->field_linkFlag.match(other_value.linkFlag(), legacy))return FALSE;
if(!other_value.autoConfigFlag().is_bound()) return FALSE;
if(!single_value->field_autoConfigFlag.match(other_value.autoConfigFlag(), legacy))return FALSE;
if(!other_value.rtAddrFlag().is_bound()) return FALSE;
if(!single_value->field_rtAddrFlag.match(other_value.rtAddrFlag(), legacy))return FALSE;
if(!other_value.reserved1().is_bound()) return FALSE;
if(!single_value->field_reserved1.match(other_value.reserved1(), legacy))return FALSE;
if(!other_value.validLifetime().is_bound()) return FALSE;
if(!single_value->field_validLifetime.match(other_value.validLifetime(), legacy))return FALSE;
if(!other_value.preferredLifetime().is_bound()) return FALSE;
if(!single_value->field_preferredLifetime.match(other_value.preferredLifetime(), legacy))return FALSE;
if(!other_value.reserved2().is_bound()) return FALSE;
if(!single_value->field_reserved2.match(other_value.reserved2(), legacy))return FALSE;
if(!other_value.prefix().is_bound()) return FALSE;
if(!single_value->field_prefix.match(other_value.prefix(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
}
return FALSE;
}

boolean PrefixInfo_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_icmpType.is_bound()) return TRUE;
if (single_value->field_optionLength.is_bound()) return TRUE;
if (single_value->field_prefixLength.is_bound()) return TRUE;
if (single_value->field_linkFlag.is_bound()) return TRUE;
if (single_value->field_autoConfigFlag.is_bound()) return TRUE;
if (single_value->field_rtAddrFlag.is_bound()) return TRUE;
if (single_value->field_reserved1.is_bound()) return TRUE;
if (single_value->field_validLifetime.is_bound()) return TRUE;
if (single_value->field_preferredLifetime.is_bound()) return TRUE;
if (single_value->field_reserved2.is_bound()) return TRUE;
if (single_value->field_prefix.is_bound()) return TRUE;
return FALSE;
}

boolean PrefixInfo_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_icmpType.is_value()) return FALSE;
if (!single_value->field_optionLength.is_value()) return FALSE;
if (!single_value->field_prefixLength.is_value()) return FALSE;
if (!single_value->field_linkFlag.is_value()) return FALSE;
if (!single_value->field_autoConfigFlag.is_value()) return FALSE;
if (!single_value->field_rtAddrFlag.is_value()) return FALSE;
if (!single_value->field_reserved1.is_value()) return FALSE;
if (!single_value->field_validLifetime.is_value()) return FALSE;
if (!single_value->field_preferredLifetime.is_value()) return FALSE;
if (!single_value->field_reserved2.is_value()) return FALSE;
if (!single_value->field_prefix.is_value()) return FALSE;
return TRUE;
}

void PrefixInfo_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PrefixInfo PrefixInfo_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
PrefixInfo ret_val;
if (single_value->field_icmpType.is_bound()) {
ret_val.icmpType() = single_value->field_icmpType.valueof();
}
if (single_value->field_optionLength.is_bound()) {
ret_val.optionLength() = single_value->field_optionLength.valueof();
}
if (single_value->field_prefixLength.is_bound()) {
ret_val.prefixLength() = single_value->field_prefixLength.valueof();
}
if (single_value->field_linkFlag.is_bound()) {
ret_val.linkFlag() = single_value->field_linkFlag.valueof();
}
if (single_value->field_autoConfigFlag.is_bound()) {
ret_val.autoConfigFlag() = single_value->field_autoConfigFlag.valueof();
}
if (single_value->field_rtAddrFlag.is_bound()) {
ret_val.rtAddrFlag() = single_value->field_rtAddrFlag.valueof();
}
if (single_value->field_reserved1.is_bound()) {
ret_val.reserved1() = single_value->field_reserved1.valueof();
}
if (single_value->field_validLifetime.is_bound()) {
ret_val.validLifetime() = single_value->field_validLifetime.valueof();
}
if (single_value->field_preferredLifetime.is_bound()) {
ret_val.preferredLifetime() = single_value->field_preferredLifetime.valueof();
}
if (single_value->field_reserved2.is_bound()) {
ret_val.reserved2() = single_value->field_reserved2.valueof();
}
if (single_value->field_prefix.is_bound()) {
ret_val.prefix() = single_value->field_prefix.valueof();
}
return ret_val;
}

void PrefixInfo_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PrefixInfo_template[list_length];
}

PrefixInfo_template& PrefixInfo_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
return value_list.list_value[list_index];
}

INTEGER_template& PrefixInfo_template::icmpType()
{
set_specific();
return single_value->field_icmpType;
}

const INTEGER_template& PrefixInfo_template::icmpType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field icmpType of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
return single_value->field_icmpType;
}

INTEGER_template& PrefixInfo_template::optionLength()
{
set_specific();
return single_value->field_optionLength;
}

const INTEGER_template& PrefixInfo_template::optionLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field optionLength of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
return single_value->field_optionLength;
}

INTEGER_template& PrefixInfo_template::prefixLength()
{
set_specific();
return single_value->field_prefixLength;
}

const INTEGER_template& PrefixInfo_template::prefixLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field prefixLength of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
return single_value->field_prefixLength;
}

INTEGER_template& PrefixInfo_template::linkFlag()
{
set_specific();
return single_value->field_linkFlag;
}

const INTEGER_template& PrefixInfo_template::linkFlag() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field linkFlag of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
return single_value->field_linkFlag;
}

INTEGER_template& PrefixInfo_template::autoConfigFlag()
{
set_specific();
return single_value->field_autoConfigFlag;
}

const INTEGER_template& PrefixInfo_template::autoConfigFlag() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field autoConfigFlag of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
return single_value->field_autoConfigFlag;
}

INTEGER_template& PrefixInfo_template::rtAddrFlag()
{
set_specific();
return single_value->field_rtAddrFlag;
}

const INTEGER_template& PrefixInfo_template::rtAddrFlag() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rtAddrFlag of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
return single_value->field_rtAddrFlag;
}

INTEGER_template& PrefixInfo_template::reserved1()
{
set_specific();
return single_value->field_reserved1;
}

const INTEGER_template& PrefixInfo_template::reserved1() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved1 of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
return single_value->field_reserved1;
}

INTEGER_template& PrefixInfo_template::validLifetime()
{
set_specific();
return single_value->field_validLifetime;
}

const INTEGER_template& PrefixInfo_template::validLifetime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field validLifetime of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
return single_value->field_validLifetime;
}

INTEGER_template& PrefixInfo_template::preferredLifetime()
{
set_specific();
return single_value->field_preferredLifetime;
}

const INTEGER_template& PrefixInfo_template::preferredLifetime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field preferredLifetime of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
return single_value->field_preferredLifetime;
}

INTEGER_template& PrefixInfo_template::reserved2()
{
set_specific();
return single_value->field_reserved2;
}

const INTEGER_template& PrefixInfo_template::reserved2() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved2 of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
return single_value->field_reserved2;
}

OCTETSTRING_template& PrefixInfo_template::prefix()
{
set_specific();
return single_value->field_prefix;
}

const OCTETSTRING_template& PrefixInfo_template::prefix() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field prefix of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
return single_value->field_prefix;
}

int PrefixInfo_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 11;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
  }
  return 0;
}

void PrefixInfo_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ icmpType := ");
single_value->field_icmpType.log();
TTCN_Logger::log_event_str(", optionLength := ");
single_value->field_optionLength.log();
TTCN_Logger::log_event_str(", prefixLength := ");
single_value->field_prefixLength.log();
TTCN_Logger::log_event_str(", linkFlag := ");
single_value->field_linkFlag.log();
TTCN_Logger::log_event_str(", autoConfigFlag := ");
single_value->field_autoConfigFlag.log();
TTCN_Logger::log_event_str(", rtAddrFlag := ");
single_value->field_rtAddrFlag.log();
TTCN_Logger::log_event_str(", reserved1 := ");
single_value->field_reserved1.log();
TTCN_Logger::log_event_str(", validLifetime := ");
single_value->field_validLifetime.log();
TTCN_Logger::log_event_str(", preferredLifetime := ");
single_value->field_preferredLifetime.log();
TTCN_Logger::log_event_str(", reserved2 := ");
single_value->field_reserved2.log();
TTCN_Logger::log_event_str(", prefix := ");
single_value->field_prefix.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PrefixInfo_template::log_match(const PrefixInfo& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_icmpType.match(match_value.icmpType(), legacy)){
TTCN_Logger::log_logmatch_info(".icmpType");
single_value->field_icmpType.log_match(match_value.icmpType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_optionLength.match(match_value.optionLength(), legacy)){
TTCN_Logger::log_logmatch_info(".optionLength");
single_value->field_optionLength.log_match(match_value.optionLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_prefixLength.match(match_value.prefixLength(), legacy)){
TTCN_Logger::log_logmatch_info(".prefixLength");
single_value->field_prefixLength.log_match(match_value.prefixLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_linkFlag.match(match_value.linkFlag(), legacy)){
TTCN_Logger::log_logmatch_info(".linkFlag");
single_value->field_linkFlag.log_match(match_value.linkFlag(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_autoConfigFlag.match(match_value.autoConfigFlag(), legacy)){
TTCN_Logger::log_logmatch_info(".autoConfigFlag");
single_value->field_autoConfigFlag.log_match(match_value.autoConfigFlag(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_rtAddrFlag.match(match_value.rtAddrFlag(), legacy)){
TTCN_Logger::log_logmatch_info(".rtAddrFlag");
single_value->field_rtAddrFlag.log_match(match_value.rtAddrFlag(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved1.match(match_value.reserved1(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved1");
single_value->field_reserved1.log_match(match_value.reserved1(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_validLifetime.match(match_value.validLifetime(), legacy)){
TTCN_Logger::log_logmatch_info(".validLifetime");
single_value->field_validLifetime.log_match(match_value.validLifetime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_preferredLifetime.match(match_value.preferredLifetime(), legacy)){
TTCN_Logger::log_logmatch_info(".preferredLifetime");
single_value->field_preferredLifetime.log_match(match_value.preferredLifetime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved2.match(match_value.reserved2(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved2");
single_value->field_reserved2.log_match(match_value.reserved2(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_prefix.match(match_value.prefix(), legacy)){
TTCN_Logger::log_logmatch_info(".prefix");
single_value->field_prefix.log_match(match_value.prefix(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ icmpType := ");
single_value->field_icmpType.log_match(match_value.icmpType(), legacy);
TTCN_Logger::log_event_str(", optionLength := ");
single_value->field_optionLength.log_match(match_value.optionLength(), legacy);
TTCN_Logger::log_event_str(", prefixLength := ");
single_value->field_prefixLength.log_match(match_value.prefixLength(), legacy);
TTCN_Logger::log_event_str(", linkFlag := ");
single_value->field_linkFlag.log_match(match_value.linkFlag(), legacy);
TTCN_Logger::log_event_str(", autoConfigFlag := ");
single_value->field_autoConfigFlag.log_match(match_value.autoConfigFlag(), legacy);
TTCN_Logger::log_event_str(", rtAddrFlag := ");
single_value->field_rtAddrFlag.log_match(match_value.rtAddrFlag(), legacy);
TTCN_Logger::log_event_str(", reserved1 := ");
single_value->field_reserved1.log_match(match_value.reserved1(), legacy);
TTCN_Logger::log_event_str(", validLifetime := ");
single_value->field_validLifetime.log_match(match_value.validLifetime(), legacy);
TTCN_Logger::log_event_str(", preferredLifetime := ");
single_value->field_preferredLifetime.log_match(match_value.preferredLifetime(), legacy);
TTCN_Logger::log_event_str(", reserved2 := ");
single_value->field_reserved2.log_match(match_value.reserved2(), legacy);
TTCN_Logger::log_event_str(", prefix := ");
single_value->field_prefix.log_match(match_value.prefix(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PrefixInfo_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_icmpType.encode_text(text_buf);
single_value->field_optionLength.encode_text(text_buf);
single_value->field_prefixLength.encode_text(text_buf);
single_value->field_linkFlag.encode_text(text_buf);
single_value->field_autoConfigFlag.encode_text(text_buf);
single_value->field_rtAddrFlag.encode_text(text_buf);
single_value->field_reserved1.encode_text(text_buf);
single_value->field_validLifetime.encode_text(text_buf);
single_value->field_preferredLifetime.encode_text(text_buf);
single_value->field_reserved2.encode_text(text_buf);
single_value->field_prefix.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
}
}

void PrefixInfo_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_icmpType.decode_text(text_buf);
single_value->field_optionLength.decode_text(text_buf);
single_value->field_prefixLength.decode_text(text_buf);
single_value->field_linkFlag.decode_text(text_buf);
single_value->field_autoConfigFlag.decode_text(text_buf);
single_value->field_rtAddrFlag.decode_text(text_buf);
single_value->field_reserved1.decode_text(text_buf);
single_value->field_validLifetime.decode_text(text_buf);
single_value->field_preferredLifetime.decode_text(text_buf);
single_value->field_reserved2.decode_text(text_buf);
single_value->field_prefix.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PrefixInfo_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo.");
}
}

void PrefixInfo_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo'");
    }
    if (strcmp("icmpType", param_field) == 0) {
      icmpType().set_param(param);
      return;
    } else if (strcmp("optionLength", param_field) == 0) {
      optionLength().set_param(param);
      return;
    } else if (strcmp("prefixLength", param_field) == 0) {
      prefixLength().set_param(param);
      return;
    } else if (strcmp("linkFlag", param_field) == 0) {
      linkFlag().set_param(param);
      return;
    } else if (strcmp("autoConfigFlag", param_field) == 0) {
      autoConfigFlag().set_param(param);
      return;
    } else if (strcmp("rtAddrFlag", param_field) == 0) {
      rtAddrFlag().set_param(param);
      return;
    } else if (strcmp("reserved1", param_field) == 0) {
      reserved1().set_param(param);
      return;
    } else if (strcmp("validLifetime", param_field) == 0) {
      validLifetime().set_param(param);
      return;
    } else if (strcmp("preferredLifetime", param_field) == 0) {
      preferredLifetime().set_param(param);
      return;
    } else if (strcmp("reserved2", param_field) == 0) {
      reserved2().set_param(param);
      return;
    } else if (strcmp("prefix", param_field) == 0) {
      prefix().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PrefixInfo_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (11<mp->get_size()) {
      param.error("record template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo has 11 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) icmpType().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) optionLength().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) prefixLength().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) linkFlag().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) autoConfigFlag().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) rtAddrFlag().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) reserved1().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) validLifetime().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) preferredLifetime().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) reserved2().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) prefix().set_param(*mp->get_elem(10));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "icmpType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          icmpType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "optionLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          optionLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "prefixLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          prefixLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "linkFlag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          linkFlag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "autoConfigFlag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          autoConfigFlag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rtAddrFlag")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rtAddrFlag().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved1")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved1().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "validLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          validLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "preferredLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          preferredLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved2().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "prefix")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          prefix().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* PrefixInfo_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo'");
    }
    if (strcmp("icmpType", param_field) == 0) {
      return icmpType().get_param(param_name);
    } else if (strcmp("optionLength", param_field) == 0) {
      return optionLength().get_param(param_name);
    } else if (strcmp("prefixLength", param_field) == 0) {
      return prefixLength().get_param(param_name);
    } else if (strcmp("linkFlag", param_field) == 0) {
      return linkFlag().get_param(param_name);
    } else if (strcmp("autoConfigFlag", param_field) == 0) {
      return autoConfigFlag().get_param(param_name);
    } else if (strcmp("rtAddrFlag", param_field) == 0) {
      return rtAddrFlag().get_param(param_name);
    } else if (strcmp("reserved1", param_field) == 0) {
      return reserved1().get_param(param_name);
    } else if (strcmp("validLifetime", param_field) == 0) {
      return validLifetime().get_param(param_name);
    } else if (strcmp("preferredLifetime", param_field) == 0) {
      return preferredLifetime().get_param(param_name);
    } else if (strcmp("reserved2", param_field) == 0) {
      return reserved2().get_param(param_name);
    } else if (strcmp("prefix", param_field) == 0) {
      return prefix().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_icmpType = single_value->field_icmpType.get_param(param_name);
    mp_field_icmpType->set_id(new Module_Param_FieldName(mcopystr("icmpType")));
    mp->add_elem(mp_field_icmpType);
    Module_Param* mp_field_optionLength = single_value->field_optionLength.get_param(param_name);
    mp_field_optionLength->set_id(new Module_Param_FieldName(mcopystr("optionLength")));
    mp->add_elem(mp_field_optionLength);
    Module_Param* mp_field_prefixLength = single_value->field_prefixLength.get_param(param_name);
    mp_field_prefixLength->set_id(new Module_Param_FieldName(mcopystr("prefixLength")));
    mp->add_elem(mp_field_prefixLength);
    Module_Param* mp_field_linkFlag = single_value->field_linkFlag.get_param(param_name);
    mp_field_linkFlag->set_id(new Module_Param_FieldName(mcopystr("linkFlag")));
    mp->add_elem(mp_field_linkFlag);
    Module_Param* mp_field_autoConfigFlag = single_value->field_autoConfigFlag.get_param(param_name);
    mp_field_autoConfigFlag->set_id(new Module_Param_FieldName(mcopystr("autoConfigFlag")));
    mp->add_elem(mp_field_autoConfigFlag);
    Module_Param* mp_field_rtAddrFlag = single_value->field_rtAddrFlag.get_param(param_name);
    mp_field_rtAddrFlag->set_id(new Module_Param_FieldName(mcopystr("rtAddrFlag")));
    mp->add_elem(mp_field_rtAddrFlag);
    Module_Param* mp_field_reserved1 = single_value->field_reserved1.get_param(param_name);
    mp_field_reserved1->set_id(new Module_Param_FieldName(mcopystr("reserved1")));
    mp->add_elem(mp_field_reserved1);
    Module_Param* mp_field_validLifetime = single_value->field_validLifetime.get_param(param_name);
    mp_field_validLifetime->set_id(new Module_Param_FieldName(mcopystr("validLifetime")));
    mp->add_elem(mp_field_validLifetime);
    Module_Param* mp_field_preferredLifetime = single_value->field_preferredLifetime.get_param(param_name);
    mp_field_preferredLifetime->set_id(new Module_Param_FieldName(mcopystr("preferredLifetime")));
    mp->add_elem(mp_field_preferredLifetime);
    Module_Param* mp_field_reserved2 = single_value->field_reserved2.get_param(param_name);
    mp_field_reserved2->set_id(new Module_Param_FieldName(mcopystr("reserved2")));
    mp->add_elem(mp_field_reserved2);
    Module_Param* mp_field_prefix = single_value->field_prefix.get_param(param_name);
    mp_field_prefix->set_id(new Module_Param_FieldName(mcopystr("prefix")));
    mp->add_elem(mp_field_prefix);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void PrefixInfo_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_icmpType.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo");
single_value->field_optionLength.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo");
single_value->field_prefixLength.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo");
single_value->field_linkFlag.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo");
single_value->field_autoConfigFlag.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo");
single_value->field_rtAddrFlag.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo");
single_value->field_reserved1.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo");
single_value->field_validLifetime.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo");
single_value->field_preferredLifetime.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo");
single_value->field_reserved2.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo");
single_value->field_prefix.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfo");
}

boolean PrefixInfo_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PrefixInfo_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void AcGn6Primitive::copy_value(const AcGn6Primitive& other_value)
{
switch (other_value.union_selection) {
case ALT_getInterfaceInfos:
field_getInterfaceInfos = new INTEGER(*other_value.field_getInterfaceInfos);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
}
union_selection = other_value.union_selection;
}

AcGn6Primitive::AcGn6Primitive()
{
union_selection = UNBOUND_VALUE;
}

AcGn6Primitive::AcGn6Primitive(const AcGn6Primitive& other_value)
: Base_Type(){
copy_value(other_value);
}

AcGn6Primitive::~AcGn6Primitive()
{
clean_up();
}

AcGn6Primitive& AcGn6Primitive::operator=(const AcGn6Primitive& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean AcGn6Primitive::operator==(const AcGn6Primitive& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_getInterfaceInfos:
return *field_getInterfaceInfos == *other_value.field_getInterfaceInfos;
default:
return FALSE;
}
}

INTEGER& AcGn6Primitive::getInterfaceInfos()
{
if (union_selection != ALT_getInterfaceInfos) {
clean_up();
field_getInterfaceInfos = new INTEGER;
union_selection = ALT_getInterfaceInfos;
}
return *field_getInterfaceInfos;
}

const INTEGER& AcGn6Primitive::getInterfaceInfos() const
{
if (union_selection != ALT_getInterfaceInfos) TTCN_error("Using non-selected field getInterfaceInfos in a value of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
return *field_getInterfaceInfos;
}

boolean AcGn6Primitive::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
return union_selection == checked_selection;
}

boolean AcGn6Primitive::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean AcGn6Primitive::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_getInterfaceInfos: return field_getInterfaceInfos->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void AcGn6Primitive::clean_up()
{
switch (union_selection) {
case ALT_getInterfaceInfos:
  delete field_getInterfaceInfos;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void AcGn6Primitive::log() const
{
switch (union_selection) {
case ALT_getInterfaceInfos:
TTCN_Logger::log_event_str("{ getInterfaceInfos := ");
field_getInterfaceInfos->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void AcGn6Primitive::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive'");
    }
    if (strcmp("getInterfaceInfos", param_field) == 0) {
      getInterfaceInfos().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "getInterfaceInfos")) {
    getInterfaceInfos().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.", mp_last->get_id()->get_name());
}

Module_Param* AcGn6Primitive::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive'");
    }
    if (strcmp("getInterfaceInfos", param_field) == 0) {
      return getInterfaceInfos().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `AcGn6Primitive'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_getInterfaceInfos:
    mp_field = field_getInterfaceInfos->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("getInterfaceInfos")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void AcGn6Primitive::set_implicit_omit()
{
switch (union_selection) {
case ALT_getInterfaceInfos:
field_getInterfaceInfos->set_implicit_omit(); break;
default: break;
}
}

void AcGn6Primitive::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_getInterfaceInfos:
field_getInterfaceInfos->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
}
}

void AcGn6Primitive::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_getInterfaceInfos:
getInterfaceInfos().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
}
}

void AcGn6Primitive::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AcGn6Primitive::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AcGn6Primitive::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = getInterfaceInfos().RAW_decode(INTEGER_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = getInterfaceInfos().RAW_decode(INTEGER_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int AcGn6Primitive::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 1;  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  memset(myleaf.body.node.nodes, 0, 1 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_getInterfaceInfos:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, INTEGER_descr_.raw);
    encoded_length = field_getInterfaceInfos->RAW_encode(INTEGER_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &INTEGER_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int AcGn6Primitive::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_getInterfaceInfos:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "getInterfaceInfos");
    enc_len += field_getInterfaceInfos->JSON_encode(INTEGER_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AcGn6Primitive::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "getInterfaceInfos", name_len)) {
      int ret_val = getInterfaceInfos().JSON_decode(INTEGER_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "getInterfaceInfos");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void AcGn6Primitive_template::copy_value(const AcGn6Primitive& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case AcGn6Primitive::ALT_getInterfaceInfos:
single_value.field_getInterfaceInfos = new INTEGER_template(other_value.getInterfaceInfos());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
}
set_selection(SPECIFIC_VALUE);
}

void AcGn6Primitive_template::copy_template(const AcGn6Primitive_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case AcGn6Primitive::ALT_getInterfaceInfos:
single_value.field_getInterfaceInfos = new INTEGER_template(*other_value.single_value.field_getInterfaceInfos);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AcGn6Primitive_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
}
set_selection(other_value);
}

AcGn6Primitive_template::AcGn6Primitive_template()
{
}

AcGn6Primitive_template::AcGn6Primitive_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AcGn6Primitive_template::AcGn6Primitive_template(const AcGn6Primitive& other_value)
{
copy_value(other_value);
}

AcGn6Primitive_template::AcGn6Primitive_template(const OPTIONAL<AcGn6Primitive>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcGn6Primitive&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive from an unbound optional field.");
}
}

AcGn6Primitive_template::AcGn6Primitive_template(const AcGn6Primitive_template& other_value)
: Base_Template(){
copy_template(other_value);
}

AcGn6Primitive_template::~AcGn6Primitive_template()
{
clean_up();
}

void AcGn6Primitive_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case AcGn6Primitive::ALT_getInterfaceInfos:
delete single_value.field_getInterfaceInfos;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AcGn6Primitive_template& AcGn6Primitive_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AcGn6Primitive_template& AcGn6Primitive_template::operator=(const AcGn6Primitive& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AcGn6Primitive_template& AcGn6Primitive_template::operator=(const OPTIONAL<AcGn6Primitive>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcGn6Primitive&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
}
return *this;
}

AcGn6Primitive_template& AcGn6Primitive_template::operator=(const AcGn6Primitive_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AcGn6Primitive_template::match(const AcGn6Primitive& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
AcGn6Primitive::union_selection_type value_selection = other_value.get_selection();
if (value_selection == AcGn6Primitive::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case AcGn6Primitive::ALT_getInterfaceInfos:
return single_value.field_getInterfaceInfos->match(other_value.getInterfaceInfos(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
}
return FALSE;
}

boolean AcGn6Primitive_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case AcGn6Primitive::ALT_getInterfaceInfos:
return single_value.field_getInterfaceInfos->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
}
}

AcGn6Primitive AcGn6Primitive_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
AcGn6Primitive ret_val;
switch (single_value.union_selection) {
case AcGn6Primitive::ALT_getInterfaceInfos:
ret_val.getInterfaceInfos() = single_value.field_getInterfaceInfos->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
}
return ret_val;
}

AcGn6Primitive_template& AcGn6Primitive_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
return value_list.list_value[list_index];
}
void AcGn6Primitive_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AcGn6Primitive_template[list_length];
}

INTEGER_template& AcGn6Primitive_template::getInterfaceInfos()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != AcGn6Primitive::ALT_getInterfaceInfos) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_getInterfaceInfos = new INTEGER_template(ANY_VALUE);
else single_value.field_getInterfaceInfos = new INTEGER_template;
single_value.union_selection = AcGn6Primitive::ALT_getInterfaceInfos;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_getInterfaceInfos;
}

const INTEGER_template& AcGn6Primitive_template::getInterfaceInfos() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field getInterfaceInfos in a non-specific template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
if (single_value.union_selection != AcGn6Primitive::ALT_getInterfaceInfos) TTCN_error("Accessing non-selected field getInterfaceInfos in a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
return *single_value.field_getInterfaceInfos;
}

boolean AcGn6Primitive_template::ischosen(AcGn6Primitive::union_selection_type checked_selection) const
{
if (checked_selection == AcGn6Primitive::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == AcGn6Primitive::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive");
}
return FALSE;
}

void AcGn6Primitive_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case AcGn6Primitive::ALT_getInterfaceInfos:
TTCN_Logger::log_event_str("{ getInterfaceInfos := ");
single_value.field_getInterfaceInfos->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AcGn6Primitive_template::log_match(const AcGn6Primitive& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case AcGn6Primitive::ALT_getInterfaceInfos:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".getInterfaceInfos");
single_value.field_getInterfaceInfos->log_match(match_value.getInterfaceInfos(), legacy);
} else {
TTCN_Logger::log_event_str("{ getInterfaceInfos := ");
single_value.field_getInterfaceInfos->log_match(match_value.getInterfaceInfos(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AcGn6Primitive_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case AcGn6Primitive::ALT_getInterfaceInfos:
single_value.field_getInterfaceInfos->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
}
}

void AcGn6Primitive_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = AcGn6Primitive::UNBOUND_VALUE;
AcGn6Primitive::union_selection_type new_selection = (AcGn6Primitive::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case AcGn6Primitive::ALT_getInterfaceInfos:
single_value.field_getInterfaceInfos = new INTEGER_template;
single_value.field_getInterfaceInfos->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AcGn6Primitive_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
}
}

boolean AcGn6Primitive_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AcGn6Primitive_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void AcGn6Primitive_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive'");
    }
    if (strcmp("getInterfaceInfos", param_field) == 0) {
      getInterfaceInfos().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AcGn6Primitive_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "getInterfaceInfos")) {
      getInterfaceInfos().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AcGn6Primitive_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive'");
    }
    if (strcmp("getInterfaceInfos", param_field) == 0) {
      return getInterfaceInfos().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `AcGn6Primitive'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case AcGn6Primitive::ALT_getInterfaceInfos:
      mp_field = single_value.field_getInterfaceInfos->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("getInterfaceInfos")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AcGn6Primitive_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case AcGn6Primitive::ALT_getInterfaceInfos:
single_value.field_getInterfaceInfos->check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Primitive");
}

void AcGn6Response::copy_value(const AcGn6Response& other_value)
{
switch (other_value.union_selection) {
case ALT_interfaceInfoList:
field_interfaceInfoList = new AcGn6InterfaceInfoList(*other_value.field_interfaceInfoList);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
}
union_selection = other_value.union_selection;
}

AcGn6Response::AcGn6Response()
{
union_selection = UNBOUND_VALUE;
}

AcGn6Response::AcGn6Response(const AcGn6Response& other_value)
: Base_Type(){
copy_value(other_value);
}

AcGn6Response::~AcGn6Response()
{
clean_up();
}

AcGn6Response& AcGn6Response::operator=(const AcGn6Response& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean AcGn6Response::operator==(const AcGn6Response& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_interfaceInfoList:
return *field_interfaceInfoList == *other_value.field_interfaceInfoList;
default:
return FALSE;
}
}

AcGn6InterfaceInfoList& AcGn6Response::interfaceInfoList()
{
if (union_selection != ALT_interfaceInfoList) {
clean_up();
field_interfaceInfoList = new AcGn6InterfaceInfoList;
union_selection = ALT_interfaceInfoList;
}
return *field_interfaceInfoList;
}

const AcGn6InterfaceInfoList& AcGn6Response::interfaceInfoList() const
{
if (union_selection != ALT_interfaceInfoList) TTCN_error("Using non-selected field interfaceInfoList in a value of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
return *field_interfaceInfoList;
}

boolean AcGn6Response::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
return union_selection == checked_selection;
}

boolean AcGn6Response::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean AcGn6Response::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_interfaceInfoList: return field_interfaceInfoList->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void AcGn6Response::clean_up()
{
switch (union_selection) {
case ALT_interfaceInfoList:
  delete field_interfaceInfoList;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void AcGn6Response::log() const
{
switch (union_selection) {
case ALT_interfaceInfoList:
TTCN_Logger::log_event_str("{ interfaceInfoList := ");
field_interfaceInfoList->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void AcGn6Response::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response'");
    }
    if (strcmp("interfaceInfoList", param_field) == 0) {
      interfaceInfoList().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "interfaceInfoList")) {
    interfaceInfoList().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.", mp_last->get_id()->get_name());
}

Module_Param* AcGn6Response::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response'");
    }
    if (strcmp("interfaceInfoList", param_field) == 0) {
      return interfaceInfoList().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `AcGn6Response'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_interfaceInfoList:
    mp_field = field_interfaceInfoList->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("interfaceInfoList")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void AcGn6Response::set_implicit_omit()
{
switch (union_selection) {
case ALT_interfaceInfoList:
field_interfaceInfoList->set_implicit_omit(); break;
default: break;
}
}

void AcGn6Response::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_interfaceInfoList:
field_interfaceInfoList->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
}
}

void AcGn6Response::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_interfaceInfoList:
interfaceInfoList().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
}
}

void AcGn6Response::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AcGn6Response::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AcGn6Response::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = interfaceInfoList().RAW_decode(AcGn6InterfaceInfoList_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = interfaceInfoList().RAW_decode(AcGn6InterfaceInfoList_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int AcGn6Response::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 1;  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  memset(myleaf.body.node.nodes, 0, 1 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_interfaceInfoList:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, AcGn6InterfaceInfoList_descr_.raw);
    encoded_length = field_interfaceInfoList->RAW_encode(AcGn6InterfaceInfoList_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &AcGn6InterfaceInfoList_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int AcGn6Response::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_interfaceInfoList:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "interfaceInfoList");
    enc_len += field_interfaceInfoList->JSON_encode(AcGn6InterfaceInfoList_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AcGn6Response::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "interfaceInfoList", name_len)) {
      int ret_val = interfaceInfoList().JSON_decode(AcGn6InterfaceInfoList_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "interfaceInfoList");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void AcGn6Response_template::copy_value(const AcGn6Response& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case AcGn6Response::ALT_interfaceInfoList:
single_value.field_interfaceInfoList = new AcGn6InterfaceInfoList_template(other_value.interfaceInfoList());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
}
set_selection(SPECIFIC_VALUE);
}

void AcGn6Response_template::copy_template(const AcGn6Response_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case AcGn6Response::ALT_interfaceInfoList:
single_value.field_interfaceInfoList = new AcGn6InterfaceInfoList_template(*other_value.single_value.field_interfaceInfoList);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AcGn6Response_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
}
set_selection(other_value);
}

AcGn6Response_template::AcGn6Response_template()
{
}

AcGn6Response_template::AcGn6Response_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AcGn6Response_template::AcGn6Response_template(const AcGn6Response& other_value)
{
copy_value(other_value);
}

AcGn6Response_template::AcGn6Response_template(const OPTIONAL<AcGn6Response>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcGn6Response&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response from an unbound optional field.");
}
}

AcGn6Response_template::AcGn6Response_template(const AcGn6Response_template& other_value)
: Base_Template(){
copy_template(other_value);
}

AcGn6Response_template::~AcGn6Response_template()
{
clean_up();
}

void AcGn6Response_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case AcGn6Response::ALT_interfaceInfoList:
delete single_value.field_interfaceInfoList;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AcGn6Response_template& AcGn6Response_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AcGn6Response_template& AcGn6Response_template::operator=(const AcGn6Response& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AcGn6Response_template& AcGn6Response_template::operator=(const OPTIONAL<AcGn6Response>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcGn6Response&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
}
return *this;
}

AcGn6Response_template& AcGn6Response_template::operator=(const AcGn6Response_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AcGn6Response_template::match(const AcGn6Response& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
AcGn6Response::union_selection_type value_selection = other_value.get_selection();
if (value_selection == AcGn6Response::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case AcGn6Response::ALT_interfaceInfoList:
return single_value.field_interfaceInfoList->match(other_value.interfaceInfoList(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
}
return FALSE;
}

boolean AcGn6Response_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case AcGn6Response::ALT_interfaceInfoList:
return single_value.field_interfaceInfoList->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
}
}

AcGn6Response AcGn6Response_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
AcGn6Response ret_val;
switch (single_value.union_selection) {
case AcGn6Response::ALT_interfaceInfoList:
ret_val.interfaceInfoList() = single_value.field_interfaceInfoList->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
}
return ret_val;
}

AcGn6Response_template& AcGn6Response_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
return value_list.list_value[list_index];
}
void AcGn6Response_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AcGn6Response_template[list_length];
}

AcGn6InterfaceInfoList_template& AcGn6Response_template::interfaceInfoList()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != AcGn6Response::ALT_interfaceInfoList) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_interfaceInfoList = new AcGn6InterfaceInfoList_template(ANY_VALUE);
else single_value.field_interfaceInfoList = new AcGn6InterfaceInfoList_template;
single_value.union_selection = AcGn6Response::ALT_interfaceInfoList;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_interfaceInfoList;
}

const AcGn6InterfaceInfoList_template& AcGn6Response_template::interfaceInfoList() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field interfaceInfoList in a non-specific template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
if (single_value.union_selection != AcGn6Response::ALT_interfaceInfoList) TTCN_error("Accessing non-selected field interfaceInfoList in a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
return *single_value.field_interfaceInfoList;
}

boolean AcGn6Response_template::ischosen(AcGn6Response::union_selection_type checked_selection) const
{
if (checked_selection == AcGn6Response::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == AcGn6Response::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response");
}
return FALSE;
}

void AcGn6Response_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case AcGn6Response::ALT_interfaceInfoList:
TTCN_Logger::log_event_str("{ interfaceInfoList := ");
single_value.field_interfaceInfoList->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AcGn6Response_template::log_match(const AcGn6Response& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case AcGn6Response::ALT_interfaceInfoList:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".interfaceInfoList");
single_value.field_interfaceInfoList->log_match(match_value.interfaceInfoList(), legacy);
} else {
TTCN_Logger::log_event_str("{ interfaceInfoList := ");
single_value.field_interfaceInfoList->log_match(match_value.interfaceInfoList(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AcGn6Response_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case AcGn6Response::ALT_interfaceInfoList:
single_value.field_interfaceInfoList->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
}
}

void AcGn6Response_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = AcGn6Response::UNBOUND_VALUE;
AcGn6Response::union_selection_type new_selection = (AcGn6Response::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case AcGn6Response::ALT_interfaceInfoList:
single_value.field_interfaceInfoList = new AcGn6InterfaceInfoList_template;
single_value.field_interfaceInfoList->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AcGn6Response_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
}
}

boolean AcGn6Response_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AcGn6Response_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void AcGn6Response_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response'");
    }
    if (strcmp("interfaceInfoList", param_field) == 0) {
      interfaceInfoList().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AcGn6Response_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "interfaceInfoList")) {
      interfaceInfoList().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AcGn6Response_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response'");
    }
    if (strcmp("interfaceInfoList", param_field) == 0) {
      return interfaceInfoList().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `AcGn6Response'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case AcGn6Response::ALT_interfaceInfoList:
      mp_field = single_value.field_interfaceInfoList->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("interfaceInfoList")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AcGn6Response_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case AcGn6Response::ALT_interfaceInfoList:
single_value.field_interfaceInfoList->check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6Response");
}


const AcGn6InterfaceInfo AcGn6InterfaceInfoList::UNBOUND_ELEM;
AcGn6InterfaceInfoList::AcGn6InterfaceInfoList()
{
val_ptr = NULL;
}

AcGn6InterfaceInfoList::AcGn6InterfaceInfoList(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

AcGn6InterfaceInfoList::AcGn6InterfaceInfoList(const AcGn6InterfaceInfoList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

AcGn6InterfaceInfoList::~AcGn6InterfaceInfoList()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void AcGn6InterfaceInfoList::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

AcGn6InterfaceInfoList& AcGn6InterfaceInfoList::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

AcGn6InterfaceInfoList& AcGn6InterfaceInfoList::operator=(const AcGn6InterfaceInfoList& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean AcGn6InterfaceInfoList::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
return val_ptr->n_elements == 0 ;
}

boolean AcGn6InterfaceInfoList::operator==(const AcGn6InterfaceInfoList& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
if (val_ptr == other_value.val_ptr) return TRUE;
if (val_ptr->n_elements != (other_value.val_ptr)->n_elements)
return FALSE;
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
if ((other_value.val_ptr)->value_elements[elem_count] != NULL){
  if (*val_ptr->value_elements[elem_count] != *(other_value.val_ptr)->value_elements[elem_count]) return FALSE;
} else return FALSE;
} else {
if ((other_value.val_ptr)->value_elements[elem_count] != NULL) return FALSE;
}
}
return TRUE;
}

AcGn6InterfaceInfo& AcGn6InterfaceInfoList::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (AcGn6InterfaceInfo**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new AcGn6InterfaceInfo(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new AcGn6InterfaceInfo;
}
return *val_ptr->value_elements[index_value];
}

AcGn6InterfaceInfo& AcGn6InterfaceInfoList::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
return (*this)[(int)index_value];
}

const AcGn6InterfaceInfo& AcGn6InterfaceInfoList::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const AcGn6InterfaceInfo& AcGn6InterfaceInfoList::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
return (*this)[(int)index_value];
}

AcGn6InterfaceInfoList AcGn6InterfaceInfoList::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

AcGn6InterfaceInfoList AcGn6InterfaceInfoList::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

AcGn6InterfaceInfoList AcGn6InterfaceInfoList::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

AcGn6InterfaceInfoList AcGn6InterfaceInfoList::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
AcGn6InterfaceInfoList ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new AcGn6InterfaceInfo(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

AcGn6InterfaceInfoList AcGn6InterfaceInfoList::operator+(const AcGn6InterfaceInfoList& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
AcGn6InterfaceInfoList ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new AcGn6InterfaceInfo(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new AcGn6InterfaceInfo(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

AcGn6InterfaceInfoList AcGn6InterfaceInfoList::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList","element");
AcGn6InterfaceInfoList ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new AcGn6InterfaceInfo(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

AcGn6InterfaceInfoList AcGn6InterfaceInfoList::replace(int index, int len, const AcGn6InterfaceInfoList& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList","element");
AcGn6InterfaceInfoList ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new AcGn6InterfaceInfo(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new AcGn6InterfaceInfo(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new AcGn6InterfaceInfo(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

AcGn6InterfaceInfoList AcGn6InterfaceInfoList::replace(int index, int len, const AcGn6InterfaceInfoList_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void AcGn6InterfaceInfoList::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (AcGn6InterfaceInfo**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new AcGn6InterfaceInfo(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (AcGn6InterfaceInfo**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (AcGn6InterfaceInfo**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean AcGn6InterfaceInfoList::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int AcGn6InterfaceInfoList::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
return val_ptr->n_elements;
}

int AcGn6InterfaceInfoList::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void AcGn6InterfaceInfoList::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void AcGn6InterfaceInfoList::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record of type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "record of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("record of value", "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("record of value", "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* AcGn6InterfaceInfoList::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void AcGn6InterfaceInfoList::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void AcGn6InterfaceInfoList::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void AcGn6InterfaceInfoList::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
val_ptr->value_elements = (AcGn6InterfaceInfo**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new AcGn6InterfaceInfo;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void AcGn6InterfaceInfoList::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AcGn6InterfaceInfoList::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AcGn6InterfaceInfoList::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int AcGn6InterfaceInfoList::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

int AcGn6InterfaceInfoList::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int AcGn6InterfaceInfoList::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    AcGn6InterfaceInfo* val = new AcGn6InterfaceInfo;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (AcGn6InterfaceInfo**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void AcGn6InterfaceInfoList_template::copy_value(const AcGn6InterfaceInfoList& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (AcGn6InterfaceInfo_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new AcGn6InterfaceInfo_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new AcGn6InterfaceInfo_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void AcGn6InterfaceInfoList_template::copy_template(const AcGn6InterfaceInfoList_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (AcGn6InterfaceInfo_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new AcGn6InterfaceInfo_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new AcGn6InterfaceInfo_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AcGn6InterfaceInfoList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
break;
}
set_selection(other_value);
}

boolean AcGn6InterfaceInfoList_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const AcGn6InterfaceInfoList_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const AcGn6InterfaceInfoList*)value_ptr)[value_index], legacy);
else return ((const AcGn6InterfaceInfoList_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

AcGn6InterfaceInfoList_template::AcGn6InterfaceInfoList_template()
{
}

AcGn6InterfaceInfoList_template::AcGn6InterfaceInfoList_template(template_sel other_value)
 : Record_Of_Template(other_value)
{
check_single_selection(other_value);
}

AcGn6InterfaceInfoList_template::AcGn6InterfaceInfoList_template(null_type)
 : Record_Of_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

AcGn6InterfaceInfoList_template::AcGn6InterfaceInfoList_template(const AcGn6InterfaceInfoList& other_value)
{
copy_value(other_value);
}

AcGn6InterfaceInfoList_template::AcGn6InterfaceInfoList_template(const OPTIONAL<AcGn6InterfaceInfoList>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcGn6InterfaceInfoList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList from an unbound optional field.");
}
}

AcGn6InterfaceInfoList_template::AcGn6InterfaceInfoList_template(const AcGn6InterfaceInfoList_template& other_value)
 : Record_Of_Template()
{
copy_template(other_value);
}

AcGn6InterfaceInfoList_template::~AcGn6InterfaceInfoList_template()
{
clean_up();
}

void AcGn6InterfaceInfoList_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AcGn6InterfaceInfoList_template& AcGn6InterfaceInfoList_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AcGn6InterfaceInfoList_template& AcGn6InterfaceInfoList_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

AcGn6InterfaceInfoList_template& AcGn6InterfaceInfoList_template::operator=(const AcGn6InterfaceInfoList& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AcGn6InterfaceInfoList_template& AcGn6InterfaceInfoList_template::operator=(const OPTIONAL<AcGn6InterfaceInfoList>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcGn6InterfaceInfoList&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
}
return *this;
}

AcGn6InterfaceInfoList_template& AcGn6InterfaceInfoList_template::operator=(const AcGn6InterfaceInfoList_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

AcGn6InterfaceInfo_template& AcGn6InterfaceInfoList_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
    break;
}
return *single_value.value_elements[index_value];
}

AcGn6InterfaceInfo_template& AcGn6InterfaceInfoList_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
return (*this)[(int)index_value];
}

const AcGn6InterfaceInfo_template& AcGn6InterfaceInfoList_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const AcGn6InterfaceInfo_template& AcGn6InterfaceInfoList_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
return (*this)[(int)index_value];
}

void AcGn6InterfaceInfoList_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (AcGn6InterfaceInfo_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new AcGn6InterfaceInfo_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new AcGn6InterfaceInfo_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (AcGn6InterfaceInfo_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int AcGn6InterfaceInfoList_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int AcGn6InterfaceInfoList_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList");
}

boolean AcGn6InterfaceInfoList_template::match(const AcGn6InterfaceInfoList& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_record_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
}
return FALSE;
}

boolean AcGn6InterfaceInfoList_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

AcGn6InterfaceInfoList AcGn6InterfaceInfoList_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
AcGn6InterfaceInfoList ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

AcGn6InterfaceInfoList AcGn6InterfaceInfoList_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

AcGn6InterfaceInfoList AcGn6InterfaceInfoList_template::replace(int index, int len, const AcGn6InterfaceInfoList_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

AcGn6InterfaceInfoList AcGn6InterfaceInfoList_template::replace(int index, int len, const AcGn6InterfaceInfoList& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void AcGn6InterfaceInfoList_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new AcGn6InterfaceInfoList_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
}
set_selection(template_type);
}

AcGn6InterfaceInfoList_template& AcGn6InterfaceInfoList_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
return value_list.list_value[list_index];
}

void AcGn6InterfaceInfoList_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
if (permutation_starts_at(elem_count)) TTCN_Logger::log_event_str("permutation(");
single_value.value_elements[elem_count]->log();
if (permutation_ends_at(elem_count)) TTCN_Logger::log_char(')');
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void AcGn6InterfaceInfoList_template::log_match(const AcGn6InterfaceInfoList& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if(!single_value.value_elements[elem_count]->match(match_value[elem_count], legacy)){
TTCN_Logger::log_logmatch_info("[%d]", elem_count);
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
log_match_length(single_value.n_elements);
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.n_elements > 0 && get_number_of_permutations() == 0 && single_value.n_elements == match_value.size_of()) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log_match(match_value[elem_count], legacy);
}
TTCN_Logger::log_event_str(" }");
log_match_length(single_value.n_elements);
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AcGn6InterfaceInfoList_template::encode_text(Text_Buf& text_buf) const
{
encode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
}
}

void AcGn6InterfaceInfoList_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_permutation(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
single_value.value_elements = (AcGn6InterfaceInfo_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new AcGn6InterfaceInfo_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AcGn6InterfaceInfoList_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
}
}

boolean AcGn6InterfaceInfoList_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AcGn6InterfaceInfoList_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void AcGn6InterfaceInfoList_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "record of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AcGn6InterfaceInfoList_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List: {
    set_size(mp->get_size());
    int curr_idx = 0;
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      switch (mp->get_elem(p_i)->get_type()) {
      case Module_Param::MP_NotUsed:
        curr_idx++;
        break;
      case Module_Param::MP_Permutation_Template: {
        int perm_start_idx = curr_idx;
        for (size_t perm_i=0; perm_i<mp->get_elem(p_i)->get_size(); perm_i++) {
          (*this)[curr_idx].set_param(*(mp->get_elem(p_i)->get_elem(perm_i)));
          curr_idx++;
        }
        int perm_end_idx = curr_idx - 1;
        add_permutation(perm_start_idx, perm_end_idx);
      } break;
      default:
        (*this)[curr_idx].set_param(*mp->get_elem(p_i));
        curr_idx++;
      }
    }
  } break;
  default:
    param.type_error("record of template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* AcGn6InterfaceInfoList_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for record of template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void AcGn6InterfaceInfoList_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList");
}

AcGn6InterfaceInfo::AcGn6InterfaceInfo()
{
  bound_flag = FALSE;
}

AcGn6InterfaceInfo::AcGn6InterfaceInfo(const CHARSTRING& par_interfaceName,
    const Ipv6AddressList& par_ipv6AddressList)
  :   field_interfaceName(par_interfaceName),
  field_ipv6AddressList(par_ipv6AddressList)
{
  bound_flag = TRUE;
}

AcGn6InterfaceInfo::AcGn6InterfaceInfo(const AcGn6InterfaceInfo& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo.");
bound_flag = TRUE;
if (other_value.interfaceName().is_bound()) field_interfaceName = other_value.interfaceName();
else field_interfaceName.clean_up();
if (other_value.ipv6AddressList().is_bound()) field_ipv6AddressList = other_value.ipv6AddressList();
else field_ipv6AddressList.clean_up();
}

void AcGn6InterfaceInfo::clean_up()
{
field_interfaceName.clean_up();
field_ipv6AddressList.clean_up();
bound_flag = FALSE;
}

AcGn6InterfaceInfo& AcGn6InterfaceInfo::operator=(const AcGn6InterfaceInfo& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo.");
  bound_flag = TRUE;
  if (other_value.interfaceName().is_bound()) field_interfaceName = other_value.interfaceName();
  else field_interfaceName.clean_up();
  if (other_value.ipv6AddressList().is_bound()) field_ipv6AddressList = other_value.ipv6AddressList();
  else field_ipv6AddressList.clean_up();
}
return *this;
}

boolean AcGn6InterfaceInfo::operator==(const AcGn6InterfaceInfo& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_interfaceName==other_value.field_interfaceName
  && field_ipv6AddressList==other_value.field_ipv6AddressList;
}

boolean AcGn6InterfaceInfo::is_bound() const
{
if (bound_flag) return TRUE;
if(field_interfaceName.is_bound()) return TRUE;
if(field_ipv6AddressList.is_bound()) return TRUE;
return FALSE;
}
boolean AcGn6InterfaceInfo::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_interfaceName.is_value()) return FALSE;
if(!field_ipv6AddressList.is_value()) return FALSE;
return TRUE;
}
int AcGn6InterfaceInfo::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo");
  return 2;
}

void AcGn6InterfaceInfo::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ interfaceName := ");
field_interfaceName.log();
TTCN_Logger::log_event_str(", ipv6AddressList := ");
field_ipv6AddressList.log();
TTCN_Logger::log_event_str(" }");
}

void AcGn6InterfaceInfo::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo'");
    }
    if (strcmp("interfaceName", param_field) == 0) {
      interfaceName().set_param(param);
      return;
    } else if (strcmp("ipv6AddressList", param_field) == 0) {
      ipv6AddressList().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) interfaceName().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ipv6AddressList().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "interfaceName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          interfaceName().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ipv6AddressList")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ipv6AddressList().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo");
  }
}

Module_Param* AcGn6InterfaceInfo::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo'");
    }
    if (strcmp("interfaceName", param_field) == 0) {
      return interfaceName().get_param(param_name);
    } else if (strcmp("ipv6AddressList", param_field) == 0) {
      return ipv6AddressList().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_interfaceName = field_interfaceName.get_param(param_name);
  mp_field_interfaceName->set_id(new Module_Param_FieldName(mcopystr("interfaceName")));
  mp->add_elem(mp_field_interfaceName);
  Module_Param* mp_field_ipv6AddressList = field_ipv6AddressList.get_param(param_name);
  mp_field_ipv6AddressList->set_id(new Module_Param_FieldName(mcopystr("ipv6AddressList")));
  mp->add_elem(mp_field_ipv6AddressList);
  return mp;
  }

void AcGn6InterfaceInfo::set_implicit_omit()
{
if (interfaceName().is_bound()) interfaceName().set_implicit_omit();
if (ipv6AddressList().is_bound()) ipv6AddressList().set_implicit_omit();
}

void AcGn6InterfaceInfo::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo.");
field_interfaceName.encode_text(text_buf);
field_ipv6AddressList.encode_text(text_buf);
}

void AcGn6InterfaceInfo::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_interfaceName.decode_text(text_buf);
field_ipv6AddressList.decode_text(text_buf);
}

void AcGn6InterfaceInfo::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AcGn6InterfaceInfo::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AcGn6InterfaceInfo::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_interfaceName.RAW_decode(CHARSTRING_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_ipv6AddressList.RAW_decode(Ipv6AddressList_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int AcGn6InterfaceInfo::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, CHARSTRING_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, Ipv6AddressList_descr_.raw);
  encoded_length += field_interfaceName.RAW_encode(CHARSTRING_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_ipv6AddressList.RAW_encode(Ipv6AddressList_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int AcGn6InterfaceInfo::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "interfaceName");
    enc_len += field_interfaceName.JSON_encode(CHARSTRING_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ipv6AddressList");
    enc_len += field_ipv6AddressList.JSON_encode(Ipv6AddressList_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AcGn6InterfaceInfo::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (13 == name_len && 0 == strncmp(fld_name, "interfaceName", name_len)) {
         int ret_val = field_interfaceName.JSON_decode(CHARSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "interfaceName");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "ipv6AddressList", name_len)) {
         int ret_val = field_ipv6AddressList.JSON_decode(Ipv6AddressList_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ipv6AddressList");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_interfaceName.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "interfaceName");
    return JSON_ERROR_FATAL;
  }
if (!field_ipv6AddressList.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "ipv6AddressList");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct AcGn6InterfaceInfo_template::single_value_struct {
CHARSTRING_template field_interfaceName;
Ipv6AddressList_template field_ipv6AddressList;
};

void AcGn6InterfaceInfo_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_interfaceName = ANY_VALUE;
single_value->field_ipv6AddressList = ANY_VALUE;
}
}
}

void AcGn6InterfaceInfo_template::copy_value(const AcGn6InterfaceInfo& other_value)
{
single_value = new single_value_struct;
if (other_value.interfaceName().is_bound()) {
  single_value->field_interfaceName = other_value.interfaceName();
} else {
  single_value->field_interfaceName.clean_up();
}
if (other_value.ipv6AddressList().is_bound()) {
  single_value->field_ipv6AddressList = other_value.ipv6AddressList();
} else {
  single_value->field_ipv6AddressList.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void AcGn6InterfaceInfo_template::copy_template(const AcGn6InterfaceInfo_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.interfaceName().get_selection()) {
single_value->field_interfaceName = other_value.interfaceName();
} else {
single_value->field_interfaceName.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.ipv6AddressList().get_selection()) {
single_value->field_ipv6AddressList = other_value.ipv6AddressList();
} else {
single_value->field_ipv6AddressList.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AcGn6InterfaceInfo_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo.");
break;
}
set_selection(other_value);
}

AcGn6InterfaceInfo_template::AcGn6InterfaceInfo_template()
{
}

AcGn6InterfaceInfo_template::AcGn6InterfaceInfo_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AcGn6InterfaceInfo_template::AcGn6InterfaceInfo_template(const AcGn6InterfaceInfo& other_value)
{
copy_value(other_value);
}

AcGn6InterfaceInfo_template::AcGn6InterfaceInfo_template(const OPTIONAL<AcGn6InterfaceInfo>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcGn6InterfaceInfo&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo from an unbound optional field.");
}
}

AcGn6InterfaceInfo_template::AcGn6InterfaceInfo_template(const AcGn6InterfaceInfo_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

AcGn6InterfaceInfo_template::~AcGn6InterfaceInfo_template()
{
clean_up();
}

AcGn6InterfaceInfo_template& AcGn6InterfaceInfo_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AcGn6InterfaceInfo_template& AcGn6InterfaceInfo_template::operator=(const AcGn6InterfaceInfo& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AcGn6InterfaceInfo_template& AcGn6InterfaceInfo_template::operator=(const OPTIONAL<AcGn6InterfaceInfo>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcGn6InterfaceInfo&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo.");
}
return *this;
}

AcGn6InterfaceInfo_template& AcGn6InterfaceInfo_template::operator=(const AcGn6InterfaceInfo_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AcGn6InterfaceInfo_template::match(const AcGn6InterfaceInfo& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.interfaceName().is_bound()) return FALSE;
if(!single_value->field_interfaceName.match(other_value.interfaceName(), legacy))return FALSE;
if(!other_value.ipv6AddressList().is_bound()) return FALSE;
if(!single_value->field_ipv6AddressList.match(other_value.ipv6AddressList(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo.");
}
return FALSE;
}

boolean AcGn6InterfaceInfo_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_interfaceName.is_bound()) return TRUE;
if (single_value->field_ipv6AddressList.is_bound()) return TRUE;
return FALSE;
}

boolean AcGn6InterfaceInfo_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_interfaceName.is_value()) return FALSE;
if (!single_value->field_ipv6AddressList.is_value()) return FALSE;
return TRUE;
}

void AcGn6InterfaceInfo_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AcGn6InterfaceInfo AcGn6InterfaceInfo_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo.");
AcGn6InterfaceInfo ret_val;
if (single_value->field_interfaceName.is_bound()) {
ret_val.interfaceName() = single_value->field_interfaceName.valueof();
}
if (single_value->field_ipv6AddressList.is_bound()) {
ret_val.ipv6AddressList() = single_value->field_ipv6AddressList.valueof();
}
return ret_val;
}

void AcGn6InterfaceInfo_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AcGn6InterfaceInfo_template[list_length];
}

AcGn6InterfaceInfo_template& AcGn6InterfaceInfo_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo.");
return value_list.list_value[list_index];
}

CHARSTRING_template& AcGn6InterfaceInfo_template::interfaceName()
{
set_specific();
return single_value->field_interfaceName;
}

const CHARSTRING_template& AcGn6InterfaceInfo_template::interfaceName() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field interfaceName of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo.");
return single_value->field_interfaceName;
}

Ipv6AddressList_template& AcGn6InterfaceInfo_template::ipv6AddressList()
{
set_specific();
return single_value->field_ipv6AddressList;
}

const Ipv6AddressList_template& AcGn6InterfaceInfo_template::ipv6AddressList() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field ipv6AddressList of a non-specific template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo.");
return single_value->field_ipv6AddressList;
}

int AcGn6InterfaceInfo_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo.");
  }
  return 0;
}

void AcGn6InterfaceInfo_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ interfaceName := ");
single_value->field_interfaceName.log();
TTCN_Logger::log_event_str(", ipv6AddressList := ");
single_value->field_ipv6AddressList.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AcGn6InterfaceInfo_template::log_match(const AcGn6InterfaceInfo& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_interfaceName.match(match_value.interfaceName(), legacy)){
TTCN_Logger::log_logmatch_info(".interfaceName");
single_value->field_interfaceName.log_match(match_value.interfaceName(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_ipv6AddressList.match(match_value.ipv6AddressList(), legacy)){
TTCN_Logger::log_logmatch_info(".ipv6AddressList");
single_value->field_ipv6AddressList.log_match(match_value.ipv6AddressList(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ interfaceName := ");
single_value->field_interfaceName.log_match(match_value.interfaceName(), legacy);
TTCN_Logger::log_event_str(", ipv6AddressList := ");
single_value->field_ipv6AddressList.log_match(match_value.ipv6AddressList(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AcGn6InterfaceInfo_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_interfaceName.encode_text(text_buf);
single_value->field_ipv6AddressList.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo.");
}
}

void AcGn6InterfaceInfo_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_interfaceName.decode_text(text_buf);
single_value->field_ipv6AddressList.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AcGn6InterfaceInfo_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo.");
}
}

void AcGn6InterfaceInfo_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo'");
    }
    if (strcmp("interfaceName", param_field) == 0) {
      interfaceName().set_param(param);
      return;
    } else if (strcmp("ipv6AddressList", param_field) == 0) {
      ipv6AddressList().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AcGn6InterfaceInfo_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) interfaceName().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) ipv6AddressList().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "interfaceName")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          interfaceName().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "ipv6AddressList")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          ipv6AddressList().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AcGn6InterfaceInfo_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo'");
    }
    if (strcmp("interfaceName", param_field) == 0) {
      return interfaceName().get_param(param_name);
    } else if (strcmp("ipv6AddressList", param_field) == 0) {
      return ipv6AddressList().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_interfaceName = single_value->field_interfaceName.get_param(param_name);
    mp_field_interfaceName->set_id(new Module_Param_FieldName(mcopystr("interfaceName")));
    mp->add_elem(mp_field_interfaceName);
    Module_Param* mp_field_ipv6AddressList = single_value->field_ipv6AddressList.get_param(param_name);
    mp_field_ipv6AddressList->set_id(new Module_Param_FieldName(mcopystr("ipv6AddressList")));
    mp->add_elem(mp_field_ipv6AddressList);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AcGn6InterfaceInfo_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_interfaceName.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo");
single_value->field_ipv6AddressList.check_restriction(t_res, t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfo");
}

boolean AcGn6InterfaceInfo_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AcGn6InterfaceInfo_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


/* Bodies of functions, altsteps and testcases */

boolean operator==(null_type, const GvlTable& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.GvlTable.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const AddressTable& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AddressTable.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const PrefixInfoList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.PrefixInfoList.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const AcGn6InterfaceInfoList& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsIpv6OverGeoNetworking_TypesAndValues.AcGn6InterfaceInfoList.");
return other_value.val_ptr->n_elements == 0;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "LibItsIpv6OverGeoNetworking_TypesAndValues");
LibCommon__BasicTypesAndValues::module_object.pre_init_module();
LibItsExternal__TypesAndValues::module_object.pre_init_module();
current_location.update_lineno(74);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 74 */
const_c__gvl1 = 0;
current_location.update_lineno(75);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 75 */
const_c__gvl2 = 1;
current_location.update_lineno(76);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 76 */
const_c__gvl3 = 2;
current_location.update_lineno(78);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 78 */
const_c__gvl1__name = cs_0;
current_location.update_lineno(79);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 79 */
const_c__gvl2__name = cs_1;
current_location.update_lineno(80);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 80 */
const_c__gvl3__name = cs_2;
current_location.update_lineno(82);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 82 */
const_c__gvlArea1 = cs_3;
current_location.update_lineno(83);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 83 */
const_c__gvlArea2 = cs_4;
current_location.update_lineno(84);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 84 */
const_c__gvlArea3 = cs_5;
current_location.update_lineno(90);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 90 */
const_c__macBroadcastAddr = os_0;
current_location.update_lineno(121);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 121 */
const_c__hopHdr = 0;
current_location.update_lineno(122);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 122 */
const_c__tcpHdr = 6;
current_location.update_lineno(123);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 123 */
const_c__udpHdr = 17;
current_location.update_lineno(124);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 124 */
const_c__tunneledIpHdr = 41;
current_location.update_lineno(125);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 125 */
const_c__routeHdr = 43;
current_location.update_lineno(126);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 126 */
const_c__fragHdr = 44;
current_location.update_lineno(127);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 127 */
const_c__espHdr = 50;
current_location.update_lineno(128);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 128 */
const_c__authHdr = 51;
current_location.update_lineno(129);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 129 */
const_c__icmpHdr = 58;
current_location.update_lineno(130);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 130 */
const_c__noNextHdr = 59;
current_location.update_lineno(131);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 131 */
const_c__dstHdr = 60;
current_location.update_lineno(132);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 132 */
const_c__mobileHdr = 135;
current_location.update_lineno(154);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 154 */
const_c__prefixInfo = 3;
current_location.update_lineno(155);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 155 */
const_c__rtAdvMsg = 134;
current_location.update_lineno(160);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 160 */
const_c__llaMcaPrefix = os_1;
current_location.update_lineno(161);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 161 */
const_c__llaPrefix = os_2;
current_location.update_lineno(163);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 163 */
const_c__allNodesMcaPostfix = os_3;
current_location.update_lineno(164);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 164 */
const_c__allRoutersMcaPostfix = os_4;
current_location.update_lineno(165);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 165 */
const_c__anycastPostfix = os_5;
current_location.update_lineno(166);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 166 */
const_c__haAnycastPostfix = os_6;
current_location.update_lineno(168);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 168 */
const_c__allNodesMca = os_7;
current_location.update_lineno(169);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 169 */
const_c__allRoutersMca = os_8;
current_location.update_lineno(171);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 171 */
const_c__unspecified = os_9;
current_location.update_lineno(174);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 174 */
const_c__itsGn6aslGeoAnycastID = bs_0;
current_location.update_lineno(243);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 243 */
const_c__maxNrPrefixInfo = 10;
current_location.update_lineno(244);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 244 */
const_c__rtAddrFlag0 = 0;
current_location.update_lineno(246);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 246 */
const_c__aFlag0 = 0;
current_location.update_lineno(247);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 247 */
const_c__aFlag1 = 1;
current_location.update_lineno(248);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 248 */
const_c__rFlag0 = 0;
current_location.update_lineno(249);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 249 */
const_c__rFlag1 = 1;
current_location.update_lineno(250);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 250 */
const_c__sFlag0 = 0;
current_location.update_lineno(251);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 251 */
const_c__sFlag1 = 1;
current_location.update_lineno(252);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 252 */
const_c__oFlag0 = 0;
current_location.update_lineno(253);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 253 */
const_c__oFlag1 = 1;
current_location.update_lineno(254);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 254 */
const_c__mFlag0 = 0;
current_location.update_lineno(255);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 255 */
const_c__mFlag1 = 1;
current_location.update_lineno(256);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 256 */
const_c__lFlag0 = 0;
current_location.update_lineno(257);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 257 */
const_c__lFlag1 = 1;
current_location.update_lineno(259);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 259 */
const_c__zeroLifetime = 0;
current_location.update_lineno(260);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 260 */
const_c__validLifetime20s = 20;
current_location.update_lineno(261);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 261 */
const_c__validLifetime30s = 30;
current_location.update_lineno(262);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 262 */
const_c__preferredLifetime30s = 30;
current_location.update_lineno(266);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 266 */
const_c__srcLinkLayerAddress = 1;
current_location.update_lineno(267);
/* LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn, line 267 */
const_c__prefixInfoLen = 4;
}

static void post_init_module()
{
TTCN_Location current_location("LibItsIpv6OverGeoNetworking_TypesAndValues.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "LibItsIpv6OverGeoNetworking_TypesAndValues");
LibCommon__BasicTypesAndValues::module_object.post_init_module();
LibItsExternal__TypesAndValues::module_object.post_init_module();
}


} /* end of namespace */
