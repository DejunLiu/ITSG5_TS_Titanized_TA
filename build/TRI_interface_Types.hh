// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef TRI__interface__Types_HH
#define TRI__interface__Types_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 50400
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef TRI__interface__Types_HH
#endif

namespace TRI__interface__Types {

/* Forward declarations of classes */

class Result__value;
class Result__value_template;
class TriComponentIdType;
class TriComponentIdType_template;
class TriPortIdType;
class TriPortIdType_template;
class TriAddressType;
class TriAddressType_template;
class msg__data__container;
class msg__data__container_template;
class Type__Value__container;
class Type__Value__container_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__OCTETSTRING Type__info__list;
typedef PreGenRecordOf::PREGEN__RECORD__OF__OCTETSTRING_template Type__info__list_template;
class Result;
class Result_template;
class Register;
class Register_template;
class Map;
class Map_template;
class UnMap;
class UnMap_template;
class Unregister;
class Unregister_template;
class SendMsg;
class SendMsg_template;
class EnqueueMsg;
class EnqueueMsg_template;
class Msg__union;
class Msg__union_template;
class TRI__mapper__PDU;
class TRI__mapper__PDU_template;

} /* end of namespace */

#ifndef TRI__interface__Types_HH
#define TRI__interface__Types_HH

namespace TRI__interface__Types {

/* Type definitions */

typedef OCTETSTRING type__info;
typedef OCTETSTRING_template type__info_template;
typedef OCTETSTRING value__info;
typedef OCTETSTRING_template value__info_template;

/* Class definitions */

class Result__value : public Base_Type { // enum
friend class Result__value_template;
public:
enum enum_type { TRI__ok = 0, TRI__error = 1, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
Result__value();
Result__value(int other_value);
Result__value(enum_type other_value);
Result__value(const Result__value& other_value);

Result__value& operator=(int other_value);
Result__value& operator=(enum_type other_value);
Result__value& operator=(const Result__value& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const Result__value& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Result__value& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const Result__value& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const Result__value& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const Result__value& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const Result__value& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const Result__value& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Result__value_template : public Base_Template {
union {
Result__value::enum_type single_value;
struct {
unsigned int n_values;
Result__value_template *list_value;
} value_list;
};

void copy_template(const Result__value_template& other_value);

public:
Result__value_template();
Result__value_template(template_sel other_value);
Result__value_template(int other_value);
Result__value_template(Result__value::enum_type other_value);
Result__value_template(const Result__value& other_value);
Result__value_template(const OPTIONAL<Result__value>& other_value);
Result__value_template(const Result__value_template& other_value);
~Result__value_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
Result__value_template& operator=(template_sel other_value);
Result__value_template& operator=(int other_value);
Result__value_template& operator=(Result__value::enum_type other_value);
Result__value_template& operator=(const Result__value& other_value);
Result__value_template& operator=(const OPTIONAL<Result__value>& other_value);
Result__value_template& operator=(const Result__value_template& other_value);

boolean match(Result__value::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const Result__value& other_value, boolean legacy = FALSE) const;
Result__value::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Result__value_template& list_item(unsigned int list_index);
void log() const;
void log_match(const Result__value& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class TriComponentIdType : public Base_Type {
  OCTETSTRING field_componentId;
  CHARSTRING field_componentName;
  CHARSTRING field_componentTypeName;
  boolean bound_flag;
public:
  TriComponentIdType();
  TriComponentIdType(const OCTETSTRING& par_componentId,
    const CHARSTRING& par_componentName,
    const CHARSTRING& par_componentTypeName);
  TriComponentIdType(const TriComponentIdType& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TriComponentIdType& operator=(const TriComponentIdType& other_value);
  boolean operator==(const TriComponentIdType& other_value) const;
  inline boolean operator!=(const TriComponentIdType& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& componentId()
    {return field_componentId;}
  inline const OCTETSTRING& componentId() const
    {return field_componentId;}
  inline CHARSTRING& componentName()
    {return field_componentName;}
  inline const CHARSTRING& componentName() const
    {return field_componentName;}
  inline CHARSTRING& componentTypeName()
    {return field_componentTypeName;}
  inline const CHARSTRING& componentTypeName() const
    {return field_componentTypeName;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TriComponentIdType_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TriComponentIdType_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TriComponentIdType& other_value);
void copy_template(const TriComponentIdType_template& other_value);

public:
TriComponentIdType_template();
TriComponentIdType_template(template_sel other_value);
TriComponentIdType_template(const TriComponentIdType& other_value);
TriComponentIdType_template(const OPTIONAL<TriComponentIdType>& other_value);
TriComponentIdType_template(const TriComponentIdType_template& other_value);
~TriComponentIdType_template();
TriComponentIdType_template& operator=(template_sel other_value);
TriComponentIdType_template& operator=(const TriComponentIdType& other_value);
TriComponentIdType_template& operator=(const OPTIONAL<TriComponentIdType>& other_value);
TriComponentIdType_template& operator=(const TriComponentIdType_template& other_value);
boolean match(const TriComponentIdType& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TriComponentIdType valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TriComponentIdType_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& componentId();
const OCTETSTRING_template& componentId() const;
CHARSTRING_template& componentName();
const CHARSTRING_template& componentName() const;
CHARSTRING_template& componentTypeName();
const CHARSTRING_template& componentTypeName() const;
int size_of() const;
void log() const;
void log_match(const TriComponentIdType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TriPortIdType : public Base_Type {
  CHARSTRING field_portName;
  CHARSTRING field_portTypeName;
  TriComponentIdType field_component__;
  OPTIONAL<INTEGER> field_portindex;
  boolean bound_flag;
public:
  TriPortIdType();
  TriPortIdType(const CHARSTRING& par_portName,
    const CHARSTRING& par_portTypeName,
    const TriComponentIdType& par_component__,
    const OPTIONAL<INTEGER>& par_portindex);
  TriPortIdType(const TriPortIdType& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TriPortIdType& operator=(const TriPortIdType& other_value);
  boolean operator==(const TriPortIdType& other_value) const;
  inline boolean operator!=(const TriPortIdType& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& portName()
    {return field_portName;}
  inline const CHARSTRING& portName() const
    {return field_portName;}
  inline CHARSTRING& portTypeName()
    {return field_portTypeName;}
  inline const CHARSTRING& portTypeName() const
    {return field_portTypeName;}
  inline TriComponentIdType& component__()
    {return field_component__;}
  inline const TriComponentIdType& component__() const
    {return field_component__;}
  inline OPTIONAL<INTEGER>& portindex()
    {return field_portindex;}
  inline const OPTIONAL<INTEGER>& portindex() const
    {return field_portindex;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TriPortIdType_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TriPortIdType_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TriPortIdType& other_value);
void copy_template(const TriPortIdType_template& other_value);

public:
TriPortIdType_template();
TriPortIdType_template(template_sel other_value);
TriPortIdType_template(const TriPortIdType& other_value);
TriPortIdType_template(const OPTIONAL<TriPortIdType>& other_value);
TriPortIdType_template(const TriPortIdType_template& other_value);
~TriPortIdType_template();
TriPortIdType_template& operator=(template_sel other_value);
TriPortIdType_template& operator=(const TriPortIdType& other_value);
TriPortIdType_template& operator=(const OPTIONAL<TriPortIdType>& other_value);
TriPortIdType_template& operator=(const TriPortIdType_template& other_value);
boolean match(const TriPortIdType& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TriPortIdType valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TriPortIdType_template& list_item(unsigned int list_index) const;
CHARSTRING_template& portName();
const CHARSTRING_template& portName() const;
CHARSTRING_template& portTypeName();
const CHARSTRING_template& portTypeName() const;
TriComponentIdType_template& component__();
const TriComponentIdType_template& component__() const;
INTEGER_template& portindex();
const INTEGER_template& portindex() const;
int size_of() const;
void log() const;
void log_match(const TriPortIdType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TriAddressType : public Base_Type {
  OCTETSTRING field_sut__address;
  boolean bound_flag;
public:
  TriAddressType();
  TriAddressType(const OCTETSTRING& par_sut__address);
  TriAddressType(const TriAddressType& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TriAddressType& operator=(const TriAddressType& other_value);
  boolean operator==(const TriAddressType& other_value) const;
  inline boolean operator!=(const TriAddressType& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& sut__address()
    {return field_sut__address;}
  inline const OCTETSTRING& sut__address() const
    {return field_sut__address;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TriAddressType_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TriAddressType_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TriAddressType& other_value);
void copy_template(const TriAddressType_template& other_value);

public:
TriAddressType_template();
TriAddressType_template(template_sel other_value);
TriAddressType_template(const TriAddressType& other_value);
TriAddressType_template(const OPTIONAL<TriAddressType>& other_value);
TriAddressType_template(const TriAddressType_template& other_value);
~TriAddressType_template();
TriAddressType_template& operator=(template_sel other_value);
TriAddressType_template& operator=(const TriAddressType& other_value);
TriAddressType_template& operator=(const OPTIONAL<TriAddressType>& other_value);
TriAddressType_template& operator=(const TriAddressType_template& other_value);
boolean match(const TriAddressType& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TriAddressType valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TriAddressType_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& sut__address();
const OCTETSTRING_template& sut__address() const;
int size_of() const;
void log() const;
void log_match(const TriAddressType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class msg__data__container : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_encoded__data = 1, ALT_tv__data = 2 };
private:
union_selection_type union_selection;
union {
OCTETSTRING *field_encoded__data;
Type__Value__container *field_tv__data;
};
void copy_value(const msg__data__container& other_value);

public:
msg__data__container();
msg__data__container(const msg__data__container& other_value);
~msg__data__container();
msg__data__container& operator=(const msg__data__container& other_value);
boolean operator==(const msg__data__container& other_value) const;
inline boolean operator!=(const msg__data__container& other_value) const { return !(*this == other_value); }
OCTETSTRING& encoded__data();
const OCTETSTRING& encoded__data() const;
Type__Value__container& tv__data();
const Type__Value__container& tv__data() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class msg__data__container_template : public Base_Template {
union {
struct {
msg__data__container::union_selection_type union_selection;
union {
OCTETSTRING_template *field_encoded__data;
Type__Value__container_template *field_tv__data;
};
} single_value;
struct {
unsigned int n_values;
msg__data__container_template *list_value;
} value_list;
};
void copy_value(const msg__data__container& other_value);

void copy_template(const msg__data__container_template& other_value);

public:
msg__data__container_template();
msg__data__container_template(template_sel other_value);
msg__data__container_template(const msg__data__container& other_value);
msg__data__container_template(const OPTIONAL<msg__data__container>& other_value);
msg__data__container_template(const msg__data__container_template& other_value);
~msg__data__container_template();
void clean_up();
msg__data__container_template& operator=(template_sel other_value);
msg__data__container_template& operator=(const msg__data__container& other_value);
msg__data__container_template& operator=(const OPTIONAL<msg__data__container>& other_value);
msg__data__container_template& operator=(const msg__data__container_template& other_value);
boolean match(const msg__data__container& other_value, boolean legacy = FALSE) const;
boolean is_value() const;msg__data__container valueof() const;
msg__data__container_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
OCTETSTRING_template& encoded__data();
const OCTETSTRING_template& encoded__data() const;
Type__Value__container_template& tv__data();
const Type__Value__container_template& tv__data() const;
boolean ischosen(msg__data__container::union_selection_type checked_selection) const;
void log() const;
void log_match(const msg__data__container& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class Type__Value__container : public Base_Type {
  OCTETSTRING field_msg__type;
  OCTETSTRING field_msg__value;
  boolean bound_flag;
public:
  Type__Value__container();
  Type__Value__container(const OCTETSTRING& par_msg__type,
    const OCTETSTRING& par_msg__value);
  Type__Value__container(const Type__Value__container& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Type__Value__container& operator=(const Type__Value__container& other_value);
  boolean operator==(const Type__Value__container& other_value) const;
  inline boolean operator!=(const Type__Value__container& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& msg__type()
    {return field_msg__type;}
  inline const OCTETSTRING& msg__type() const
    {return field_msg__type;}
  inline OCTETSTRING& msg__value()
    {return field_msg__value;}
  inline const OCTETSTRING& msg__value() const
    {return field_msg__value;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Type__Value__container_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Type__Value__container_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Type__Value__container& other_value);
void copy_template(const Type__Value__container_template& other_value);

public:
Type__Value__container_template();
Type__Value__container_template(template_sel other_value);
Type__Value__container_template(const Type__Value__container& other_value);
Type__Value__container_template(const OPTIONAL<Type__Value__container>& other_value);
Type__Value__container_template(const Type__Value__container_template& other_value);
~Type__Value__container_template();
Type__Value__container_template& operator=(template_sel other_value);
Type__Value__container_template& operator=(const Type__Value__container& other_value);
Type__Value__container_template& operator=(const OPTIONAL<Type__Value__container>& other_value);
Type__Value__container_template& operator=(const Type__Value__container_template& other_value);
boolean match(const Type__Value__container& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Type__Value__container valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Type__Value__container_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& msg__type();
const OCTETSTRING_template& msg__type() const;
OCTETSTRING_template& msg__value();
const OCTETSTRING_template& msg__value() const;
int size_of() const;
void log() const;
void log_match(const Type__Value__container& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Result : public Base_Type {
  Result__value field_result;
  OPTIONAL<CHARSTRING> field_result__string;
  boolean bound_flag;
public:
  Result();
  Result(const Result__value& par_result,
    const OPTIONAL<CHARSTRING>& par_result__string);
  Result(const Result& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Result& operator=(const Result& other_value);
  boolean operator==(const Result& other_value) const;
  inline boolean operator!=(const Result& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline Result__value& result()
    {return field_result;}
  inline const Result__value& result() const
    {return field_result;}
  inline OPTIONAL<CHARSTRING>& result__string()
    {return field_result__string;}
  inline const OPTIONAL<CHARSTRING>& result__string() const
    {return field_result__string;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Result_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Result_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Result& other_value);
void copy_template(const Result_template& other_value);

public:
Result_template();
Result_template(template_sel other_value);
Result_template(const Result& other_value);
Result_template(const OPTIONAL<Result>& other_value);
Result_template(const Result_template& other_value);
~Result_template();
Result_template& operator=(template_sel other_value);
Result_template& operator=(const Result& other_value);
Result_template& operator=(const OPTIONAL<Result>& other_value);
Result_template& operator=(const Result_template& other_value);
boolean match(const Result& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Result valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Result_template& list_item(unsigned int list_index) const;
Result__value_template& result();
const Result__value_template& result() const;
CHARSTRING_template& result__string();
const CHARSTRING_template& result__string() const;
int size_of() const;
void log() const;
void log_match(const Result& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Register : public Base_Type {
  TriPortIdType field_portid;
  OPTIONAL<Type__info__list> field_type__list;
  boolean bound_flag;
public:
  Register();
  Register(const TriPortIdType& par_portid,
    const OPTIONAL<Type__info__list>& par_type__list);
  Register(const Register& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Register& operator=(const Register& other_value);
  boolean operator==(const Register& other_value) const;
  inline boolean operator!=(const Register& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline TriPortIdType& portid()
    {return field_portid;}
  inline const TriPortIdType& portid() const
    {return field_portid;}
  inline OPTIONAL<Type__info__list>& type__list()
    {return field_type__list;}
  inline const OPTIONAL<Type__info__list>& type__list() const
    {return field_type__list;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Register_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Register_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Register& other_value);
void copy_template(const Register_template& other_value);

public:
Register_template();
Register_template(template_sel other_value);
Register_template(const Register& other_value);
Register_template(const OPTIONAL<Register>& other_value);
Register_template(const Register_template& other_value);
~Register_template();
Register_template& operator=(template_sel other_value);
Register_template& operator=(const Register& other_value);
Register_template& operator=(const OPTIONAL<Register>& other_value);
Register_template& operator=(const Register_template& other_value);
boolean match(const Register& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Register valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Register_template& list_item(unsigned int list_index) const;
TriPortIdType_template& portid();
const TriPortIdType_template& portid() const;
Type__info__list_template& type__list();
const Type__info__list_template& type__list() const;
int size_of() const;
void log() const;
void log_match(const Register& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Map : public Base_Type {
  TriPortIdType field_portid;
  boolean bound_flag;
public:
  Map();
  Map(const TriPortIdType& par_portid);
  Map(const Map& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Map& operator=(const Map& other_value);
  boolean operator==(const Map& other_value) const;
  inline boolean operator!=(const Map& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline TriPortIdType& portid()
    {return field_portid;}
  inline const TriPortIdType& portid() const
    {return field_portid;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Map_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Map_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Map& other_value);
void copy_template(const Map_template& other_value);

public:
Map_template();
Map_template(template_sel other_value);
Map_template(const Map& other_value);
Map_template(const OPTIONAL<Map>& other_value);
Map_template(const Map_template& other_value);
~Map_template();
Map_template& operator=(template_sel other_value);
Map_template& operator=(const Map& other_value);
Map_template& operator=(const OPTIONAL<Map>& other_value);
Map_template& operator=(const Map_template& other_value);
boolean match(const Map& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Map valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Map_template& list_item(unsigned int list_index) const;
TriPortIdType_template& portid();
const TriPortIdType_template& portid() const;
int size_of() const;
void log() const;
void log_match(const Map& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UnMap : public Base_Type {
boolean bound_flag;
public:
UnMap();
UnMap(null_type other_value);
UnMap(const UnMap& other_value);
UnMap& operator=(null_type other_value);
UnMap& operator=(const UnMap& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const UnMap& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const UnMap& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UnMap_template : public Base_Template {
struct {
unsigned int n_values;
UnMap_template *list_value;
} value_list;
void copy_template(const UnMap_template& other_value);

public:
UnMap_template();
UnMap_template(template_sel other_value);
UnMap_template(null_type other_value);
UnMap_template(const UnMap& other_value);
UnMap_template(const OPTIONAL<UnMap>& other_value);
UnMap_template(const UnMap_template& other_value);
~UnMap_template();
void clean_up();
UnMap_template& operator=(template_sel other_value);
UnMap_template& operator=(null_type other_value);
UnMap_template& operator=(const UnMap& other_value);
UnMap_template& operator=(const OPTIONAL<UnMap>& other_value);
UnMap_template& operator=(const UnMap_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const UnMap& other_value, boolean legacy = FALSE) const;
UnMap valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UnMap_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const UnMap& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Unregister : public Base_Type {
boolean bound_flag;
public:
Unregister();
Unregister(null_type other_value);
Unregister(const Unregister& other_value);
Unregister& operator=(null_type other_value);
Unregister& operator=(const Unregister& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const Unregister& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Unregister& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Unregister_template : public Base_Template {
struct {
unsigned int n_values;
Unregister_template *list_value;
} value_list;
void copy_template(const Unregister_template& other_value);

public:
Unregister_template();
Unregister_template(template_sel other_value);
Unregister_template(null_type other_value);
Unregister_template(const Unregister& other_value);
Unregister_template(const OPTIONAL<Unregister>& other_value);
Unregister_template(const Unregister_template& other_value);
~Unregister_template();
void clean_up();
Unregister_template& operator=(template_sel other_value);
Unregister_template& operator=(null_type other_value);
Unregister_template& operator=(const Unregister& other_value);
Unregister_template& operator=(const OPTIONAL<Unregister>& other_value);
Unregister_template& operator=(const Unregister_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const Unregister& other_value, boolean legacy = FALSE) const;
Unregister valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Unregister_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const Unregister& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SendMsg : public Base_Type {
  OPTIONAL<TriAddressType> field_addr;
  msg__data__container field_data;
  boolean bound_flag;
public:
  SendMsg();
  SendMsg(const OPTIONAL<TriAddressType>& par_addr,
    const msg__data__container& par_data);
  SendMsg(const SendMsg& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SendMsg& operator=(const SendMsg& other_value);
  boolean operator==(const SendMsg& other_value) const;
  inline boolean operator!=(const SendMsg& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<TriAddressType>& addr()
    {return field_addr;}
  inline const OPTIONAL<TriAddressType>& addr() const
    {return field_addr;}
  inline msg__data__container& data()
    {return field_data;}
  inline const msg__data__container& data() const
    {return field_data;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SendMsg_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SendMsg_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SendMsg& other_value);
void copy_template(const SendMsg_template& other_value);

public:
SendMsg_template();
SendMsg_template(template_sel other_value);
SendMsg_template(const SendMsg& other_value);
SendMsg_template(const OPTIONAL<SendMsg>& other_value);
SendMsg_template(const SendMsg_template& other_value);
~SendMsg_template();
SendMsg_template& operator=(template_sel other_value);
SendMsg_template& operator=(const SendMsg& other_value);
SendMsg_template& operator=(const OPTIONAL<SendMsg>& other_value);
SendMsg_template& operator=(const SendMsg_template& other_value);
boolean match(const SendMsg& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SendMsg valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SendMsg_template& list_item(unsigned int list_index) const;
TriAddressType_template& addr();
const TriAddressType_template& addr() const;
msg__data__container_template& data();
const msg__data__container_template& data() const;
int size_of() const;
void log() const;
void log_match(const SendMsg& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class EnqueueMsg : public Base_Type {
  OPTIONAL<TriAddressType> field_addr;
  msg__data__container field_data;
  boolean bound_flag;
public:
  EnqueueMsg();
  EnqueueMsg(const OPTIONAL<TriAddressType>& par_addr,
    const msg__data__container& par_data);
  EnqueueMsg(const EnqueueMsg& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  EnqueueMsg& operator=(const EnqueueMsg& other_value);
  boolean operator==(const EnqueueMsg& other_value) const;
  inline boolean operator!=(const EnqueueMsg& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<TriAddressType>& addr()
    {return field_addr;}
  inline const OPTIONAL<TriAddressType>& addr() const
    {return field_addr;}
  inline msg__data__container& data()
    {return field_data;}
  inline const msg__data__container& data() const
    {return field_data;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class EnqueueMsg_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
EnqueueMsg_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const EnqueueMsg& other_value);
void copy_template(const EnqueueMsg_template& other_value);

public:
EnqueueMsg_template();
EnqueueMsg_template(template_sel other_value);
EnqueueMsg_template(const EnqueueMsg& other_value);
EnqueueMsg_template(const OPTIONAL<EnqueueMsg>& other_value);
EnqueueMsg_template(const EnqueueMsg_template& other_value);
~EnqueueMsg_template();
EnqueueMsg_template& operator=(template_sel other_value);
EnqueueMsg_template& operator=(const EnqueueMsg& other_value);
EnqueueMsg_template& operator=(const OPTIONAL<EnqueueMsg>& other_value);
EnqueueMsg_template& operator=(const EnqueueMsg_template& other_value);
boolean match(const EnqueueMsg& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
EnqueueMsg valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EnqueueMsg_template& list_item(unsigned int list_index) const;
TriAddressType_template& addr();
const TriAddressType_template& addr() const;
msg__data__container_template& data();
const msg__data__container_template& data() const;
int size_of() const;
void log() const;
void log_match(const EnqueueMsg& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Msg__union : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_result = 1, ALT_reg = 2, ALT_mapped = 3, ALT_unmapped = 4, ALT_unregister = 5, ALT_sendmsg = 6, ALT_enqueue__msg = 7 };
private:
union_selection_type union_selection;
union {
Result *field_result;
Register *field_reg;
Map *field_mapped;
UnMap *field_unmapped;
Unregister *field_unregister;
SendMsg *field_sendmsg;
EnqueueMsg *field_enqueue__msg;
};
void copy_value(const Msg__union& other_value);

public:
Msg__union();
Msg__union(const Msg__union& other_value);
~Msg__union();
Msg__union& operator=(const Msg__union& other_value);
boolean operator==(const Msg__union& other_value) const;
inline boolean operator!=(const Msg__union& other_value) const { return !(*this == other_value); }
Result& result();
const Result& result() const;
Register& reg();
const Register& reg() const;
Map& mapped();
const Map& mapped() const;
UnMap& unmapped();
const UnMap& unmapped() const;
Unregister& unregister();
const Unregister& unregister() const;
SendMsg& sendmsg();
const SendMsg& sendmsg() const;
EnqueueMsg& enqueue__msg();
const EnqueueMsg& enqueue__msg() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Msg__union_template : public Base_Template {
union {
struct {
Msg__union::union_selection_type union_selection;
union {
Result_template *field_result;
Register_template *field_reg;
Map_template *field_mapped;
UnMap_template *field_unmapped;
Unregister_template *field_unregister;
SendMsg_template *field_sendmsg;
EnqueueMsg_template *field_enqueue__msg;
};
} single_value;
struct {
unsigned int n_values;
Msg__union_template *list_value;
} value_list;
};
void copy_value(const Msg__union& other_value);

void copy_template(const Msg__union_template& other_value);

public:
Msg__union_template();
Msg__union_template(template_sel other_value);
Msg__union_template(const Msg__union& other_value);
Msg__union_template(const OPTIONAL<Msg__union>& other_value);
Msg__union_template(const Msg__union_template& other_value);
~Msg__union_template();
void clean_up();
Msg__union_template& operator=(template_sel other_value);
Msg__union_template& operator=(const Msg__union& other_value);
Msg__union_template& operator=(const OPTIONAL<Msg__union>& other_value);
Msg__union_template& operator=(const Msg__union_template& other_value);
boolean match(const Msg__union& other_value, boolean legacy = FALSE) const;
boolean is_value() const;Msg__union valueof() const;
Msg__union_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
Result_template& result();
const Result_template& result() const;
Register_template& reg();
const Register_template& reg() const;
Map_template& mapped();
const Map_template& mapped() const;
UnMap_template& unmapped();
const UnMap_template& unmapped() const;
Unregister_template& unregister();
const Unregister_template& unregister() const;
SendMsg_template& sendmsg();
const SendMsg_template& sendmsg() const;
EnqueueMsg_template& enqueue__msg();
const EnqueueMsg_template& enqueue__msg() const;
boolean ischosen(Msg__union::union_selection_type checked_selection) const;
void log() const;
void log_match(const Msg__union& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class TRI__mapper__PDU : public Base_Type {
  INTEGER field_msg__id;
  Msg__union field_msg;
  boolean bound_flag;
public:
  TRI__mapper__PDU();
  TRI__mapper__PDU(const INTEGER& par_msg__id,
    const Msg__union& par_msg);
  TRI__mapper__PDU(const TRI__mapper__PDU& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TRI__mapper__PDU& operator=(const TRI__mapper__PDU& other_value);
  boolean operator==(const TRI__mapper__PDU& other_value) const;
  inline boolean operator!=(const TRI__mapper__PDU& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& msg__id()
    {return field_msg__id;}
  inline const INTEGER& msg__id() const
    {return field_msg__id;}
  inline Msg__union& msg()
    {return field_msg;}
  inline const Msg__union& msg() const
    {return field_msg;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TRI__mapper__PDU_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TRI__mapper__PDU_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TRI__mapper__PDU& other_value);
void copy_template(const TRI__mapper__PDU_template& other_value);

public:
TRI__mapper__PDU_template();
TRI__mapper__PDU_template(template_sel other_value);
TRI__mapper__PDU_template(const TRI__mapper__PDU& other_value);
TRI__mapper__PDU_template(const OPTIONAL<TRI__mapper__PDU>& other_value);
TRI__mapper__PDU_template(const TRI__mapper__PDU_template& other_value);
~TRI__mapper__PDU_template();
TRI__mapper__PDU_template& operator=(template_sel other_value);
TRI__mapper__PDU_template& operator=(const TRI__mapper__PDU& other_value);
TRI__mapper__PDU_template& operator=(const OPTIONAL<TRI__mapper__PDU>& other_value);
TRI__mapper__PDU_template& operator=(const TRI__mapper__PDU_template& other_value);
boolean match(const TRI__mapper__PDU& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TRI__mapper__PDU valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TRI__mapper__PDU_template& list_item(unsigned int list_index) const;
INTEGER_template& msg__id();
const INTEGER_template& msg__id() const;
Msg__union_template& msg();
const Msg__union_template& msg() const;
int size_of() const;
void log() const;
void log_match(const TRI__mapper__PDU& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern OCTETSTRING TRI__encode(const TRI__mapper__PDU& pdu);
extern INTEGER TRI__decode(const OCTETSTRING& stream, TRI__mapper__PDU& pdu);
extern boolean operator==(null_type null_value, const UnMap& other_value);
inline boolean operator!=(null_type null_value, const UnMap& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Unregister& other_value);
inline boolean operator!=(null_type null_value, const Unregister& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const TTCN_JSONdescriptor_t Result__value_json_;
extern const TTCN_Typedescriptor_t Result__value_descr_;
extern const XERdescriptor_t TriComponentIdType_componentId_xer_;
extern const TTCN_Typedescriptor_t TriComponentIdType_componentId_descr_;
extern const XERdescriptor_t TriComponentIdType_componentName_xer_;
extern const TTCN_Typedescriptor_t TriComponentIdType_componentName_descr_;
extern const XERdescriptor_t TriComponentIdType_componentTypeName_xer_;
extern const TTCN_Typedescriptor_t TriComponentIdType_componentTypeName_descr_;
extern const TTCN_JSONdescriptor_t TriComponentIdType_json_;
extern const TTCN_Typedescriptor_t TriComponentIdType_descr_;
extern const XERdescriptor_t TriPortIdType_portName_xer_;
extern const TTCN_Typedescriptor_t TriPortIdType_portName_descr_;
extern const XERdescriptor_t TriPortIdType_portTypeName_xer_;
extern const TTCN_Typedescriptor_t TriPortIdType_portTypeName_descr_;
extern const TTCN_JSONdescriptor_t TriPortIdType_json_;
extern const TTCN_Typedescriptor_t TriPortIdType_descr_;
extern const XERdescriptor_t TriPortIdType_portindex_xer_;
extern const TTCN_Typedescriptor_t TriPortIdType_portindex_descr_;
extern const XERdescriptor_t TriAddressType_sut__address_xer_;
extern const TTCN_Typedescriptor_t TriAddressType_sut__address_descr_;
extern const TTCN_JSONdescriptor_t TriAddressType_json_;
extern const TTCN_Typedescriptor_t TriAddressType_descr_;
extern const TTCN_JSONdescriptor_t msg__data__container_json_;
extern const TTCN_Typedescriptor_t msg__data__container_descr_;
extern const XERdescriptor_t msg__data__container_encoded__data_xer_;
extern const TTCN_Typedescriptor_t msg__data__container_encoded__data_descr_;
extern const XERdescriptor_t type__info_xer_;
extern const TTCN_Typedescriptor_t type__info_descr_;
extern const XERdescriptor_t Type__Value__container_msg__type_xer_;
extern const TTCN_Typedescriptor_t Type__Value__container_msg__type_descr_;
extern const XERdescriptor_t value__info_xer_;
extern const TTCN_Typedescriptor_t value__info_descr_;
extern const XERdescriptor_t Type__Value__container_msg__value_xer_;
extern const TTCN_Typedescriptor_t Type__Value__container_msg__value_descr_;
extern const TTCN_JSONdescriptor_t Type__Value__container_json_;
extern const TTCN_Typedescriptor_t Type__Value__container_descr_;
extern const TTCN_JSONdescriptor_t Type__info__list_json_;
extern const TTCN_Typedescriptor_t Type__info__list_descr_;
extern const XERdescriptor_t Type__info__list_0_xer_;
extern const TTCN_Typedescriptor_t Type__info__list_0_descr_;
extern const TTCN_JSONdescriptor_t Result_json_;
extern const TTCN_Typedescriptor_t Result_descr_;
extern const XERdescriptor_t Result_result__string_xer_;
extern const TTCN_Typedescriptor_t Result_result__string_descr_;
extern const TTCN_JSONdescriptor_t Register_json_;
extern const TTCN_Typedescriptor_t Register_descr_;
extern const TTCN_JSONdescriptor_t Map_json_;
extern const TTCN_Typedescriptor_t Map_descr_;
extern const TTCN_JSONdescriptor_t UnMap_json_;
extern const TTCN_Typedescriptor_t UnMap_descr_;
extern const TTCN_JSONdescriptor_t Unregister_json_;
extern const TTCN_Typedescriptor_t Unregister_descr_;
extern const TTCN_JSONdescriptor_t SendMsg_json_;
extern const TTCN_Typedescriptor_t SendMsg_descr_;
extern const TTCN_JSONdescriptor_t EnqueueMsg_json_;
extern const TTCN_Typedescriptor_t EnqueueMsg_descr_;
extern const XERdescriptor_t TRI__mapper__PDU_msg__id_xer_;
extern const TTCN_Typedescriptor_t TRI__mapper__PDU_msg__id_descr_;
extern const TTCN_JSONdescriptor_t Msg__union_json_;
extern const TTCN_Typedescriptor_t Msg__union_descr_;
extern const TTCN_JSONdescriptor_t TRI__mapper__PDU_json_;
extern const TTCN_Typedescriptor_t TRI__mapper__PDU_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
