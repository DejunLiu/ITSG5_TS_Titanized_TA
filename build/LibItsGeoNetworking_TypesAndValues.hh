// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef LibItsGeoNetworking__TypesAndValues_HH
#define LibItsGeoNetworking__TypesAndValues_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "LibItsCommon_TypesAndValues.hh"
#include "LibItsBtp_TypesAndValues.hh"
#include "LibItsIpv6OverGeoNetworking_TypesAndValues.hh"
#include "LibItsSecurity_TypesAndValues.hh"

#if TTCN3_VERSION != 50400
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef LibItsGeoNetworking__TypesAndValues_HH
#endif

namespace LibItsGeoNetworking__TypesAndValues {

/* Forward declarations of classes */

class TypeOfAddress;
class TypeOfAddress_template;
class StationType;
class StationType_template;
class GN__Address;
class GN__Address_template;
class LongPosVector;
class LongPosVector_template;
class PositionEntry;
class PositionEntry_template;
class PositionTable;
class PositionTable_template;
class Area;
class Area_template;
class HeaderSubTypeGeoBroadcast;
class HeaderSubTypeGeoBroadcast_template;
class GeoBroadcastArea;
class GeoBroadcastArea_template;
class HeaderSubTypeGeoAnycast;
class HeaderSubTypeGeoAnycast_template;
class GeoAnycastArea;
class GeoAnycastArea_template;
class GeoShape;
class GeoShape_template;
class GeoArea;
class GeoArea_template;
class GeoAreaEntry;
class GeoAreaEntry_template;
class GeoAreaTable;
class GeoAreaTable_template;
class BasicNextHeader;
class BasicNextHeader_template;
class LtBase;
class LtBase_template;
class Lifetime;
class Lifetime_template;
class BasicHeader;
class BasicHeader_template;
class NextHeader;
class NextHeader_template;
class HeaderTST;
class HeaderTST_template;
class HeaderType;
class HeaderType_template;
class AnyHeaderType;
class AnyHeaderType_template;
class BeaconHeaderType;
class BeaconHeaderType_template;
class GeoUnicastHeaderType;
class GeoUnicastHeaderType_template;
class GeoAnycastHeaderType;
class GeoAnycastHeaderType_template;
class GeoBroadcastHeaderType;
class GeoBroadcastHeaderType_template;
class HeaderSubTypeTSB;
class HeaderSubTypeTSB_template;
class TsbHeaderType;
class TsbHeaderType_template;
class HeaderSubTypeLs;
class HeaderSubTypeLs_template;
class LsHeaderType;
class LsHeaderType_template;
class HeaderSubTypeSa;
class HeaderSubTypeSa_template;
class SaHeaderType;
class SaHeaderType_template;
class SCF;
class SCF_template;
class ChannelOffload;
class ChannelOffload_template;
class TrafficClass;
class TrafficClass_template;
class CommonHeader;
class CommonHeader_template;
class GnNonSecuredPacket;
class GnNonSecuredPacket_template;
class ExtendedHeader;
class ExtendedHeader_template;
class ShortPosVector;
class ShortPosVector_template;
class GeoUnicastHeader;
class GeoUnicastHeader_template;
class TSBHeader;
class TSBHeader_template;
class SHBHeader;
class SHBHeader_template;
class GeoAnycastHeader;
class GeoAnycastHeader_template;
class BeaconHeader;
class BeaconHeader_template;
class LSRequestHeader;
class LSRequestHeader_template;
class LSReplyHeader;
class LSReplyHeader_template;
class AnyHeader;
class AnyHeader_template;
class Payload;
class Payload_template;
class DecodedPayload;
class DecodedPayload_template;
class GeoNetworkingPacket;
class GeoNetworkingPacket_template;
class GeoNetworkingPdu;
class GeoNetworkingPdu_template;
class GeoUnicastForwardingAlgorithm;
class GeoUnicastForwardingAlgorithm_template;
class GeoBroadcastForwardingAlgorithm;
class GeoBroadcastForwardingAlgorithm_template;
class GnAddressConfigurationMethod;
class GnAddressConfigurationMethod_template;
class UtGnTrigger;
class UtGnTrigger_template;
class GenerateGeoUnicastMessage;
class GenerateGeoUnicastMessage_template;
class GenerateGeoBroadcastMessage;
class GenerateGeoBroadcastMessage_template;
class GenerateSHBMessage;
class GenerateSHBMessage_template;
class GenerateTSBMessage;
class GenerateTSBMessage_template;
class UtGnTriggerResult;
class UtGnTriggerResult_template;
class UtGnEventInd;
class UtGnEventInd_template;
class UtGnEventIndList;
class UtGnEventIndList_template;
class AcGnPrimitive;
class AcGnPrimitive_template;
class AcStartBeaconing;
class AcStartBeaconing_template;
class AcStopBeaconing;
class AcStopBeaconing_template;
class AcStartPassBeaconing;
class AcStartPassBeaconing_template;
class AcStopPassBeaconing;
class AcStopPassBeaconing_template;
class AcStartBeaconingMultipleNeighbour;
class AcStartBeaconingMultipleNeighbour_template;
class AcStopBeaconingMultipleNeighbour;
class AcStopBeaconingMultipleNeighbour_template;
class AcGetLongPosVector;
class AcGetLongPosVector_template;
class AcGnResponse;
class AcGnResponse_template;
class AcGnResponseFailure;
class AcGnResponseFailure_template;

} /* end of namespace */

#ifndef LibItsGeoNetworking__TypesAndValues_HH
#define LibItsGeoNetworking__TypesAndValues_HH

namespace LibItsGeoNetworking__TypesAndValues {

/* Type definitions */

typedef INTEGER TcId;
typedef INTEGER_template TcId_template;
typedef GeoAnycastHeader GeoBroadcastHeader;
typedef GeoAnycastHeader_template GeoBroadcastHeader_template;
typedef OCTETSTRING GnRawPayload;
typedef OCTETSTRING_template GnRawPayload_template;
typedef GenerateGeoBroadcastMessage GenerateGeoAnycastMessage;
typedef GenerateGeoBroadcastMessage_template GenerateGeoAnycastMessage_template;

/* Class definitions */

class TypeOfAddress : public Base_Type { // enum
friend class TypeOfAddress_template;
public:
enum enum_type { e__manual = 1, e__initial = 0, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
TypeOfAddress();
TypeOfAddress(int other_value);
TypeOfAddress(enum_type other_value);
TypeOfAddress(const TypeOfAddress& other_value);

TypeOfAddress& operator=(int other_value);
TypeOfAddress& operator=(enum_type other_value);
TypeOfAddress& operator=(const TypeOfAddress& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const TypeOfAddress& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const TypeOfAddress& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const TypeOfAddress& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const TypeOfAddress& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const TypeOfAddress& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const TypeOfAddress& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const TypeOfAddress& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TypeOfAddress_template : public Base_Template {
union {
TypeOfAddress::enum_type single_value;
struct {
unsigned int n_values;
TypeOfAddress_template *list_value;
} value_list;
};

void copy_template(const TypeOfAddress_template& other_value);

public:
TypeOfAddress_template();
TypeOfAddress_template(template_sel other_value);
TypeOfAddress_template(int other_value);
TypeOfAddress_template(TypeOfAddress::enum_type other_value);
TypeOfAddress_template(const TypeOfAddress& other_value);
TypeOfAddress_template(const OPTIONAL<TypeOfAddress>& other_value);
TypeOfAddress_template(const TypeOfAddress_template& other_value);
~TypeOfAddress_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
TypeOfAddress_template& operator=(template_sel other_value);
TypeOfAddress_template& operator=(int other_value);
TypeOfAddress_template& operator=(TypeOfAddress::enum_type other_value);
TypeOfAddress_template& operator=(const TypeOfAddress& other_value);
TypeOfAddress_template& operator=(const OPTIONAL<TypeOfAddress>& other_value);
TypeOfAddress_template& operator=(const TypeOfAddress_template& other_value);

boolean match(TypeOfAddress::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const TypeOfAddress& other_value, boolean legacy = FALSE) const;
TypeOfAddress::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TypeOfAddress_template& list_item(unsigned int list_index);
void log() const;
void log_match(const TypeOfAddress& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class StationType : public Base_Type { // enum
friend class StationType_template;
public:
enum enum_type { e__unknown = 0, e__pedestrian = 1, e__cyclist = 2, e__moped = 3, e__motorcycle = 4, e__passengerCar = 5, e__bus = 6, e__lightTruck = 7, e__heavyTruck = 8, e__trailer = 9, e__specialVehicle = 10, e__tram = 11, e__roadSideUnit = 15, UNKNOWN_VALUE = 12, UNBOUND_VALUE = 13 };
private:
enum_type enum_value;

public:
StationType();
StationType(int other_value);
StationType(enum_type other_value);
StationType(const StationType& other_value);

StationType& operator=(int other_value);
StationType& operator=(enum_type other_value);
StationType& operator=(const StationType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const StationType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const StationType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const StationType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const StationType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const StationType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const StationType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const StationType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class StationType_template : public Base_Template {
union {
StationType::enum_type single_value;
struct {
unsigned int n_values;
StationType_template *list_value;
} value_list;
};

void copy_template(const StationType_template& other_value);

public:
StationType_template();
StationType_template(template_sel other_value);
StationType_template(int other_value);
StationType_template(StationType::enum_type other_value);
StationType_template(const StationType& other_value);
StationType_template(const OPTIONAL<StationType>& other_value);
StationType_template(const StationType_template& other_value);
~StationType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
StationType_template& operator=(template_sel other_value);
StationType_template& operator=(int other_value);
StationType_template& operator=(StationType::enum_type other_value);
StationType_template& operator=(const StationType& other_value);
StationType_template& operator=(const OPTIONAL<StationType>& other_value);
StationType_template& operator=(const StationType_template& other_value);

boolean match(StationType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const StationType& other_value, boolean legacy = FALSE) const;
StationType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
StationType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const StationType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GN__Address : public Base_Type {
  TypeOfAddress field_typeOfAddress;
  StationType field_stationType;
  INTEGER field_stationCountryCode;
  OCTETSTRING field_mid;
  boolean bound_flag;
public:
  GN__Address();
  GN__Address(const TypeOfAddress& par_typeOfAddress,
    const StationType& par_stationType,
    const INTEGER& par_stationCountryCode,
    const OCTETSTRING& par_mid);
  GN__Address(const GN__Address& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GN__Address& operator=(const GN__Address& other_value);
  boolean operator==(const GN__Address& other_value) const;
  inline boolean operator!=(const GN__Address& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline TypeOfAddress& typeOfAddress()
    {return field_typeOfAddress;}
  inline const TypeOfAddress& typeOfAddress() const
    {return field_typeOfAddress;}
  inline StationType& stationType()
    {return field_stationType;}
  inline const StationType& stationType() const
    {return field_stationType;}
  inline INTEGER& stationCountryCode()
    {return field_stationCountryCode;}
  inline const INTEGER& stationCountryCode() const
    {return field_stationCountryCode;}
  inline OCTETSTRING& mid()
    {return field_mid;}
  inline const OCTETSTRING& mid() const
    {return field_mid;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GN__Address_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GN__Address_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GN__Address& other_value);
void copy_template(const GN__Address_template& other_value);

public:
GN__Address_template();
GN__Address_template(template_sel other_value);
GN__Address_template(const GN__Address& other_value);
GN__Address_template(const OPTIONAL<GN__Address>& other_value);
GN__Address_template(const GN__Address_template& other_value);
~GN__Address_template();
GN__Address_template& operator=(template_sel other_value);
GN__Address_template& operator=(const GN__Address& other_value);
GN__Address_template& operator=(const OPTIONAL<GN__Address>& other_value);
GN__Address_template& operator=(const GN__Address_template& other_value);
boolean match(const GN__Address& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GN__Address valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GN__Address_template& list_item(unsigned int list_index) const;
TypeOfAddress_template& typeOfAddress();
const TypeOfAddress_template& typeOfAddress() const;
StationType_template& stationType();
const StationType_template& stationType() const;
INTEGER_template& stationCountryCode();
const INTEGER_template& stationCountryCode() const;
OCTETSTRING_template& mid();
const OCTETSTRING_template& mid() const;
int size_of() const;
void log() const;
void log_match(const GN__Address& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class LongPosVector : public Base_Type {
  GN__Address field_gnAddr;
  INTEGER field_timestamp;
  INTEGER field_latitude;
  INTEGER field_longitude;
  BITSTRING field_pai;
  INTEGER field_speed;
  INTEGER field_heading;
  boolean bound_flag;
public:
  LongPosVector();
  LongPosVector(const GN__Address& par_gnAddr,
    const INTEGER& par_timestamp,
    const INTEGER& par_latitude,
    const INTEGER& par_longitude,
    const BITSTRING& par_pai,
    const INTEGER& par_speed,
    const INTEGER& par_heading);
  LongPosVector(const LongPosVector& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  LongPosVector& operator=(const LongPosVector& other_value);
  boolean operator==(const LongPosVector& other_value) const;
  inline boolean operator!=(const LongPosVector& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline GN__Address& gnAddr()
    {return field_gnAddr;}
  inline const GN__Address& gnAddr() const
    {return field_gnAddr;}
  inline INTEGER& timestamp()
    {return field_timestamp;}
  inline const INTEGER& timestamp() const
    {return field_timestamp;}
  inline INTEGER& latitude()
    {return field_latitude;}
  inline const INTEGER& latitude() const
    {return field_latitude;}
  inline INTEGER& longitude()
    {return field_longitude;}
  inline const INTEGER& longitude() const
    {return field_longitude;}
  inline BITSTRING& pai()
    {return field_pai;}
  inline const BITSTRING& pai() const
    {return field_pai;}
  inline INTEGER& speed()
    {return field_speed;}
  inline const INTEGER& speed() const
    {return field_speed;}
  inline INTEGER& heading()
    {return field_heading;}
  inline const INTEGER& heading() const
    {return field_heading;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class LongPosVector_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
LongPosVector_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const LongPosVector& other_value);
void copy_template(const LongPosVector_template& other_value);

public:
LongPosVector_template();
LongPosVector_template(template_sel other_value);
LongPosVector_template(const LongPosVector& other_value);
LongPosVector_template(const OPTIONAL<LongPosVector>& other_value);
LongPosVector_template(const LongPosVector_template& other_value);
~LongPosVector_template();
LongPosVector_template& operator=(template_sel other_value);
LongPosVector_template& operator=(const LongPosVector& other_value);
LongPosVector_template& operator=(const OPTIONAL<LongPosVector>& other_value);
LongPosVector_template& operator=(const LongPosVector_template& other_value);
boolean match(const LongPosVector& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
LongPosVector valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
LongPosVector_template& list_item(unsigned int list_index) const;
GN__Address_template& gnAddr();
const GN__Address_template& gnAddr() const;
INTEGER_template& timestamp();
const INTEGER_template& timestamp() const;
INTEGER_template& latitude();
const INTEGER_template& latitude() const;
INTEGER_template& longitude();
const INTEGER_template& longitude() const;
BITSTRING_template& pai();
const BITSTRING_template& pai() const;
INTEGER_template& speed();
const INTEGER_template& speed() const;
INTEGER_template& heading();
const INTEGER_template& heading() const;
int size_of() const;
void log() const;
void log_match(const LongPosVector& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class PositionEntry : public Base_Type {
  CHARSTRING field_key;
  LongPosVector field_position;
  boolean bound_flag;
public:
  PositionEntry();
  PositionEntry(const CHARSTRING& par_key,
    const LongPosVector& par_position);
  PositionEntry(const PositionEntry& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  PositionEntry& operator=(const PositionEntry& other_value);
  boolean operator==(const PositionEntry& other_value) const;
  inline boolean operator!=(const PositionEntry& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& key()
    {return field_key;}
  inline const CHARSTRING& key() const
    {return field_key;}
  inline LongPosVector& position()
    {return field_position;}
  inline const LongPosVector& position() const
    {return field_position;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class PositionEntry_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
PositionEntry_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const PositionEntry& other_value);
void copy_template(const PositionEntry_template& other_value);

public:
PositionEntry_template();
PositionEntry_template(template_sel other_value);
PositionEntry_template(const PositionEntry& other_value);
PositionEntry_template(const OPTIONAL<PositionEntry>& other_value);
PositionEntry_template(const PositionEntry_template& other_value);
~PositionEntry_template();
PositionEntry_template& operator=(template_sel other_value);
PositionEntry_template& operator=(const PositionEntry& other_value);
PositionEntry_template& operator=(const OPTIONAL<PositionEntry>& other_value);
PositionEntry_template& operator=(const PositionEntry_template& other_value);
boolean match(const PositionEntry& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
PositionEntry valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PositionEntry_template& list_item(unsigned int list_index) const;
CHARSTRING_template& key();
const CHARSTRING_template& key() const;
LongPosVector_template& position();
const LongPosVector_template& position() const;
int size_of() const;
void log() const;
void log_match(const PositionEntry& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class PositionTable : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
PositionEntry **value_elements;
} *val_ptr;

static const PositionEntry UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const PositionTable& other_value);

public:
  typedef PositionEntry of_type;
PositionTable();
PositionTable(null_type other_value);
PositionTable(const PositionTable& other_value);
~PositionTable();

void clean_up();
PositionTable& operator=(null_type other_value);
PositionTable& operator=(const PositionTable& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const PositionTable& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PositionTable& other_value) const { return !(*this == other_value); }

PositionEntry& operator[](int index_value);
PositionEntry& operator[](const INTEGER& index_value);
const PositionEntry& operator[](int index_value) const;
const PositionEntry& operator[](const INTEGER& index_value) const;

PositionTable operator<<=(int rotate_count) const;
PositionTable operator<<=(const INTEGER& rotate_count) const;
PositionTable operator>>=(int rotate_count) const;
PositionTable operator>>=(const INTEGER& rotate_count) const;

PositionTable operator+(const PositionTable& other_value) const;

PositionTable substr(int index, int returncount) const;

PositionTable replace(int index, int len, const PositionTable& repl) const;

PositionTable replace(int index, int len, const PositionTable_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class PositionTable_template : public Record_Of_Template {
union {
struct {
int n_elements;
PositionEntry_template **value_elements;
} single_value;
struct {
unsigned int n_values;
PositionTable_template *list_value;
} value_list;
};
void copy_value(const PositionTable& other_value);
void copy_template(const PositionTable_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
PositionTable_template();
PositionTable_template(template_sel other_value);
PositionTable_template(null_type other_value);
PositionTable_template(const PositionTable& other_value);
PositionTable_template(const OPTIONAL<PositionTable>& other_value);
PositionTable_template(const PositionTable_template& other_value);
~PositionTable_template();

void clean_up();
PositionTable_template& operator=(template_sel other_value);
PositionTable_template& operator=(null_type other_value);
PositionTable_template& operator=(const PositionTable& other_value);
PositionTable_template& operator=(const OPTIONAL<PositionTable>& other_value);
PositionTable_template& operator=(const PositionTable_template& other_value);

PositionEntry_template& operator[](int index_value);
PositionEntry_template& operator[](const INTEGER& index_value);
const PositionEntry_template& operator[](int index_value) const;
const PositionEntry_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const PositionTable& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
PositionTable valueof() const;
PositionTable substr(int index, int returncount) const;

PositionTable replace(int index, int len, const PositionTable_template& repl) const;

PositionTable replace(int index, int len, const PositionTable& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
PositionTable_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PositionTable& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class Area : public Base_Type {
  INTEGER field_geoAreaPosLatitude;
  INTEGER field_geoAreaPosLongitude;
  INTEGER field_distanceA;
  INTEGER field_distanceB;
  INTEGER field_angle;
  boolean bound_flag;
public:
  Area();
  Area(const INTEGER& par_geoAreaPosLatitude,
    const INTEGER& par_geoAreaPosLongitude,
    const INTEGER& par_distanceA,
    const INTEGER& par_distanceB,
    const INTEGER& par_angle);
  Area(const Area& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Area& operator=(const Area& other_value);
  boolean operator==(const Area& other_value) const;
  inline boolean operator!=(const Area& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& geoAreaPosLatitude()
    {return field_geoAreaPosLatitude;}
  inline const INTEGER& geoAreaPosLatitude() const
    {return field_geoAreaPosLatitude;}
  inline INTEGER& geoAreaPosLongitude()
    {return field_geoAreaPosLongitude;}
  inline const INTEGER& geoAreaPosLongitude() const
    {return field_geoAreaPosLongitude;}
  inline INTEGER& distanceA()
    {return field_distanceA;}
  inline const INTEGER& distanceA() const
    {return field_distanceA;}
  inline INTEGER& distanceB()
    {return field_distanceB;}
  inline const INTEGER& distanceB() const
    {return field_distanceB;}
  inline INTEGER& angle()
    {return field_angle;}
  inline const INTEGER& angle() const
    {return field_angle;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Area_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Area_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Area& other_value);
void copy_template(const Area_template& other_value);

public:
Area_template();
Area_template(template_sel other_value);
Area_template(const Area& other_value);
Area_template(const OPTIONAL<Area>& other_value);
Area_template(const Area_template& other_value);
~Area_template();
Area_template& operator=(template_sel other_value);
Area_template& operator=(const Area& other_value);
Area_template& operator=(const OPTIONAL<Area>& other_value);
Area_template& operator=(const Area_template& other_value);
boolean match(const Area& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Area valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Area_template& list_item(unsigned int list_index) const;
INTEGER_template& geoAreaPosLatitude();
const INTEGER_template& geoAreaPosLatitude() const;
INTEGER_template& geoAreaPosLongitude();
const INTEGER_template& geoAreaPosLongitude() const;
INTEGER_template& distanceA();
const INTEGER_template& distanceA() const;
INTEGER_template& distanceB();
const INTEGER_template& distanceB() const;
INTEGER_template& angle();
const INTEGER_template& angle() const;
int size_of() const;
void log() const;
void log_match(const Area& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HeaderSubTypeGeoBroadcast : public Base_Type { // enum
friend class HeaderSubTypeGeoBroadcast_template;
public:
enum enum_type { e__geoBroadcastCircle = 0, e__geoBroadcastRect = 1, e__geoBroadcastElip = 2, e__reserved = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
HeaderSubTypeGeoBroadcast();
HeaderSubTypeGeoBroadcast(int other_value);
HeaderSubTypeGeoBroadcast(enum_type other_value);
HeaderSubTypeGeoBroadcast(const HeaderSubTypeGeoBroadcast& other_value);

HeaderSubTypeGeoBroadcast& operator=(int other_value);
HeaderSubTypeGeoBroadcast& operator=(enum_type other_value);
HeaderSubTypeGeoBroadcast& operator=(const HeaderSubTypeGeoBroadcast& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const HeaderSubTypeGeoBroadcast& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const HeaderSubTypeGeoBroadcast& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const HeaderSubTypeGeoBroadcast& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const HeaderSubTypeGeoBroadcast& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const HeaderSubTypeGeoBroadcast& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const HeaderSubTypeGeoBroadcast& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const HeaderSubTypeGeoBroadcast& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class HeaderSubTypeGeoBroadcast_template : public Base_Template {
union {
HeaderSubTypeGeoBroadcast::enum_type single_value;
struct {
unsigned int n_values;
HeaderSubTypeGeoBroadcast_template *list_value;
} value_list;
};

void copy_template(const HeaderSubTypeGeoBroadcast_template& other_value);

public:
HeaderSubTypeGeoBroadcast_template();
HeaderSubTypeGeoBroadcast_template(template_sel other_value);
HeaderSubTypeGeoBroadcast_template(int other_value);
HeaderSubTypeGeoBroadcast_template(HeaderSubTypeGeoBroadcast::enum_type other_value);
HeaderSubTypeGeoBroadcast_template(const HeaderSubTypeGeoBroadcast& other_value);
HeaderSubTypeGeoBroadcast_template(const OPTIONAL<HeaderSubTypeGeoBroadcast>& other_value);
HeaderSubTypeGeoBroadcast_template(const HeaderSubTypeGeoBroadcast_template& other_value);
~HeaderSubTypeGeoBroadcast_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
HeaderSubTypeGeoBroadcast_template& operator=(template_sel other_value);
HeaderSubTypeGeoBroadcast_template& operator=(int other_value);
HeaderSubTypeGeoBroadcast_template& operator=(HeaderSubTypeGeoBroadcast::enum_type other_value);
HeaderSubTypeGeoBroadcast_template& operator=(const HeaderSubTypeGeoBroadcast& other_value);
HeaderSubTypeGeoBroadcast_template& operator=(const OPTIONAL<HeaderSubTypeGeoBroadcast>& other_value);
HeaderSubTypeGeoBroadcast_template& operator=(const HeaderSubTypeGeoBroadcast_template& other_value);

boolean match(HeaderSubTypeGeoBroadcast::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const HeaderSubTypeGeoBroadcast& other_value, boolean legacy = FALSE) const;
HeaderSubTypeGeoBroadcast::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HeaderSubTypeGeoBroadcast_template& list_item(unsigned int list_index);
void log() const;
void log_match(const HeaderSubTypeGeoBroadcast& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GeoBroadcastArea : public Base_Type {
  HeaderSubTypeGeoBroadcast field_geoBroadcastSubType;
  Area field_geoBroadcastArea;
  boolean bound_flag;
public:
  GeoBroadcastArea();
  GeoBroadcastArea(const HeaderSubTypeGeoBroadcast& par_geoBroadcastSubType,
    const Area& par_geoBroadcastArea);
  GeoBroadcastArea(const GeoBroadcastArea& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GeoBroadcastArea& operator=(const GeoBroadcastArea& other_value);
  boolean operator==(const GeoBroadcastArea& other_value) const;
  inline boolean operator!=(const GeoBroadcastArea& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline HeaderSubTypeGeoBroadcast& geoBroadcastSubType()
    {return field_geoBroadcastSubType;}
  inline const HeaderSubTypeGeoBroadcast& geoBroadcastSubType() const
    {return field_geoBroadcastSubType;}
  inline Area& geoBroadcastArea()
    {return field_geoBroadcastArea;}
  inline const Area& geoBroadcastArea() const
    {return field_geoBroadcastArea;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GeoBroadcastArea_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GeoBroadcastArea_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GeoBroadcastArea& other_value);
void copy_template(const GeoBroadcastArea_template& other_value);

public:
GeoBroadcastArea_template();
GeoBroadcastArea_template(template_sel other_value);
GeoBroadcastArea_template(const GeoBroadcastArea& other_value);
GeoBroadcastArea_template(const OPTIONAL<GeoBroadcastArea>& other_value);
GeoBroadcastArea_template(const GeoBroadcastArea_template& other_value);
~GeoBroadcastArea_template();
GeoBroadcastArea_template& operator=(template_sel other_value);
GeoBroadcastArea_template& operator=(const GeoBroadcastArea& other_value);
GeoBroadcastArea_template& operator=(const OPTIONAL<GeoBroadcastArea>& other_value);
GeoBroadcastArea_template& operator=(const GeoBroadcastArea_template& other_value);
boolean match(const GeoBroadcastArea& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GeoBroadcastArea valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GeoBroadcastArea_template& list_item(unsigned int list_index) const;
HeaderSubTypeGeoBroadcast_template& geoBroadcastSubType();
const HeaderSubTypeGeoBroadcast_template& geoBroadcastSubType() const;
Area_template& geoBroadcastArea();
const Area_template& geoBroadcastArea() const;
int size_of() const;
void log() const;
void log_match(const GeoBroadcastArea& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HeaderSubTypeGeoAnycast : public Base_Type { // enum
friend class HeaderSubTypeGeoAnycast_template;
public:
enum enum_type { e__geoAnycastCircle = 0, e__geoAnycastRect = 1, e__geoAnycastElip = 2, e__reserved = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
HeaderSubTypeGeoAnycast();
HeaderSubTypeGeoAnycast(int other_value);
HeaderSubTypeGeoAnycast(enum_type other_value);
HeaderSubTypeGeoAnycast(const HeaderSubTypeGeoAnycast& other_value);

HeaderSubTypeGeoAnycast& operator=(int other_value);
HeaderSubTypeGeoAnycast& operator=(enum_type other_value);
HeaderSubTypeGeoAnycast& operator=(const HeaderSubTypeGeoAnycast& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const HeaderSubTypeGeoAnycast& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const HeaderSubTypeGeoAnycast& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const HeaderSubTypeGeoAnycast& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const HeaderSubTypeGeoAnycast& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const HeaderSubTypeGeoAnycast& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const HeaderSubTypeGeoAnycast& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const HeaderSubTypeGeoAnycast& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class HeaderSubTypeGeoAnycast_template : public Base_Template {
union {
HeaderSubTypeGeoAnycast::enum_type single_value;
struct {
unsigned int n_values;
HeaderSubTypeGeoAnycast_template *list_value;
} value_list;
};

void copy_template(const HeaderSubTypeGeoAnycast_template& other_value);

public:
HeaderSubTypeGeoAnycast_template();
HeaderSubTypeGeoAnycast_template(template_sel other_value);
HeaderSubTypeGeoAnycast_template(int other_value);
HeaderSubTypeGeoAnycast_template(HeaderSubTypeGeoAnycast::enum_type other_value);
HeaderSubTypeGeoAnycast_template(const HeaderSubTypeGeoAnycast& other_value);
HeaderSubTypeGeoAnycast_template(const OPTIONAL<HeaderSubTypeGeoAnycast>& other_value);
HeaderSubTypeGeoAnycast_template(const HeaderSubTypeGeoAnycast_template& other_value);
~HeaderSubTypeGeoAnycast_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
HeaderSubTypeGeoAnycast_template& operator=(template_sel other_value);
HeaderSubTypeGeoAnycast_template& operator=(int other_value);
HeaderSubTypeGeoAnycast_template& operator=(HeaderSubTypeGeoAnycast::enum_type other_value);
HeaderSubTypeGeoAnycast_template& operator=(const HeaderSubTypeGeoAnycast& other_value);
HeaderSubTypeGeoAnycast_template& operator=(const OPTIONAL<HeaderSubTypeGeoAnycast>& other_value);
HeaderSubTypeGeoAnycast_template& operator=(const HeaderSubTypeGeoAnycast_template& other_value);

boolean match(HeaderSubTypeGeoAnycast::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const HeaderSubTypeGeoAnycast& other_value, boolean legacy = FALSE) const;
HeaderSubTypeGeoAnycast::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HeaderSubTypeGeoAnycast_template& list_item(unsigned int list_index);
void log() const;
void log_match(const HeaderSubTypeGeoAnycast& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GeoAnycastArea : public Base_Type {
  HeaderSubTypeGeoAnycast field_geoAnycastSubType;
  Area field_geoAnycastArea;
  boolean bound_flag;
public:
  GeoAnycastArea();
  GeoAnycastArea(const HeaderSubTypeGeoAnycast& par_geoAnycastSubType,
    const Area& par_geoAnycastArea);
  GeoAnycastArea(const GeoAnycastArea& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GeoAnycastArea& operator=(const GeoAnycastArea& other_value);
  boolean operator==(const GeoAnycastArea& other_value) const;
  inline boolean operator!=(const GeoAnycastArea& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline HeaderSubTypeGeoAnycast& geoAnycastSubType()
    {return field_geoAnycastSubType;}
  inline const HeaderSubTypeGeoAnycast& geoAnycastSubType() const
    {return field_geoAnycastSubType;}
  inline Area& geoAnycastArea()
    {return field_geoAnycastArea;}
  inline const Area& geoAnycastArea() const
    {return field_geoAnycastArea;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GeoAnycastArea_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GeoAnycastArea_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GeoAnycastArea& other_value);
void copy_template(const GeoAnycastArea_template& other_value);

public:
GeoAnycastArea_template();
GeoAnycastArea_template(template_sel other_value);
GeoAnycastArea_template(const GeoAnycastArea& other_value);
GeoAnycastArea_template(const OPTIONAL<GeoAnycastArea>& other_value);
GeoAnycastArea_template(const GeoAnycastArea_template& other_value);
~GeoAnycastArea_template();
GeoAnycastArea_template& operator=(template_sel other_value);
GeoAnycastArea_template& operator=(const GeoAnycastArea& other_value);
GeoAnycastArea_template& operator=(const OPTIONAL<GeoAnycastArea>& other_value);
GeoAnycastArea_template& operator=(const GeoAnycastArea_template& other_value);
boolean match(const GeoAnycastArea& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GeoAnycastArea valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GeoAnycastArea_template& list_item(unsigned int list_index) const;
HeaderSubTypeGeoAnycast_template& geoAnycastSubType();
const HeaderSubTypeGeoAnycast_template& geoAnycastSubType() const;
Area_template& geoAnycastArea();
const Area_template& geoAnycastArea() const;
int size_of() const;
void log() const;
void log_match(const GeoAnycastArea& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GeoShape : public Base_Type { // enum
friend class GeoShape_template;
public:
enum enum_type { e__geoCircle = 0, e__geoRect = 1, e__geoElip = 2, e__reserved = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
GeoShape();
GeoShape(int other_value);
GeoShape(enum_type other_value);
GeoShape(const GeoShape& other_value);

GeoShape& operator=(int other_value);
GeoShape& operator=(enum_type other_value);
GeoShape& operator=(const GeoShape& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const GeoShape& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GeoShape& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const GeoShape& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const GeoShape& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const GeoShape& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const GeoShape& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const GeoShape& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GeoShape_template : public Base_Template {
union {
GeoShape::enum_type single_value;
struct {
unsigned int n_values;
GeoShape_template *list_value;
} value_list;
};

void copy_template(const GeoShape_template& other_value);

public:
GeoShape_template();
GeoShape_template(template_sel other_value);
GeoShape_template(int other_value);
GeoShape_template(GeoShape::enum_type other_value);
GeoShape_template(const GeoShape& other_value);
GeoShape_template(const OPTIONAL<GeoShape>& other_value);
GeoShape_template(const GeoShape_template& other_value);
~GeoShape_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
GeoShape_template& operator=(template_sel other_value);
GeoShape_template& operator=(int other_value);
GeoShape_template& operator=(GeoShape::enum_type other_value);
GeoShape_template& operator=(const GeoShape& other_value);
GeoShape_template& operator=(const OPTIONAL<GeoShape>& other_value);
GeoShape_template& operator=(const GeoShape_template& other_value);

boolean match(GeoShape::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const GeoShape& other_value, boolean legacy = FALSE) const;
GeoShape::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GeoShape_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GeoShape& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GeoArea : public Base_Type {
  GeoShape field_shape;
  Area field_area;
  boolean bound_flag;
public:
  GeoArea();
  GeoArea(const GeoShape& par_shape,
    const Area& par_area);
  GeoArea(const GeoArea& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GeoArea& operator=(const GeoArea& other_value);
  boolean operator==(const GeoArea& other_value) const;
  inline boolean operator!=(const GeoArea& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline GeoShape& shape()
    {return field_shape;}
  inline const GeoShape& shape() const
    {return field_shape;}
  inline Area& area()
    {return field_area;}
  inline const Area& area() const
    {return field_area;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GeoArea_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GeoArea_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GeoArea& other_value);
void copy_template(const GeoArea_template& other_value);

public:
GeoArea_template();
GeoArea_template(template_sel other_value);
GeoArea_template(const GeoArea& other_value);
GeoArea_template(const OPTIONAL<GeoArea>& other_value);
GeoArea_template(const GeoArea_template& other_value);
~GeoArea_template();
GeoArea_template& operator=(template_sel other_value);
GeoArea_template& operator=(const GeoArea& other_value);
GeoArea_template& operator=(const OPTIONAL<GeoArea>& other_value);
GeoArea_template& operator=(const GeoArea_template& other_value);
boolean match(const GeoArea& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GeoArea valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GeoArea_template& list_item(unsigned int list_index) const;
GeoShape_template& shape();
const GeoShape_template& shape() const;
Area_template& area();
const Area_template& area() const;
int size_of() const;
void log() const;
void log_match(const GeoArea& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GeoAreaEntry : public Base_Type {
  CHARSTRING field_key;
  GeoArea field_geoArea;
  boolean bound_flag;
public:
  GeoAreaEntry();
  GeoAreaEntry(const CHARSTRING& par_key,
    const GeoArea& par_geoArea);
  GeoAreaEntry(const GeoAreaEntry& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GeoAreaEntry& operator=(const GeoAreaEntry& other_value);
  boolean operator==(const GeoAreaEntry& other_value) const;
  inline boolean operator!=(const GeoAreaEntry& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CHARSTRING& key()
    {return field_key;}
  inline const CHARSTRING& key() const
    {return field_key;}
  inline GeoArea& geoArea()
    {return field_geoArea;}
  inline const GeoArea& geoArea() const
    {return field_geoArea;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GeoAreaEntry_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GeoAreaEntry_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GeoAreaEntry& other_value);
void copy_template(const GeoAreaEntry_template& other_value);

public:
GeoAreaEntry_template();
GeoAreaEntry_template(template_sel other_value);
GeoAreaEntry_template(const GeoAreaEntry& other_value);
GeoAreaEntry_template(const OPTIONAL<GeoAreaEntry>& other_value);
GeoAreaEntry_template(const GeoAreaEntry_template& other_value);
~GeoAreaEntry_template();
GeoAreaEntry_template& operator=(template_sel other_value);
GeoAreaEntry_template& operator=(const GeoAreaEntry& other_value);
GeoAreaEntry_template& operator=(const OPTIONAL<GeoAreaEntry>& other_value);
GeoAreaEntry_template& operator=(const GeoAreaEntry_template& other_value);
boolean match(const GeoAreaEntry& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GeoAreaEntry valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GeoAreaEntry_template& list_item(unsigned int list_index) const;
CHARSTRING_template& key();
const CHARSTRING_template& key() const;
GeoArea_template& geoArea();
const GeoArea_template& geoArea() const;
int size_of() const;
void log() const;
void log_match(const GeoAreaEntry& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GeoAreaTable : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
GeoAreaEntry **value_elements;
} *val_ptr;

static const GeoAreaEntry UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const GeoAreaTable& other_value);

public:
  typedef GeoAreaEntry of_type;
GeoAreaTable();
GeoAreaTable(null_type other_value);
GeoAreaTable(const GeoAreaTable& other_value);
~GeoAreaTable();

void clean_up();
GeoAreaTable& operator=(null_type other_value);
GeoAreaTable& operator=(const GeoAreaTable& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const GeoAreaTable& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GeoAreaTable& other_value) const { return !(*this == other_value); }

GeoAreaEntry& operator[](int index_value);
GeoAreaEntry& operator[](const INTEGER& index_value);
const GeoAreaEntry& operator[](int index_value) const;
const GeoAreaEntry& operator[](const INTEGER& index_value) const;

GeoAreaTable operator<<=(int rotate_count) const;
GeoAreaTable operator<<=(const INTEGER& rotate_count) const;
GeoAreaTable operator>>=(int rotate_count) const;
GeoAreaTable operator>>=(const INTEGER& rotate_count) const;

GeoAreaTable operator+(const GeoAreaTable& other_value) const;

GeoAreaTable substr(int index, int returncount) const;

GeoAreaTable replace(int index, int len, const GeoAreaTable& repl) const;

GeoAreaTable replace(int index, int len, const GeoAreaTable_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GeoAreaTable_template : public Record_Of_Template {
union {
struct {
int n_elements;
GeoAreaEntry_template **value_elements;
} single_value;
struct {
unsigned int n_values;
GeoAreaTable_template *list_value;
} value_list;
};
void copy_value(const GeoAreaTable& other_value);
void copy_template(const GeoAreaTable_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
GeoAreaTable_template();
GeoAreaTable_template(template_sel other_value);
GeoAreaTable_template(null_type other_value);
GeoAreaTable_template(const GeoAreaTable& other_value);
GeoAreaTable_template(const OPTIONAL<GeoAreaTable>& other_value);
GeoAreaTable_template(const GeoAreaTable_template& other_value);
~GeoAreaTable_template();

void clean_up();
GeoAreaTable_template& operator=(template_sel other_value);
GeoAreaTable_template& operator=(null_type other_value);
GeoAreaTable_template& operator=(const GeoAreaTable& other_value);
GeoAreaTable_template& operator=(const OPTIONAL<GeoAreaTable>& other_value);
GeoAreaTable_template& operator=(const GeoAreaTable_template& other_value);

GeoAreaEntry_template& operator[](int index_value);
GeoAreaEntry_template& operator[](const INTEGER& index_value);
const GeoAreaEntry_template& operator[](int index_value) const;
const GeoAreaEntry_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const GeoAreaTable& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
GeoAreaTable valueof() const;
GeoAreaTable substr(int index, int returncount) const;

GeoAreaTable replace(int index, int len, const GeoAreaTable_template& repl) const;

GeoAreaTable replace(int index, int len, const GeoAreaTable& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
GeoAreaTable_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GeoAreaTable& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class BasicNextHeader : public Base_Type { // enum
friend class BasicNextHeader_template;
public:
enum enum_type { e__any = 0, e__commonHeader = 1, e__securedPacket = 2, e__reserved = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
BasicNextHeader();
BasicNextHeader(int other_value);
BasicNextHeader(enum_type other_value);
BasicNextHeader(const BasicNextHeader& other_value);

BasicNextHeader& operator=(int other_value);
BasicNextHeader& operator=(enum_type other_value);
BasicNextHeader& operator=(const BasicNextHeader& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const BasicNextHeader& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const BasicNextHeader& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const BasicNextHeader& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const BasicNextHeader& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const BasicNextHeader& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const BasicNextHeader& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const BasicNextHeader& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class BasicNextHeader_template : public Base_Template {
union {
BasicNextHeader::enum_type single_value;
struct {
unsigned int n_values;
BasicNextHeader_template *list_value;
} value_list;
};

void copy_template(const BasicNextHeader_template& other_value);

public:
BasicNextHeader_template();
BasicNextHeader_template(template_sel other_value);
BasicNextHeader_template(int other_value);
BasicNextHeader_template(BasicNextHeader::enum_type other_value);
BasicNextHeader_template(const BasicNextHeader& other_value);
BasicNextHeader_template(const OPTIONAL<BasicNextHeader>& other_value);
BasicNextHeader_template(const BasicNextHeader_template& other_value);
~BasicNextHeader_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
BasicNextHeader_template& operator=(template_sel other_value);
BasicNextHeader_template& operator=(int other_value);
BasicNextHeader_template& operator=(BasicNextHeader::enum_type other_value);
BasicNextHeader_template& operator=(const BasicNextHeader& other_value);
BasicNextHeader_template& operator=(const OPTIONAL<BasicNextHeader>& other_value);
BasicNextHeader_template& operator=(const BasicNextHeader_template& other_value);

boolean match(BasicNextHeader::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const BasicNextHeader& other_value, boolean legacy = FALSE) const;
BasicNextHeader::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BasicNextHeader_template& list_item(unsigned int list_index);
void log() const;
void log_match(const BasicNextHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class LtBase : public Base_Type { // enum
friend class LtBase_template;
public:
enum enum_type { e__50ms = 0, e__1s = 1, e__10s = 2, e__100s = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
LtBase();
LtBase(int other_value);
LtBase(enum_type other_value);
LtBase(const LtBase& other_value);

LtBase& operator=(int other_value);
LtBase& operator=(enum_type other_value);
LtBase& operator=(const LtBase& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const LtBase& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const LtBase& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const LtBase& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const LtBase& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const LtBase& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const LtBase& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const LtBase& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class LtBase_template : public Base_Template {
union {
LtBase::enum_type single_value;
struct {
unsigned int n_values;
LtBase_template *list_value;
} value_list;
};

void copy_template(const LtBase_template& other_value);

public:
LtBase_template();
LtBase_template(template_sel other_value);
LtBase_template(int other_value);
LtBase_template(LtBase::enum_type other_value);
LtBase_template(const LtBase& other_value);
LtBase_template(const OPTIONAL<LtBase>& other_value);
LtBase_template(const LtBase_template& other_value);
~LtBase_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
LtBase_template& operator=(template_sel other_value);
LtBase_template& operator=(int other_value);
LtBase_template& operator=(LtBase::enum_type other_value);
LtBase_template& operator=(const LtBase& other_value);
LtBase_template& operator=(const OPTIONAL<LtBase>& other_value);
LtBase_template& operator=(const LtBase_template& other_value);

boolean match(LtBase::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const LtBase& other_value, boolean legacy = FALSE) const;
LtBase::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
LtBase_template& list_item(unsigned int list_index);
void log() const;
void log_match(const LtBase& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class Lifetime : public Base_Type {
  INTEGER field_multiplier;
  LtBase field_ltBase;
  boolean bound_flag;
public:
  Lifetime();
  Lifetime(const INTEGER& par_multiplier,
    const LtBase& par_ltBase);
  Lifetime(const Lifetime& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Lifetime& operator=(const Lifetime& other_value);
  boolean operator==(const Lifetime& other_value) const;
  inline boolean operator!=(const Lifetime& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& multiplier()
    {return field_multiplier;}
  inline const INTEGER& multiplier() const
    {return field_multiplier;}
  inline LtBase& ltBase()
    {return field_ltBase;}
  inline const LtBase& ltBase() const
    {return field_ltBase;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Lifetime_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Lifetime_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Lifetime& other_value);
void copy_template(const Lifetime_template& other_value);

public:
Lifetime_template();
Lifetime_template(template_sel other_value);
Lifetime_template(const Lifetime& other_value);
Lifetime_template(const OPTIONAL<Lifetime>& other_value);
Lifetime_template(const Lifetime_template& other_value);
~Lifetime_template();
Lifetime_template& operator=(template_sel other_value);
Lifetime_template& operator=(const Lifetime& other_value);
Lifetime_template& operator=(const OPTIONAL<Lifetime>& other_value);
Lifetime_template& operator=(const Lifetime_template& other_value);
boolean match(const Lifetime& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Lifetime valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Lifetime_template& list_item(unsigned int list_index) const;
INTEGER_template& multiplier();
const INTEGER_template& multiplier() const;
LtBase_template& ltBase();
const LtBase_template& ltBase() const;
int size_of() const;
void log() const;
void log_match(const Lifetime& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class BasicHeader : public Base_Type {
  INTEGER field_version;
  BasicNextHeader field_nextHeader;
  INTEGER field_reserved;
  Lifetime field_lifeTime;
  INTEGER field_routerHopLimit;
  boolean bound_flag;
public:
  BasicHeader();
  BasicHeader(const INTEGER& par_version,
    const BasicNextHeader& par_nextHeader,
    const INTEGER& par_reserved,
    const Lifetime& par_lifeTime,
    const INTEGER& par_routerHopLimit);
  BasicHeader(const BasicHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BasicHeader& operator=(const BasicHeader& other_value);
  boolean operator==(const BasicHeader& other_value) const;
  inline boolean operator!=(const BasicHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& version()
    {return field_version;}
  inline const INTEGER& version() const
    {return field_version;}
  inline BasicNextHeader& nextHeader()
    {return field_nextHeader;}
  inline const BasicNextHeader& nextHeader() const
    {return field_nextHeader;}
  inline INTEGER& reserved()
    {return field_reserved;}
  inline const INTEGER& reserved() const
    {return field_reserved;}
  inline Lifetime& lifeTime()
    {return field_lifeTime;}
  inline const Lifetime& lifeTime() const
    {return field_lifeTime;}
  inline INTEGER& routerHopLimit()
    {return field_routerHopLimit;}
  inline const INTEGER& routerHopLimit() const
    {return field_routerHopLimit;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class BasicHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BasicHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BasicHeader& other_value);
void copy_template(const BasicHeader_template& other_value);

public:
BasicHeader_template();
BasicHeader_template(template_sel other_value);
BasicHeader_template(const BasicHeader& other_value);
BasicHeader_template(const OPTIONAL<BasicHeader>& other_value);
BasicHeader_template(const BasicHeader_template& other_value);
~BasicHeader_template();
BasicHeader_template& operator=(template_sel other_value);
BasicHeader_template& operator=(const BasicHeader& other_value);
BasicHeader_template& operator=(const OPTIONAL<BasicHeader>& other_value);
BasicHeader_template& operator=(const BasicHeader_template& other_value);
boolean match(const BasicHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BasicHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BasicHeader_template& list_item(unsigned int list_index) const;
INTEGER_template& version();
const INTEGER_template& version() const;
BasicNextHeader_template& nextHeader();
const BasicNextHeader_template& nextHeader() const;
INTEGER_template& reserved();
const INTEGER_template& reserved() const;
Lifetime_template& lifeTime();
const Lifetime_template& lifeTime() const;
INTEGER_template& routerHopLimit();
const INTEGER_template& routerHopLimit() const;
int size_of() const;
void log() const;
void log_match(const BasicHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class NextHeader : public Base_Type { // enum
friend class NextHeader_template;
public:
enum enum_type { e__any = 0, e__btpA = 1, e__btpB = 2, e__ipv6 = 3, e__reserved = 4, UNKNOWN_VALUE = 5, UNBOUND_VALUE = 6 };
private:
enum_type enum_value;

public:
NextHeader();
NextHeader(int other_value);
NextHeader(enum_type other_value);
NextHeader(const NextHeader& other_value);

NextHeader& operator=(int other_value);
NextHeader& operator=(enum_type other_value);
NextHeader& operator=(const NextHeader& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const NextHeader& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const NextHeader& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const NextHeader& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const NextHeader& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const NextHeader& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const NextHeader& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const NextHeader& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class NextHeader_template : public Base_Template {
union {
NextHeader::enum_type single_value;
struct {
unsigned int n_values;
NextHeader_template *list_value;
} value_list;
};

void copy_template(const NextHeader_template& other_value);

public:
NextHeader_template();
NextHeader_template(template_sel other_value);
NextHeader_template(int other_value);
NextHeader_template(NextHeader::enum_type other_value);
NextHeader_template(const NextHeader& other_value);
NextHeader_template(const OPTIONAL<NextHeader>& other_value);
NextHeader_template(const NextHeader_template& other_value);
~NextHeader_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
NextHeader_template& operator=(template_sel other_value);
NextHeader_template& operator=(int other_value);
NextHeader_template& operator=(NextHeader::enum_type other_value);
NextHeader_template& operator=(const NextHeader& other_value);
NextHeader_template& operator=(const OPTIONAL<NextHeader>& other_value);
NextHeader_template& operator=(const NextHeader_template& other_value);

boolean match(NextHeader::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const NextHeader& other_value, boolean legacy = FALSE) const;
NextHeader::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
NextHeader_template& list_item(unsigned int list_index);
void log() const;
void log_match(const NextHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class HeaderTST : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_anyHdr = 1, ALT_beaconHdr = 2, ALT_geoUnicastHdr = 3, ALT_geoAnycastHdr = 4, ALT_geoBroadcastHdr = 5, ALT_tsbHdr = 6, ALT_lsHdr = 7, ALT_saHdr = 8, ALT_reserved = 9 };
private:
union_selection_type union_selection;
union {
AnyHeaderType *field_anyHdr;
BeaconHeaderType *field_beaconHdr;
GeoUnicastHeaderType *field_geoUnicastHdr;
GeoAnycastHeaderType *field_geoAnycastHdr;
GeoBroadcastHeaderType *field_geoBroadcastHdr;
TsbHeaderType *field_tsbHdr;
LsHeaderType *field_lsHdr;
SaHeaderType *field_saHdr;
INTEGER *field_reserved;
};
void copy_value(const HeaderTST& other_value);

public:
HeaderTST();
HeaderTST(const HeaderTST& other_value);
~HeaderTST();
HeaderTST& operator=(const HeaderTST& other_value);
boolean operator==(const HeaderTST& other_value) const;
inline boolean operator!=(const HeaderTST& other_value) const { return !(*this == other_value); }
AnyHeaderType& anyHdr();
const AnyHeaderType& anyHdr() const;
BeaconHeaderType& beaconHdr();
const BeaconHeaderType& beaconHdr() const;
GeoUnicastHeaderType& geoUnicastHdr();
const GeoUnicastHeaderType& geoUnicastHdr() const;
GeoAnycastHeaderType& geoAnycastHdr();
const GeoAnycastHeaderType& geoAnycastHdr() const;
GeoBroadcastHeaderType& geoBroadcastHdr();
const GeoBroadcastHeaderType& geoBroadcastHdr() const;
TsbHeaderType& tsbHdr();
const TsbHeaderType& tsbHdr() const;
LsHeaderType& lsHdr();
const LsHeaderType& lsHdr() const;
SaHeaderType& saHdr();
const SaHeaderType& saHdr() const;
INTEGER& reserved();
const INTEGER& reserved() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class HeaderTST_template : public Base_Template {
union {
struct {
HeaderTST::union_selection_type union_selection;
union {
AnyHeaderType_template *field_anyHdr;
BeaconHeaderType_template *field_beaconHdr;
GeoUnicastHeaderType_template *field_geoUnicastHdr;
GeoAnycastHeaderType_template *field_geoAnycastHdr;
GeoBroadcastHeaderType_template *field_geoBroadcastHdr;
TsbHeaderType_template *field_tsbHdr;
LsHeaderType_template *field_lsHdr;
SaHeaderType_template *field_saHdr;
INTEGER_template *field_reserved;
};
} single_value;
struct {
unsigned int n_values;
HeaderTST_template *list_value;
} value_list;
};
void copy_value(const HeaderTST& other_value);

void copy_template(const HeaderTST_template& other_value);

public:
HeaderTST_template();
HeaderTST_template(template_sel other_value);
HeaderTST_template(const HeaderTST& other_value);
HeaderTST_template(const OPTIONAL<HeaderTST>& other_value);
HeaderTST_template(const HeaderTST_template& other_value);
~HeaderTST_template();
void clean_up();
HeaderTST_template& operator=(template_sel other_value);
HeaderTST_template& operator=(const HeaderTST& other_value);
HeaderTST_template& operator=(const OPTIONAL<HeaderTST>& other_value);
HeaderTST_template& operator=(const HeaderTST_template& other_value);
boolean match(const HeaderTST& other_value, boolean legacy = FALSE) const;
boolean is_value() const;HeaderTST valueof() const;
HeaderTST_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
AnyHeaderType_template& anyHdr();
const AnyHeaderType_template& anyHdr() const;
BeaconHeaderType_template& beaconHdr();
const BeaconHeaderType_template& beaconHdr() const;
GeoUnicastHeaderType_template& geoUnicastHdr();
const GeoUnicastHeaderType_template& geoUnicastHdr() const;
GeoAnycastHeaderType_template& geoAnycastHdr();
const GeoAnycastHeaderType_template& geoAnycastHdr() const;
GeoBroadcastHeaderType_template& geoBroadcastHdr();
const GeoBroadcastHeaderType_template& geoBroadcastHdr() const;
TsbHeaderType_template& tsbHdr();
const TsbHeaderType_template& tsbHdr() const;
LsHeaderType_template& lsHdr();
const LsHeaderType_template& lsHdr() const;
SaHeaderType_template& saHdr();
const SaHeaderType_template& saHdr() const;
INTEGER_template& reserved();
const INTEGER_template& reserved() const;
boolean ischosen(HeaderTST::union_selection_type checked_selection) const;
void log() const;
void log_match(const HeaderTST& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class HeaderType : public Base_Type { // enum
friend class HeaderType_template;
public:
enum enum_type { e__any = 0, e__beacon = 1, e__geoUnicast = 2, e__geoAnycast = 3, e__geoBroadcast = 4, e__topologicallyScopedBroadcast = 5, e__locationService = 6, e__serviceAnnouncement = 7, e__reserved = 8, UNKNOWN_VALUE = 9, UNBOUND_VALUE = 10 };
private:
enum_type enum_value;

public:
HeaderType();
HeaderType(int other_value);
HeaderType(enum_type other_value);
HeaderType(const HeaderType& other_value);

HeaderType& operator=(int other_value);
HeaderType& operator=(enum_type other_value);
HeaderType& operator=(const HeaderType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const HeaderType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const HeaderType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const HeaderType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const HeaderType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const HeaderType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const HeaderType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const HeaderType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class HeaderType_template : public Base_Template {
union {
HeaderType::enum_type single_value;
struct {
unsigned int n_values;
HeaderType_template *list_value;
} value_list;
};

void copy_template(const HeaderType_template& other_value);

public:
HeaderType_template();
HeaderType_template(template_sel other_value);
HeaderType_template(int other_value);
HeaderType_template(HeaderType::enum_type other_value);
HeaderType_template(const HeaderType& other_value);
HeaderType_template(const OPTIONAL<HeaderType>& other_value);
HeaderType_template(const HeaderType_template& other_value);
~HeaderType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
HeaderType_template& operator=(template_sel other_value);
HeaderType_template& operator=(int other_value);
HeaderType_template& operator=(HeaderType::enum_type other_value);
HeaderType_template& operator=(const HeaderType& other_value);
HeaderType_template& operator=(const OPTIONAL<HeaderType>& other_value);
HeaderType_template& operator=(const HeaderType_template& other_value);

boolean match(HeaderType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const HeaderType& other_value, boolean legacy = FALSE) const;
HeaderType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HeaderType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const HeaderType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class AnyHeaderType : public Base_Type {
  HeaderType field_headerType;
  INTEGER field_headerSubType;
  boolean bound_flag;
public:
  AnyHeaderType();
  AnyHeaderType(const HeaderType& par_headerType,
    const INTEGER& par_headerSubType);
  AnyHeaderType(const AnyHeaderType& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AnyHeaderType& operator=(const AnyHeaderType& other_value);
  boolean operator==(const AnyHeaderType& other_value) const;
  inline boolean operator!=(const AnyHeaderType& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline HeaderType& headerType()
    {return field_headerType;}
  inline const HeaderType& headerType() const
    {return field_headerType;}
  inline INTEGER& headerSubType()
    {return field_headerSubType;}
  inline const INTEGER& headerSubType() const
    {return field_headerSubType;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AnyHeaderType_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AnyHeaderType_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AnyHeaderType& other_value);
void copy_template(const AnyHeaderType_template& other_value);

public:
AnyHeaderType_template();
AnyHeaderType_template(template_sel other_value);
AnyHeaderType_template(const AnyHeaderType& other_value);
AnyHeaderType_template(const OPTIONAL<AnyHeaderType>& other_value);
AnyHeaderType_template(const AnyHeaderType_template& other_value);
~AnyHeaderType_template();
AnyHeaderType_template& operator=(template_sel other_value);
AnyHeaderType_template& operator=(const AnyHeaderType& other_value);
AnyHeaderType_template& operator=(const OPTIONAL<AnyHeaderType>& other_value);
AnyHeaderType_template& operator=(const AnyHeaderType_template& other_value);
boolean match(const AnyHeaderType& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AnyHeaderType valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AnyHeaderType_template& list_item(unsigned int list_index) const;
HeaderType_template& headerType();
const HeaderType_template& headerType() const;
INTEGER_template& headerSubType();
const INTEGER_template& headerSubType() const;
int size_of() const;
void log() const;
void log_match(const AnyHeaderType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class BeaconHeaderType : public Base_Type {
  HeaderType field_headerType;
  INTEGER field_headerSubType;
  boolean bound_flag;
public:
  BeaconHeaderType();
  BeaconHeaderType(const HeaderType& par_headerType,
    const INTEGER& par_headerSubType);
  BeaconHeaderType(const BeaconHeaderType& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BeaconHeaderType& operator=(const BeaconHeaderType& other_value);
  boolean operator==(const BeaconHeaderType& other_value) const;
  inline boolean operator!=(const BeaconHeaderType& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline HeaderType& headerType()
    {return field_headerType;}
  inline const HeaderType& headerType() const
    {return field_headerType;}
  inline INTEGER& headerSubType()
    {return field_headerSubType;}
  inline const INTEGER& headerSubType() const
    {return field_headerSubType;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class BeaconHeaderType_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BeaconHeaderType_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BeaconHeaderType& other_value);
void copy_template(const BeaconHeaderType_template& other_value);

public:
BeaconHeaderType_template();
BeaconHeaderType_template(template_sel other_value);
BeaconHeaderType_template(const BeaconHeaderType& other_value);
BeaconHeaderType_template(const OPTIONAL<BeaconHeaderType>& other_value);
BeaconHeaderType_template(const BeaconHeaderType_template& other_value);
~BeaconHeaderType_template();
BeaconHeaderType_template& operator=(template_sel other_value);
BeaconHeaderType_template& operator=(const BeaconHeaderType& other_value);
BeaconHeaderType_template& operator=(const OPTIONAL<BeaconHeaderType>& other_value);
BeaconHeaderType_template& operator=(const BeaconHeaderType_template& other_value);
boolean match(const BeaconHeaderType& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BeaconHeaderType valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BeaconHeaderType_template& list_item(unsigned int list_index) const;
HeaderType_template& headerType();
const HeaderType_template& headerType() const;
INTEGER_template& headerSubType();
const INTEGER_template& headerSubType() const;
int size_of() const;
void log() const;
void log_match(const BeaconHeaderType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GeoUnicastHeaderType : public Base_Type {
  HeaderType field_headerType;
  INTEGER field_headerSubType;
  boolean bound_flag;
public:
  GeoUnicastHeaderType();
  GeoUnicastHeaderType(const HeaderType& par_headerType,
    const INTEGER& par_headerSubType);
  GeoUnicastHeaderType(const GeoUnicastHeaderType& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GeoUnicastHeaderType& operator=(const GeoUnicastHeaderType& other_value);
  boolean operator==(const GeoUnicastHeaderType& other_value) const;
  inline boolean operator!=(const GeoUnicastHeaderType& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline HeaderType& headerType()
    {return field_headerType;}
  inline const HeaderType& headerType() const
    {return field_headerType;}
  inline INTEGER& headerSubType()
    {return field_headerSubType;}
  inline const INTEGER& headerSubType() const
    {return field_headerSubType;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GeoUnicastHeaderType_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GeoUnicastHeaderType_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GeoUnicastHeaderType& other_value);
void copy_template(const GeoUnicastHeaderType_template& other_value);

public:
GeoUnicastHeaderType_template();
GeoUnicastHeaderType_template(template_sel other_value);
GeoUnicastHeaderType_template(const GeoUnicastHeaderType& other_value);
GeoUnicastHeaderType_template(const OPTIONAL<GeoUnicastHeaderType>& other_value);
GeoUnicastHeaderType_template(const GeoUnicastHeaderType_template& other_value);
~GeoUnicastHeaderType_template();
GeoUnicastHeaderType_template& operator=(template_sel other_value);
GeoUnicastHeaderType_template& operator=(const GeoUnicastHeaderType& other_value);
GeoUnicastHeaderType_template& operator=(const OPTIONAL<GeoUnicastHeaderType>& other_value);
GeoUnicastHeaderType_template& operator=(const GeoUnicastHeaderType_template& other_value);
boolean match(const GeoUnicastHeaderType& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GeoUnicastHeaderType valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GeoUnicastHeaderType_template& list_item(unsigned int list_index) const;
HeaderType_template& headerType();
const HeaderType_template& headerType() const;
INTEGER_template& headerSubType();
const INTEGER_template& headerSubType() const;
int size_of() const;
void log() const;
void log_match(const GeoUnicastHeaderType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GeoAnycastHeaderType : public Base_Type {
  HeaderType field_headerType;
  HeaderSubTypeGeoAnycast field_headerSubType;
  boolean bound_flag;
public:
  GeoAnycastHeaderType();
  GeoAnycastHeaderType(const HeaderType& par_headerType,
    const HeaderSubTypeGeoAnycast& par_headerSubType);
  GeoAnycastHeaderType(const GeoAnycastHeaderType& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GeoAnycastHeaderType& operator=(const GeoAnycastHeaderType& other_value);
  boolean operator==(const GeoAnycastHeaderType& other_value) const;
  inline boolean operator!=(const GeoAnycastHeaderType& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline HeaderType& headerType()
    {return field_headerType;}
  inline const HeaderType& headerType() const
    {return field_headerType;}
  inline HeaderSubTypeGeoAnycast& headerSubType()
    {return field_headerSubType;}
  inline const HeaderSubTypeGeoAnycast& headerSubType() const
    {return field_headerSubType;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GeoAnycastHeaderType_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GeoAnycastHeaderType_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GeoAnycastHeaderType& other_value);
void copy_template(const GeoAnycastHeaderType_template& other_value);

public:
GeoAnycastHeaderType_template();
GeoAnycastHeaderType_template(template_sel other_value);
GeoAnycastHeaderType_template(const GeoAnycastHeaderType& other_value);
GeoAnycastHeaderType_template(const OPTIONAL<GeoAnycastHeaderType>& other_value);
GeoAnycastHeaderType_template(const GeoAnycastHeaderType_template& other_value);
~GeoAnycastHeaderType_template();
GeoAnycastHeaderType_template& operator=(template_sel other_value);
GeoAnycastHeaderType_template& operator=(const GeoAnycastHeaderType& other_value);
GeoAnycastHeaderType_template& operator=(const OPTIONAL<GeoAnycastHeaderType>& other_value);
GeoAnycastHeaderType_template& operator=(const GeoAnycastHeaderType_template& other_value);
boolean match(const GeoAnycastHeaderType& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GeoAnycastHeaderType valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GeoAnycastHeaderType_template& list_item(unsigned int list_index) const;
HeaderType_template& headerType();
const HeaderType_template& headerType() const;
HeaderSubTypeGeoAnycast_template& headerSubType();
const HeaderSubTypeGeoAnycast_template& headerSubType() const;
int size_of() const;
void log() const;
void log_match(const GeoAnycastHeaderType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GeoBroadcastHeaderType : public Base_Type {
  HeaderType field_headerType;
  HeaderSubTypeGeoBroadcast field_headerSubType;
  boolean bound_flag;
public:
  GeoBroadcastHeaderType();
  GeoBroadcastHeaderType(const HeaderType& par_headerType,
    const HeaderSubTypeGeoBroadcast& par_headerSubType);
  GeoBroadcastHeaderType(const GeoBroadcastHeaderType& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GeoBroadcastHeaderType& operator=(const GeoBroadcastHeaderType& other_value);
  boolean operator==(const GeoBroadcastHeaderType& other_value) const;
  inline boolean operator!=(const GeoBroadcastHeaderType& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline HeaderType& headerType()
    {return field_headerType;}
  inline const HeaderType& headerType() const
    {return field_headerType;}
  inline HeaderSubTypeGeoBroadcast& headerSubType()
    {return field_headerSubType;}
  inline const HeaderSubTypeGeoBroadcast& headerSubType() const
    {return field_headerSubType;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GeoBroadcastHeaderType_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GeoBroadcastHeaderType_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GeoBroadcastHeaderType& other_value);
void copy_template(const GeoBroadcastHeaderType_template& other_value);

public:
GeoBroadcastHeaderType_template();
GeoBroadcastHeaderType_template(template_sel other_value);
GeoBroadcastHeaderType_template(const GeoBroadcastHeaderType& other_value);
GeoBroadcastHeaderType_template(const OPTIONAL<GeoBroadcastHeaderType>& other_value);
GeoBroadcastHeaderType_template(const GeoBroadcastHeaderType_template& other_value);
~GeoBroadcastHeaderType_template();
GeoBroadcastHeaderType_template& operator=(template_sel other_value);
GeoBroadcastHeaderType_template& operator=(const GeoBroadcastHeaderType& other_value);
GeoBroadcastHeaderType_template& operator=(const OPTIONAL<GeoBroadcastHeaderType>& other_value);
GeoBroadcastHeaderType_template& operator=(const GeoBroadcastHeaderType_template& other_value);
boolean match(const GeoBroadcastHeaderType& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GeoBroadcastHeaderType valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GeoBroadcastHeaderType_template& list_item(unsigned int list_index) const;
HeaderType_template& headerType();
const HeaderType_template& headerType() const;
HeaderSubTypeGeoBroadcast_template& headerSubType();
const HeaderSubTypeGeoBroadcast_template& headerSubType() const;
int size_of() const;
void log() const;
void log_match(const GeoBroadcastHeaderType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HeaderSubTypeTSB : public Base_Type { // enum
friend class HeaderSubTypeTSB_template;
public:
enum enum_type { e__singleHop = 0, e__multiHop = 1, e__reserved = 2, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
HeaderSubTypeTSB();
HeaderSubTypeTSB(int other_value);
HeaderSubTypeTSB(enum_type other_value);
HeaderSubTypeTSB(const HeaderSubTypeTSB& other_value);

HeaderSubTypeTSB& operator=(int other_value);
HeaderSubTypeTSB& operator=(enum_type other_value);
HeaderSubTypeTSB& operator=(const HeaderSubTypeTSB& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const HeaderSubTypeTSB& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const HeaderSubTypeTSB& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const HeaderSubTypeTSB& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const HeaderSubTypeTSB& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const HeaderSubTypeTSB& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const HeaderSubTypeTSB& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const HeaderSubTypeTSB& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class HeaderSubTypeTSB_template : public Base_Template {
union {
HeaderSubTypeTSB::enum_type single_value;
struct {
unsigned int n_values;
HeaderSubTypeTSB_template *list_value;
} value_list;
};

void copy_template(const HeaderSubTypeTSB_template& other_value);

public:
HeaderSubTypeTSB_template();
HeaderSubTypeTSB_template(template_sel other_value);
HeaderSubTypeTSB_template(int other_value);
HeaderSubTypeTSB_template(HeaderSubTypeTSB::enum_type other_value);
HeaderSubTypeTSB_template(const HeaderSubTypeTSB& other_value);
HeaderSubTypeTSB_template(const OPTIONAL<HeaderSubTypeTSB>& other_value);
HeaderSubTypeTSB_template(const HeaderSubTypeTSB_template& other_value);
~HeaderSubTypeTSB_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
HeaderSubTypeTSB_template& operator=(template_sel other_value);
HeaderSubTypeTSB_template& operator=(int other_value);
HeaderSubTypeTSB_template& operator=(HeaderSubTypeTSB::enum_type other_value);
HeaderSubTypeTSB_template& operator=(const HeaderSubTypeTSB& other_value);
HeaderSubTypeTSB_template& operator=(const OPTIONAL<HeaderSubTypeTSB>& other_value);
HeaderSubTypeTSB_template& operator=(const HeaderSubTypeTSB_template& other_value);

boolean match(HeaderSubTypeTSB::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const HeaderSubTypeTSB& other_value, boolean legacy = FALSE) const;
HeaderSubTypeTSB::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HeaderSubTypeTSB_template& list_item(unsigned int list_index);
void log() const;
void log_match(const HeaderSubTypeTSB& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class TsbHeaderType : public Base_Type {
  HeaderType field_headerType;
  HeaderSubTypeTSB field_headerSubType;
  boolean bound_flag;
public:
  TsbHeaderType();
  TsbHeaderType(const HeaderType& par_headerType,
    const HeaderSubTypeTSB& par_headerSubType);
  TsbHeaderType(const TsbHeaderType& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TsbHeaderType& operator=(const TsbHeaderType& other_value);
  boolean operator==(const TsbHeaderType& other_value) const;
  inline boolean operator!=(const TsbHeaderType& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline HeaderType& headerType()
    {return field_headerType;}
  inline const HeaderType& headerType() const
    {return field_headerType;}
  inline HeaderSubTypeTSB& headerSubType()
    {return field_headerSubType;}
  inline const HeaderSubTypeTSB& headerSubType() const
    {return field_headerSubType;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TsbHeaderType_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TsbHeaderType_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TsbHeaderType& other_value);
void copy_template(const TsbHeaderType_template& other_value);

public:
TsbHeaderType_template();
TsbHeaderType_template(template_sel other_value);
TsbHeaderType_template(const TsbHeaderType& other_value);
TsbHeaderType_template(const OPTIONAL<TsbHeaderType>& other_value);
TsbHeaderType_template(const TsbHeaderType_template& other_value);
~TsbHeaderType_template();
TsbHeaderType_template& operator=(template_sel other_value);
TsbHeaderType_template& operator=(const TsbHeaderType& other_value);
TsbHeaderType_template& operator=(const OPTIONAL<TsbHeaderType>& other_value);
TsbHeaderType_template& operator=(const TsbHeaderType_template& other_value);
boolean match(const TsbHeaderType& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TsbHeaderType valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TsbHeaderType_template& list_item(unsigned int list_index) const;
HeaderType_template& headerType();
const HeaderType_template& headerType() const;
HeaderSubTypeTSB_template& headerSubType();
const HeaderSubTypeTSB_template& headerSubType() const;
int size_of() const;
void log() const;
void log_match(const TsbHeaderType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HeaderSubTypeLs : public Base_Type { // enum
friend class HeaderSubTypeLs_template;
public:
enum enum_type { e__lsRequest = 0, e__lsReply = 1, e__reserved = 2, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
HeaderSubTypeLs();
HeaderSubTypeLs(int other_value);
HeaderSubTypeLs(enum_type other_value);
HeaderSubTypeLs(const HeaderSubTypeLs& other_value);

HeaderSubTypeLs& operator=(int other_value);
HeaderSubTypeLs& operator=(enum_type other_value);
HeaderSubTypeLs& operator=(const HeaderSubTypeLs& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const HeaderSubTypeLs& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const HeaderSubTypeLs& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const HeaderSubTypeLs& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const HeaderSubTypeLs& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const HeaderSubTypeLs& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const HeaderSubTypeLs& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const HeaderSubTypeLs& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class HeaderSubTypeLs_template : public Base_Template {
union {
HeaderSubTypeLs::enum_type single_value;
struct {
unsigned int n_values;
HeaderSubTypeLs_template *list_value;
} value_list;
};

void copy_template(const HeaderSubTypeLs_template& other_value);

public:
HeaderSubTypeLs_template();
HeaderSubTypeLs_template(template_sel other_value);
HeaderSubTypeLs_template(int other_value);
HeaderSubTypeLs_template(HeaderSubTypeLs::enum_type other_value);
HeaderSubTypeLs_template(const HeaderSubTypeLs& other_value);
HeaderSubTypeLs_template(const OPTIONAL<HeaderSubTypeLs>& other_value);
HeaderSubTypeLs_template(const HeaderSubTypeLs_template& other_value);
~HeaderSubTypeLs_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
HeaderSubTypeLs_template& operator=(template_sel other_value);
HeaderSubTypeLs_template& operator=(int other_value);
HeaderSubTypeLs_template& operator=(HeaderSubTypeLs::enum_type other_value);
HeaderSubTypeLs_template& operator=(const HeaderSubTypeLs& other_value);
HeaderSubTypeLs_template& operator=(const OPTIONAL<HeaderSubTypeLs>& other_value);
HeaderSubTypeLs_template& operator=(const HeaderSubTypeLs_template& other_value);

boolean match(HeaderSubTypeLs::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const HeaderSubTypeLs& other_value, boolean legacy = FALSE) const;
HeaderSubTypeLs::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HeaderSubTypeLs_template& list_item(unsigned int list_index);
void log() const;
void log_match(const HeaderSubTypeLs& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class LsHeaderType : public Base_Type {
  HeaderType field_headerType;
  HeaderSubTypeLs field_headerSubType;
  boolean bound_flag;
public:
  LsHeaderType();
  LsHeaderType(const HeaderType& par_headerType,
    const HeaderSubTypeLs& par_headerSubType);
  LsHeaderType(const LsHeaderType& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  LsHeaderType& operator=(const LsHeaderType& other_value);
  boolean operator==(const LsHeaderType& other_value) const;
  inline boolean operator!=(const LsHeaderType& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline HeaderType& headerType()
    {return field_headerType;}
  inline const HeaderType& headerType() const
    {return field_headerType;}
  inline HeaderSubTypeLs& headerSubType()
    {return field_headerSubType;}
  inline const HeaderSubTypeLs& headerSubType() const
    {return field_headerSubType;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class LsHeaderType_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
LsHeaderType_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const LsHeaderType& other_value);
void copy_template(const LsHeaderType_template& other_value);

public:
LsHeaderType_template();
LsHeaderType_template(template_sel other_value);
LsHeaderType_template(const LsHeaderType& other_value);
LsHeaderType_template(const OPTIONAL<LsHeaderType>& other_value);
LsHeaderType_template(const LsHeaderType_template& other_value);
~LsHeaderType_template();
LsHeaderType_template& operator=(template_sel other_value);
LsHeaderType_template& operator=(const LsHeaderType& other_value);
LsHeaderType_template& operator=(const OPTIONAL<LsHeaderType>& other_value);
LsHeaderType_template& operator=(const LsHeaderType_template& other_value);
boolean match(const LsHeaderType& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
LsHeaderType valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
LsHeaderType_template& list_item(unsigned int list_index) const;
HeaderType_template& headerType();
const HeaderType_template& headerType() const;
HeaderSubTypeLs_template& headerSubType();
const HeaderSubTypeLs_template& headerSubType() const;
int size_of() const;
void log() const;
void log_match(const LsHeaderType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HeaderSubTypeSa : public Base_Type { // enum
friend class HeaderSubTypeSa_template;
public:
enum enum_type { e__sa = 0, e__saEos = 1, e__reserved = 2, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
HeaderSubTypeSa();
HeaderSubTypeSa(int other_value);
HeaderSubTypeSa(enum_type other_value);
HeaderSubTypeSa(const HeaderSubTypeSa& other_value);

HeaderSubTypeSa& operator=(int other_value);
HeaderSubTypeSa& operator=(enum_type other_value);
HeaderSubTypeSa& operator=(const HeaderSubTypeSa& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const HeaderSubTypeSa& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const HeaderSubTypeSa& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const HeaderSubTypeSa& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const HeaderSubTypeSa& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const HeaderSubTypeSa& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const HeaderSubTypeSa& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const HeaderSubTypeSa& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class HeaderSubTypeSa_template : public Base_Template {
union {
HeaderSubTypeSa::enum_type single_value;
struct {
unsigned int n_values;
HeaderSubTypeSa_template *list_value;
} value_list;
};

void copy_template(const HeaderSubTypeSa_template& other_value);

public:
HeaderSubTypeSa_template();
HeaderSubTypeSa_template(template_sel other_value);
HeaderSubTypeSa_template(int other_value);
HeaderSubTypeSa_template(HeaderSubTypeSa::enum_type other_value);
HeaderSubTypeSa_template(const HeaderSubTypeSa& other_value);
HeaderSubTypeSa_template(const OPTIONAL<HeaderSubTypeSa>& other_value);
HeaderSubTypeSa_template(const HeaderSubTypeSa_template& other_value);
~HeaderSubTypeSa_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
HeaderSubTypeSa_template& operator=(template_sel other_value);
HeaderSubTypeSa_template& operator=(int other_value);
HeaderSubTypeSa_template& operator=(HeaderSubTypeSa::enum_type other_value);
HeaderSubTypeSa_template& operator=(const HeaderSubTypeSa& other_value);
HeaderSubTypeSa_template& operator=(const OPTIONAL<HeaderSubTypeSa>& other_value);
HeaderSubTypeSa_template& operator=(const HeaderSubTypeSa_template& other_value);

boolean match(HeaderSubTypeSa::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const HeaderSubTypeSa& other_value, boolean legacy = FALSE) const;
HeaderSubTypeSa::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HeaderSubTypeSa_template& list_item(unsigned int list_index);
void log() const;
void log_match(const HeaderSubTypeSa& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SaHeaderType : public Base_Type {
  HeaderType field_headerType;
  HeaderSubTypeSa field_headerSubType;
  boolean bound_flag;
public:
  SaHeaderType();
  SaHeaderType(const HeaderType& par_headerType,
    const HeaderSubTypeSa& par_headerSubType);
  SaHeaderType(const SaHeaderType& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SaHeaderType& operator=(const SaHeaderType& other_value);
  boolean operator==(const SaHeaderType& other_value) const;
  inline boolean operator!=(const SaHeaderType& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline HeaderType& headerType()
    {return field_headerType;}
  inline const HeaderType& headerType() const
    {return field_headerType;}
  inline HeaderSubTypeSa& headerSubType()
    {return field_headerSubType;}
  inline const HeaderSubTypeSa& headerSubType() const
    {return field_headerSubType;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SaHeaderType_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SaHeaderType_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SaHeaderType& other_value);
void copy_template(const SaHeaderType_template& other_value);

public:
SaHeaderType_template();
SaHeaderType_template(template_sel other_value);
SaHeaderType_template(const SaHeaderType& other_value);
SaHeaderType_template(const OPTIONAL<SaHeaderType>& other_value);
SaHeaderType_template(const SaHeaderType_template& other_value);
~SaHeaderType_template();
SaHeaderType_template& operator=(template_sel other_value);
SaHeaderType_template& operator=(const SaHeaderType& other_value);
SaHeaderType_template& operator=(const OPTIONAL<SaHeaderType>& other_value);
SaHeaderType_template& operator=(const SaHeaderType_template& other_value);
boolean match(const SaHeaderType& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SaHeaderType valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SaHeaderType_template& list_item(unsigned int list_index) const;
HeaderType_template& headerType();
const HeaderType_template& headerType() const;
HeaderSubTypeSa_template& headerSubType();
const HeaderSubTypeSa_template& headerSubType() const;
int size_of() const;
void log() const;
void log_match(const SaHeaderType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SCF : public Base_Type { // enum
friend class SCF_template;
public:
enum enum_type { e__scfDisabled = 0, e__scfEnable = 1, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
SCF();
SCF(int other_value);
SCF(enum_type other_value);
SCF(const SCF& other_value);

SCF& operator=(int other_value);
SCF& operator=(enum_type other_value);
SCF& operator=(const SCF& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const SCF& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SCF& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const SCF& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const SCF& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const SCF& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const SCF& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const SCF& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SCF_template : public Base_Template {
union {
SCF::enum_type single_value;
struct {
unsigned int n_values;
SCF_template *list_value;
} value_list;
};

void copy_template(const SCF_template& other_value);

public:
SCF_template();
SCF_template(template_sel other_value);
SCF_template(int other_value);
SCF_template(SCF::enum_type other_value);
SCF_template(const SCF& other_value);
SCF_template(const OPTIONAL<SCF>& other_value);
SCF_template(const SCF_template& other_value);
~SCF_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
SCF_template& operator=(template_sel other_value);
SCF_template& operator=(int other_value);
SCF_template& operator=(SCF::enum_type other_value);
SCF_template& operator=(const SCF& other_value);
SCF_template& operator=(const OPTIONAL<SCF>& other_value);
SCF_template& operator=(const SCF_template& other_value);

boolean match(SCF::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const SCF& other_value, boolean legacy = FALSE) const;
SCF::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SCF_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SCF& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ChannelOffload : public Base_Type { // enum
friend class ChannelOffload_template;
public:
enum enum_type { e__choffDisabled = 0, e__choffEnable = 1, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
ChannelOffload();
ChannelOffload(int other_value);
ChannelOffload(enum_type other_value);
ChannelOffload(const ChannelOffload& other_value);

ChannelOffload& operator=(int other_value);
ChannelOffload& operator=(enum_type other_value);
ChannelOffload& operator=(const ChannelOffload& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const ChannelOffload& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ChannelOffload& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const ChannelOffload& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const ChannelOffload& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const ChannelOffload& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const ChannelOffload& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const ChannelOffload& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ChannelOffload_template : public Base_Template {
union {
ChannelOffload::enum_type single_value;
struct {
unsigned int n_values;
ChannelOffload_template *list_value;
} value_list;
};

void copy_template(const ChannelOffload_template& other_value);

public:
ChannelOffload_template();
ChannelOffload_template(template_sel other_value);
ChannelOffload_template(int other_value);
ChannelOffload_template(ChannelOffload::enum_type other_value);
ChannelOffload_template(const ChannelOffload& other_value);
ChannelOffload_template(const OPTIONAL<ChannelOffload>& other_value);
ChannelOffload_template(const ChannelOffload_template& other_value);
~ChannelOffload_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
ChannelOffload_template& operator=(template_sel other_value);
ChannelOffload_template& operator=(int other_value);
ChannelOffload_template& operator=(ChannelOffload::enum_type other_value);
ChannelOffload_template& operator=(const ChannelOffload& other_value);
ChannelOffload_template& operator=(const OPTIONAL<ChannelOffload>& other_value);
ChannelOffload_template& operator=(const ChannelOffload_template& other_value);

boolean match(ChannelOffload::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const ChannelOffload& other_value, boolean legacy = FALSE) const;
ChannelOffload::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ChannelOffload_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ChannelOffload& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class TrafficClass : public Base_Type {
  SCF field_scf;
  ChannelOffload field_channelOffload;
  INTEGER field_tcId;
  boolean bound_flag;
public:
  TrafficClass();
  TrafficClass(const SCF& par_scf,
    const ChannelOffload& par_channelOffload,
    const INTEGER& par_tcId);
  TrafficClass(const TrafficClass& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TrafficClass& operator=(const TrafficClass& other_value);
  boolean operator==(const TrafficClass& other_value) const;
  inline boolean operator!=(const TrafficClass& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline SCF& scf()
    {return field_scf;}
  inline const SCF& scf() const
    {return field_scf;}
  inline ChannelOffload& channelOffload()
    {return field_channelOffload;}
  inline const ChannelOffload& channelOffload() const
    {return field_channelOffload;}
  inline INTEGER& tcId()
    {return field_tcId;}
  inline const INTEGER& tcId() const
    {return field_tcId;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TrafficClass_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TrafficClass_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TrafficClass& other_value);
void copy_template(const TrafficClass_template& other_value);

public:
TrafficClass_template();
TrafficClass_template(template_sel other_value);
TrafficClass_template(const TrafficClass& other_value);
TrafficClass_template(const OPTIONAL<TrafficClass>& other_value);
TrafficClass_template(const TrafficClass_template& other_value);
~TrafficClass_template();
TrafficClass_template& operator=(template_sel other_value);
TrafficClass_template& operator=(const TrafficClass& other_value);
TrafficClass_template& operator=(const OPTIONAL<TrafficClass>& other_value);
TrafficClass_template& operator=(const TrafficClass_template& other_value);
boolean match(const TrafficClass& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TrafficClass valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TrafficClass_template& list_item(unsigned int list_index) const;
SCF_template& scf();
const SCF_template& scf() const;
ChannelOffload_template& channelOffload();
const ChannelOffload_template& channelOffload() const;
INTEGER_template& tcId();
const INTEGER_template& tcId() const;
int size_of() const;
void log() const;
void log_match(const TrafficClass& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CommonHeader : public Base_Type {
  NextHeader field_nextHeader;
  INTEGER field_reserved;
  HeaderTST field_headerTST;
  TrafficClass field_trafficClass;
  BITSTRING field_flags;
  INTEGER field_plLength;
  INTEGER field_maxHopLimit;
  INTEGER field_reserved2;
  boolean bound_flag;
public:
  CommonHeader();
  CommonHeader(const NextHeader& par_nextHeader,
    const INTEGER& par_reserved,
    const HeaderTST& par_headerTST,
    const TrafficClass& par_trafficClass,
    const BITSTRING& par_flags,
    const INTEGER& par_plLength,
    const INTEGER& par_maxHopLimit,
    const INTEGER& par_reserved2);
  CommonHeader(const CommonHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CommonHeader& operator=(const CommonHeader& other_value);
  boolean operator==(const CommonHeader& other_value) const;
  inline boolean operator!=(const CommonHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NextHeader& nextHeader()
    {return field_nextHeader;}
  inline const NextHeader& nextHeader() const
    {return field_nextHeader;}
  inline INTEGER& reserved()
    {return field_reserved;}
  inline const INTEGER& reserved() const
    {return field_reserved;}
  inline HeaderTST& headerTST()
    {return field_headerTST;}
  inline const HeaderTST& headerTST() const
    {return field_headerTST;}
  inline TrafficClass& trafficClass()
    {return field_trafficClass;}
  inline const TrafficClass& trafficClass() const
    {return field_trafficClass;}
  inline BITSTRING& flags()
    {return field_flags;}
  inline const BITSTRING& flags() const
    {return field_flags;}
  inline INTEGER& plLength()
    {return field_plLength;}
  inline const INTEGER& plLength() const
    {return field_plLength;}
  inline INTEGER& maxHopLimit()
    {return field_maxHopLimit;}
  inline const INTEGER& maxHopLimit() const
    {return field_maxHopLimit;}
  inline INTEGER& reserved2()
    {return field_reserved2;}
  inline const INTEGER& reserved2() const
    {return field_reserved2;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class CommonHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CommonHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CommonHeader& other_value);
void copy_template(const CommonHeader_template& other_value);

public:
CommonHeader_template();
CommonHeader_template(template_sel other_value);
CommonHeader_template(const CommonHeader& other_value);
CommonHeader_template(const OPTIONAL<CommonHeader>& other_value);
CommonHeader_template(const CommonHeader_template& other_value);
~CommonHeader_template();
CommonHeader_template& operator=(template_sel other_value);
CommonHeader_template& operator=(const CommonHeader& other_value);
CommonHeader_template& operator=(const OPTIONAL<CommonHeader>& other_value);
CommonHeader_template& operator=(const CommonHeader_template& other_value);
boolean match(const CommonHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CommonHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CommonHeader_template& list_item(unsigned int list_index) const;
NextHeader_template& nextHeader();
const NextHeader_template& nextHeader() const;
INTEGER_template& reserved();
const INTEGER_template& reserved() const;
HeaderTST_template& headerTST();
const HeaderTST_template& headerTST() const;
TrafficClass_template& trafficClass();
const TrafficClass_template& trafficClass() const;
BITSTRING_template& flags();
const BITSTRING_template& flags() const;
INTEGER_template& plLength();
const INTEGER_template& plLength() const;
INTEGER_template& maxHopLimit();
const INTEGER_template& maxHopLimit() const;
INTEGER_template& reserved2();
const INTEGER_template& reserved2() const;
int size_of() const;
void log() const;
void log_match(const CommonHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GnNonSecuredPacket : public Base_Type {
  CommonHeader field_commonHeader;
  OPTIONAL<ExtendedHeader> field_extendedHeader;
  OPTIONAL<Payload> field_payload;
  boolean bound_flag;
public:
  GnNonSecuredPacket();
  GnNonSecuredPacket(const CommonHeader& par_commonHeader,
    const OPTIONAL<ExtendedHeader>& par_extendedHeader,
    const OPTIONAL<Payload>& par_payload);
  GnNonSecuredPacket(const GnNonSecuredPacket& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GnNonSecuredPacket& operator=(const GnNonSecuredPacket& other_value);
  boolean operator==(const GnNonSecuredPacket& other_value) const;
  inline boolean operator!=(const GnNonSecuredPacket& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline CommonHeader& commonHeader()
    {return field_commonHeader;}
  inline const CommonHeader& commonHeader() const
    {return field_commonHeader;}
  inline OPTIONAL<ExtendedHeader>& extendedHeader()
    {return field_extendedHeader;}
  inline const OPTIONAL<ExtendedHeader>& extendedHeader() const
    {return field_extendedHeader;}
  inline OPTIONAL<Payload>& payload()
    {return field_payload;}
  inline const OPTIONAL<Payload>& payload() const
    {return field_payload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GnNonSecuredPacket_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GnNonSecuredPacket_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GnNonSecuredPacket& other_value);
void copy_template(const GnNonSecuredPacket_template& other_value);

public:
GnNonSecuredPacket_template();
GnNonSecuredPacket_template(template_sel other_value);
GnNonSecuredPacket_template(const GnNonSecuredPacket& other_value);
GnNonSecuredPacket_template(const OPTIONAL<GnNonSecuredPacket>& other_value);
GnNonSecuredPacket_template(const GnNonSecuredPacket_template& other_value);
~GnNonSecuredPacket_template();
GnNonSecuredPacket_template& operator=(template_sel other_value);
GnNonSecuredPacket_template& operator=(const GnNonSecuredPacket& other_value);
GnNonSecuredPacket_template& operator=(const OPTIONAL<GnNonSecuredPacket>& other_value);
GnNonSecuredPacket_template& operator=(const GnNonSecuredPacket_template& other_value);
boolean match(const GnNonSecuredPacket& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GnNonSecuredPacket valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GnNonSecuredPacket_template& list_item(unsigned int list_index) const;
CommonHeader_template& commonHeader();
const CommonHeader_template& commonHeader() const;
ExtendedHeader_template& extendedHeader();
const ExtendedHeader_template& extendedHeader() const;
Payload_template& payload();
const Payload_template& payload() const;
int size_of() const;
void log() const;
void log_match(const GnNonSecuredPacket& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtendedHeader : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_geoUnicastHeader = 1, ALT_tsbHeader = 2, ALT_shbHeader = 3, ALT_geoBroadcastHeader = 4, ALT_geoAnycastHeader = 5, ALT_beaconHeader = 6, ALT_lsRequestHeader = 7, ALT_lsReplyHeader = 8, ALT_anyHeader = 9 };
private:
union_selection_type union_selection;
union {
GeoUnicastHeader *field_geoUnicastHeader;
TSBHeader *field_tsbHeader;
SHBHeader *field_shbHeader;
GeoAnycastHeader *field_geoBroadcastHeader;
GeoAnycastHeader *field_geoAnycastHeader;
BeaconHeader *field_beaconHeader;
LSRequestHeader *field_lsRequestHeader;
LSReplyHeader *field_lsReplyHeader;
AnyHeader *field_anyHeader;
};
void copy_value(const ExtendedHeader& other_value);

public:
ExtendedHeader();
ExtendedHeader(const ExtendedHeader& other_value);
~ExtendedHeader();
ExtendedHeader& operator=(const ExtendedHeader& other_value);
boolean operator==(const ExtendedHeader& other_value) const;
inline boolean operator!=(const ExtendedHeader& other_value) const { return !(*this == other_value); }
GeoUnicastHeader& geoUnicastHeader();
const GeoUnicastHeader& geoUnicastHeader() const;
TSBHeader& tsbHeader();
const TSBHeader& tsbHeader() const;
SHBHeader& shbHeader();
const SHBHeader& shbHeader() const;
GeoAnycastHeader& geoBroadcastHeader();
const GeoAnycastHeader& geoBroadcastHeader() const;
GeoAnycastHeader& geoAnycastHeader();
const GeoAnycastHeader& geoAnycastHeader() const;
BeaconHeader& beaconHeader();
const BeaconHeader& beaconHeader() const;
LSRequestHeader& lsRequestHeader();
const LSRequestHeader& lsRequestHeader() const;
LSReplyHeader& lsReplyHeader();
const LSReplyHeader& lsReplyHeader() const;
AnyHeader& anyHeader();
const AnyHeader& anyHeader() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ExtendedHeader_template : public Base_Template {
union {
struct {
ExtendedHeader::union_selection_type union_selection;
union {
GeoUnicastHeader_template *field_geoUnicastHeader;
TSBHeader_template *field_tsbHeader;
SHBHeader_template *field_shbHeader;
GeoAnycastHeader_template *field_geoBroadcastHeader;
GeoAnycastHeader_template *field_geoAnycastHeader;
BeaconHeader_template *field_beaconHeader;
LSRequestHeader_template *field_lsRequestHeader;
LSReplyHeader_template *field_lsReplyHeader;
AnyHeader_template *field_anyHeader;
};
} single_value;
struct {
unsigned int n_values;
ExtendedHeader_template *list_value;
} value_list;
};
void copy_value(const ExtendedHeader& other_value);

void copy_template(const ExtendedHeader_template& other_value);

public:
ExtendedHeader_template();
ExtendedHeader_template(template_sel other_value);
ExtendedHeader_template(const ExtendedHeader& other_value);
ExtendedHeader_template(const OPTIONAL<ExtendedHeader>& other_value);
ExtendedHeader_template(const ExtendedHeader_template& other_value);
~ExtendedHeader_template();
void clean_up();
ExtendedHeader_template& operator=(template_sel other_value);
ExtendedHeader_template& operator=(const ExtendedHeader& other_value);
ExtendedHeader_template& operator=(const OPTIONAL<ExtendedHeader>& other_value);
ExtendedHeader_template& operator=(const ExtendedHeader_template& other_value);
boolean match(const ExtendedHeader& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ExtendedHeader valueof() const;
ExtendedHeader_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
GeoUnicastHeader_template& geoUnicastHeader();
const GeoUnicastHeader_template& geoUnicastHeader() const;
TSBHeader_template& tsbHeader();
const TSBHeader_template& tsbHeader() const;
SHBHeader_template& shbHeader();
const SHBHeader_template& shbHeader() const;
GeoAnycastHeader_template& geoBroadcastHeader();
const GeoAnycastHeader_template& geoBroadcastHeader() const;
GeoAnycastHeader_template& geoAnycastHeader();
const GeoAnycastHeader_template& geoAnycastHeader() const;
BeaconHeader_template& beaconHeader();
const BeaconHeader_template& beaconHeader() const;
LSRequestHeader_template& lsRequestHeader();
const LSRequestHeader_template& lsRequestHeader() const;
LSReplyHeader_template& lsReplyHeader();
const LSReplyHeader_template& lsReplyHeader() const;
AnyHeader_template& anyHeader();
const AnyHeader_template& anyHeader() const;
boolean ischosen(ExtendedHeader::union_selection_type checked_selection) const;
void log() const;
void log_match(const ExtendedHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ShortPosVector : public Base_Type {
  GN__Address field_gnAddr;
  INTEGER field_timestamp;
  INTEGER field_latitude;
  INTEGER field_longitude;
  boolean bound_flag;
public:
  ShortPosVector();
  ShortPosVector(const GN__Address& par_gnAddr,
    const INTEGER& par_timestamp,
    const INTEGER& par_latitude,
    const INTEGER& par_longitude);
  ShortPosVector(const ShortPosVector& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ShortPosVector& operator=(const ShortPosVector& other_value);
  boolean operator==(const ShortPosVector& other_value) const;
  inline boolean operator!=(const ShortPosVector& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline GN__Address& gnAddr()
    {return field_gnAddr;}
  inline const GN__Address& gnAddr() const
    {return field_gnAddr;}
  inline INTEGER& timestamp()
    {return field_timestamp;}
  inline const INTEGER& timestamp() const
    {return field_timestamp;}
  inline INTEGER& latitude()
    {return field_latitude;}
  inline const INTEGER& latitude() const
    {return field_latitude;}
  inline INTEGER& longitude()
    {return field_longitude;}
  inline const INTEGER& longitude() const
    {return field_longitude;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class ShortPosVector_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ShortPosVector_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ShortPosVector& other_value);
void copy_template(const ShortPosVector_template& other_value);

public:
ShortPosVector_template();
ShortPosVector_template(template_sel other_value);
ShortPosVector_template(const ShortPosVector& other_value);
ShortPosVector_template(const OPTIONAL<ShortPosVector>& other_value);
ShortPosVector_template(const ShortPosVector_template& other_value);
~ShortPosVector_template();
ShortPosVector_template& operator=(template_sel other_value);
ShortPosVector_template& operator=(const ShortPosVector& other_value);
ShortPosVector_template& operator=(const OPTIONAL<ShortPosVector>& other_value);
ShortPosVector_template& operator=(const ShortPosVector_template& other_value);
boolean match(const ShortPosVector& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ShortPosVector valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ShortPosVector_template& list_item(unsigned int list_index) const;
GN__Address_template& gnAddr();
const GN__Address_template& gnAddr() const;
INTEGER_template& timestamp();
const INTEGER_template& timestamp() const;
INTEGER_template& latitude();
const INTEGER_template& latitude() const;
INTEGER_template& longitude();
const INTEGER_template& longitude() const;
int size_of() const;
void log() const;
void log_match(const ShortPosVector& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GeoUnicastHeader : public Base_Type {
  INTEGER field_seqNumber;
  INTEGER field_reserved;
  LongPosVector field_srcPosVector;
  ShortPosVector field_dstPosVector;
  boolean bound_flag;
public:
  GeoUnicastHeader();
  GeoUnicastHeader(const INTEGER& par_seqNumber,
    const INTEGER& par_reserved,
    const LongPosVector& par_srcPosVector,
    const ShortPosVector& par_dstPosVector);
  GeoUnicastHeader(const GeoUnicastHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GeoUnicastHeader& operator=(const GeoUnicastHeader& other_value);
  boolean operator==(const GeoUnicastHeader& other_value) const;
  inline boolean operator!=(const GeoUnicastHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& seqNumber()
    {return field_seqNumber;}
  inline const INTEGER& seqNumber() const
    {return field_seqNumber;}
  inline INTEGER& reserved()
    {return field_reserved;}
  inline const INTEGER& reserved() const
    {return field_reserved;}
  inline LongPosVector& srcPosVector()
    {return field_srcPosVector;}
  inline const LongPosVector& srcPosVector() const
    {return field_srcPosVector;}
  inline ShortPosVector& dstPosVector()
    {return field_dstPosVector;}
  inline const ShortPosVector& dstPosVector() const
    {return field_dstPosVector;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GeoUnicastHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GeoUnicastHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GeoUnicastHeader& other_value);
void copy_template(const GeoUnicastHeader_template& other_value);

public:
GeoUnicastHeader_template();
GeoUnicastHeader_template(template_sel other_value);
GeoUnicastHeader_template(const GeoUnicastHeader& other_value);
GeoUnicastHeader_template(const OPTIONAL<GeoUnicastHeader>& other_value);
GeoUnicastHeader_template(const GeoUnicastHeader_template& other_value);
~GeoUnicastHeader_template();
GeoUnicastHeader_template& operator=(template_sel other_value);
GeoUnicastHeader_template& operator=(const GeoUnicastHeader& other_value);
GeoUnicastHeader_template& operator=(const OPTIONAL<GeoUnicastHeader>& other_value);
GeoUnicastHeader_template& operator=(const GeoUnicastHeader_template& other_value);
boolean match(const GeoUnicastHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GeoUnicastHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GeoUnicastHeader_template& list_item(unsigned int list_index) const;
INTEGER_template& seqNumber();
const INTEGER_template& seqNumber() const;
INTEGER_template& reserved();
const INTEGER_template& reserved() const;
LongPosVector_template& srcPosVector();
const LongPosVector_template& srcPosVector() const;
ShortPosVector_template& dstPosVector();
const ShortPosVector_template& dstPosVector() const;
int size_of() const;
void log() const;
void log_match(const GeoUnicastHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TSBHeader : public Base_Type {
  INTEGER field_seqNumber;
  INTEGER field_reserved;
  LongPosVector field_srcPosVector;
  boolean bound_flag;
public:
  TSBHeader();
  TSBHeader(const INTEGER& par_seqNumber,
    const INTEGER& par_reserved,
    const LongPosVector& par_srcPosVector);
  TSBHeader(const TSBHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TSBHeader& operator=(const TSBHeader& other_value);
  boolean operator==(const TSBHeader& other_value) const;
  inline boolean operator!=(const TSBHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& seqNumber()
    {return field_seqNumber;}
  inline const INTEGER& seqNumber() const
    {return field_seqNumber;}
  inline INTEGER& reserved()
    {return field_reserved;}
  inline const INTEGER& reserved() const
    {return field_reserved;}
  inline LongPosVector& srcPosVector()
    {return field_srcPosVector;}
  inline const LongPosVector& srcPosVector() const
    {return field_srcPosVector;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class TSBHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TSBHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TSBHeader& other_value);
void copy_template(const TSBHeader_template& other_value);

public:
TSBHeader_template();
TSBHeader_template(template_sel other_value);
TSBHeader_template(const TSBHeader& other_value);
TSBHeader_template(const OPTIONAL<TSBHeader>& other_value);
TSBHeader_template(const TSBHeader_template& other_value);
~TSBHeader_template();
TSBHeader_template& operator=(template_sel other_value);
TSBHeader_template& operator=(const TSBHeader& other_value);
TSBHeader_template& operator=(const OPTIONAL<TSBHeader>& other_value);
TSBHeader_template& operator=(const TSBHeader_template& other_value);
boolean match(const TSBHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TSBHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TSBHeader_template& list_item(unsigned int list_index) const;
INTEGER_template& seqNumber();
const INTEGER_template& seqNumber() const;
INTEGER_template& reserved();
const INTEGER_template& reserved() const;
LongPosVector_template& srcPosVector();
const LongPosVector_template& srcPosVector() const;
int size_of() const;
void log() const;
void log_match(const TSBHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SHBHeader : public Base_Type {
  LongPosVector field_srcPosVector;
  INTEGER field_reserved;
  boolean bound_flag;
public:
  SHBHeader();
  SHBHeader(const LongPosVector& par_srcPosVector,
    const INTEGER& par_reserved);
  SHBHeader(const SHBHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SHBHeader& operator=(const SHBHeader& other_value);
  boolean operator==(const SHBHeader& other_value) const;
  inline boolean operator!=(const SHBHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline LongPosVector& srcPosVector()
    {return field_srcPosVector;}
  inline const LongPosVector& srcPosVector() const
    {return field_srcPosVector;}
  inline INTEGER& reserved()
    {return field_reserved;}
  inline const INTEGER& reserved() const
    {return field_reserved;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class SHBHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SHBHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SHBHeader& other_value);
void copy_template(const SHBHeader_template& other_value);

public:
SHBHeader_template();
SHBHeader_template(template_sel other_value);
SHBHeader_template(const SHBHeader& other_value);
SHBHeader_template(const OPTIONAL<SHBHeader>& other_value);
SHBHeader_template(const SHBHeader_template& other_value);
~SHBHeader_template();
SHBHeader_template& operator=(template_sel other_value);
SHBHeader_template& operator=(const SHBHeader& other_value);
SHBHeader_template& operator=(const OPTIONAL<SHBHeader>& other_value);
SHBHeader_template& operator=(const SHBHeader_template& other_value);
boolean match(const SHBHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SHBHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SHBHeader_template& list_item(unsigned int list_index) const;
LongPosVector_template& srcPosVector();
const LongPosVector_template& srcPosVector() const;
INTEGER_template& reserved();
const INTEGER_template& reserved() const;
int size_of() const;
void log() const;
void log_match(const SHBHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GeoAnycastHeader : public Base_Type {
  INTEGER field_seqNumber;
  INTEGER field_reserved;
  LongPosVector field_srcPosVector;
  INTEGER field_geoAreaPosLatitude;
  INTEGER field_geoAreaPosLongitude;
  INTEGER field_distanceA;
  INTEGER field_distanceB;
  INTEGER field_angle;
  INTEGER field_reserved2;
  boolean bound_flag;
public:
  GeoAnycastHeader();
  GeoAnycastHeader(const INTEGER& par_seqNumber,
    const INTEGER& par_reserved,
    const LongPosVector& par_srcPosVector,
    const INTEGER& par_geoAreaPosLatitude,
    const INTEGER& par_geoAreaPosLongitude,
    const INTEGER& par_distanceA,
    const INTEGER& par_distanceB,
    const INTEGER& par_angle,
    const INTEGER& par_reserved2);
  GeoAnycastHeader(const GeoAnycastHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GeoAnycastHeader& operator=(const GeoAnycastHeader& other_value);
  boolean operator==(const GeoAnycastHeader& other_value) const;
  inline boolean operator!=(const GeoAnycastHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& seqNumber()
    {return field_seqNumber;}
  inline const INTEGER& seqNumber() const
    {return field_seqNumber;}
  inline INTEGER& reserved()
    {return field_reserved;}
  inline const INTEGER& reserved() const
    {return field_reserved;}
  inline LongPosVector& srcPosVector()
    {return field_srcPosVector;}
  inline const LongPosVector& srcPosVector() const
    {return field_srcPosVector;}
  inline INTEGER& geoAreaPosLatitude()
    {return field_geoAreaPosLatitude;}
  inline const INTEGER& geoAreaPosLatitude() const
    {return field_geoAreaPosLatitude;}
  inline INTEGER& geoAreaPosLongitude()
    {return field_geoAreaPosLongitude;}
  inline const INTEGER& geoAreaPosLongitude() const
    {return field_geoAreaPosLongitude;}
  inline INTEGER& distanceA()
    {return field_distanceA;}
  inline const INTEGER& distanceA() const
    {return field_distanceA;}
  inline INTEGER& distanceB()
    {return field_distanceB;}
  inline const INTEGER& distanceB() const
    {return field_distanceB;}
  inline INTEGER& angle()
    {return field_angle;}
  inline const INTEGER& angle() const
    {return field_angle;}
  inline INTEGER& reserved2()
    {return field_reserved2;}
  inline const INTEGER& reserved2() const
    {return field_reserved2;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GeoAnycastHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GeoAnycastHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GeoAnycastHeader& other_value);
void copy_template(const GeoAnycastHeader_template& other_value);

public:
GeoAnycastHeader_template();
GeoAnycastHeader_template(template_sel other_value);
GeoAnycastHeader_template(const GeoAnycastHeader& other_value);
GeoAnycastHeader_template(const OPTIONAL<GeoAnycastHeader>& other_value);
GeoAnycastHeader_template(const GeoAnycastHeader_template& other_value);
~GeoAnycastHeader_template();
GeoAnycastHeader_template& operator=(template_sel other_value);
GeoAnycastHeader_template& operator=(const GeoAnycastHeader& other_value);
GeoAnycastHeader_template& operator=(const OPTIONAL<GeoAnycastHeader>& other_value);
GeoAnycastHeader_template& operator=(const GeoAnycastHeader_template& other_value);
boolean match(const GeoAnycastHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GeoAnycastHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GeoAnycastHeader_template& list_item(unsigned int list_index) const;
INTEGER_template& seqNumber();
const INTEGER_template& seqNumber() const;
INTEGER_template& reserved();
const INTEGER_template& reserved() const;
LongPosVector_template& srcPosVector();
const LongPosVector_template& srcPosVector() const;
INTEGER_template& geoAreaPosLatitude();
const INTEGER_template& geoAreaPosLatitude() const;
INTEGER_template& geoAreaPosLongitude();
const INTEGER_template& geoAreaPosLongitude() const;
INTEGER_template& distanceA();
const INTEGER_template& distanceA() const;
INTEGER_template& distanceB();
const INTEGER_template& distanceB() const;
INTEGER_template& angle();
const INTEGER_template& angle() const;
INTEGER_template& reserved2();
const INTEGER_template& reserved2() const;
int size_of() const;
void log() const;
void log_match(const GeoAnycastHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class BeaconHeader : public Base_Type {
  LongPosVector field_srcPosVector;
  boolean bound_flag;
public:
  BeaconHeader();
  BeaconHeader(const LongPosVector& par_srcPosVector);
  BeaconHeader(const BeaconHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BeaconHeader& operator=(const BeaconHeader& other_value);
  boolean operator==(const BeaconHeader& other_value) const;
  inline boolean operator!=(const BeaconHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline LongPosVector& srcPosVector()
    {return field_srcPosVector;}
  inline const LongPosVector& srcPosVector() const
    {return field_srcPosVector;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class BeaconHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BeaconHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BeaconHeader& other_value);
void copy_template(const BeaconHeader_template& other_value);

public:
BeaconHeader_template();
BeaconHeader_template(template_sel other_value);
BeaconHeader_template(const BeaconHeader& other_value);
BeaconHeader_template(const OPTIONAL<BeaconHeader>& other_value);
BeaconHeader_template(const BeaconHeader_template& other_value);
~BeaconHeader_template();
BeaconHeader_template& operator=(template_sel other_value);
BeaconHeader_template& operator=(const BeaconHeader& other_value);
BeaconHeader_template& operator=(const OPTIONAL<BeaconHeader>& other_value);
BeaconHeader_template& operator=(const BeaconHeader_template& other_value);
boolean match(const BeaconHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BeaconHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BeaconHeader_template& list_item(unsigned int list_index) const;
LongPosVector_template& srcPosVector();
const LongPosVector_template& srcPosVector() const;
int size_of() const;
void log() const;
void log_match(const BeaconHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class LSRequestHeader : public Base_Type {
  INTEGER field_seqNumber;
  INTEGER field_reserved;
  LongPosVector field_srcPosVector;
  GN__Address field_gnAddress;
  boolean bound_flag;
public:
  LSRequestHeader();
  LSRequestHeader(const INTEGER& par_seqNumber,
    const INTEGER& par_reserved,
    const LongPosVector& par_srcPosVector,
    const GN__Address& par_gnAddress);
  LSRequestHeader(const LSRequestHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  LSRequestHeader& operator=(const LSRequestHeader& other_value);
  boolean operator==(const LSRequestHeader& other_value) const;
  inline boolean operator!=(const LSRequestHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& seqNumber()
    {return field_seqNumber;}
  inline const INTEGER& seqNumber() const
    {return field_seqNumber;}
  inline INTEGER& reserved()
    {return field_reserved;}
  inline const INTEGER& reserved() const
    {return field_reserved;}
  inline LongPosVector& srcPosVector()
    {return field_srcPosVector;}
  inline const LongPosVector& srcPosVector() const
    {return field_srcPosVector;}
  inline GN__Address& gnAddress()
    {return field_gnAddress;}
  inline const GN__Address& gnAddress() const
    {return field_gnAddress;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class LSRequestHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
LSRequestHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const LSRequestHeader& other_value);
void copy_template(const LSRequestHeader_template& other_value);

public:
LSRequestHeader_template();
LSRequestHeader_template(template_sel other_value);
LSRequestHeader_template(const LSRequestHeader& other_value);
LSRequestHeader_template(const OPTIONAL<LSRequestHeader>& other_value);
LSRequestHeader_template(const LSRequestHeader_template& other_value);
~LSRequestHeader_template();
LSRequestHeader_template& operator=(template_sel other_value);
LSRequestHeader_template& operator=(const LSRequestHeader& other_value);
LSRequestHeader_template& operator=(const OPTIONAL<LSRequestHeader>& other_value);
LSRequestHeader_template& operator=(const LSRequestHeader_template& other_value);
boolean match(const LSRequestHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
LSRequestHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
LSRequestHeader_template& list_item(unsigned int list_index) const;
INTEGER_template& seqNumber();
const INTEGER_template& seqNumber() const;
INTEGER_template& reserved();
const INTEGER_template& reserved() const;
LongPosVector_template& srcPosVector();
const LongPosVector_template& srcPosVector() const;
GN__Address_template& gnAddress();
const GN__Address_template& gnAddress() const;
int size_of() const;
void log() const;
void log_match(const LSRequestHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class LSReplyHeader : public Base_Type {
  INTEGER field_seqNumber;
  INTEGER field_reserved;
  LongPosVector field_srcPosVector;
  ShortPosVector field_dstPosVector;
  boolean bound_flag;
public:
  LSReplyHeader();
  LSReplyHeader(const INTEGER& par_seqNumber,
    const INTEGER& par_reserved,
    const LongPosVector& par_srcPosVector,
    const ShortPosVector& par_dstPosVector);
  LSReplyHeader(const LSReplyHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  LSReplyHeader& operator=(const LSReplyHeader& other_value);
  boolean operator==(const LSReplyHeader& other_value) const;
  inline boolean operator!=(const LSReplyHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& seqNumber()
    {return field_seqNumber;}
  inline const INTEGER& seqNumber() const
    {return field_seqNumber;}
  inline INTEGER& reserved()
    {return field_reserved;}
  inline const INTEGER& reserved() const
    {return field_reserved;}
  inline LongPosVector& srcPosVector()
    {return field_srcPosVector;}
  inline const LongPosVector& srcPosVector() const
    {return field_srcPosVector;}
  inline ShortPosVector& dstPosVector()
    {return field_dstPosVector;}
  inline const ShortPosVector& dstPosVector() const
    {return field_dstPosVector;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class LSReplyHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
LSReplyHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const LSReplyHeader& other_value);
void copy_template(const LSReplyHeader_template& other_value);

public:
LSReplyHeader_template();
LSReplyHeader_template(template_sel other_value);
LSReplyHeader_template(const LSReplyHeader& other_value);
LSReplyHeader_template(const OPTIONAL<LSReplyHeader>& other_value);
LSReplyHeader_template(const LSReplyHeader_template& other_value);
~LSReplyHeader_template();
LSReplyHeader_template& operator=(template_sel other_value);
LSReplyHeader_template& operator=(const LSReplyHeader& other_value);
LSReplyHeader_template& operator=(const OPTIONAL<LSReplyHeader>& other_value);
LSReplyHeader_template& operator=(const LSReplyHeader_template& other_value);
boolean match(const LSReplyHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
LSReplyHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
LSReplyHeader_template& list_item(unsigned int list_index) const;
INTEGER_template& seqNumber();
const INTEGER_template& seqNumber() const;
INTEGER_template& reserved();
const INTEGER_template& reserved() const;
LongPosVector_template& srcPosVector();
const LongPosVector_template& srcPosVector() const;
ShortPosVector_template& dstPosVector();
const ShortPosVector_template& dstPosVector() const;
int size_of() const;
void log() const;
void log_match(const LSReplyHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AnyHeader : public Base_Type {
  INTEGER field_seqNumber;
  INTEGER field_reserved;
  boolean bound_flag;
public:
  AnyHeader();
  AnyHeader(const INTEGER& par_seqNumber,
    const INTEGER& par_reserved);
  AnyHeader(const AnyHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AnyHeader& operator=(const AnyHeader& other_value);
  boolean operator==(const AnyHeader& other_value) const;
  inline boolean operator!=(const AnyHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& seqNumber()
    {return field_seqNumber;}
  inline const INTEGER& seqNumber() const
    {return field_seqNumber;}
  inline INTEGER& reserved()
    {return field_reserved;}
  inline const INTEGER& reserved() const
    {return field_reserved;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AnyHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AnyHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AnyHeader& other_value);
void copy_template(const AnyHeader_template& other_value);

public:
AnyHeader_template();
AnyHeader_template(template_sel other_value);
AnyHeader_template(const AnyHeader& other_value);
AnyHeader_template(const OPTIONAL<AnyHeader>& other_value);
AnyHeader_template(const AnyHeader_template& other_value);
~AnyHeader_template();
AnyHeader_template& operator=(template_sel other_value);
AnyHeader_template& operator=(const AnyHeader& other_value);
AnyHeader_template& operator=(const OPTIONAL<AnyHeader>& other_value);
AnyHeader_template& operator=(const AnyHeader_template& other_value);
boolean match(const AnyHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AnyHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AnyHeader_template& list_item(unsigned int list_index) const;
INTEGER_template& seqNumber();
const INTEGER_template& seqNumber() const;
INTEGER_template& reserved();
const INTEGER_template& reserved() const;
int size_of() const;
void log() const;
void log_match(const AnyHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Payload : public Base_Type {
  OPTIONAL<DecodedPayload> field_decodedPayload;
  OCTETSTRING field_rawPayload;
  boolean bound_flag;
public:
  Payload();
  Payload(const OPTIONAL<DecodedPayload>& par_decodedPayload,
    const OCTETSTRING& par_rawPayload);
  Payload(const Payload& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Payload& operator=(const Payload& other_value);
  boolean operator==(const Payload& other_value) const;
  inline boolean operator!=(const Payload& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<DecodedPayload>& decodedPayload()
    {return field_decodedPayload;}
  inline const OPTIONAL<DecodedPayload>& decodedPayload() const
    {return field_decodedPayload;}
  inline OCTETSTRING& rawPayload()
    {return field_rawPayload;}
  inline const OCTETSTRING& rawPayload() const
    {return field_rawPayload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Payload_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Payload_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Payload& other_value);
void copy_template(const Payload_template& other_value);

public:
Payload_template();
Payload_template(template_sel other_value);
Payload_template(const Payload& other_value);
Payload_template(const OPTIONAL<Payload>& other_value);
Payload_template(const Payload_template& other_value);
~Payload_template();
Payload_template& operator=(template_sel other_value);
Payload_template& operator=(const Payload& other_value);
Payload_template& operator=(const OPTIONAL<Payload>& other_value);
Payload_template& operator=(const Payload_template& other_value);
boolean match(const Payload& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Payload valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Payload_template& list_item(unsigned int list_index) const;
DecodedPayload_template& decodedPayload();
const DecodedPayload_template& decodedPayload() const;
OCTETSTRING_template& rawPayload();
const OCTETSTRING_template& rawPayload() const;
int size_of() const;
void log() const;
void log_match(const Payload& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DecodedPayload : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_ipv6Packet = 1, ALT_btpPacket = 2 };
private:
union_selection_type union_selection;
union {
LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet *field_ipv6Packet;
LibItsBtp__TypesAndValues::BtpPacket *field_btpPacket;
};
void copy_value(const DecodedPayload& other_value);

public:
DecodedPayload();
DecodedPayload(const DecodedPayload& other_value);
~DecodedPayload();
DecodedPayload& operator=(const DecodedPayload& other_value);
boolean operator==(const DecodedPayload& other_value) const;
inline boolean operator!=(const DecodedPayload& other_value) const { return !(*this == other_value); }
LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet& ipv6Packet();
const LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet& ipv6Packet() const;
LibItsBtp__TypesAndValues::BtpPacket& btpPacket();
const LibItsBtp__TypesAndValues::BtpPacket& btpPacket() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class DecodedPayload_template : public Base_Template {
union {
struct {
DecodedPayload::union_selection_type union_selection;
union {
LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_template *field_ipv6Packet;
LibItsBtp__TypesAndValues::BtpPacket_template *field_btpPacket;
};
} single_value;
struct {
unsigned int n_values;
DecodedPayload_template *list_value;
} value_list;
};
void copy_value(const DecodedPayload& other_value);

void copy_template(const DecodedPayload_template& other_value);

public:
DecodedPayload_template();
DecodedPayload_template(template_sel other_value);
DecodedPayload_template(const DecodedPayload& other_value);
DecodedPayload_template(const OPTIONAL<DecodedPayload>& other_value);
DecodedPayload_template(const DecodedPayload_template& other_value);
~DecodedPayload_template();
void clean_up();
DecodedPayload_template& operator=(template_sel other_value);
DecodedPayload_template& operator=(const DecodedPayload& other_value);
DecodedPayload_template& operator=(const OPTIONAL<DecodedPayload>& other_value);
DecodedPayload_template& operator=(const DecodedPayload_template& other_value);
boolean match(const DecodedPayload& other_value, boolean legacy = FALSE) const;
boolean is_value() const;DecodedPayload valueof() const;
DecodedPayload_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_template& ipv6Packet();
const LibItsIpv6OverGeoNetworking__TypesAndValues::Ipv6Packet_template& ipv6Packet() const;
LibItsBtp__TypesAndValues::BtpPacket_template& btpPacket();
const LibItsBtp__TypesAndValues::BtpPacket_template& btpPacket() const;
boolean ischosen(DecodedPayload::union_selection_type checked_selection) const;
void log() const;
void log_match(const DecodedPayload& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GeoNetworkingPacket : public Base_Type {
  GnNonSecuredPacket field_packet;
  OPTIONAL<LibItsSecurity__TypesAndValues::SecuredMessage> field_securedMsg;
  boolean bound_flag;
public:
  GeoNetworkingPacket();
  GeoNetworkingPacket(const GnNonSecuredPacket& par_packet,
    const OPTIONAL<LibItsSecurity__TypesAndValues::SecuredMessage>& par_securedMsg);
  GeoNetworkingPacket(const GeoNetworkingPacket& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GeoNetworkingPacket& operator=(const GeoNetworkingPacket& other_value);
  boolean operator==(const GeoNetworkingPacket& other_value) const;
  inline boolean operator!=(const GeoNetworkingPacket& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline GnNonSecuredPacket& packet()
    {return field_packet;}
  inline const GnNonSecuredPacket& packet() const
    {return field_packet;}
  inline OPTIONAL<LibItsSecurity__TypesAndValues::SecuredMessage>& securedMsg()
    {return field_securedMsg;}
  inline const OPTIONAL<LibItsSecurity__TypesAndValues::SecuredMessage>& securedMsg() const
    {return field_securedMsg;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GeoNetworkingPacket_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GeoNetworkingPacket_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GeoNetworkingPacket& other_value);
void copy_template(const GeoNetworkingPacket_template& other_value);

public:
GeoNetworkingPacket_template();
GeoNetworkingPacket_template(template_sel other_value);
GeoNetworkingPacket_template(const GeoNetworkingPacket& other_value);
GeoNetworkingPacket_template(const OPTIONAL<GeoNetworkingPacket>& other_value);
GeoNetworkingPacket_template(const GeoNetworkingPacket_template& other_value);
~GeoNetworkingPacket_template();
GeoNetworkingPacket_template& operator=(template_sel other_value);
GeoNetworkingPacket_template& operator=(const GeoNetworkingPacket& other_value);
GeoNetworkingPacket_template& operator=(const OPTIONAL<GeoNetworkingPacket>& other_value);
GeoNetworkingPacket_template& operator=(const GeoNetworkingPacket_template& other_value);
boolean match(const GeoNetworkingPacket& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GeoNetworkingPacket valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GeoNetworkingPacket_template& list_item(unsigned int list_index) const;
GnNonSecuredPacket_template& packet();
const GnNonSecuredPacket_template& packet() const;
LibItsSecurity__TypesAndValues::SecuredMessage_template& securedMsg();
const LibItsSecurity__TypesAndValues::SecuredMessage_template& securedMsg() const;
int size_of() const;
void log() const;
void log_match(const GeoNetworkingPacket& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GeoNetworkingPdu : public Base_Type {
  BasicHeader field_basicHeader;
  GeoNetworkingPacket field_gnPacket;
  boolean bound_flag;
public:
  GeoNetworkingPdu();
  GeoNetworkingPdu(const BasicHeader& par_basicHeader,
    const GeoNetworkingPacket& par_gnPacket);
  GeoNetworkingPdu(const GeoNetworkingPdu& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GeoNetworkingPdu& operator=(const GeoNetworkingPdu& other_value);
  boolean operator==(const GeoNetworkingPdu& other_value) const;
  inline boolean operator!=(const GeoNetworkingPdu& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BasicHeader& basicHeader()
    {return field_basicHeader;}
  inline const BasicHeader& basicHeader() const
    {return field_basicHeader;}
  inline GeoNetworkingPacket& gnPacket()
    {return field_gnPacket;}
  inline const GeoNetworkingPacket& gnPacket() const
    {return field_gnPacket;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GeoNetworkingPdu_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GeoNetworkingPdu_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GeoNetworkingPdu& other_value);
void copy_template(const GeoNetworkingPdu_template& other_value);

public:
GeoNetworkingPdu_template();
GeoNetworkingPdu_template(template_sel other_value);
GeoNetworkingPdu_template(const GeoNetworkingPdu& other_value);
GeoNetworkingPdu_template(const OPTIONAL<GeoNetworkingPdu>& other_value);
GeoNetworkingPdu_template(const GeoNetworkingPdu_template& other_value);
~GeoNetworkingPdu_template();
GeoNetworkingPdu_template& operator=(template_sel other_value);
GeoNetworkingPdu_template& operator=(const GeoNetworkingPdu& other_value);
GeoNetworkingPdu_template& operator=(const OPTIONAL<GeoNetworkingPdu>& other_value);
GeoNetworkingPdu_template& operator=(const GeoNetworkingPdu_template& other_value);
boolean match(const GeoNetworkingPdu& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GeoNetworkingPdu valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GeoNetworkingPdu_template& list_item(unsigned int list_index) const;
BasicHeader_template& basicHeader();
const BasicHeader_template& basicHeader() const;
GeoNetworkingPacket_template& gnPacket();
const GeoNetworkingPacket_template& gnPacket() const;
int size_of() const;
void log() const;
void log_match(const GeoNetworkingPdu& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GeoUnicastForwardingAlgorithm : public Base_Type { // enum
friend class GeoUnicastForwardingAlgorithm_template;
public:
enum enum_type { e__unspecified = 0, e__greedy = 1, e__cbf = 2, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
GeoUnicastForwardingAlgorithm();
GeoUnicastForwardingAlgorithm(int other_value);
GeoUnicastForwardingAlgorithm(enum_type other_value);
GeoUnicastForwardingAlgorithm(const GeoUnicastForwardingAlgorithm& other_value);

GeoUnicastForwardingAlgorithm& operator=(int other_value);
GeoUnicastForwardingAlgorithm& operator=(enum_type other_value);
GeoUnicastForwardingAlgorithm& operator=(const GeoUnicastForwardingAlgorithm& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const GeoUnicastForwardingAlgorithm& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GeoUnicastForwardingAlgorithm& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const GeoUnicastForwardingAlgorithm& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const GeoUnicastForwardingAlgorithm& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const GeoUnicastForwardingAlgorithm& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const GeoUnicastForwardingAlgorithm& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const GeoUnicastForwardingAlgorithm& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GeoUnicastForwardingAlgorithm_template : public Base_Template {
union {
GeoUnicastForwardingAlgorithm::enum_type single_value;
struct {
unsigned int n_values;
GeoUnicastForwardingAlgorithm_template *list_value;
} value_list;
};

void copy_template(const GeoUnicastForwardingAlgorithm_template& other_value);

public:
GeoUnicastForwardingAlgorithm_template();
GeoUnicastForwardingAlgorithm_template(template_sel other_value);
GeoUnicastForwardingAlgorithm_template(int other_value);
GeoUnicastForwardingAlgorithm_template(GeoUnicastForwardingAlgorithm::enum_type other_value);
GeoUnicastForwardingAlgorithm_template(const GeoUnicastForwardingAlgorithm& other_value);
GeoUnicastForwardingAlgorithm_template(const OPTIONAL<GeoUnicastForwardingAlgorithm>& other_value);
GeoUnicastForwardingAlgorithm_template(const GeoUnicastForwardingAlgorithm_template& other_value);
~GeoUnicastForwardingAlgorithm_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
GeoUnicastForwardingAlgorithm_template& operator=(template_sel other_value);
GeoUnicastForwardingAlgorithm_template& operator=(int other_value);
GeoUnicastForwardingAlgorithm_template& operator=(GeoUnicastForwardingAlgorithm::enum_type other_value);
GeoUnicastForwardingAlgorithm_template& operator=(const GeoUnicastForwardingAlgorithm& other_value);
GeoUnicastForwardingAlgorithm_template& operator=(const OPTIONAL<GeoUnicastForwardingAlgorithm>& other_value);
GeoUnicastForwardingAlgorithm_template& operator=(const GeoUnicastForwardingAlgorithm_template& other_value);

boolean match(GeoUnicastForwardingAlgorithm::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const GeoUnicastForwardingAlgorithm& other_value, boolean legacy = FALSE) const;
GeoUnicastForwardingAlgorithm::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GeoUnicastForwardingAlgorithm_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GeoUnicastForwardingAlgorithm& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GeoBroadcastForwardingAlgorithm : public Base_Type { // enum
friend class GeoBroadcastForwardingAlgorithm_template;
public:
enum enum_type { e__unspecified = 0, e__simple = 1, e__cbf = 2, e__advanced = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
GeoBroadcastForwardingAlgorithm();
GeoBroadcastForwardingAlgorithm(int other_value);
GeoBroadcastForwardingAlgorithm(enum_type other_value);
GeoBroadcastForwardingAlgorithm(const GeoBroadcastForwardingAlgorithm& other_value);

GeoBroadcastForwardingAlgorithm& operator=(int other_value);
GeoBroadcastForwardingAlgorithm& operator=(enum_type other_value);
GeoBroadcastForwardingAlgorithm& operator=(const GeoBroadcastForwardingAlgorithm& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const GeoBroadcastForwardingAlgorithm& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GeoBroadcastForwardingAlgorithm& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const GeoBroadcastForwardingAlgorithm& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const GeoBroadcastForwardingAlgorithm& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const GeoBroadcastForwardingAlgorithm& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const GeoBroadcastForwardingAlgorithm& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const GeoBroadcastForwardingAlgorithm& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GeoBroadcastForwardingAlgorithm_template : public Base_Template {
union {
GeoBroadcastForwardingAlgorithm::enum_type single_value;
struct {
unsigned int n_values;
GeoBroadcastForwardingAlgorithm_template *list_value;
} value_list;
};

void copy_template(const GeoBroadcastForwardingAlgorithm_template& other_value);

public:
GeoBroadcastForwardingAlgorithm_template();
GeoBroadcastForwardingAlgorithm_template(template_sel other_value);
GeoBroadcastForwardingAlgorithm_template(int other_value);
GeoBroadcastForwardingAlgorithm_template(GeoBroadcastForwardingAlgorithm::enum_type other_value);
GeoBroadcastForwardingAlgorithm_template(const GeoBroadcastForwardingAlgorithm& other_value);
GeoBroadcastForwardingAlgorithm_template(const OPTIONAL<GeoBroadcastForwardingAlgorithm>& other_value);
GeoBroadcastForwardingAlgorithm_template(const GeoBroadcastForwardingAlgorithm_template& other_value);
~GeoBroadcastForwardingAlgorithm_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
GeoBroadcastForwardingAlgorithm_template& operator=(template_sel other_value);
GeoBroadcastForwardingAlgorithm_template& operator=(int other_value);
GeoBroadcastForwardingAlgorithm_template& operator=(GeoBroadcastForwardingAlgorithm::enum_type other_value);
GeoBroadcastForwardingAlgorithm_template& operator=(const GeoBroadcastForwardingAlgorithm& other_value);
GeoBroadcastForwardingAlgorithm_template& operator=(const OPTIONAL<GeoBroadcastForwardingAlgorithm>& other_value);
GeoBroadcastForwardingAlgorithm_template& operator=(const GeoBroadcastForwardingAlgorithm_template& other_value);

boolean match(GeoBroadcastForwardingAlgorithm::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const GeoBroadcastForwardingAlgorithm& other_value, boolean legacy = FALSE) const;
GeoBroadcastForwardingAlgorithm::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GeoBroadcastForwardingAlgorithm_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GeoBroadcastForwardingAlgorithm& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GnAddressConfigurationMethod : public Base_Type { // enum
friend class GnAddressConfigurationMethod_template;
public:
enum enum_type { e__auto = 0, e__managed = 1, e__anonymous = 2, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
GnAddressConfigurationMethod();
GnAddressConfigurationMethod(int other_value);
GnAddressConfigurationMethod(enum_type other_value);
GnAddressConfigurationMethod(const GnAddressConfigurationMethod& other_value);

GnAddressConfigurationMethod& operator=(int other_value);
GnAddressConfigurationMethod& operator=(enum_type other_value);
GnAddressConfigurationMethod& operator=(const GnAddressConfigurationMethod& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const GnAddressConfigurationMethod& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GnAddressConfigurationMethod& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const GnAddressConfigurationMethod& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const GnAddressConfigurationMethod& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const GnAddressConfigurationMethod& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const GnAddressConfigurationMethod& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const GnAddressConfigurationMethod& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GnAddressConfigurationMethod_template : public Base_Template {
union {
GnAddressConfigurationMethod::enum_type single_value;
struct {
unsigned int n_values;
GnAddressConfigurationMethod_template *list_value;
} value_list;
};

void copy_template(const GnAddressConfigurationMethod_template& other_value);

public:
GnAddressConfigurationMethod_template();
GnAddressConfigurationMethod_template(template_sel other_value);
GnAddressConfigurationMethod_template(int other_value);
GnAddressConfigurationMethod_template(GnAddressConfigurationMethod::enum_type other_value);
GnAddressConfigurationMethod_template(const GnAddressConfigurationMethod& other_value);
GnAddressConfigurationMethod_template(const OPTIONAL<GnAddressConfigurationMethod>& other_value);
GnAddressConfigurationMethod_template(const GnAddressConfigurationMethod_template& other_value);
~GnAddressConfigurationMethod_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
GnAddressConfigurationMethod_template& operator=(template_sel other_value);
GnAddressConfigurationMethod_template& operator=(int other_value);
GnAddressConfigurationMethod_template& operator=(GnAddressConfigurationMethod::enum_type other_value);
GnAddressConfigurationMethod_template& operator=(const GnAddressConfigurationMethod& other_value);
GnAddressConfigurationMethod_template& operator=(const OPTIONAL<GnAddressConfigurationMethod>& other_value);
GnAddressConfigurationMethod_template& operator=(const GnAddressConfigurationMethod_template& other_value);

boolean match(GnAddressConfigurationMethod::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const GnAddressConfigurationMethod& other_value, boolean legacy = FALSE) const;
GnAddressConfigurationMethod::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GnAddressConfigurationMethod_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GnAddressConfigurationMethod& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class UtGnTrigger : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_geoUnicast = 1, ALT_geoBroadcast = 2, ALT_geoAnycast = 3, ALT_shb = 4, ALT_tsb = 5 };
private:
union_selection_type union_selection;
union {
GenerateGeoUnicastMessage *field_geoUnicast;
GenerateGeoBroadcastMessage *field_geoBroadcast;
GenerateGeoBroadcastMessage *field_geoAnycast;
GenerateSHBMessage *field_shb;
GenerateTSBMessage *field_tsb;
};
void copy_value(const UtGnTrigger& other_value);

public:
UtGnTrigger();
UtGnTrigger(const UtGnTrigger& other_value);
~UtGnTrigger();
UtGnTrigger& operator=(const UtGnTrigger& other_value);
boolean operator==(const UtGnTrigger& other_value) const;
inline boolean operator!=(const UtGnTrigger& other_value) const { return !(*this == other_value); }
GenerateGeoUnicastMessage& geoUnicast();
const GenerateGeoUnicastMessage& geoUnicast() const;
GenerateGeoBroadcastMessage& geoBroadcast();
const GenerateGeoBroadcastMessage& geoBroadcast() const;
GenerateGeoBroadcastMessage& geoAnycast();
const GenerateGeoBroadcastMessage& geoAnycast() const;
GenerateSHBMessage& shb();
const GenerateSHBMessage& shb() const;
GenerateTSBMessage& tsb();
const GenerateTSBMessage& tsb() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtGnTrigger_template : public Base_Template {
union {
struct {
UtGnTrigger::union_selection_type union_selection;
union {
GenerateGeoUnicastMessage_template *field_geoUnicast;
GenerateGeoBroadcastMessage_template *field_geoBroadcast;
GenerateGeoBroadcastMessage_template *field_geoAnycast;
GenerateSHBMessage_template *field_shb;
GenerateTSBMessage_template *field_tsb;
};
} single_value;
struct {
unsigned int n_values;
UtGnTrigger_template *list_value;
} value_list;
};
void copy_value(const UtGnTrigger& other_value);

void copy_template(const UtGnTrigger_template& other_value);

public:
UtGnTrigger_template();
UtGnTrigger_template(template_sel other_value);
UtGnTrigger_template(const UtGnTrigger& other_value);
UtGnTrigger_template(const OPTIONAL<UtGnTrigger>& other_value);
UtGnTrigger_template(const UtGnTrigger_template& other_value);
~UtGnTrigger_template();
void clean_up();
UtGnTrigger_template& operator=(template_sel other_value);
UtGnTrigger_template& operator=(const UtGnTrigger& other_value);
UtGnTrigger_template& operator=(const OPTIONAL<UtGnTrigger>& other_value);
UtGnTrigger_template& operator=(const UtGnTrigger_template& other_value);
boolean match(const UtGnTrigger& other_value, boolean legacy = FALSE) const;
boolean is_value() const;UtGnTrigger valueof() const;
UtGnTrigger_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
GenerateGeoUnicastMessage_template& geoUnicast();
const GenerateGeoUnicastMessage_template& geoUnicast() const;
GenerateGeoBroadcastMessage_template& geoBroadcast();
const GenerateGeoBroadcastMessage_template& geoBroadcast() const;
GenerateGeoBroadcastMessage_template& geoAnycast();
const GenerateGeoBroadcastMessage_template& geoAnycast() const;
GenerateSHBMessage_template& shb();
const GenerateSHBMessage_template& shb() const;
GenerateTSBMessage_template& tsb();
const GenerateTSBMessage_template& tsb() const;
boolean ischosen(UtGnTrigger::union_selection_type checked_selection) const;
void log() const;
void log_match(const UtGnTrigger& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GenerateGeoUnicastMessage : public Base_Type {
  GN__Address field_gnAddress;
  INTEGER field_lifetime;
  TrafficClass field_trafficClass;
  Payload field_payload;
  boolean bound_flag;
public:
  GenerateGeoUnicastMessage();
  GenerateGeoUnicastMessage(const GN__Address& par_gnAddress,
    const INTEGER& par_lifetime,
    const TrafficClass& par_trafficClass,
    const Payload& par_payload);
  GenerateGeoUnicastMessage(const GenerateGeoUnicastMessage& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GenerateGeoUnicastMessage& operator=(const GenerateGeoUnicastMessage& other_value);
  boolean operator==(const GenerateGeoUnicastMessage& other_value) const;
  inline boolean operator!=(const GenerateGeoUnicastMessage& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline GN__Address& gnAddress()
    {return field_gnAddress;}
  inline const GN__Address& gnAddress() const
    {return field_gnAddress;}
  inline INTEGER& lifetime()
    {return field_lifetime;}
  inline const INTEGER& lifetime() const
    {return field_lifetime;}
  inline TrafficClass& trafficClass()
    {return field_trafficClass;}
  inline const TrafficClass& trafficClass() const
    {return field_trafficClass;}
  inline Payload& payload()
    {return field_payload;}
  inline const Payload& payload() const
    {return field_payload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GenerateGeoUnicastMessage_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GenerateGeoUnicastMessage_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GenerateGeoUnicastMessage& other_value);
void copy_template(const GenerateGeoUnicastMessage_template& other_value);

public:
GenerateGeoUnicastMessage_template();
GenerateGeoUnicastMessage_template(template_sel other_value);
GenerateGeoUnicastMessage_template(const GenerateGeoUnicastMessage& other_value);
GenerateGeoUnicastMessage_template(const OPTIONAL<GenerateGeoUnicastMessage>& other_value);
GenerateGeoUnicastMessage_template(const GenerateGeoUnicastMessage_template& other_value);
~GenerateGeoUnicastMessage_template();
GenerateGeoUnicastMessage_template& operator=(template_sel other_value);
GenerateGeoUnicastMessage_template& operator=(const GenerateGeoUnicastMessage& other_value);
GenerateGeoUnicastMessage_template& operator=(const OPTIONAL<GenerateGeoUnicastMessage>& other_value);
GenerateGeoUnicastMessage_template& operator=(const GenerateGeoUnicastMessage_template& other_value);
boolean match(const GenerateGeoUnicastMessage& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GenerateGeoUnicastMessage valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GenerateGeoUnicastMessage_template& list_item(unsigned int list_index) const;
GN__Address_template& gnAddress();
const GN__Address_template& gnAddress() const;
INTEGER_template& lifetime();
const INTEGER_template& lifetime() const;
TrafficClass_template& trafficClass();
const TrafficClass_template& trafficClass() const;
Payload_template& payload();
const Payload_template& payload() const;
int size_of() const;
void log() const;
void log_match(const GenerateGeoUnicastMessage& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GenerateGeoBroadcastMessage : public Base_Type {
  GeoShape field_shape;
  INTEGER field_lifetime;
  TrafficClass field_trafficClass;
  INTEGER field_reserved;
  Area field_area;
  Payload field_payload;
  boolean bound_flag;
public:
  GenerateGeoBroadcastMessage();
  GenerateGeoBroadcastMessage(const GeoShape& par_shape,
    const INTEGER& par_lifetime,
    const TrafficClass& par_trafficClass,
    const INTEGER& par_reserved,
    const Area& par_area,
    const Payload& par_payload);
  GenerateGeoBroadcastMessage(const GenerateGeoBroadcastMessage& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GenerateGeoBroadcastMessage& operator=(const GenerateGeoBroadcastMessage& other_value);
  boolean operator==(const GenerateGeoBroadcastMessage& other_value) const;
  inline boolean operator!=(const GenerateGeoBroadcastMessage& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline GeoShape& shape()
    {return field_shape;}
  inline const GeoShape& shape() const
    {return field_shape;}
  inline INTEGER& lifetime()
    {return field_lifetime;}
  inline const INTEGER& lifetime() const
    {return field_lifetime;}
  inline TrafficClass& trafficClass()
    {return field_trafficClass;}
  inline const TrafficClass& trafficClass() const
    {return field_trafficClass;}
  inline INTEGER& reserved()
    {return field_reserved;}
  inline const INTEGER& reserved() const
    {return field_reserved;}
  inline Area& area()
    {return field_area;}
  inline const Area& area() const
    {return field_area;}
  inline Payload& payload()
    {return field_payload;}
  inline const Payload& payload() const
    {return field_payload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GenerateGeoBroadcastMessage_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GenerateGeoBroadcastMessage_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GenerateGeoBroadcastMessage& other_value);
void copy_template(const GenerateGeoBroadcastMessage_template& other_value);

public:
GenerateGeoBroadcastMessage_template();
GenerateGeoBroadcastMessage_template(template_sel other_value);
GenerateGeoBroadcastMessage_template(const GenerateGeoBroadcastMessage& other_value);
GenerateGeoBroadcastMessage_template(const OPTIONAL<GenerateGeoBroadcastMessage>& other_value);
GenerateGeoBroadcastMessage_template(const GenerateGeoBroadcastMessage_template& other_value);
~GenerateGeoBroadcastMessage_template();
GenerateGeoBroadcastMessage_template& operator=(template_sel other_value);
GenerateGeoBroadcastMessage_template& operator=(const GenerateGeoBroadcastMessage& other_value);
GenerateGeoBroadcastMessage_template& operator=(const OPTIONAL<GenerateGeoBroadcastMessage>& other_value);
GenerateGeoBroadcastMessage_template& operator=(const GenerateGeoBroadcastMessage_template& other_value);
boolean match(const GenerateGeoBroadcastMessage& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GenerateGeoBroadcastMessage valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GenerateGeoBroadcastMessage_template& list_item(unsigned int list_index) const;
GeoShape_template& shape();
const GeoShape_template& shape() const;
INTEGER_template& lifetime();
const INTEGER_template& lifetime() const;
TrafficClass_template& trafficClass();
const TrafficClass_template& trafficClass() const;
INTEGER_template& reserved();
const INTEGER_template& reserved() const;
Area_template& area();
const Area_template& area() const;
Payload_template& payload();
const Payload_template& payload() const;
int size_of() const;
void log() const;
void log_match(const GenerateGeoBroadcastMessage& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GenerateSHBMessage : public Base_Type {
  TrafficClass field_trafficClass;
  Payload field_payload;
  boolean bound_flag;
public:
  GenerateSHBMessage();
  GenerateSHBMessage(const TrafficClass& par_trafficClass,
    const Payload& par_payload);
  GenerateSHBMessage(const GenerateSHBMessage& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GenerateSHBMessage& operator=(const GenerateSHBMessage& other_value);
  boolean operator==(const GenerateSHBMessage& other_value) const;
  inline boolean operator!=(const GenerateSHBMessage& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline TrafficClass& trafficClass()
    {return field_trafficClass;}
  inline const TrafficClass& trafficClass() const
    {return field_trafficClass;}
  inline Payload& payload()
    {return field_payload;}
  inline const Payload& payload() const
    {return field_payload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GenerateSHBMessage_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GenerateSHBMessage_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GenerateSHBMessage& other_value);
void copy_template(const GenerateSHBMessage_template& other_value);

public:
GenerateSHBMessage_template();
GenerateSHBMessage_template(template_sel other_value);
GenerateSHBMessage_template(const GenerateSHBMessage& other_value);
GenerateSHBMessage_template(const OPTIONAL<GenerateSHBMessage>& other_value);
GenerateSHBMessage_template(const GenerateSHBMessage_template& other_value);
~GenerateSHBMessage_template();
GenerateSHBMessage_template& operator=(template_sel other_value);
GenerateSHBMessage_template& operator=(const GenerateSHBMessage& other_value);
GenerateSHBMessage_template& operator=(const OPTIONAL<GenerateSHBMessage>& other_value);
GenerateSHBMessage_template& operator=(const GenerateSHBMessage_template& other_value);
boolean match(const GenerateSHBMessage& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GenerateSHBMessage valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GenerateSHBMessage_template& list_item(unsigned int list_index) const;
TrafficClass_template& trafficClass();
const TrafficClass_template& trafficClass() const;
Payload_template& payload();
const Payload_template& payload() const;
int size_of() const;
void log() const;
void log_match(const GenerateSHBMessage& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GenerateTSBMessage : public Base_Type {
  INTEGER field_nbHops;
  INTEGER field_lifetime;
  TrafficClass field_trafficClass;
  Payload field_payload;
  boolean bound_flag;
public:
  GenerateTSBMessage();
  GenerateTSBMessage(const INTEGER& par_nbHops,
    const INTEGER& par_lifetime,
    const TrafficClass& par_trafficClass,
    const Payload& par_payload);
  GenerateTSBMessage(const GenerateTSBMessage& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GenerateTSBMessage& operator=(const GenerateTSBMessage& other_value);
  boolean operator==(const GenerateTSBMessage& other_value) const;
  inline boolean operator!=(const GenerateTSBMessage& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& nbHops()
    {return field_nbHops;}
  inline const INTEGER& nbHops() const
    {return field_nbHops;}
  inline INTEGER& lifetime()
    {return field_lifetime;}
  inline const INTEGER& lifetime() const
    {return field_lifetime;}
  inline TrafficClass& trafficClass()
    {return field_trafficClass;}
  inline const TrafficClass& trafficClass() const
    {return field_trafficClass;}
  inline Payload& payload()
    {return field_payload;}
  inline const Payload& payload() const
    {return field_payload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class GenerateTSBMessage_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GenerateTSBMessage_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GenerateTSBMessage& other_value);
void copy_template(const GenerateTSBMessage_template& other_value);

public:
GenerateTSBMessage_template();
GenerateTSBMessage_template(template_sel other_value);
GenerateTSBMessage_template(const GenerateTSBMessage& other_value);
GenerateTSBMessage_template(const OPTIONAL<GenerateTSBMessage>& other_value);
GenerateTSBMessage_template(const GenerateTSBMessage_template& other_value);
~GenerateTSBMessage_template();
GenerateTSBMessage_template& operator=(template_sel other_value);
GenerateTSBMessage_template& operator=(const GenerateTSBMessage& other_value);
GenerateTSBMessage_template& operator=(const OPTIONAL<GenerateTSBMessage>& other_value);
GenerateTSBMessage_template& operator=(const GenerateTSBMessage_template& other_value);
boolean match(const GenerateTSBMessage& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GenerateTSBMessage valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GenerateTSBMessage_template& list_item(unsigned int list_index) const;
INTEGER_template& nbHops();
const INTEGER_template& nbHops() const;
INTEGER_template& lifetime();
const INTEGER_template& lifetime() const;
TrafficClass_template& trafficClass();
const TrafficClass_template& trafficClass() const;
Payload_template& payload();
const Payload_template& payload() const;
int size_of() const;
void log() const;
void log_match(const GenerateTSBMessage& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtGnTriggerResult : public Base_Type {
  BOOLEAN field_utGnTriggerResult;
  boolean bound_flag;
public:
  UtGnTriggerResult();
  UtGnTriggerResult(const BOOLEAN& par_utGnTriggerResult);
  UtGnTriggerResult(const UtGnTriggerResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtGnTriggerResult& operator=(const UtGnTriggerResult& other_value);
  boolean operator==(const UtGnTriggerResult& other_value) const;
  inline boolean operator!=(const UtGnTriggerResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BOOLEAN& utGnTriggerResult()
    {return field_utGnTriggerResult;}
  inline const BOOLEAN& utGnTriggerResult() const
    {return field_utGnTriggerResult;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtGnTriggerResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtGnTriggerResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtGnTriggerResult& other_value);
void copy_template(const UtGnTriggerResult_template& other_value);

public:
UtGnTriggerResult_template();
UtGnTriggerResult_template(template_sel other_value);
UtGnTriggerResult_template(const UtGnTriggerResult& other_value);
UtGnTriggerResult_template(const OPTIONAL<UtGnTriggerResult>& other_value);
UtGnTriggerResult_template(const UtGnTriggerResult_template& other_value);
~UtGnTriggerResult_template();
UtGnTriggerResult_template& operator=(template_sel other_value);
UtGnTriggerResult_template& operator=(const UtGnTriggerResult& other_value);
UtGnTriggerResult_template& operator=(const OPTIONAL<UtGnTriggerResult>& other_value);
UtGnTriggerResult_template& operator=(const UtGnTriggerResult_template& other_value);
boolean match(const UtGnTriggerResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtGnTriggerResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtGnTriggerResult_template& list_item(unsigned int list_index) const;
BOOLEAN_template& utGnTriggerResult();
const BOOLEAN_template& utGnTriggerResult() const;
int size_of() const;
void log() const;
void log_match(const UtGnTriggerResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtGnEventInd : public Base_Type {
  OCTETSTRING field_rawPayload;
  boolean bound_flag;
public:
  UtGnEventInd();
  UtGnEventInd(const OCTETSTRING& par_rawPayload);
  UtGnEventInd(const UtGnEventInd& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtGnEventInd& operator=(const UtGnEventInd& other_value);
  boolean operator==(const UtGnEventInd& other_value) const;
  inline boolean operator!=(const UtGnEventInd& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& rawPayload()
    {return field_rawPayload;}
  inline const OCTETSTRING& rawPayload() const
    {return field_rawPayload;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtGnEventInd_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtGnEventInd_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtGnEventInd& other_value);
void copy_template(const UtGnEventInd_template& other_value);

public:
UtGnEventInd_template();
UtGnEventInd_template(template_sel other_value);
UtGnEventInd_template(const UtGnEventInd& other_value);
UtGnEventInd_template(const OPTIONAL<UtGnEventInd>& other_value);
UtGnEventInd_template(const UtGnEventInd_template& other_value);
~UtGnEventInd_template();
UtGnEventInd_template& operator=(template_sel other_value);
UtGnEventInd_template& operator=(const UtGnEventInd& other_value);
UtGnEventInd_template& operator=(const OPTIONAL<UtGnEventInd>& other_value);
UtGnEventInd_template& operator=(const UtGnEventInd_template& other_value);
boolean match(const UtGnEventInd& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtGnEventInd valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtGnEventInd_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& rawPayload();
const OCTETSTRING_template& rawPayload() const;
int size_of() const;
void log() const;
void log_match(const UtGnEventInd& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtGnEventIndList : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
UtGnEventInd **value_elements;
} *val_ptr;

static const UtGnEventInd UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const UtGnEventIndList& other_value);

public:
  typedef UtGnEventInd of_type;
UtGnEventIndList();
UtGnEventIndList(null_type other_value);
UtGnEventIndList(const UtGnEventIndList& other_value);
~UtGnEventIndList();

void clean_up();
UtGnEventIndList& operator=(null_type other_value);
UtGnEventIndList& operator=(const UtGnEventIndList& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const UtGnEventIndList& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const UtGnEventIndList& other_value) const { return !(*this == other_value); }

UtGnEventInd& operator[](int index_value);
UtGnEventInd& operator[](const INTEGER& index_value);
const UtGnEventInd& operator[](int index_value) const;
const UtGnEventInd& operator[](const INTEGER& index_value) const;

UtGnEventIndList operator<<=(int rotate_count) const;
UtGnEventIndList operator<<=(const INTEGER& rotate_count) const;
UtGnEventIndList operator>>=(int rotate_count) const;
UtGnEventIndList operator>>=(const INTEGER& rotate_count) const;

UtGnEventIndList operator+(const UtGnEventIndList& other_value) const;

UtGnEventIndList substr(int index, int returncount) const;

UtGnEventIndList replace(int index, int len, const UtGnEventIndList& repl) const;

UtGnEventIndList replace(int index, int len, const UtGnEventIndList_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class UtGnEventIndList_template : public Record_Of_Template {
union {
struct {
int n_elements;
UtGnEventInd_template **value_elements;
} single_value;
struct {
unsigned int n_values;
UtGnEventIndList_template *list_value;
} value_list;
};
void copy_value(const UtGnEventIndList& other_value);
void copy_template(const UtGnEventIndList_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
UtGnEventIndList_template();
UtGnEventIndList_template(template_sel other_value);
UtGnEventIndList_template(null_type other_value);
UtGnEventIndList_template(const UtGnEventIndList& other_value);
UtGnEventIndList_template(const OPTIONAL<UtGnEventIndList>& other_value);
UtGnEventIndList_template(const UtGnEventIndList_template& other_value);
~UtGnEventIndList_template();

void clean_up();
UtGnEventIndList_template& operator=(template_sel other_value);
UtGnEventIndList_template& operator=(null_type other_value);
UtGnEventIndList_template& operator=(const UtGnEventIndList& other_value);
UtGnEventIndList_template& operator=(const OPTIONAL<UtGnEventIndList>& other_value);
UtGnEventIndList_template& operator=(const UtGnEventIndList_template& other_value);

UtGnEventInd_template& operator[](int index_value);
UtGnEventInd_template& operator[](const INTEGER& index_value);
const UtGnEventInd_template& operator[](int index_value) const;
const UtGnEventInd_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const UtGnEventIndList& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
UtGnEventIndList valueof() const;
UtGnEventIndList substr(int index, int returncount) const;

UtGnEventIndList replace(int index, int len, const UtGnEventIndList_template& repl) const;

UtGnEventIndList replace(int index, int len, const UtGnEventIndList& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
UtGnEventIndList_template& list_item(unsigned int list_index);
void log() const;
void log_match(const UtGnEventIndList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class AcGnPrimitive : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_startBeaconing = 1, ALT_stopBeaconing = 2, ALT_startPassBeaconing = 3, ALT_stopPassBeaconing = 4, ALT_startBeaconingMultipleNeighbour = 5, ALT_stopBeaconingMultipleNeighbour = 6, ALT_getLongPosVector = 7, ALT_acEnableSecurity = 8, ALT_acDisableSecurity = 9 };
private:
union_selection_type union_selection;
union {
AcStartBeaconing *field_startBeaconing;
AcStopBeaconing *field_stopBeaconing;
AcStartPassBeaconing *field_startPassBeaconing;
AcStopPassBeaconing *field_stopPassBeaconing;
AcStartBeaconingMultipleNeighbour *field_startBeaconingMultipleNeighbour;
AcStopBeaconingMultipleNeighbour *field_stopBeaconingMultipleNeighbour;
AcGetLongPosVector *field_getLongPosVector;
LibItsSecurity__TypesAndValues::AcEnableSecurity *field_acEnableSecurity;
LibItsSecurity__TypesAndValues::AcDisableSecurity *field_acDisableSecurity;
};
void copy_value(const AcGnPrimitive& other_value);

public:
AcGnPrimitive();
AcGnPrimitive(const AcGnPrimitive& other_value);
~AcGnPrimitive();
AcGnPrimitive& operator=(const AcGnPrimitive& other_value);
boolean operator==(const AcGnPrimitive& other_value) const;
inline boolean operator!=(const AcGnPrimitive& other_value) const { return !(*this == other_value); }
AcStartBeaconing& startBeaconing();
const AcStartBeaconing& startBeaconing() const;
AcStopBeaconing& stopBeaconing();
const AcStopBeaconing& stopBeaconing() const;
AcStartPassBeaconing& startPassBeaconing();
const AcStartPassBeaconing& startPassBeaconing() const;
AcStopPassBeaconing& stopPassBeaconing();
const AcStopPassBeaconing& stopPassBeaconing() const;
AcStartBeaconingMultipleNeighbour& startBeaconingMultipleNeighbour();
const AcStartBeaconingMultipleNeighbour& startBeaconingMultipleNeighbour() const;
AcStopBeaconingMultipleNeighbour& stopBeaconingMultipleNeighbour();
const AcStopBeaconingMultipleNeighbour& stopBeaconingMultipleNeighbour() const;
AcGetLongPosVector& getLongPosVector();
const AcGetLongPosVector& getLongPosVector() const;
LibItsSecurity__TypesAndValues::AcEnableSecurity& acEnableSecurity();
const LibItsSecurity__TypesAndValues::AcEnableSecurity& acEnableSecurity() const;
LibItsSecurity__TypesAndValues::AcDisableSecurity& acDisableSecurity();
const LibItsSecurity__TypesAndValues::AcDisableSecurity& acDisableSecurity() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AcGnPrimitive_template : public Base_Template {
union {
struct {
AcGnPrimitive::union_selection_type union_selection;
union {
AcStartBeaconing_template *field_startBeaconing;
AcStopBeaconing_template *field_stopBeaconing;
AcStartPassBeaconing_template *field_startPassBeaconing;
AcStopPassBeaconing_template *field_stopPassBeaconing;
AcStartBeaconingMultipleNeighbour_template *field_startBeaconingMultipleNeighbour;
AcStopBeaconingMultipleNeighbour_template *field_stopBeaconingMultipleNeighbour;
AcGetLongPosVector_template *field_getLongPosVector;
LibItsSecurity__TypesAndValues::AcEnableSecurity_template *field_acEnableSecurity;
LibItsSecurity__TypesAndValues::AcDisableSecurity_template *field_acDisableSecurity;
};
} single_value;
struct {
unsigned int n_values;
AcGnPrimitive_template *list_value;
} value_list;
};
void copy_value(const AcGnPrimitive& other_value);

void copy_template(const AcGnPrimitive_template& other_value);

public:
AcGnPrimitive_template();
AcGnPrimitive_template(template_sel other_value);
AcGnPrimitive_template(const AcGnPrimitive& other_value);
AcGnPrimitive_template(const OPTIONAL<AcGnPrimitive>& other_value);
AcGnPrimitive_template(const AcGnPrimitive_template& other_value);
~AcGnPrimitive_template();
void clean_up();
AcGnPrimitive_template& operator=(template_sel other_value);
AcGnPrimitive_template& operator=(const AcGnPrimitive& other_value);
AcGnPrimitive_template& operator=(const OPTIONAL<AcGnPrimitive>& other_value);
AcGnPrimitive_template& operator=(const AcGnPrimitive_template& other_value);
boolean match(const AcGnPrimitive& other_value, boolean legacy = FALSE) const;
boolean is_value() const;AcGnPrimitive valueof() const;
AcGnPrimitive_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
AcStartBeaconing_template& startBeaconing();
const AcStartBeaconing_template& startBeaconing() const;
AcStopBeaconing_template& stopBeaconing();
const AcStopBeaconing_template& stopBeaconing() const;
AcStartPassBeaconing_template& startPassBeaconing();
const AcStartPassBeaconing_template& startPassBeaconing() const;
AcStopPassBeaconing_template& stopPassBeaconing();
const AcStopPassBeaconing_template& stopPassBeaconing() const;
AcStartBeaconingMultipleNeighbour_template& startBeaconingMultipleNeighbour();
const AcStartBeaconingMultipleNeighbour_template& startBeaconingMultipleNeighbour() const;
AcStopBeaconingMultipleNeighbour_template& stopBeaconingMultipleNeighbour();
const AcStopBeaconingMultipleNeighbour_template& stopBeaconingMultipleNeighbour() const;
AcGetLongPosVector_template& getLongPosVector();
const AcGetLongPosVector_template& getLongPosVector() const;
LibItsSecurity__TypesAndValues::AcEnableSecurity_template& acEnableSecurity();
const LibItsSecurity__TypesAndValues::AcEnableSecurity_template& acEnableSecurity() const;
LibItsSecurity__TypesAndValues::AcDisableSecurity_template& acDisableSecurity();
const LibItsSecurity__TypesAndValues::AcDisableSecurity_template& acDisableSecurity() const;
boolean ischosen(AcGnPrimitive::union_selection_type checked_selection) const;
void log() const;
void log_match(const AcGnPrimitive& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class AcStartBeaconing : public Base_Type {
  GeoNetworkingPdu field_beaconPacket;
  boolean bound_flag;
public:
  AcStartBeaconing();
  AcStartBeaconing(const GeoNetworkingPdu& par_beaconPacket);
  AcStartBeaconing(const AcStartBeaconing& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AcStartBeaconing& operator=(const AcStartBeaconing& other_value);
  boolean operator==(const AcStartBeaconing& other_value) const;
  inline boolean operator!=(const AcStartBeaconing& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline GeoNetworkingPdu& beaconPacket()
    {return field_beaconPacket;}
  inline const GeoNetworkingPdu& beaconPacket() const
    {return field_beaconPacket;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AcStartBeaconing_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AcStartBeaconing_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AcStartBeaconing& other_value);
void copy_template(const AcStartBeaconing_template& other_value);

public:
AcStartBeaconing_template();
AcStartBeaconing_template(template_sel other_value);
AcStartBeaconing_template(const AcStartBeaconing& other_value);
AcStartBeaconing_template(const OPTIONAL<AcStartBeaconing>& other_value);
AcStartBeaconing_template(const AcStartBeaconing_template& other_value);
~AcStartBeaconing_template();
AcStartBeaconing_template& operator=(template_sel other_value);
AcStartBeaconing_template& operator=(const AcStartBeaconing& other_value);
AcStartBeaconing_template& operator=(const OPTIONAL<AcStartBeaconing>& other_value);
AcStartBeaconing_template& operator=(const AcStartBeaconing_template& other_value);
boolean match(const AcStartBeaconing& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AcStartBeaconing valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AcStartBeaconing_template& list_item(unsigned int list_index) const;
GeoNetworkingPdu_template& beaconPacket();
const GeoNetworkingPdu_template& beaconPacket() const;
int size_of() const;
void log() const;
void log_match(const AcStartBeaconing& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AcStopBeaconing : public Base_Type {
boolean bound_flag;
public:
AcStopBeaconing();
AcStopBeaconing(null_type other_value);
AcStopBeaconing(const AcStopBeaconing& other_value);
AcStopBeaconing& operator=(null_type other_value);
AcStopBeaconing& operator=(const AcStopBeaconing& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const AcStopBeaconing& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const AcStopBeaconing& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AcStopBeaconing_template : public Base_Template {
struct {
unsigned int n_values;
AcStopBeaconing_template *list_value;
} value_list;
void copy_template(const AcStopBeaconing_template& other_value);

public:
AcStopBeaconing_template();
AcStopBeaconing_template(template_sel other_value);
AcStopBeaconing_template(null_type other_value);
AcStopBeaconing_template(const AcStopBeaconing& other_value);
AcStopBeaconing_template(const OPTIONAL<AcStopBeaconing>& other_value);
AcStopBeaconing_template(const AcStopBeaconing_template& other_value);
~AcStopBeaconing_template();
void clean_up();
AcStopBeaconing_template& operator=(template_sel other_value);
AcStopBeaconing_template& operator=(null_type other_value);
AcStopBeaconing_template& operator=(const AcStopBeaconing& other_value);
AcStopBeaconing_template& operator=(const OPTIONAL<AcStopBeaconing>& other_value);
AcStopBeaconing_template& operator=(const AcStopBeaconing_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const AcStopBeaconing& other_value, boolean legacy = FALSE) const;
AcStopBeaconing valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AcStopBeaconing_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const AcStopBeaconing& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AcStartPassBeaconing : public Base_Type {
  BeaconHeader field_beaconHeader;
  boolean bound_flag;
public:
  AcStartPassBeaconing();
  AcStartPassBeaconing(const BeaconHeader& par_beaconHeader);
  AcStartPassBeaconing(const AcStartPassBeaconing& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AcStartPassBeaconing& operator=(const AcStartPassBeaconing& other_value);
  boolean operator==(const AcStartPassBeaconing& other_value) const;
  inline boolean operator!=(const AcStartPassBeaconing& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BeaconHeader& beaconHeader()
    {return field_beaconHeader;}
  inline const BeaconHeader& beaconHeader() const
    {return field_beaconHeader;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AcStartPassBeaconing_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AcStartPassBeaconing_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AcStartPassBeaconing& other_value);
void copy_template(const AcStartPassBeaconing_template& other_value);

public:
AcStartPassBeaconing_template();
AcStartPassBeaconing_template(template_sel other_value);
AcStartPassBeaconing_template(const AcStartPassBeaconing& other_value);
AcStartPassBeaconing_template(const OPTIONAL<AcStartPassBeaconing>& other_value);
AcStartPassBeaconing_template(const AcStartPassBeaconing_template& other_value);
~AcStartPassBeaconing_template();
AcStartPassBeaconing_template& operator=(template_sel other_value);
AcStartPassBeaconing_template& operator=(const AcStartPassBeaconing& other_value);
AcStartPassBeaconing_template& operator=(const OPTIONAL<AcStartPassBeaconing>& other_value);
AcStartPassBeaconing_template& operator=(const AcStartPassBeaconing_template& other_value);
boolean match(const AcStartPassBeaconing& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AcStartPassBeaconing valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AcStartPassBeaconing_template& list_item(unsigned int list_index) const;
BeaconHeader_template& beaconHeader();
const BeaconHeader_template& beaconHeader() const;
int size_of() const;
void log() const;
void log_match(const AcStartPassBeaconing& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AcStopPassBeaconing : public Base_Type {
boolean bound_flag;
public:
AcStopPassBeaconing();
AcStopPassBeaconing(null_type other_value);
AcStopPassBeaconing(const AcStopPassBeaconing& other_value);
AcStopPassBeaconing& operator=(null_type other_value);
AcStopPassBeaconing& operator=(const AcStopPassBeaconing& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const AcStopPassBeaconing& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const AcStopPassBeaconing& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AcStopPassBeaconing_template : public Base_Template {
struct {
unsigned int n_values;
AcStopPassBeaconing_template *list_value;
} value_list;
void copy_template(const AcStopPassBeaconing_template& other_value);

public:
AcStopPassBeaconing_template();
AcStopPassBeaconing_template(template_sel other_value);
AcStopPassBeaconing_template(null_type other_value);
AcStopPassBeaconing_template(const AcStopPassBeaconing& other_value);
AcStopPassBeaconing_template(const OPTIONAL<AcStopPassBeaconing>& other_value);
AcStopPassBeaconing_template(const AcStopPassBeaconing_template& other_value);
~AcStopPassBeaconing_template();
void clean_up();
AcStopPassBeaconing_template& operator=(template_sel other_value);
AcStopPassBeaconing_template& operator=(null_type other_value);
AcStopPassBeaconing_template& operator=(const AcStopPassBeaconing& other_value);
AcStopPassBeaconing_template& operator=(const OPTIONAL<AcStopPassBeaconing>& other_value);
AcStopPassBeaconing_template& operator=(const AcStopPassBeaconing_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const AcStopPassBeaconing& other_value, boolean legacy = FALSE) const;
AcStopPassBeaconing valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AcStopPassBeaconing_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const AcStopPassBeaconing& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AcStartBeaconingMultipleNeighbour : public Base_Type {
  GeoNetworkingPdu field_beaconPacket;
  INTEGER field_numberOfNeighbour;
  boolean bound_flag;
public:
  AcStartBeaconingMultipleNeighbour();
  AcStartBeaconingMultipleNeighbour(const GeoNetworkingPdu& par_beaconPacket,
    const INTEGER& par_numberOfNeighbour);
  AcStartBeaconingMultipleNeighbour(const AcStartBeaconingMultipleNeighbour& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AcStartBeaconingMultipleNeighbour& operator=(const AcStartBeaconingMultipleNeighbour& other_value);
  boolean operator==(const AcStartBeaconingMultipleNeighbour& other_value) const;
  inline boolean operator!=(const AcStartBeaconingMultipleNeighbour& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline GeoNetworkingPdu& beaconPacket()
    {return field_beaconPacket;}
  inline const GeoNetworkingPdu& beaconPacket() const
    {return field_beaconPacket;}
  inline INTEGER& numberOfNeighbour()
    {return field_numberOfNeighbour;}
  inline const INTEGER& numberOfNeighbour() const
    {return field_numberOfNeighbour;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AcStartBeaconingMultipleNeighbour_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AcStartBeaconingMultipleNeighbour_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AcStartBeaconingMultipleNeighbour& other_value);
void copy_template(const AcStartBeaconingMultipleNeighbour_template& other_value);

public:
AcStartBeaconingMultipleNeighbour_template();
AcStartBeaconingMultipleNeighbour_template(template_sel other_value);
AcStartBeaconingMultipleNeighbour_template(const AcStartBeaconingMultipleNeighbour& other_value);
AcStartBeaconingMultipleNeighbour_template(const OPTIONAL<AcStartBeaconingMultipleNeighbour>& other_value);
AcStartBeaconingMultipleNeighbour_template(const AcStartBeaconingMultipleNeighbour_template& other_value);
~AcStartBeaconingMultipleNeighbour_template();
AcStartBeaconingMultipleNeighbour_template& operator=(template_sel other_value);
AcStartBeaconingMultipleNeighbour_template& operator=(const AcStartBeaconingMultipleNeighbour& other_value);
AcStartBeaconingMultipleNeighbour_template& operator=(const OPTIONAL<AcStartBeaconingMultipleNeighbour>& other_value);
AcStartBeaconingMultipleNeighbour_template& operator=(const AcStartBeaconingMultipleNeighbour_template& other_value);
boolean match(const AcStartBeaconingMultipleNeighbour& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AcStartBeaconingMultipleNeighbour valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AcStartBeaconingMultipleNeighbour_template& list_item(unsigned int list_index) const;
GeoNetworkingPdu_template& beaconPacket();
const GeoNetworkingPdu_template& beaconPacket() const;
INTEGER_template& numberOfNeighbour();
const INTEGER_template& numberOfNeighbour() const;
int size_of() const;
void log() const;
void log_match(const AcStartBeaconingMultipleNeighbour& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AcStopBeaconingMultipleNeighbour : public Base_Type {
boolean bound_flag;
public:
AcStopBeaconingMultipleNeighbour();
AcStopBeaconingMultipleNeighbour(null_type other_value);
AcStopBeaconingMultipleNeighbour(const AcStopBeaconingMultipleNeighbour& other_value);
AcStopBeaconingMultipleNeighbour& operator=(null_type other_value);
AcStopBeaconingMultipleNeighbour& operator=(const AcStopBeaconingMultipleNeighbour& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const AcStopBeaconingMultipleNeighbour& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const AcStopBeaconingMultipleNeighbour& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AcStopBeaconingMultipleNeighbour_template : public Base_Template {
struct {
unsigned int n_values;
AcStopBeaconingMultipleNeighbour_template *list_value;
} value_list;
void copy_template(const AcStopBeaconingMultipleNeighbour_template& other_value);

public:
AcStopBeaconingMultipleNeighbour_template();
AcStopBeaconingMultipleNeighbour_template(template_sel other_value);
AcStopBeaconingMultipleNeighbour_template(null_type other_value);
AcStopBeaconingMultipleNeighbour_template(const AcStopBeaconingMultipleNeighbour& other_value);
AcStopBeaconingMultipleNeighbour_template(const OPTIONAL<AcStopBeaconingMultipleNeighbour>& other_value);
AcStopBeaconingMultipleNeighbour_template(const AcStopBeaconingMultipleNeighbour_template& other_value);
~AcStopBeaconingMultipleNeighbour_template();
void clean_up();
AcStopBeaconingMultipleNeighbour_template& operator=(template_sel other_value);
AcStopBeaconingMultipleNeighbour_template& operator=(null_type other_value);
AcStopBeaconingMultipleNeighbour_template& operator=(const AcStopBeaconingMultipleNeighbour& other_value);
AcStopBeaconingMultipleNeighbour_template& operator=(const OPTIONAL<AcStopBeaconingMultipleNeighbour>& other_value);
AcStopBeaconingMultipleNeighbour_template& operator=(const AcStopBeaconingMultipleNeighbour_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const AcStopBeaconingMultipleNeighbour& other_value, boolean legacy = FALSE) const;
AcStopBeaconingMultipleNeighbour valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AcStopBeaconingMultipleNeighbour_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const AcStopBeaconingMultipleNeighbour& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AcGetLongPosVector : public Base_Type {
  GN__Address field_gnAddress;
  boolean bound_flag;
public:
  AcGetLongPosVector();
  AcGetLongPosVector(const GN__Address& par_gnAddress);
  AcGetLongPosVector(const AcGetLongPosVector& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AcGetLongPosVector& operator=(const AcGetLongPosVector& other_value);
  boolean operator==(const AcGetLongPosVector& other_value) const;
  inline boolean operator!=(const AcGetLongPosVector& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline GN__Address& gnAddress()
    {return field_gnAddress;}
  inline const GN__Address& gnAddress() const
    {return field_gnAddress;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AcGetLongPosVector_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AcGetLongPosVector_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AcGetLongPosVector& other_value);
void copy_template(const AcGetLongPosVector_template& other_value);

public:
AcGetLongPosVector_template();
AcGetLongPosVector_template(template_sel other_value);
AcGetLongPosVector_template(const AcGetLongPosVector& other_value);
AcGetLongPosVector_template(const OPTIONAL<AcGetLongPosVector>& other_value);
AcGetLongPosVector_template(const AcGetLongPosVector_template& other_value);
~AcGetLongPosVector_template();
AcGetLongPosVector_template& operator=(template_sel other_value);
AcGetLongPosVector_template& operator=(const AcGetLongPosVector& other_value);
AcGetLongPosVector_template& operator=(const OPTIONAL<AcGetLongPosVector>& other_value);
AcGetLongPosVector_template& operator=(const AcGetLongPosVector_template& other_value);
boolean match(const AcGetLongPosVector& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AcGetLongPosVector valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AcGetLongPosVector_template& list_item(unsigned int list_index) const;
GN__Address_template& gnAddress();
const GN__Address_template& gnAddress() const;
int size_of() const;
void log() const;
void log_match(const AcGetLongPosVector& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AcGnResponse : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_getLongPosVector = 1, ALT_failure = 2 };
private:
union_selection_type union_selection;
union {
LongPosVector *field_getLongPosVector;
AcGnResponseFailure *field_failure;
};
void copy_value(const AcGnResponse& other_value);

public:
AcGnResponse();
AcGnResponse(const AcGnResponse& other_value);
~AcGnResponse();
AcGnResponse& operator=(const AcGnResponse& other_value);
boolean operator==(const AcGnResponse& other_value) const;
inline boolean operator!=(const AcGnResponse& other_value) const { return !(*this == other_value); }
LongPosVector& getLongPosVector();
const LongPosVector& getLongPosVector() const;
AcGnResponseFailure& failure();
const AcGnResponseFailure& failure() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AcGnResponse_template : public Base_Template {
union {
struct {
AcGnResponse::union_selection_type union_selection;
union {
LongPosVector_template *field_getLongPosVector;
AcGnResponseFailure_template *field_failure;
};
} single_value;
struct {
unsigned int n_values;
AcGnResponse_template *list_value;
} value_list;
};
void copy_value(const AcGnResponse& other_value);

void copy_template(const AcGnResponse_template& other_value);

public:
AcGnResponse_template();
AcGnResponse_template(template_sel other_value);
AcGnResponse_template(const AcGnResponse& other_value);
AcGnResponse_template(const OPTIONAL<AcGnResponse>& other_value);
AcGnResponse_template(const AcGnResponse_template& other_value);
~AcGnResponse_template();
void clean_up();
AcGnResponse_template& operator=(template_sel other_value);
AcGnResponse_template& operator=(const AcGnResponse& other_value);
AcGnResponse_template& operator=(const OPTIONAL<AcGnResponse>& other_value);
AcGnResponse_template& operator=(const AcGnResponse_template& other_value);
boolean match(const AcGnResponse& other_value, boolean legacy = FALSE) const;
boolean is_value() const;AcGnResponse valueof() const;
AcGnResponse_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
LongPosVector_template& getLongPosVector();
const LongPosVector_template& getLongPosVector() const;
AcGnResponseFailure_template& failure();
const AcGnResponseFailure_template& failure() const;
boolean ischosen(AcGnResponse::union_selection_type checked_selection) const;
void log() const;
void log_match(const AcGnResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class AcGnResponseFailure : public Base_Type {
  BOOLEAN field_failure;
  boolean bound_flag;
public:
  AcGnResponseFailure();
  AcGnResponseFailure(const BOOLEAN& par_failure);
  AcGnResponseFailure(const AcGnResponseFailure& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AcGnResponseFailure& operator=(const AcGnResponseFailure& other_value);
  boolean operator==(const AcGnResponseFailure& other_value) const;
  inline boolean operator!=(const AcGnResponseFailure& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BOOLEAN& failure()
    {return field_failure;}
  inline const BOOLEAN& failure() const
    {return field_failure;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class AcGnResponseFailure_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AcGnResponseFailure_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AcGnResponseFailure& other_value);
void copy_template(const AcGnResponseFailure_template& other_value);

public:
AcGnResponseFailure_template();
AcGnResponseFailure_template(template_sel other_value);
AcGnResponseFailure_template(const AcGnResponseFailure& other_value);
AcGnResponseFailure_template(const OPTIONAL<AcGnResponseFailure>& other_value);
AcGnResponseFailure_template(const AcGnResponseFailure_template& other_value);
~AcGnResponseFailure_template();
AcGnResponseFailure_template& operator=(template_sel other_value);
AcGnResponseFailure_template& operator=(const AcGnResponseFailure& other_value);
AcGnResponseFailure_template& operator=(const OPTIONAL<AcGnResponseFailure>& other_value);
AcGnResponseFailure_template& operator=(const AcGnResponseFailure_template& other_value);
boolean match(const AcGnResponseFailure& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AcGnResponseFailure valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AcGnResponseFailure_template& list_item(unsigned int list_index) const;
BOOLEAN_template& failure();
const BOOLEAN_template& failure() const;
int size_of() const;
void log() const;
void log_match(const AcGnResponseFailure& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const PositionTable& other_value);
inline boolean operator!=(null_type null_value, const PositionTable& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const GeoAreaTable& other_value);
inline boolean operator!=(null_type null_value, const GeoAreaTable& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const UtGnEventIndList& other_value);
inline boolean operator!=(null_type null_value, const UtGnEventIndList& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const AcStopBeaconing& other_value);
inline boolean operator!=(null_type null_value, const AcStopBeaconing& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const AcStopPassBeaconing& other_value);
inline boolean operator!=(null_type null_value, const AcStopPassBeaconing& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const AcStopBeaconingMultipleNeighbour& other_value);
inline boolean operator!=(null_type null_value, const AcStopBeaconingMultipleNeighbour& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const CHARSTRING& c__compIut;
extern const CHARSTRING& c__compMTC;
extern const CHARSTRING& c__compNodeA;
extern const CHARSTRING& c__compNodeB;
extern const CHARSTRING& c__compNodeC;
extern const CHARSTRING& c__compNodeD;
extern const CHARSTRING& c__compNodeE;
extern const CHARSTRING& c__compNodeF;
extern const CHARSTRING& c__area1;
extern const CHARSTRING& c__area2;
extern const INTEGER& c__latitudeFactorNodeA;
extern const INTEGER& c__latitudeFactorNodeB;
extern const INTEGER& c__latitudeFactorNodeC;
extern const INTEGER& c__latitudeFactorNodeD;
extern const INTEGER& c__latitudeFactorNodeE;
extern const INTEGER& c__latitudeFactorNodeF;
extern const INTEGER& c__longitudeFactorNodeA;
extern const INTEGER& c__longitudeFactorNodeB;
extern const INTEGER& c__longitudeFactorNodeC;
extern const INTEGER& c__longitudeFactorNodeD;
extern const INTEGER& c__longitudeFactorNodeE;
extern const INTEGER& c__longitudeFactorNodeF;
extern const CHARSTRING& c__msgSent;
extern const INTEGER& c__defaultLifetime;
extern const INTEGER& c__lifetime;
extern const FLOAT& c__squareKm;
extern const XERdescriptor_t PositionEntry_key_xer_;
extern const TTCN_Typedescriptor_t PositionEntry_key_descr_;
extern const TTCN_RAWdescriptor_t TypeOfAddress_raw_;
extern const TTCN_JSONdescriptor_t TypeOfAddress_json_;
extern const TTCN_Typedescriptor_t TypeOfAddress_descr_;
extern const TTCN_RAWdescriptor_t StationType_raw_;
extern const TTCN_JSONdescriptor_t StationType_json_;
extern const TTCN_Typedescriptor_t StationType_descr_;
extern const XERdescriptor_t GN__Address_stationCountryCode_xer_;
extern const TTCN_Typedescriptor_t GN__Address_stationCountryCode_descr_;
extern const XERdescriptor_t GN__Address_mid_xer_;
extern const TTCN_Typedescriptor_t GN__Address_mid_descr_;
extern const TTCN_RAWdescriptor_t GN__Address_raw_;
extern const TTCN_JSONdescriptor_t GN__Address_json_;
extern const TTCN_Typedescriptor_t GN__Address_descr_;
extern const XERdescriptor_t LongPosVector_timestamp_xer_;
extern const TTCN_Typedescriptor_t LongPosVector_timestamp_descr_;
extern const XERdescriptor_t LongPosVector_latitude_xer_;
extern const TTCN_Typedescriptor_t LongPosVector_latitude_descr_;
extern const XERdescriptor_t LongPosVector_longitude_xer_;
extern const TTCN_Typedescriptor_t LongPosVector_longitude_descr_;
extern const XERdescriptor_t LongPosVector_pai_xer_;
extern const TTCN_Typedescriptor_t LongPosVector_pai_descr_;
extern const XERdescriptor_t LongPosVector_speed_xer_;
extern const TTCN_Typedescriptor_t LongPosVector_speed_descr_;
extern const XERdescriptor_t LongPosVector_heading_xer_;
extern const TTCN_Typedescriptor_t LongPosVector_heading_descr_;
extern const TTCN_RAWdescriptor_t LongPosVector_raw_;
extern const TTCN_JSONdescriptor_t LongPosVector_json_;
extern const TTCN_Typedescriptor_t LongPosVector_descr_;
extern const TTCN_RAWdescriptor_t PositionEntry_raw_;
extern const TTCN_JSONdescriptor_t PositionEntry_json_;
extern const TTCN_Typedescriptor_t PositionEntry_descr_;
extern const TTCN_RAWdescriptor_t PositionTable_raw_;
extern const TTCN_Typedescriptor_t PositionTable_descr_;
extern const XERdescriptor_t Area_geoAreaPosLatitude_xer_;
extern const TTCN_Typedescriptor_t Area_geoAreaPosLatitude_descr_;
extern const XERdescriptor_t Area_geoAreaPosLongitude_xer_;
extern const TTCN_Typedescriptor_t Area_geoAreaPosLongitude_descr_;
extern const XERdescriptor_t Area_distanceA_xer_;
extern const TTCN_Typedescriptor_t Area_distanceA_descr_;
extern const XERdescriptor_t Area_distanceB_xer_;
extern const TTCN_Typedescriptor_t Area_distanceB_descr_;
extern const XERdescriptor_t Area_angle_xer_;
extern const TTCN_Typedescriptor_t Area_angle_descr_;
extern const TTCN_RAWdescriptor_t Area_raw_;
extern const TTCN_JSONdescriptor_t Area_json_;
extern const TTCN_Typedescriptor_t Area_descr_;
extern const TTCN_RAWdescriptor_t HeaderSubTypeGeoBroadcast_raw_;
extern const TTCN_JSONdescriptor_t HeaderSubTypeGeoBroadcast_json_;
extern const TTCN_Typedescriptor_t HeaderSubTypeGeoBroadcast_descr_;
extern const TTCN_RAWdescriptor_t GeoBroadcastArea_raw_;
extern const TTCN_JSONdescriptor_t GeoBroadcastArea_json_;
extern const TTCN_Typedescriptor_t GeoBroadcastArea_descr_;
extern const TTCN_RAWdescriptor_t HeaderSubTypeGeoAnycast_raw_;
extern const TTCN_JSONdescriptor_t HeaderSubTypeGeoAnycast_json_;
extern const TTCN_Typedescriptor_t HeaderSubTypeGeoAnycast_descr_;
extern const TTCN_RAWdescriptor_t GeoAnycastArea_raw_;
extern const TTCN_JSONdescriptor_t GeoAnycastArea_json_;
extern const TTCN_Typedescriptor_t GeoAnycastArea_descr_;
extern const TTCN_RAWdescriptor_t GeoShape_raw_;
extern const TTCN_JSONdescriptor_t GeoShape_json_;
extern const TTCN_Typedescriptor_t GeoShape_descr_;
extern const TTCN_RAWdescriptor_t GeoArea_raw_;
extern const TTCN_JSONdescriptor_t GeoArea_json_;
extern const TTCN_Typedescriptor_t GeoArea_descr_;
extern const XERdescriptor_t GeoAreaEntry_key_xer_;
extern const TTCN_Typedescriptor_t GeoAreaEntry_key_descr_;
extern const TTCN_RAWdescriptor_t GeoAreaEntry_raw_;
extern const TTCN_JSONdescriptor_t GeoAreaEntry_json_;
extern const TTCN_Typedescriptor_t GeoAreaEntry_descr_;
extern const TTCN_RAWdescriptor_t GeoAreaTable_raw_;
extern const TTCN_Typedescriptor_t GeoAreaTable_descr_;
extern const INTEGER& c__geoNwProtocolVersion;
extern const INTEGER& c__hopLimit1;
extern const INTEGER& c__defaultHopLimit;
extern const TTCN_RAWdescriptor_t BasicHeader_version_raw_;
extern const XERdescriptor_t BasicHeader_version_xer_;
extern const TTCN_Typedescriptor_t BasicHeader_version_descr_;
extern const TTCN_RAWdescriptor_t BasicNextHeader_raw_;
extern const TTCN_JSONdescriptor_t BasicNextHeader_json_;
extern const TTCN_Typedescriptor_t BasicNextHeader_descr_;
extern const TTCN_RAWdescriptor_t BasicHeader_nextHeader_raw_;
extern const TTCN_Typedescriptor_t BasicHeader_nextHeader_descr_;
extern const TTCN_RAWdescriptor_t BasicHeader_reserved_raw_;
extern const XERdescriptor_t BasicHeader_reserved_xer_;
extern const TTCN_Typedescriptor_t BasicHeader_reserved_descr_;
extern const XERdescriptor_t Lifetime_multiplier_xer_;
extern const TTCN_Typedescriptor_t Lifetime_multiplier_descr_;
extern const TTCN_RAWdescriptor_t LtBase_raw_;
extern const TTCN_JSONdescriptor_t LtBase_json_;
extern const TTCN_Typedescriptor_t LtBase_descr_;
extern const TTCN_RAWdescriptor_t Lifetime_raw_;
extern const TTCN_JSONdescriptor_t Lifetime_json_;
extern const TTCN_Typedescriptor_t Lifetime_descr_;
extern const TTCN_RAWdescriptor_t BasicHeader_lifeTime_raw_;
extern const TTCN_Typedescriptor_t BasicHeader_lifeTime_descr_;
extern const TTCN_RAWdescriptor_t BasicHeader_routerHopLimit_raw_;
extern const XERdescriptor_t BasicHeader_routerHopLimit_xer_;
extern const TTCN_Typedescriptor_t BasicHeader_routerHopLimit_descr_;
extern const TTCN_RAWdescriptor_t BasicHeader_raw_;
extern const TTCN_JSONdescriptor_t BasicHeader_json_;
extern const TTCN_Typedescriptor_t BasicHeader_descr_;
extern const TTCN_RAWdescriptor_t NextHeader_raw_;
extern const TTCN_JSONdescriptor_t NextHeader_json_;
extern const TTCN_Typedescriptor_t NextHeader_descr_;
extern const TTCN_RAWdescriptor_t CommonHeader_nextHeader_raw_;
extern const TTCN_Typedescriptor_t CommonHeader_nextHeader_descr_;
extern const TTCN_RAWdescriptor_t CommonHeader_reserved_raw_;
extern const XERdescriptor_t CommonHeader_reserved_xer_;
extern const TTCN_Typedescriptor_t CommonHeader_reserved_descr_;
extern const TTCN_RAWdescriptor_t HeaderTST_raw_;
extern const TTCN_JSONdescriptor_t HeaderTST_json_;
extern const TTCN_Typedescriptor_t HeaderTST_descr_;
extern const TTCN_RAWdescriptor_t HeaderType_raw_;
extern const TTCN_JSONdescriptor_t HeaderType_json_;
extern const TTCN_Typedescriptor_t HeaderType_descr_;
extern const TTCN_RAWdescriptor_t AnyHeaderType_headerType_raw_;
extern const TTCN_Typedescriptor_t AnyHeaderType_headerType_descr_;
extern const TTCN_RAWdescriptor_t AnyHeaderType_headerSubType_raw_;
extern const XERdescriptor_t AnyHeaderType_headerSubType_xer_;
extern const TTCN_Typedescriptor_t AnyHeaderType_headerSubType_descr_;
extern const TTCN_RAWdescriptor_t AnyHeaderType_raw_;
extern const TTCN_JSONdescriptor_t AnyHeaderType_json_;
extern const TTCN_Typedescriptor_t AnyHeaderType_descr_;
extern const TTCN_RAWdescriptor_t BeaconHeaderType_headerType_raw_;
extern const TTCN_Typedescriptor_t BeaconHeaderType_headerType_descr_;
extern const TTCN_RAWdescriptor_t BeaconHeaderType_headerSubType_raw_;
extern const XERdescriptor_t BeaconHeaderType_headerSubType_xer_;
extern const TTCN_Typedescriptor_t BeaconHeaderType_headerSubType_descr_;
extern const TTCN_RAWdescriptor_t BeaconHeaderType_raw_;
extern const TTCN_JSONdescriptor_t BeaconHeaderType_json_;
extern const TTCN_Typedescriptor_t BeaconHeaderType_descr_;
extern const TTCN_RAWdescriptor_t GeoUnicastHeaderType_headerType_raw_;
extern const TTCN_Typedescriptor_t GeoUnicastHeaderType_headerType_descr_;
extern const TTCN_RAWdescriptor_t GeoUnicastHeaderType_headerSubType_raw_;
extern const XERdescriptor_t GeoUnicastHeaderType_headerSubType_xer_;
extern const TTCN_Typedescriptor_t GeoUnicastHeaderType_headerSubType_descr_;
extern const TTCN_RAWdescriptor_t GeoUnicastHeaderType_raw_;
extern const TTCN_JSONdescriptor_t GeoUnicastHeaderType_json_;
extern const TTCN_Typedescriptor_t GeoUnicastHeaderType_descr_;
extern const TTCN_RAWdescriptor_t GeoAnycastHeaderType_headerType_raw_;
extern const TTCN_Typedescriptor_t GeoAnycastHeaderType_headerType_descr_;
extern const TTCN_RAWdescriptor_t GeoAnycastHeaderType_headerSubType_raw_;
extern const TTCN_Typedescriptor_t GeoAnycastHeaderType_headerSubType_descr_;
extern const TTCN_RAWdescriptor_t GeoAnycastHeaderType_raw_;
extern const TTCN_JSONdescriptor_t GeoAnycastHeaderType_json_;
extern const TTCN_Typedescriptor_t GeoAnycastHeaderType_descr_;
extern const TTCN_RAWdescriptor_t GeoBroadcastHeaderType_headerType_raw_;
extern const TTCN_Typedescriptor_t GeoBroadcastHeaderType_headerType_descr_;
extern const TTCN_RAWdescriptor_t GeoBroadcastHeaderType_headerSubType_raw_;
extern const TTCN_Typedescriptor_t GeoBroadcastHeaderType_headerSubType_descr_;
extern const TTCN_RAWdescriptor_t GeoBroadcastHeaderType_raw_;
extern const TTCN_JSONdescriptor_t GeoBroadcastHeaderType_json_;
extern const TTCN_Typedescriptor_t GeoBroadcastHeaderType_descr_;
extern const TTCN_RAWdescriptor_t TsbHeaderType_headerType_raw_;
extern const TTCN_Typedescriptor_t TsbHeaderType_headerType_descr_;
extern const TTCN_RAWdescriptor_t HeaderSubTypeTSB_raw_;
extern const TTCN_JSONdescriptor_t HeaderSubTypeTSB_json_;
extern const TTCN_Typedescriptor_t HeaderSubTypeTSB_descr_;
extern const TTCN_RAWdescriptor_t TsbHeaderType_headerSubType_raw_;
extern const TTCN_Typedescriptor_t TsbHeaderType_headerSubType_descr_;
extern const TTCN_RAWdescriptor_t TsbHeaderType_raw_;
extern const TTCN_JSONdescriptor_t TsbHeaderType_json_;
extern const TTCN_Typedescriptor_t TsbHeaderType_descr_;
extern const TTCN_RAWdescriptor_t LsHeaderType_headerType_raw_;
extern const TTCN_Typedescriptor_t LsHeaderType_headerType_descr_;
extern const TTCN_RAWdescriptor_t HeaderSubTypeLs_raw_;
extern const TTCN_JSONdescriptor_t HeaderSubTypeLs_json_;
extern const TTCN_Typedescriptor_t HeaderSubTypeLs_descr_;
extern const TTCN_RAWdescriptor_t LsHeaderType_headerSubType_raw_;
extern const TTCN_Typedescriptor_t LsHeaderType_headerSubType_descr_;
extern const TTCN_RAWdescriptor_t LsHeaderType_raw_;
extern const TTCN_JSONdescriptor_t LsHeaderType_json_;
extern const TTCN_Typedescriptor_t LsHeaderType_descr_;
extern const TTCN_RAWdescriptor_t SaHeaderType_headerType_raw_;
extern const TTCN_Typedescriptor_t SaHeaderType_headerType_descr_;
extern const TTCN_RAWdescriptor_t HeaderSubTypeSa_raw_;
extern const TTCN_JSONdescriptor_t HeaderSubTypeSa_json_;
extern const TTCN_Typedescriptor_t HeaderSubTypeSa_descr_;
extern const TTCN_RAWdescriptor_t SaHeaderType_headerSubType_raw_;
extern const TTCN_Typedescriptor_t SaHeaderType_headerSubType_descr_;
extern const TTCN_RAWdescriptor_t SaHeaderType_raw_;
extern const TTCN_JSONdescriptor_t SaHeaderType_json_;
extern const TTCN_Typedescriptor_t SaHeaderType_descr_;
extern const XERdescriptor_t HeaderTST_reserved_xer_;
extern const TTCN_Typedescriptor_t HeaderTST_reserved_descr_;
extern const TTCN_RAWdescriptor_t CommonHeader_headerTST_raw_;
extern const TTCN_Typedescriptor_t CommonHeader_headerTST_descr_;
extern const TTCN_RAWdescriptor_t SCF_raw_;
extern const TTCN_JSONdescriptor_t SCF_json_;
extern const TTCN_Typedescriptor_t SCF_descr_;
extern const TTCN_RAWdescriptor_t ChannelOffload_raw_;
extern const TTCN_JSONdescriptor_t ChannelOffload_json_;
extern const TTCN_Typedescriptor_t ChannelOffload_descr_;
extern const TTCN_RAWdescriptor_t TcId_raw_;
extern const XERdescriptor_t TcId_xer_;
extern const TTCN_Typedescriptor_t TcId_descr_;
extern const XERdescriptor_t TrafficClass_tcId_xer_;
extern const TTCN_Typedescriptor_t TrafficClass_tcId_descr_;
extern const TTCN_RAWdescriptor_t TrafficClass_raw_;
extern const TTCN_JSONdescriptor_t TrafficClass_json_;
extern const TTCN_Typedescriptor_t TrafficClass_descr_;
extern const TTCN_RAWdescriptor_t CommonHeader_trafficClass_raw_;
extern const TTCN_Typedescriptor_t CommonHeader_trafficClass_descr_;
extern const TTCN_RAWdescriptor_t CommonHeader_flags_raw_;
extern const XERdescriptor_t CommonHeader_flags_xer_;
extern const TTCN_Typedescriptor_t CommonHeader_flags_descr_;
extern const TTCN_RAWdescriptor_t CommonHeader_plLength_raw_;
extern const XERdescriptor_t CommonHeader_plLength_xer_;
extern const TTCN_Typedescriptor_t CommonHeader_plLength_descr_;
extern const TTCN_RAWdescriptor_t CommonHeader_maxHopLimit_raw_;
extern const XERdescriptor_t CommonHeader_maxHopLimit_xer_;
extern const TTCN_Typedescriptor_t CommonHeader_maxHopLimit_descr_;
extern const TTCN_RAWdescriptor_t CommonHeader_reserved2_raw_;
extern const XERdescriptor_t CommonHeader_reserved2_xer_;
extern const TTCN_Typedescriptor_t CommonHeader_reserved2_descr_;
extern const TTCN_RAWdescriptor_t CommonHeader_raw_;
extern const TTCN_JSONdescriptor_t CommonHeader_json_;
extern const TTCN_Typedescriptor_t CommonHeader_descr_;
extern const TTCN_RAWdescriptor_t GnNonSecuredPacket_raw_;
extern const TTCN_JSONdescriptor_t GnNonSecuredPacket_json_;
extern const TTCN_Typedescriptor_t GnNonSecuredPacket_descr_;
extern const TTCN_RAWdescriptor_t ExtendedHeader_raw_;
extern const TTCN_JSONdescriptor_t ExtendedHeader_json_;
extern const TTCN_Typedescriptor_t ExtendedHeader_descr_;
extern const XERdescriptor_t GeoUnicastHeader_seqNumber_xer_;
extern const TTCN_Typedescriptor_t GeoUnicastHeader_seqNumber_descr_;
extern const XERdescriptor_t GeoUnicastHeader_reserved_xer_;
extern const TTCN_Typedescriptor_t GeoUnicastHeader_reserved_descr_;
extern const XERdescriptor_t ShortPosVector_timestamp_xer_;
extern const TTCN_Typedescriptor_t ShortPosVector_timestamp_descr_;
extern const XERdescriptor_t ShortPosVector_latitude_xer_;
extern const TTCN_Typedescriptor_t ShortPosVector_latitude_descr_;
extern const XERdescriptor_t ShortPosVector_longitude_xer_;
extern const TTCN_Typedescriptor_t ShortPosVector_longitude_descr_;
extern const TTCN_RAWdescriptor_t ShortPosVector_raw_;
extern const TTCN_JSONdescriptor_t ShortPosVector_json_;
extern const TTCN_Typedescriptor_t ShortPosVector_descr_;
extern const TTCN_RAWdescriptor_t GeoUnicastHeader_raw_;
extern const TTCN_JSONdescriptor_t GeoUnicastHeader_json_;
extern const TTCN_Typedescriptor_t GeoUnicastHeader_descr_;
extern const XERdescriptor_t TSBHeader_seqNumber_xer_;
extern const TTCN_Typedescriptor_t TSBHeader_seqNumber_descr_;
extern const XERdescriptor_t TSBHeader_reserved_xer_;
extern const TTCN_Typedescriptor_t TSBHeader_reserved_descr_;
extern const TTCN_RAWdescriptor_t TSBHeader_raw_;
extern const TTCN_JSONdescriptor_t TSBHeader_json_;
extern const TTCN_Typedescriptor_t TSBHeader_descr_;
extern const XERdescriptor_t SHBHeader_reserved_xer_;
extern const TTCN_Typedescriptor_t SHBHeader_reserved_descr_;
extern const TTCN_RAWdescriptor_t SHBHeader_raw_;
extern const TTCN_JSONdescriptor_t SHBHeader_json_;
extern const TTCN_Typedescriptor_t SHBHeader_descr_;
extern const XERdescriptor_t GeoAnycastHeader_seqNumber_xer_;
extern const TTCN_Typedescriptor_t GeoAnycastHeader_seqNumber_descr_;
extern const XERdescriptor_t GeoAnycastHeader_reserved_xer_;
extern const TTCN_Typedescriptor_t GeoAnycastHeader_reserved_descr_;
extern const XERdescriptor_t GeoAnycastHeader_geoAreaPosLatitude_xer_;
extern const TTCN_Typedescriptor_t GeoAnycastHeader_geoAreaPosLatitude_descr_;
extern const XERdescriptor_t GeoAnycastHeader_geoAreaPosLongitude_xer_;
extern const TTCN_Typedescriptor_t GeoAnycastHeader_geoAreaPosLongitude_descr_;
extern const XERdescriptor_t GeoAnycastHeader_distanceA_xer_;
extern const TTCN_Typedescriptor_t GeoAnycastHeader_distanceA_descr_;
extern const XERdescriptor_t GeoAnycastHeader_distanceB_xer_;
extern const TTCN_Typedescriptor_t GeoAnycastHeader_distanceB_descr_;
extern const XERdescriptor_t GeoAnycastHeader_angle_xer_;
extern const TTCN_Typedescriptor_t GeoAnycastHeader_angle_descr_;
extern const XERdescriptor_t GeoAnycastHeader_reserved2_xer_;
extern const TTCN_Typedescriptor_t GeoAnycastHeader_reserved2_descr_;
extern const TTCN_RAWdescriptor_t GeoAnycastHeader_raw_;
extern const TTCN_JSONdescriptor_t GeoAnycastHeader_json_;
extern const TTCN_Typedescriptor_t GeoAnycastHeader_descr_;
extern const TTCN_RAWdescriptor_t GeoBroadcastHeader_raw_;
extern const TTCN_Typedescriptor_t GeoBroadcastHeader_descr_;
extern const TTCN_RAWdescriptor_t BeaconHeader_raw_;
extern const TTCN_JSONdescriptor_t BeaconHeader_json_;
extern const TTCN_Typedescriptor_t BeaconHeader_descr_;
extern const XERdescriptor_t LSRequestHeader_seqNumber_xer_;
extern const TTCN_Typedescriptor_t LSRequestHeader_seqNumber_descr_;
extern const XERdescriptor_t LSRequestHeader_reserved_xer_;
extern const TTCN_Typedescriptor_t LSRequestHeader_reserved_descr_;
extern const TTCN_RAWdescriptor_t LSRequestHeader_raw_;
extern const TTCN_JSONdescriptor_t LSRequestHeader_json_;
extern const TTCN_Typedescriptor_t LSRequestHeader_descr_;
extern const XERdescriptor_t LSReplyHeader_seqNumber_xer_;
extern const TTCN_Typedescriptor_t LSReplyHeader_seqNumber_descr_;
extern const XERdescriptor_t LSReplyHeader_reserved_xer_;
extern const TTCN_Typedescriptor_t LSReplyHeader_reserved_descr_;
extern const TTCN_RAWdescriptor_t LSReplyHeader_raw_;
extern const TTCN_JSONdescriptor_t LSReplyHeader_json_;
extern const TTCN_Typedescriptor_t LSReplyHeader_descr_;
extern const XERdescriptor_t AnyHeader_seqNumber_xer_;
extern const TTCN_Typedescriptor_t AnyHeader_seqNumber_descr_;
extern const XERdescriptor_t AnyHeader_reserved_xer_;
extern const TTCN_Typedescriptor_t AnyHeader_reserved_descr_;
extern const TTCN_RAWdescriptor_t AnyHeader_raw_;
extern const TTCN_JSONdescriptor_t AnyHeader_json_;
extern const TTCN_Typedescriptor_t AnyHeader_descr_;
extern const TTCN_RAWdescriptor_t GnRawPayload_raw_;
extern const XERdescriptor_t GnRawPayload_xer_;
extern const TTCN_Typedescriptor_t GnRawPayload_descr_;
extern const XERdescriptor_t Payload_rawPayload_xer_;
extern const TTCN_Typedescriptor_t Payload_rawPayload_descr_;
extern const TTCN_RAWdescriptor_t Payload_raw_;
extern const TTCN_JSONdescriptor_t Payload_json_;
extern const TTCN_Typedescriptor_t Payload_descr_;
extern const TTCN_RAWdescriptor_t DecodedPayload_raw_;
extern const TTCN_JSONdescriptor_t DecodedPayload_json_;
extern const TTCN_Typedescriptor_t DecodedPayload_descr_;
extern const TTCN_RAWdescriptor_t GeoNetworkingPacket_raw_;
extern const TTCN_JSONdescriptor_t GeoNetworkingPacket_json_;
extern const TTCN_Typedescriptor_t GeoNetworkingPacket_descr_;
extern const TTCN_RAWdescriptor_t GeoNetworkingPdu_raw_;
extern const TTCN_JSONdescriptor_t GeoNetworkingPdu_json_;
extern const TTCN_Typedescriptor_t GeoNetworkingPdu_descr_;
extern const TTCN_RAWdescriptor_t GeoUnicastForwardingAlgorithm_raw_;
extern const TTCN_Typedescriptor_t GeoUnicastForwardingAlgorithm_descr_;
extern const TTCN_RAWdescriptor_t GeoBroadcastForwardingAlgorithm_raw_;
extern const TTCN_Typedescriptor_t GeoBroadcastForwardingAlgorithm_descr_;
extern const TTCN_RAWdescriptor_t GnAddressConfigurationMethod_raw_;
extern const TTCN_Typedescriptor_t GnAddressConfigurationMethod_descr_;
extern const TTCN_RAWdescriptor_t UtGnTrigger_raw_;
extern const TTCN_JSONdescriptor_t UtGnTrigger_json_;
extern const TTCN_Typedescriptor_t UtGnTrigger_descr_;
extern const XERdescriptor_t GenerateGeoUnicastMessage_lifetime_xer_;
extern const TTCN_Typedescriptor_t GenerateGeoUnicastMessage_lifetime_descr_;
extern const TTCN_RAWdescriptor_t GenerateGeoUnicastMessage_raw_;
extern const TTCN_JSONdescriptor_t GenerateGeoUnicastMessage_json_;
extern const TTCN_Typedescriptor_t GenerateGeoUnicastMessage_descr_;
extern const XERdescriptor_t GenerateGeoBroadcastMessage_lifetime_xer_;
extern const TTCN_Typedescriptor_t GenerateGeoBroadcastMessage_lifetime_descr_;
extern const XERdescriptor_t GenerateGeoBroadcastMessage_reserved_xer_;
extern const TTCN_Typedescriptor_t GenerateGeoBroadcastMessage_reserved_descr_;
extern const TTCN_RAWdescriptor_t GenerateGeoBroadcastMessage_raw_;
extern const TTCN_JSONdescriptor_t GenerateGeoBroadcastMessage_json_;
extern const TTCN_Typedescriptor_t GenerateGeoBroadcastMessage_descr_;
extern const TTCN_RAWdescriptor_t GenerateGeoAnycastMessage_raw_;
extern const TTCN_Typedescriptor_t GenerateGeoAnycastMessage_descr_;
extern const TTCN_RAWdescriptor_t GenerateSHBMessage_raw_;
extern const TTCN_JSONdescriptor_t GenerateSHBMessage_json_;
extern const TTCN_Typedescriptor_t GenerateSHBMessage_descr_;
extern const XERdescriptor_t GenerateTSBMessage_nbHops_xer_;
extern const TTCN_Typedescriptor_t GenerateTSBMessage_nbHops_descr_;
extern const XERdescriptor_t GenerateTSBMessage_lifetime_xer_;
extern const TTCN_Typedescriptor_t GenerateTSBMessage_lifetime_descr_;
extern const TTCN_RAWdescriptor_t GenerateTSBMessage_raw_;
extern const TTCN_JSONdescriptor_t GenerateTSBMessage_json_;
extern const TTCN_Typedescriptor_t GenerateTSBMessage_descr_;
extern const XERdescriptor_t UtGnTriggerResult_utGnTriggerResult_xer_;
extern const TTCN_Typedescriptor_t UtGnTriggerResult_utGnTriggerResult_descr_;
extern const TTCN_RAWdescriptor_t UtGnTriggerResult_raw_;
extern const TTCN_JSONdescriptor_t UtGnTriggerResult_json_;
extern const TTCN_Typedescriptor_t UtGnTriggerResult_descr_;
extern const XERdescriptor_t UtGnEventInd_rawPayload_xer_;
extern const TTCN_Typedescriptor_t UtGnEventInd_rawPayload_descr_;
extern const TTCN_RAWdescriptor_t UtGnEventInd_raw_;
extern const TTCN_JSONdescriptor_t UtGnEventInd_json_;
extern const TTCN_Typedescriptor_t UtGnEventInd_descr_;
extern const TTCN_RAWdescriptor_t UtGnEventIndList_raw_;
extern const TTCN_Typedescriptor_t UtGnEventIndList_descr_;
extern const TTCN_RAWdescriptor_t AcGnPrimitive_raw_;
extern const TTCN_JSONdescriptor_t AcGnPrimitive_json_;
extern const TTCN_Typedescriptor_t AcGnPrimitive_descr_;
extern const TTCN_RAWdescriptor_t AcStartBeaconing_raw_;
extern const TTCN_JSONdescriptor_t AcStartBeaconing_json_;
extern const TTCN_Typedescriptor_t AcStartBeaconing_descr_;
extern const TTCN_RAWdescriptor_t AcStopBeaconing_raw_;
extern const TTCN_JSONdescriptor_t AcStopBeaconing_json_;
extern const TTCN_Typedescriptor_t AcStopBeaconing_descr_;
extern const TTCN_RAWdescriptor_t AcStartPassBeaconing_raw_;
extern const TTCN_JSONdescriptor_t AcStartPassBeaconing_json_;
extern const TTCN_Typedescriptor_t AcStartPassBeaconing_descr_;
extern const TTCN_RAWdescriptor_t AcStopPassBeaconing_raw_;
extern const TTCN_JSONdescriptor_t AcStopPassBeaconing_json_;
extern const TTCN_Typedescriptor_t AcStopPassBeaconing_descr_;
extern const XERdescriptor_t AcStartBeaconingMultipleNeighbour_numberOfNeighbour_xer_;
extern const TTCN_Typedescriptor_t AcStartBeaconingMultipleNeighbour_numberOfNeighbour_descr_;
extern const TTCN_RAWdescriptor_t AcStartBeaconingMultipleNeighbour_raw_;
extern const TTCN_JSONdescriptor_t AcStartBeaconingMultipleNeighbour_json_;
extern const TTCN_Typedescriptor_t AcStartBeaconingMultipleNeighbour_descr_;
extern const TTCN_RAWdescriptor_t AcStopBeaconingMultipleNeighbour_raw_;
extern const TTCN_JSONdescriptor_t AcStopBeaconingMultipleNeighbour_json_;
extern const TTCN_Typedescriptor_t AcStopBeaconingMultipleNeighbour_descr_;
extern const TTCN_RAWdescriptor_t AcGetLongPosVector_raw_;
extern const TTCN_JSONdescriptor_t AcGetLongPosVector_json_;
extern const TTCN_Typedescriptor_t AcGetLongPosVector_descr_;
extern const TTCN_RAWdescriptor_t AcGnResponse_raw_;
extern const TTCN_JSONdescriptor_t AcGnResponse_json_;
extern const TTCN_Typedescriptor_t AcGnResponse_descr_;
extern const XERdescriptor_t AcGnResponseFailure_failure_xer_;
extern const TTCN_Typedescriptor_t AcGnResponseFailure_failure_descr_;
extern const TTCN_RAWdescriptor_t AcGnResponseFailure_raw_;
extern const TTCN_JSONdescriptor_t AcGnResponseFailure_json_;
extern const TTCN_Typedescriptor_t AcGnResponseFailure_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
