// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "LibItsMapSpat_TestSystem.hh"

namespace LibItsMapSpat__TestSystem {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();
static boolean init_comp_type(const char *component_type, boolean init_base_comps);

/* Literal string constants */

static const unsigned char module_checksum[] = { 0xb8, 0xb6, 0xd7, 0x2a, 0xfa, 0x13, 0xfa, 0xc0, 0x9e, 0x87, 0x71, 0x45, 0xf2, 0x0f, 0xe7, 0x6a };

/* Global variable definitions */

const TTCN_Typedescriptor_t& ItsMapSpatSystem_descr_ = COMPONENT_descr_;
UpperTesterMapSpatPort ItsMapSpatSystem_component_utPort("utPort");
MapSpatPort ItsMapSpatSystem_component_mapSpatPort("mapSpatPort");
const TTCN_Typedescriptor_t& ItsMapSpat_descr_ = COMPONENT_descr_;
UpperTesterMapSpatPort ItsMapSpat_component_utPort("utPort");
MapSpatPort ItsMapSpat_component_mapSpatPort("mapSpatPort");
const XERdescriptor_t       RawData_xer_ = { {"RawData>\n", "RawData>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t RawData_descr_ = { "@LibItsMapSpat_TestSystem.RawData", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &RawData_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MapMsg_rawData_xer_ = { {"rawData>\n", "rawData>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t MapMsg_rawData_descr_ = { "@LibItsMapSpat_TestSystem.MapMsg.rawData", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &MapMsg_rawData_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MapMsg
const TTCN_Typedescriptor_t MapMsg_descr_ = { "@LibItsMapSpat_TestSystem.MapMsg", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for MapInd
const TTCN_Typedescriptor_t MapInd_descr_ = { "@LibItsMapSpat_TestSystem.MapInd", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MapInd_gnNextHeader_xer_ = { {"gnNextHeader>\n", "gnNextHeader>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t MapInd_gnNextHeader_descr_ = { "@LibItsMapSpat_TestSystem.MapInd.gnNextHeader", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &MapInd_gnNextHeader_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MapInd_gnHeaderType_xer_ = { {"gnHeaderType>\n", "gnHeaderType>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t MapInd_gnHeaderType_descr_ = { "@LibItsMapSpat_TestSystem.MapInd.gnHeaderType", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &MapInd_gnHeaderType_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MapInd_gnHeaderSubtype_xer_ = { {"gnHeaderSubtype>\n", "gnHeaderSubtype>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t MapInd_gnHeaderSubtype_descr_ = { "@LibItsMapSpat_TestSystem.MapInd.gnHeaderSubtype", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &MapInd_gnHeaderSubtype_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MapInd_gnLifetime_xer_ = { {"gnLifetime>\n", "gnLifetime>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t MapInd_gnLifetime_descr_ = { "@LibItsMapSpat_TestSystem.MapInd.gnLifetime", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt32_raw_, &INTEGER_text_, &MapInd_gnLifetime_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MapInd_gnTrafficClass_xer_ = { {"gnTrafficClass>\n", "gnTrafficClass>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t MapInd_gnTrafficClass_descr_ = { "@LibItsMapSpat_TestSystem.MapInd.gnTrafficClass", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &MapInd_gnTrafficClass_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MapInd_btpDestinationPort_xer_ = { {"btpDestinationPort>\n", "btpDestinationPort>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t MapInd_btpDestinationPort_descr_ = { "@LibItsMapSpat_TestSystem.MapInd.btpDestinationPort", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &MapInd_btpDestinationPort_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       MapInd_btpInfo_xer_ = { {"btpInfo>\n", "btpInfo>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t MapInd_btpInfo_descr_ = { "@LibItsMapSpat_TestSystem.MapInd.btpInfo", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &MapInd_btpInfo_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
MapInd ItsMapSpat_component_vc__mapMsg;
const XERdescriptor_t       SpatMsg_rawData_xer_ = { {"rawData>\n", "rawData>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SpatMsg_rawData_descr_ = { "@LibItsMapSpat_TestSystem.SpatMsg.rawData", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &SpatMsg_rawData_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SpatMsg
const TTCN_Typedescriptor_t SpatMsg_descr_ = { "@LibItsMapSpat_TestSystem.SpatMsg", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SpatInd
const TTCN_Typedescriptor_t SpatInd_descr_ = { "@LibItsMapSpat_TestSystem.SpatInd", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SpatInd_gnNextHeader_xer_ = { {"gnNextHeader>\n", "gnNextHeader>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SpatInd_gnNextHeader_descr_ = { "@LibItsMapSpat_TestSystem.SpatInd.gnNextHeader", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &SpatInd_gnNextHeader_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SpatInd_gnHeaderType_xer_ = { {"gnHeaderType>\n", "gnHeaderType>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SpatInd_gnHeaderType_descr_ = { "@LibItsMapSpat_TestSystem.SpatInd.gnHeaderType", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &SpatInd_gnHeaderType_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SpatInd_gnHeaderSubtype_xer_ = { {"gnHeaderSubtype>\n", "gnHeaderSubtype>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SpatInd_gnHeaderSubtype_descr_ = { "@LibItsMapSpat_TestSystem.SpatInd.gnHeaderSubtype", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &SpatInd_gnHeaderSubtype_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SpatInd_gnLifetime_xer_ = { {"gnLifetime>\n", "gnLifetime>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SpatInd_gnLifetime_descr_ = { "@LibItsMapSpat_TestSystem.SpatInd.gnLifetime", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt32_raw_, &INTEGER_text_, &SpatInd_gnLifetime_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SpatInd_gnTrafficClass_xer_ = { {"gnTrafficClass>\n", "gnTrafficClass>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SpatInd_gnTrafficClass_descr_ = { "@LibItsMapSpat_TestSystem.SpatInd.gnTrafficClass", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &SpatInd_gnTrafficClass_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SpatInd_btpDestinationPort_xer_ = { {"btpDestinationPort>\n", "btpDestinationPort>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SpatInd_btpDestinationPort_descr_ = { "@LibItsMapSpat_TestSystem.SpatInd.btpDestinationPort", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &SpatInd_btpDestinationPort_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SpatInd_btpInfo_xer_ = { {"btpInfo>\n", "btpInfo>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SpatInd_btpInfo_descr_ = { "@LibItsMapSpat_TestSystem.SpatInd.btpInfo", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &SpatInd_btpInfo_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
SpatInd ItsMapSpat_component_vc__spatMsg;
LibItsMapSpat__TypesAndValues::UtMapEventIndList ItsMapSpat_component_vc__utMapEvents;
LibItsMapSpat__TypesAndValues::UtSpatEventIndList ItsMapSpat_component_vc__utSpatEvents;
DEFAULT ItsMapSpat_component_vc__default;
BOOLEAN ItsMapSpat_component_vc__mapReceived;
BOOLEAN ItsMapSpat_component_vc__spatReceived;
// No XER for MapReq
const TTCN_Typedescriptor_t MapReq_descr_ = { "@LibItsMapSpat_TestSystem.MapReq", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for SpatReq
const TTCN_Typedescriptor_t SpatReq_descr_ = { "@LibItsMapSpat_TestSystem.SpatReq", NULL, NULL, NULL, NULL, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const size_t num_namespaces = 0;
TTCN_Module module_object("LibItsMapSpat_TestSystem", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, init_comp_type, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_5,
  current_runtime_version.requires_minor_version_4,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

void UpperTesterMapSpatPort_BASE::remove_msg_queue_head()
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
switch (my_head->item_selection) {
case MESSAGE_0:
delete (my_head)->message_0;
break;
case MESSAGE_1:
delete (my_head)->message_1;
break;
case MESSAGE_2:
delete (my_head)->message_2;
break;
case MESSAGE_3:
delete (my_head)->message_3;
break;
default:
TTCN_error("Internal error: Invalid message selector in the queue of port %s.", port_name);
}
msg_queue_item_base *next_item = msg_queue_head->next_item;
delete (msg_queue_item*)msg_queue_head;
msg_queue_head = next_item;
if (next_item == NULL) msg_queue_tail = NULL;
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::extract__msg, port_name, 0, ++msg_head_count, CHARSTRING(0,NULL), CHARSTRING(0,NULL));}

void UpperTesterMapSpatPort_BASE::clear_queue()
{
while (msg_queue_head != NULL) remove_msg_queue_head();
}

UpperTesterMapSpatPort_BASE::UpperTesterMapSpatPort_BASE(const char *par_port_name)
 : PORT(par_port_name)
{
msg_queue_head = NULL;
msg_queue_tail = NULL;
}

UpperTesterMapSpatPort_BASE::~UpperTesterMapSpatPort_BASE()
{
clear_queue();
}

void UpperTesterMapSpatPort_BASE::send(const LibItsCommon__TypesAndValues::UtInitialize& send_par, const COMPONENT& destination_component)
{
if (!is_started) TTCN_error("Sending a message on port %s, which is not started.", port_name);
if (!destination_component.is_bound()) TTCN_error("Unbound component reference in the to clause of send operation.");
const TTCN_Logger::Severity log_sev = destination_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMSEND:TTCN_Logger::PORTEVENT_MCSEND;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_send(port_name, destination_component,
(TTCN_Logger::begin_event(log_sev, TRUE), TTCN_Logger::log_event_str(" @LibItsCommon_TypesAndValues.UtInitialize : "),
send_par.log(), TTCN_Logger::end_event_log2str()));
}
if (destination_component == SYSTEM_COMPREF) outgoing_send(send_par);
else {
Text_Buf text_buf;
prepare_message(text_buf, "@LibItsCommon_TypesAndValues.UtInitialize");
send_par.encode_text(text_buf);
send_data(text_buf, destination_component);
}
}

void UpperTesterMapSpatPort_BASE::send(const LibItsCommon__TypesAndValues::UtInitialize& send_par)
{
send(send_par, COMPONENT(get_default_destination()));
}

void UpperTesterMapSpatPort_BASE::send(const LibItsCommon__TypesAndValues::UtInitialize_template& send_par, const COMPONENT& destination_component)
{
const LibItsCommon__TypesAndValues::UtInitialize& send_par_value = LibItsCommon__TypesAndValues::UtInitialize(send_par.valueof());
send(send_par_value, destination_component);
}

void UpperTesterMapSpatPort_BASE::send(const LibItsCommon__TypesAndValues::UtInitialize_template& send_par)
{
const LibItsCommon__TypesAndValues::UtInitialize& send_par_value = LibItsCommon__TypesAndValues::UtInitialize(send_par.valueof());
send(send_par_value, COMPONENT(get_default_destination()));
}

void UpperTesterMapSpatPort_BASE::send(const LibItsMapSpat__TypesAndValues::UtMapSpatTrigger& send_par, const COMPONENT& destination_component)
{
if (!is_started) TTCN_error("Sending a message on port %s, which is not started.", port_name);
if (!destination_component.is_bound()) TTCN_error("Unbound component reference in the to clause of send operation.");
const TTCN_Logger::Severity log_sev = destination_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMSEND:TTCN_Logger::PORTEVENT_MCSEND;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_send(port_name, destination_component,
(TTCN_Logger::begin_event(log_sev, TRUE), TTCN_Logger::log_event_str(" @LibItsMapSpat_TypesAndValues.UtMapSpatTrigger : "),
send_par.log(), TTCN_Logger::end_event_log2str()));
}
if (destination_component == SYSTEM_COMPREF) outgoing_send(send_par);
else {
Text_Buf text_buf;
prepare_message(text_buf, "@LibItsMapSpat_TypesAndValues.UtMapSpatTrigger");
send_par.encode_text(text_buf);
send_data(text_buf, destination_component);
}
}

void UpperTesterMapSpatPort_BASE::send(const LibItsMapSpat__TypesAndValues::UtMapSpatTrigger& send_par)
{
send(send_par, COMPONENT(get_default_destination()));
}

void UpperTesterMapSpatPort_BASE::send(const LibItsMapSpat__TypesAndValues::UtMapSpatTrigger_template& send_par, const COMPONENT& destination_component)
{
const LibItsMapSpat__TypesAndValues::UtMapSpatTrigger& send_par_value = LibItsMapSpat__TypesAndValues::UtMapSpatTrigger(send_par.valueof());
send(send_par_value, destination_component);
}

void UpperTesterMapSpatPort_BASE::send(const LibItsMapSpat__TypesAndValues::UtMapSpatTrigger_template& send_par)
{
const LibItsMapSpat__TypesAndValues::UtMapSpatTrigger& send_par_value = LibItsMapSpat__TypesAndValues::UtMapSpatTrigger(send_par.valueof());
send(send_par_value, COMPONENT(get_default_destination()));
}

alt_status UpperTesterMapSpatPort_BASE::receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtInitializeResult: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_1:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtMapSpatTriggerResult: "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_2:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtMapEventInd: "),
my_head->message_2->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_3:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtSpatEventInd: "),
my_head->message_3->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterMapSpatPort_BASE::check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtInitializeResult: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_1:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtMapSpatTriggerResult: "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_2:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtMapEventInd: "),
my_head->message_2->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_3:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtSpatEventInd: "),
my_head->message_3->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
return ALT_YES;
}
}

alt_status UpperTesterMapSpatPort_BASE::trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtInitializeResult: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_1:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtMapSpatTriggerResult: "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_2:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtMapEventInd: "),
my_head->message_2->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_3:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtSpatEventInd: "),
my_head->message_3->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterMapSpatPort_BASE::receive(const LibItsCommon__TypesAndValues::UtInitializeResult_template& value_template, LibItsCommon__TypesAndValues::UtInitializeResult *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsCommon_TypesAndValues.UtInitializeResult.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtInitializeResult : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterMapSpatPort_BASE::check_receive(const LibItsCommon__TypesAndValues::UtInitializeResult_template& value_template, LibItsCommon__TypesAndValues::UtInitializeResult *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsCommon_TypesAndValues.UtInitializeResult.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtInitializeResult : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
return ALT_YES;
}
}

alt_status UpperTesterMapSpatPort_BASE::trigger(const LibItsCommon__TypesAndValues::UtInitializeResult_template& value_template, LibItsCommon__TypesAndValues::UtInitializeResult *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s will drop a message: Type of the first message in the queue is not @LibItsCommon_TypesAndValues.UtInitializeResult.", port_name);
remove_msg_queue_head();
return ALT_REPEAT;
} else if (!value_template.match(*my_head->message_0, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsCommon_TypesAndValues.UtInitializeResult : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterMapSpatPort_BASE::receive(const LibItsMapSpat__TypesAndValues::UtMapSpatTriggerResult_template& value_template, LibItsMapSpat__TypesAndValues::UtMapSpatTriggerResult *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_1) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsMapSpat_TypesAndValues.UtMapSpatTriggerResult.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_1, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_1;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtMapSpatTriggerResult : "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterMapSpatPort_BASE::check_receive(const LibItsMapSpat__TypesAndValues::UtMapSpatTriggerResult_template& value_template, LibItsMapSpat__TypesAndValues::UtMapSpatTriggerResult *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_1) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsMapSpat_TypesAndValues.UtMapSpatTriggerResult.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_1, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_1;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtMapSpatTriggerResult : "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
return ALT_YES;
}
}

alt_status UpperTesterMapSpatPort_BASE::trigger(const LibItsMapSpat__TypesAndValues::UtMapSpatTriggerResult_template& value_template, LibItsMapSpat__TypesAndValues::UtMapSpatTriggerResult *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else if (my_head->item_selection != MESSAGE_1) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s will drop a message: Type of the first message in the queue is not @LibItsMapSpat_TypesAndValues.UtMapSpatTriggerResult.", port_name);
remove_msg_queue_head();
return ALT_REPEAT;
} else if (!value_template.match(*my_head->message_1, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_1;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtMapSpatTriggerResult : "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterMapSpatPort_BASE::receive(const LibItsMapSpat__TypesAndValues::UtMapEventInd_template& value_template, LibItsMapSpat__TypesAndValues::UtMapEventInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_2) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsMapSpat_TypesAndValues.UtMapEventInd.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_2, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_2, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_2;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_2, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtMapEventInd : "),
my_head->message_2->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterMapSpatPort_BASE::check_receive(const LibItsMapSpat__TypesAndValues::UtMapEventInd_template& value_template, LibItsMapSpat__TypesAndValues::UtMapEventInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_2) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsMapSpat_TypesAndValues.UtMapEventInd.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_2, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_2, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_2;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_2, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtMapEventInd : "),
my_head->message_2->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
return ALT_YES;
}
}

alt_status UpperTesterMapSpatPort_BASE::trigger(const LibItsMapSpat__TypesAndValues::UtMapEventInd_template& value_template, LibItsMapSpat__TypesAndValues::UtMapEventInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else if (my_head->item_selection != MESSAGE_2) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s will drop a message: Type of the first message in the queue is not @LibItsMapSpat_TypesAndValues.UtMapEventInd.", port_name);
remove_msg_queue_head();
return ALT_REPEAT;
} else if (!value_template.match(*my_head->message_2, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_2, TRUE),
 TTCN_Logger::end_event_log2str()));
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_2;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_2, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtMapEventInd : "),
my_head->message_2->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterMapSpatPort_BASE::receive(const LibItsMapSpat__TypesAndValues::UtSpatEventInd_template& value_template, LibItsMapSpat__TypesAndValues::UtSpatEventInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_3) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsMapSpat_TypesAndValues.UtSpatEventInd.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_3, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_3, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_3;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_3, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtSpatEventInd : "),
my_head->message_3->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status UpperTesterMapSpatPort_BASE::check_receive(const LibItsMapSpat__TypesAndValues::UtSpatEventInd_template& value_template, LibItsMapSpat__TypesAndValues::UtSpatEventInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_3) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsMapSpat_TypesAndValues.UtSpatEventInd.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_3, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_3, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_3;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_3, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtSpatEventInd : "),
my_head->message_3->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
return ALT_YES;
}
}

alt_status UpperTesterMapSpatPort_BASE::trigger(const LibItsMapSpat__TypesAndValues::UtSpatEventInd_template& value_template, LibItsMapSpat__TypesAndValues::UtSpatEventInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else if (my_head->item_selection != MESSAGE_3) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s will drop a message: Type of the first message in the queue is not @LibItsMapSpat_TypesAndValues.UtSpatEventInd.", port_name);
remove_msg_queue_head();
return ALT_REPEAT;
} else if (!value_template.match(*my_head->message_3, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_3, TRUE),
 TTCN_Logger::end_event_log2str()));
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_3;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_3, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TypesAndValues.UtSpatEventInd : "),
my_head->message_3->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

void UpperTesterMapSpatPort_BASE::incoming_message(const LibItsCommon__TypesAndValues::UtInitializeResult& incoming_par, component sender_component)
{
if (!is_started) TTCN_error("Port %s is not started but a message has arrived on it.", port_name);
msg_tail_count++;
if (TTCN_Logger::log_this_event(TTCN_Logger::PORTEVENT_MQUEUE)) {
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::enqueue__msg, port_name, sender_component, msg_tail_count,
CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(TTCN_Logger::PORTEVENT_MQUEUE, TRUE), TTCN_Logger::log_event_str(" @LibItsCommon_TypesAndValues.UtInitializeResult : "), incoming_par.log(), TTCN_Logger::end_event_log2str()));
}
msg_queue_item *new_item = new msg_queue_item;
new_item->item_selection = MESSAGE_0;
new_item->message_0 = new LibItsCommon__TypesAndValues::UtInitializeResult(incoming_par);
new_item->sender_component = sender_component;
append_to_msg_queue(new_item);
}

void UpperTesterMapSpatPort_BASE::incoming_message(const LibItsMapSpat__TypesAndValues::UtMapSpatTriggerResult& incoming_par, component sender_component)
{
if (!is_started) TTCN_error("Port %s is not started but a message has arrived on it.", port_name);
msg_tail_count++;
if (TTCN_Logger::log_this_event(TTCN_Logger::PORTEVENT_MQUEUE)) {
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::enqueue__msg, port_name, sender_component, msg_tail_count,
CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(TTCN_Logger::PORTEVENT_MQUEUE, TRUE), TTCN_Logger::log_event_str(" @LibItsMapSpat_TypesAndValues.UtMapSpatTriggerResult : "), incoming_par.log(), TTCN_Logger::end_event_log2str()));
}
msg_queue_item *new_item = new msg_queue_item;
new_item->item_selection = MESSAGE_1;
new_item->message_1 = new LibItsMapSpat__TypesAndValues::UtMapSpatTriggerResult(incoming_par);
new_item->sender_component = sender_component;
append_to_msg_queue(new_item);
}

void UpperTesterMapSpatPort_BASE::incoming_message(const LibItsMapSpat__TypesAndValues::UtMapEventInd& incoming_par, component sender_component)
{
if (!is_started) TTCN_error("Port %s is not started but a message has arrived on it.", port_name);
msg_tail_count++;
if (TTCN_Logger::log_this_event(TTCN_Logger::PORTEVENT_MQUEUE)) {
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::enqueue__msg, port_name, sender_component, msg_tail_count,
CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(TTCN_Logger::PORTEVENT_MQUEUE, TRUE), TTCN_Logger::log_event_str(" @LibItsMapSpat_TypesAndValues.UtMapEventInd : "), incoming_par.log(), TTCN_Logger::end_event_log2str()));
}
msg_queue_item *new_item = new msg_queue_item;
new_item->item_selection = MESSAGE_2;
new_item->message_2 = new LibItsMapSpat__TypesAndValues::UtMapEventInd(incoming_par);
new_item->sender_component = sender_component;
append_to_msg_queue(new_item);
}

void UpperTesterMapSpatPort_BASE::incoming_message(const LibItsMapSpat__TypesAndValues::UtSpatEventInd& incoming_par, component sender_component)
{
if (!is_started) TTCN_error("Port %s is not started but a message has arrived on it.", port_name);
msg_tail_count++;
if (TTCN_Logger::log_this_event(TTCN_Logger::PORTEVENT_MQUEUE)) {
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::enqueue__msg, port_name, sender_component, msg_tail_count,
CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(TTCN_Logger::PORTEVENT_MQUEUE, TRUE), TTCN_Logger::log_event_str(" @LibItsMapSpat_TypesAndValues.UtSpatEventInd : "), incoming_par.log(), TTCN_Logger::end_event_log2str()));
}
msg_queue_item *new_item = new msg_queue_item;
new_item->item_selection = MESSAGE_3;
new_item->message_3 = new LibItsMapSpat__TypesAndValues::UtSpatEventInd(incoming_par);
new_item->sender_component = sender_component;
append_to_msg_queue(new_item);
}

boolean UpperTesterMapSpatPort_BASE::process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING&)
{
if (!strcmp(message_type, "@LibItsCommon_TypesAndValues.UtInitializeResult")) {
LibItsCommon__TypesAndValues::UtInitializeResult incoming_par;
incoming_par.decode_text(incoming_buf);
incoming_message(incoming_par, sender_component);
return TRUE;
} else if (!strcmp(message_type, "@LibItsMapSpat_TypesAndValues.UtMapSpatTriggerResult")) {
LibItsMapSpat__TypesAndValues::UtMapSpatTriggerResult incoming_par;
incoming_par.decode_text(incoming_buf);
incoming_message(incoming_par, sender_component);
return TRUE;
} else if (!strcmp(message_type, "@LibItsMapSpat_TypesAndValues.UtMapEventInd")) {
LibItsMapSpat__TypesAndValues::UtMapEventInd incoming_par;
incoming_par.decode_text(incoming_buf);
incoming_message(incoming_par, sender_component);
return TRUE;
} else if (!strcmp(message_type, "@LibItsMapSpat_TypesAndValues.UtSpatEventInd")) {
LibItsMapSpat__TypesAndValues::UtSpatEventInd incoming_par;
incoming_par.decode_text(incoming_buf);
incoming_message(incoming_par, sender_component);
return TRUE;
} else return FALSE;
}

void MapSpatPort_BASE::remove_msg_queue_head()
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
switch (my_head->item_selection) {
case MESSAGE_0:
delete (my_head)->message_0;
break;
case MESSAGE_1:
delete (my_head)->message_1;
break;
default:
TTCN_error("Internal error: Invalid message selector in the queue of port %s.", port_name);
}
msg_queue_item_base *next_item = msg_queue_head->next_item;
delete (msg_queue_item*)msg_queue_head;
msg_queue_head = next_item;
if (next_item == NULL) msg_queue_tail = NULL;
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::extract__msg, port_name, 0, ++msg_head_count, CHARSTRING(0,NULL), CHARSTRING(0,NULL));}

void MapSpatPort_BASE::clear_queue()
{
while (msg_queue_head != NULL) remove_msg_queue_head();
}

MapSpatPort_BASE::MapSpatPort_BASE(const char *par_port_name)
 : PORT(par_port_name)
{
msg_queue_head = NULL;
msg_queue_tail = NULL;
}

MapSpatPort_BASE::~MapSpatPort_BASE()
{
clear_queue();
}

void MapSpatPort_BASE::send(const MapReq& send_par, const COMPONENT& destination_component)
{
if (!is_started) TTCN_error("Sending a message on port %s, which is not started.", port_name);
if (!destination_component.is_bound()) TTCN_error("Unbound component reference in the to clause of send operation.");
const TTCN_Logger::Severity log_sev = destination_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMSEND:TTCN_Logger::PORTEVENT_MCSEND;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_send(port_name, destination_component,
(TTCN_Logger::begin_event(log_sev, TRUE), TTCN_Logger::log_event_str(" @LibItsMapSpat_TestSystem.MapReq : "),
send_par.log(), TTCN_Logger::end_event_log2str()));
}
if (destination_component == SYSTEM_COMPREF) outgoing_send(send_par);
else {
Text_Buf text_buf;
prepare_message(text_buf, "@LibItsMapSpat_TestSystem.MapReq");
send_par.encode_text(text_buf);
send_data(text_buf, destination_component);
}
}

void MapSpatPort_BASE::send(const MapReq& send_par)
{
send(send_par, COMPONENT(get_default_destination()));
}

void MapSpatPort_BASE::send(const MapReq_template& send_par, const COMPONENT& destination_component)
{
const MapReq& send_par_value = MapReq(send_par.valueof());
send(send_par_value, destination_component);
}

void MapSpatPort_BASE::send(const MapReq_template& send_par)
{
const MapReq& send_par_value = MapReq(send_par.valueof());
send(send_par_value, COMPONENT(get_default_destination()));
}

void MapSpatPort_BASE::send(const SpatReq& send_par, const COMPONENT& destination_component)
{
if (!is_started) TTCN_error("Sending a message on port %s, which is not started.", port_name);
if (!destination_component.is_bound()) TTCN_error("Unbound component reference in the to clause of send operation.");
const TTCN_Logger::Severity log_sev = destination_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMSEND:TTCN_Logger::PORTEVENT_MCSEND;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_send(port_name, destination_component,
(TTCN_Logger::begin_event(log_sev, TRUE), TTCN_Logger::log_event_str(" @LibItsMapSpat_TestSystem.SpatReq : "),
send_par.log(), TTCN_Logger::end_event_log2str()));
}
if (destination_component == SYSTEM_COMPREF) outgoing_send(send_par);
else {
Text_Buf text_buf;
prepare_message(text_buf, "@LibItsMapSpat_TestSystem.SpatReq");
send_par.encode_text(text_buf);
send_data(text_buf, destination_component);
}
}

void MapSpatPort_BASE::send(const SpatReq& send_par)
{
send(send_par, COMPONENT(get_default_destination()));
}

void MapSpatPort_BASE::send(const SpatReq_template& send_par, const COMPONENT& destination_component)
{
const SpatReq& send_par_value = SpatReq(send_par.valueof());
send(send_par_value, destination_component);
}

void MapSpatPort_BASE::send(const SpatReq_template& send_par)
{
const SpatReq& send_par_value = SpatReq(send_par.valueof());
send(send_par_value, COMPONENT(get_default_destination()));
}

alt_status MapSpatPort_BASE::receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TestSystem.MapInd: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_1:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TestSystem.SpatInd: "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status MapSpatPort_BASE::check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TestSystem.MapInd: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_1:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TestSystem.SpatInd: "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
return ALT_YES;
}
}

alt_status MapSpatPort_BASE::trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS, "Matching on port %s succeeded.", port_name);
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
switch (my_head->item_selection) {
case MESSAGE_0:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TestSystem.MapInd: "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
case MESSAGE_1:
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TestSystem.SpatInd: "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()), msg_head_count+1);
break;
default:
TTCN_error("Internal error: unknown message");
}
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status MapSpatPort_BASE::receive(const MapInd_template& value_template, MapInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsMapSpat_TestSystem.MapInd.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TestSystem.MapInd : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status MapSpatPort_BASE::check_receive(const MapInd_template& value_template, MapInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsMapSpat_TestSystem.MapInd.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_0, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TestSystem.MapInd : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
return ALT_YES;
}
}

alt_status MapSpatPort_BASE::trigger(const MapInd_template& value_template, MapInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else if (my_head->item_selection != MESSAGE_0) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s will drop a message: Type of the first message in the queue is not @LibItsMapSpat_TestSystem.MapInd.", port_name);
remove_msg_queue_head();
return ALT_REPEAT;
} else if (!value_template.match(*my_head->message_0, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_0;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_0, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TestSystem.MapInd : "),
my_head->message_0->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status MapSpatPort_BASE::receive(const SpatInd_template& value_template, SpatInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_1) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsMapSpat_TestSystem.SpatInd.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_1, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_1;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TestSystem.SpatInd : "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

alt_status MapSpatPort_BASE::check_receive(const SpatInd_template& value_template, SpatInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s failed: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
return ALT_NO;
} else if (my_head->item_selection != MESSAGE_1) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s failed: Type of the first message in the queue is not @LibItsMapSpat_TestSystem.SpatInd.", port_name);
return ALT_NO;
} else if (!value_template.match(*my_head->message_1, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
return ALT_NO;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_1;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::check__receive__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TestSystem.SpatInd : "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
return ALT_YES;
}
}

alt_status MapSpatPort_BASE::trigger(const SpatInd_template& value_template, SpatInd *value_ptr, const COMPONENT_template& sender_template, COMPONENT *sender_ptr)
{
msg_queue_item *my_head = (msg_queue_item*)msg_queue_head;
if (msg_queue_head == NULL) {
if (is_started) return ALT_MAYBE;
else {
TTCN_Logger::log(TTCN_Logger::MATCHING_PROBLEM, "Matching on port %s failed: Port is not started and the queue is empty.", port_name);
return ALT_NO;
}
} else if (!sender_template.match(my_head->sender_component)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::begin_event(log_sev);
TTCN_Logger::log_event("Matching on port %s will drop a message: Sender of the first message in the queue does not match the from clause: ", port_name);
sender_template.log_match(my_head->sender_component);
TTCN_Logger::end_event();
}
remove_msg_queue_head();
return ALT_REPEAT;
} else if (my_head->item_selection != MESSAGE_1) {
TTCN_Logger::log(my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMUNSUCC:TTCN_Logger::MATCHING_MCUNSUCC, "Matching on port %s will drop a message: Type of the first message in the queue is not @LibItsMapSpat_TestSystem.SpatInd.", port_name);
remove_msg_queue_head();
return ALT_REPEAT;
} else if (!value_template.match(*my_head->message_1, TRUE)) {
const TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF ? TTCN_Logger::MATCHING_MMUNSUCC : TTCN_Logger::MATCHING_MCUNSUCC;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_failure(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
TitanLoggerApiSimple::MatchingFailureType_reason::message__does__not__match__template,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
remove_msg_queue_head();
return ALT_REPEAT;
} else {
if (value_ptr != NULL) *value_ptr = *my_head->message_1;
if (sender_ptr != NULL) *sender_ptr = my_head->sender_component;
TTCN_Logger::Severity log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::MATCHING_MMSUCCESS:TTCN_Logger::MATCHING_MCSUCCESS;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_matching_success(TitanLoggerApiSimple::PortType::message__,
port_name, my_head->sender_component,
(TTCN_Logger::begin_event(log_sev, TRUE), value_template.log_match(*my_head->message_1, TRUE),
 TTCN_Logger::end_event_log2str()));
}
log_sev = my_head->sender_component==SYSTEM_COMPREF?TTCN_Logger::PORTEVENT_MMRECV:TTCN_Logger::PORTEVENT_MCRECV;
if (TTCN_Logger::log_this_event(log_sev)) {
TTCN_Logger::log_msgport_recv(port_name, TitanLoggerApiSimple::Msg__port__recv_operation::trigger__op,
my_head->sender_component, CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(log_sev,TRUE), TTCN_Logger::log_event_str(": @LibItsMapSpat_TestSystem.SpatInd : "),
my_head->message_1->log(), TTCN_Logger::end_event_log2str()),
msg_head_count+1);
}
remove_msg_queue_head();
return ALT_YES;
}
}

void MapSpatPort_BASE::incoming_message(const MapInd& incoming_par, component sender_component)
{
if (!is_started) TTCN_error("Port %s is not started but a message has arrived on it.", port_name);
msg_tail_count++;
if (TTCN_Logger::log_this_event(TTCN_Logger::PORTEVENT_MQUEUE)) {
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::enqueue__msg, port_name, sender_component, msg_tail_count,
CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(TTCN_Logger::PORTEVENT_MQUEUE, TRUE), TTCN_Logger::log_event_str(" @LibItsMapSpat_TestSystem.MapInd : "), incoming_par.log(), TTCN_Logger::end_event_log2str()));
}
msg_queue_item *new_item = new msg_queue_item;
new_item->item_selection = MESSAGE_0;
new_item->message_0 = new MapInd(incoming_par);
new_item->sender_component = sender_component;
append_to_msg_queue(new_item);
}

void MapSpatPort_BASE::incoming_message(const SpatInd& incoming_par, component sender_component)
{
if (!is_started) TTCN_error("Port %s is not started but a message has arrived on it.", port_name);
msg_tail_count++;
if (TTCN_Logger::log_this_event(TTCN_Logger::PORTEVENT_MQUEUE)) {
TTCN_Logger::log_port_queue(TitanLoggerApiSimple::Port__Queue_operation::enqueue__msg, port_name, sender_component, msg_tail_count,
CHARSTRING(0, NULL),
(TTCN_Logger::begin_event(TTCN_Logger::PORTEVENT_MQUEUE, TRUE), TTCN_Logger::log_event_str(" @LibItsMapSpat_TestSystem.SpatInd : "), incoming_par.log(), TTCN_Logger::end_event_log2str()));
}
msg_queue_item *new_item = new msg_queue_item;
new_item->item_selection = MESSAGE_1;
new_item->message_1 = new SpatInd(incoming_par);
new_item->sender_component = sender_component;
append_to_msg_queue(new_item);
}

boolean MapSpatPort_BASE::process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING&)
{
if (!strcmp(message_type, "@LibItsMapSpat_TestSystem.MapInd")) {
MapInd incoming_par;
incoming_par.decode_text(incoming_buf);
incoming_message(incoming_par, sender_component);
return TRUE;
} else if (!strcmp(message_type, "@LibItsMapSpat_TestSystem.SpatInd")) {
SpatInd incoming_par;
incoming_par.decode_text(incoming_buf);
incoming_message(incoming_par, sender_component);
return TRUE;
} else return FALSE;
}

MapMsg::MapMsg()
{
  bound_flag = FALSE;
}

MapMsg::MapMsg(const MAP__SPAT__ETSI::MAP__PDU& par_msgMap,
    const OCTETSTRING& par_rawData)
  :   field_msgMap(par_msgMap),
  field_rawData(par_rawData)
{
  bound_flag = TRUE;
}

MapMsg::MapMsg(const MapMsg& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsMapSpat_TestSystem.MapMsg.");
bound_flag = TRUE;
if (other_value.msgMap().is_bound()) field_msgMap = other_value.msgMap();
else field_msgMap.clean_up();
if (other_value.rawData().is_bound()) field_rawData = other_value.rawData();
else field_rawData.clean_up();
}

void MapMsg::clean_up()
{
field_msgMap.clean_up();
field_rawData.clean_up();
bound_flag = FALSE;
}

MapMsg& MapMsg::operator=(const MapMsg& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsMapSpat_TestSystem.MapMsg.");
  bound_flag = TRUE;
  if (other_value.msgMap().is_bound()) field_msgMap = other_value.msgMap();
  else field_msgMap.clean_up();
  if (other_value.rawData().is_bound()) field_rawData = other_value.rawData();
  else field_rawData.clean_up();
}
return *this;
}

boolean MapMsg::operator==(const MapMsg& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_msgMap==other_value.field_msgMap
  && field_rawData==other_value.field_rawData;
}

boolean MapMsg::is_bound() const
{
if (bound_flag) return TRUE;
if(field_msgMap.is_bound()) return TRUE;
if(field_rawData.is_bound()) return TRUE;
return FALSE;
}
boolean MapMsg::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_msgMap.is_value()) return FALSE;
if(!field_rawData.is_value()) return FALSE;
return TRUE;
}
int MapMsg::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsMapSpat_TestSystem.MapMsg");
  return 2;
}

void MapMsg::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ msgMap := ");
field_msgMap.log();
TTCN_Logger::log_event_str(", rawData := ");
field_rawData.log();
TTCN_Logger::log_event_str(" }");
}

void MapMsg::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsMapSpat_TestSystem.MapMsg'");
    }
    if (strcmp("msgMap", param_field) == 0) {
      msgMap().set_param(param);
      return;
    } else if (strcmp("rawData", param_field) == 0) {
      rawData().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.MapMsg'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsMapSpat_TestSystem.MapMsg has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgMap().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) rawData().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgMap")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgMap().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawData")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawData().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsMapSpat_TestSystem.MapMsg: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsMapSpat_TestSystem.MapMsg");
  }
}

Module_Param* MapMsg::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsMapSpat_TestSystem.MapMsg'");
    }
    if (strcmp("msgMap", param_field) == 0) {
      return msgMap().get_param(param_name);
    } else if (strcmp("rawData", param_field) == 0) {
      return rawData().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.MapMsg'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_msgMap = field_msgMap.get_param(param_name);
  mp_field_msgMap->set_id(new Module_Param_FieldName(mcopystr("msgMap")));
  mp->add_elem(mp_field_msgMap);
  Module_Param* mp_field_rawData = field_rawData.get_param(param_name);
  mp_field_rawData->set_id(new Module_Param_FieldName(mcopystr("rawData")));
  mp->add_elem(mp_field_rawData);
  return mp;
  }

void MapMsg::set_implicit_omit()
{
if (msgMap().is_bound()) msgMap().set_implicit_omit();
if (rawData().is_bound()) rawData().set_implicit_omit();
}

void MapMsg::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsMapSpat_TestSystem.MapMsg.");
field_msgMap.encode_text(text_buf);
field_rawData.encode_text(text_buf);
}

void MapMsg::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_msgMap.decode_text(text_buf);
field_rawData.decode_text(text_buf);
}

struct MapMsg_template::single_value_struct {
MAP__SPAT__ETSI::MAP__PDU_template field_msgMap;
OCTETSTRING_template field_rawData;
};

void MapMsg_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_msgMap = ANY_VALUE;
single_value->field_rawData = ANY_VALUE;
}
}
}

void MapMsg_template::copy_value(const MapMsg& other_value)
{
single_value = new single_value_struct;
if (other_value.msgMap().is_bound()) {
  single_value->field_msgMap = other_value.msgMap();
} else {
  single_value->field_msgMap.clean_up();
}
if (other_value.rawData().is_bound()) {
  single_value->field_rawData = other_value.rawData();
} else {
  single_value->field_rawData.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MapMsg_template::copy_template(const MapMsg_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.msgMap().get_selection()) {
single_value->field_msgMap = other_value.msgMap();
} else {
single_value->field_msgMap.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rawData().get_selection()) {
single_value->field_rawData = other_value.rawData();
} else {
single_value->field_rawData.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MapMsg_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.MapMsg.");
break;
}
set_selection(other_value);
}

MapMsg_template::MapMsg_template()
{
}

MapMsg_template::MapMsg_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MapMsg_template::MapMsg_template(const MapMsg& other_value)
{
copy_value(other_value);
}

MapMsg_template::MapMsg_template(const OPTIONAL<MapMsg>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MapMsg&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsMapSpat_TestSystem.MapMsg from an unbound optional field.");
}
}

MapMsg_template::MapMsg_template(const MapMsg_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MapMsg_template::~MapMsg_template()
{
clean_up();
}

MapMsg_template& MapMsg_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MapMsg_template& MapMsg_template::operator=(const MapMsg& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MapMsg_template& MapMsg_template::operator=(const OPTIONAL<MapMsg>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MapMsg&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsMapSpat_TestSystem.MapMsg.");
}
return *this;
}

MapMsg_template& MapMsg_template::operator=(const MapMsg_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MapMsg_template::match(const MapMsg& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.msgMap().is_bound()) return FALSE;
if(!single_value->field_msgMap.match(other_value.msgMap(), legacy))return FALSE;
if(!other_value.rawData().is_bound()) return FALSE;
if(!single_value->field_rawData.match(other_value.rawData(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.MapMsg.");
}
return FALSE;
}

boolean MapMsg_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_msgMap.is_bound()) return TRUE;
if (single_value->field_rawData.is_bound()) return TRUE;
return FALSE;
}

boolean MapMsg_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_msgMap.is_value()) return FALSE;
if (!single_value->field_rawData.is_value()) return FALSE;
return TRUE;
}

void MapMsg_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MapMsg MapMsg_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsMapSpat_TestSystem.MapMsg.");
MapMsg ret_val;
if (single_value->field_msgMap.is_bound()) {
ret_val.msgMap() = single_value->field_msgMap.valueof();
}
if (single_value->field_rawData.is_bound()) {
ret_val.rawData() = single_value->field_rawData.valueof();
}
return ret_val;
}

void MapMsg_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsMapSpat_TestSystem.MapMsg.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MapMsg_template[list_length];
}

MapMsg_template& MapMsg_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsMapSpat_TestSystem.MapMsg.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsMapSpat_TestSystem.MapMsg.");
return value_list.list_value[list_index];
}

MAP__SPAT__ETSI::MAP__PDU_template& MapMsg_template::msgMap()
{
set_specific();
return single_value->field_msgMap;
}

const MAP__SPAT__ETSI::MAP__PDU_template& MapMsg_template::msgMap() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msgMap of a non-specific template of type @LibItsMapSpat_TestSystem.MapMsg.");
return single_value->field_msgMap;
}

OCTETSTRING_template& MapMsg_template::rawData()
{
set_specific();
return single_value->field_rawData;
}

const OCTETSTRING_template& MapMsg_template::rawData() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rawData of a non-specific template of type @LibItsMapSpat_TestSystem.MapMsg.");
return single_value->field_rawData;
}

int MapMsg_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapMsg which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapMsg containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapMsg containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapMsg containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapMsg containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapMsg containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.MapMsg.");
  }
  return 0;
}

void MapMsg_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ msgMap := ");
single_value->field_msgMap.log();
TTCN_Logger::log_event_str(", rawData := ");
single_value->field_rawData.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MapMsg_template::log_match(const MapMsg& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_msgMap.match(match_value.msgMap(), legacy)){
TTCN_Logger::log_logmatch_info(".msgMap");
single_value->field_msgMap.log_match(match_value.msgMap(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_rawData.match(match_value.rawData(), legacy)){
TTCN_Logger::log_logmatch_info(".rawData");
single_value->field_rawData.log_match(match_value.rawData(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ msgMap := ");
single_value->field_msgMap.log_match(match_value.msgMap(), legacy);
TTCN_Logger::log_event_str(", rawData := ");
single_value->field_rawData.log_match(match_value.rawData(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MapMsg_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_msgMap.encode_text(text_buf);
single_value->field_rawData.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.MapMsg.");
}
}

void MapMsg_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_msgMap.decode_text(text_buf);
single_value->field_rawData.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MapMsg_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsMapSpat_TestSystem.MapMsg.");
}
}

void MapMsg_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsMapSpat_TestSystem.MapMsg'");
    }
    if (strcmp("msgMap", param_field) == 0) {
      msgMap().set_param(param);
      return;
    } else if (strcmp("rawData", param_field) == 0) {
      rawData().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsMapSpat_TestSystem.MapMsg'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MapMsg_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsMapSpat_TestSystem.MapMsg has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgMap().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) rawData().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgMap")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgMap().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawData")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawData().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsMapSpat_TestSystem.MapMsg: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsMapSpat_TestSystem.MapMsg");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* MapMsg_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsMapSpat_TestSystem.MapMsg'");
    }
    if (strcmp("msgMap", param_field) == 0) {
      return msgMap().get_param(param_name);
    } else if (strcmp("rawData", param_field) == 0) {
      return rawData().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.MapMsg'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_msgMap = single_value->field_msgMap.get_param(param_name);
    mp_field_msgMap->set_id(new Module_Param_FieldName(mcopystr("msgMap")));
    mp->add_elem(mp_field_msgMap);
    Module_Param* mp_field_rawData = single_value->field_rawData.get_param(param_name);
    mp_field_rawData->set_id(new Module_Param_FieldName(mcopystr("rawData")));
    mp->add_elem(mp_field_rawData);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void MapMsg_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_msgMap.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.MapMsg");
single_value->field_rawData.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.MapMsg");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsMapSpat_TestSystem.MapMsg");
}

boolean MapMsg_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MapMsg_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MapInd::MapInd()
{
  bound_flag = FALSE;
}

MapInd::MapInd(const MapMsg& par_msgIn,
    const OPTIONAL<INTEGER>& par_gnNextHeader,
    const OPTIONAL<INTEGER>& par_gnHeaderType,
    const OPTIONAL<INTEGER>& par_gnHeaderSubtype,
    const OPTIONAL<INTEGER>& par_gnLifetime,
    const OPTIONAL<INTEGER>& par_gnTrafficClass,
    const OPTIONAL<INTEGER>& par_btpDestinationPort,
    const OPTIONAL<INTEGER>& par_btpInfo)
  :   field_msgIn(par_msgIn),
  field_gnNextHeader(par_gnNextHeader),
  field_gnHeaderType(par_gnHeaderType),
  field_gnHeaderSubtype(par_gnHeaderSubtype),
  field_gnLifetime(par_gnLifetime),
  field_gnTrafficClass(par_gnTrafficClass),
  field_btpDestinationPort(par_btpDestinationPort),
  field_btpInfo(par_btpInfo)
{
  bound_flag = TRUE;
}

MapInd::MapInd(const MapInd& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsMapSpat_TestSystem.MapInd.");
bound_flag = TRUE;
if (other_value.msgIn().is_bound()) field_msgIn = other_value.msgIn();
else field_msgIn.clean_up();
if (other_value.gnNextHeader().is_bound()) field_gnNextHeader = other_value.gnNextHeader();
else field_gnNextHeader.clean_up();
if (other_value.gnHeaderType().is_bound()) field_gnHeaderType = other_value.gnHeaderType();
else field_gnHeaderType.clean_up();
if (other_value.gnHeaderSubtype().is_bound()) field_gnHeaderSubtype = other_value.gnHeaderSubtype();
else field_gnHeaderSubtype.clean_up();
if (other_value.gnLifetime().is_bound()) field_gnLifetime = other_value.gnLifetime();
else field_gnLifetime.clean_up();
if (other_value.gnTrafficClass().is_bound()) field_gnTrafficClass = other_value.gnTrafficClass();
else field_gnTrafficClass.clean_up();
if (other_value.btpDestinationPort().is_bound()) field_btpDestinationPort = other_value.btpDestinationPort();
else field_btpDestinationPort.clean_up();
if (other_value.btpInfo().is_bound()) field_btpInfo = other_value.btpInfo();
else field_btpInfo.clean_up();
}

void MapInd::clean_up()
{
field_msgIn.clean_up();
field_gnNextHeader.clean_up();
field_gnHeaderType.clean_up();
field_gnHeaderSubtype.clean_up();
field_gnLifetime.clean_up();
field_gnTrafficClass.clean_up();
field_btpDestinationPort.clean_up();
field_btpInfo.clean_up();
bound_flag = FALSE;
}

MapInd& MapInd::operator=(const MapInd& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsMapSpat_TestSystem.MapInd.");
  bound_flag = TRUE;
  if (other_value.msgIn().is_bound()) field_msgIn = other_value.msgIn();
  else field_msgIn.clean_up();
  if (other_value.gnNextHeader().is_bound()) field_gnNextHeader = other_value.gnNextHeader();
  else field_gnNextHeader.clean_up();
  if (other_value.gnHeaderType().is_bound()) field_gnHeaderType = other_value.gnHeaderType();
  else field_gnHeaderType.clean_up();
  if (other_value.gnHeaderSubtype().is_bound()) field_gnHeaderSubtype = other_value.gnHeaderSubtype();
  else field_gnHeaderSubtype.clean_up();
  if (other_value.gnLifetime().is_bound()) field_gnLifetime = other_value.gnLifetime();
  else field_gnLifetime.clean_up();
  if (other_value.gnTrafficClass().is_bound()) field_gnTrafficClass = other_value.gnTrafficClass();
  else field_gnTrafficClass.clean_up();
  if (other_value.btpDestinationPort().is_bound()) field_btpDestinationPort = other_value.btpDestinationPort();
  else field_btpDestinationPort.clean_up();
  if (other_value.btpInfo().is_bound()) field_btpInfo = other_value.btpInfo();
  else field_btpInfo.clean_up();
}
return *this;
}

boolean MapInd::operator==(const MapInd& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_msgIn==other_value.field_msgIn
  && field_gnNextHeader==other_value.field_gnNextHeader
  && field_gnHeaderType==other_value.field_gnHeaderType
  && field_gnHeaderSubtype==other_value.field_gnHeaderSubtype
  && field_gnLifetime==other_value.field_gnLifetime
  && field_gnTrafficClass==other_value.field_gnTrafficClass
  && field_btpDestinationPort==other_value.field_btpDestinationPort
  && field_btpInfo==other_value.field_btpInfo;
}

boolean MapInd::is_bound() const
{
if (bound_flag) return TRUE;
if(field_msgIn.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_gnNextHeader.get_selection() || field_gnNextHeader.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_gnHeaderType.get_selection() || field_gnHeaderType.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_gnHeaderSubtype.get_selection() || field_gnHeaderSubtype.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_gnLifetime.get_selection() || field_gnLifetime.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_gnTrafficClass.get_selection() || field_gnTrafficClass.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_btpDestinationPort.get_selection() || field_btpDestinationPort.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_btpInfo.get_selection() || field_btpInfo.is_bound()) return TRUE;
return FALSE;
}
boolean MapInd::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_msgIn.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_gnNextHeader.get_selection() && !field_gnNextHeader.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_gnHeaderType.get_selection() && !field_gnHeaderType.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_gnHeaderSubtype.get_selection() && !field_gnHeaderSubtype.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_gnLifetime.get_selection() && !field_gnLifetime.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_gnTrafficClass.get_selection() && !field_gnTrafficClass.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_btpDestinationPort.get_selection() && !field_btpDestinationPort.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_btpInfo.get_selection() && !field_btpInfo.is_value()) return FALSE;
return TRUE;
}
int MapInd::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsMapSpat_TestSystem.MapInd");
  int ret_val = 1;
  if (field_gnNextHeader.ispresent()) ret_val++;
  if (field_gnHeaderType.ispresent()) ret_val++;
  if (field_gnHeaderSubtype.ispresent()) ret_val++;
  if (field_gnLifetime.ispresent()) ret_val++;
  if (field_gnTrafficClass.ispresent()) ret_val++;
  if (field_btpDestinationPort.ispresent()) ret_val++;
  if (field_btpInfo.ispresent()) ret_val++;
  return ret_val;
}

void MapInd::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ msgIn := ");
field_msgIn.log();
TTCN_Logger::log_event_str(", gnNextHeader := ");
field_gnNextHeader.log();
TTCN_Logger::log_event_str(", gnHeaderType := ");
field_gnHeaderType.log();
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
field_gnHeaderSubtype.log();
TTCN_Logger::log_event_str(", gnLifetime := ");
field_gnLifetime.log();
TTCN_Logger::log_event_str(", gnTrafficClass := ");
field_gnTrafficClass.log();
TTCN_Logger::log_event_str(", btpDestinationPort := ");
field_btpDestinationPort.log();
TTCN_Logger::log_event_str(", btpInfo := ");
field_btpInfo.log();
TTCN_Logger::log_event_str(" }");
}

void MapInd::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsMapSpat_TestSystem.MapInd'");
    }
    if (strcmp("msgIn", param_field) == 0) {
      msgIn().set_param(param);
      return;
    } else if (strcmp("gnNextHeader", param_field) == 0) {
      gnNextHeader().set_param(param);
      return;
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      gnHeaderType().set_param(param);
      return;
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      gnHeaderSubtype().set_param(param);
      return;
    } else if (strcmp("gnLifetime", param_field) == 0) {
      gnLifetime().set_param(param);
      return;
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      gnTrafficClass().set_param(param);
      return;
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      btpDestinationPort().set_param(param);
      return;
    } else if (strcmp("btpInfo", param_field) == 0) {
      btpInfo().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.MapInd'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (8<mp->get_size()) {
      param.error("record value of type @LibItsMapSpat_TestSystem.MapInd has 8 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgIn().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) gnNextHeader().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) gnHeaderType().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) gnHeaderSubtype().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) gnLifetime().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) gnTrafficClass().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) btpDestinationPort().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) btpInfo().set_param(*mp->get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgIn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgIn().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnNextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnNextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderSubtype")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderSubtype().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnTrafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnTrafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpDestinationPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpDestinationPort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpInfo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpInfo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsMapSpat_TestSystem.MapInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsMapSpat_TestSystem.MapInd");
  }
}

Module_Param* MapInd::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsMapSpat_TestSystem.MapInd'");
    }
    if (strcmp("msgIn", param_field) == 0) {
      return msgIn().get_param(param_name);
    } else if (strcmp("gnNextHeader", param_field) == 0) {
      return gnNextHeader().get_param(param_name);
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      return gnHeaderType().get_param(param_name);
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      return gnHeaderSubtype().get_param(param_name);
    } else if (strcmp("gnLifetime", param_field) == 0) {
      return gnLifetime().get_param(param_name);
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      return gnTrafficClass().get_param(param_name);
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      return btpDestinationPort().get_param(param_name);
    } else if (strcmp("btpInfo", param_field) == 0) {
      return btpInfo().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.MapInd'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_msgIn = field_msgIn.get_param(param_name);
  mp_field_msgIn->set_id(new Module_Param_FieldName(mcopystr("msgIn")));
  mp->add_elem(mp_field_msgIn);
  Module_Param* mp_field_gnNextHeader = field_gnNextHeader.get_param(param_name);
  mp_field_gnNextHeader->set_id(new Module_Param_FieldName(mcopystr("gnNextHeader")));
  mp->add_elem(mp_field_gnNextHeader);
  Module_Param* mp_field_gnHeaderType = field_gnHeaderType.get_param(param_name);
  mp_field_gnHeaderType->set_id(new Module_Param_FieldName(mcopystr("gnHeaderType")));
  mp->add_elem(mp_field_gnHeaderType);
  Module_Param* mp_field_gnHeaderSubtype = field_gnHeaderSubtype.get_param(param_name);
  mp_field_gnHeaderSubtype->set_id(new Module_Param_FieldName(mcopystr("gnHeaderSubtype")));
  mp->add_elem(mp_field_gnHeaderSubtype);
  Module_Param* mp_field_gnLifetime = field_gnLifetime.get_param(param_name);
  mp_field_gnLifetime->set_id(new Module_Param_FieldName(mcopystr("gnLifetime")));
  mp->add_elem(mp_field_gnLifetime);
  Module_Param* mp_field_gnTrafficClass = field_gnTrafficClass.get_param(param_name);
  mp_field_gnTrafficClass->set_id(new Module_Param_FieldName(mcopystr("gnTrafficClass")));
  mp->add_elem(mp_field_gnTrafficClass);
  Module_Param* mp_field_btpDestinationPort = field_btpDestinationPort.get_param(param_name);
  mp_field_btpDestinationPort->set_id(new Module_Param_FieldName(mcopystr("btpDestinationPort")));
  mp->add_elem(mp_field_btpDestinationPort);
  Module_Param* mp_field_btpInfo = field_btpInfo.get_param(param_name);
  mp_field_btpInfo->set_id(new Module_Param_FieldName(mcopystr("btpInfo")));
  mp->add_elem(mp_field_btpInfo);
  return mp;
  }

void MapInd::set_implicit_omit()
{
if (msgIn().is_bound()) msgIn().set_implicit_omit();
if (!gnNextHeader().is_bound()) gnNextHeader() = OMIT_VALUE;
else gnNextHeader().set_implicit_omit();
if (!gnHeaderType().is_bound()) gnHeaderType() = OMIT_VALUE;
else gnHeaderType().set_implicit_omit();
if (!gnHeaderSubtype().is_bound()) gnHeaderSubtype() = OMIT_VALUE;
else gnHeaderSubtype().set_implicit_omit();
if (!gnLifetime().is_bound()) gnLifetime() = OMIT_VALUE;
else gnLifetime().set_implicit_omit();
if (!gnTrafficClass().is_bound()) gnTrafficClass() = OMIT_VALUE;
else gnTrafficClass().set_implicit_omit();
if (!btpDestinationPort().is_bound()) btpDestinationPort() = OMIT_VALUE;
else btpDestinationPort().set_implicit_omit();
if (!btpInfo().is_bound()) btpInfo() = OMIT_VALUE;
else btpInfo().set_implicit_omit();
}

void MapInd::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsMapSpat_TestSystem.MapInd.");
field_msgIn.encode_text(text_buf);
field_gnNextHeader.encode_text(text_buf);
field_gnHeaderType.encode_text(text_buf);
field_gnHeaderSubtype.encode_text(text_buf);
field_gnLifetime.encode_text(text_buf);
field_gnTrafficClass.encode_text(text_buf);
field_btpDestinationPort.encode_text(text_buf);
field_btpInfo.encode_text(text_buf);
}

void MapInd::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_msgIn.decode_text(text_buf);
field_gnNextHeader.decode_text(text_buf);
field_gnHeaderType.decode_text(text_buf);
field_gnHeaderSubtype.decode_text(text_buf);
field_gnLifetime.decode_text(text_buf);
field_gnTrafficClass.decode_text(text_buf);
field_btpDestinationPort.decode_text(text_buf);
field_btpInfo.decode_text(text_buf);
}

struct MapInd_template::single_value_struct {
MapMsg_template field_msgIn;
INTEGER_template field_gnNextHeader;
INTEGER_template field_gnHeaderType;
INTEGER_template field_gnHeaderSubtype;
INTEGER_template field_gnLifetime;
INTEGER_template field_gnTrafficClass;
INTEGER_template field_btpDestinationPort;
INTEGER_template field_btpInfo;
};

void MapInd_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_msgIn = ANY_VALUE;
single_value->field_gnNextHeader = ANY_OR_OMIT;
single_value->field_gnHeaderType = ANY_OR_OMIT;
single_value->field_gnHeaderSubtype = ANY_OR_OMIT;
single_value->field_gnLifetime = ANY_OR_OMIT;
single_value->field_gnTrafficClass = ANY_OR_OMIT;
single_value->field_btpDestinationPort = ANY_OR_OMIT;
single_value->field_btpInfo = ANY_OR_OMIT;
}
}
}

void MapInd_template::copy_value(const MapInd& other_value)
{
single_value = new single_value_struct;
if (other_value.msgIn().is_bound()) {
  single_value->field_msgIn = other_value.msgIn();
} else {
  single_value->field_msgIn.clean_up();
}
if (other_value.gnNextHeader().is_bound()) {
  if (other_value.gnNextHeader().ispresent()) single_value->field_gnNextHeader = other_value.gnNextHeader()();
  else single_value->field_gnNextHeader = OMIT_VALUE;
} else {
  single_value->field_gnNextHeader.clean_up();
}
if (other_value.gnHeaderType().is_bound()) {
  if (other_value.gnHeaderType().ispresent()) single_value->field_gnHeaderType = other_value.gnHeaderType()();
  else single_value->field_gnHeaderType = OMIT_VALUE;
} else {
  single_value->field_gnHeaderType.clean_up();
}
if (other_value.gnHeaderSubtype().is_bound()) {
  if (other_value.gnHeaderSubtype().ispresent()) single_value->field_gnHeaderSubtype = other_value.gnHeaderSubtype()();
  else single_value->field_gnHeaderSubtype = OMIT_VALUE;
} else {
  single_value->field_gnHeaderSubtype.clean_up();
}
if (other_value.gnLifetime().is_bound()) {
  if (other_value.gnLifetime().ispresent()) single_value->field_gnLifetime = other_value.gnLifetime()();
  else single_value->field_gnLifetime = OMIT_VALUE;
} else {
  single_value->field_gnLifetime.clean_up();
}
if (other_value.gnTrafficClass().is_bound()) {
  if (other_value.gnTrafficClass().ispresent()) single_value->field_gnTrafficClass = other_value.gnTrafficClass()();
  else single_value->field_gnTrafficClass = OMIT_VALUE;
} else {
  single_value->field_gnTrafficClass.clean_up();
}
if (other_value.btpDestinationPort().is_bound()) {
  if (other_value.btpDestinationPort().ispresent()) single_value->field_btpDestinationPort = other_value.btpDestinationPort()();
  else single_value->field_btpDestinationPort = OMIT_VALUE;
} else {
  single_value->field_btpDestinationPort.clean_up();
}
if (other_value.btpInfo().is_bound()) {
  if (other_value.btpInfo().ispresent()) single_value->field_btpInfo = other_value.btpInfo()();
  else single_value->field_btpInfo = OMIT_VALUE;
} else {
  single_value->field_btpInfo.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MapInd_template::copy_template(const MapInd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.msgIn().get_selection()) {
single_value->field_msgIn = other_value.msgIn();
} else {
single_value->field_msgIn.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnNextHeader().get_selection()) {
single_value->field_gnNextHeader = other_value.gnNextHeader();
} else {
single_value->field_gnNextHeader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnHeaderType().get_selection()) {
single_value->field_gnHeaderType = other_value.gnHeaderType();
} else {
single_value->field_gnHeaderType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnHeaderSubtype().get_selection()) {
single_value->field_gnHeaderSubtype = other_value.gnHeaderSubtype();
} else {
single_value->field_gnHeaderSubtype.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnLifetime().get_selection()) {
single_value->field_gnLifetime = other_value.gnLifetime();
} else {
single_value->field_gnLifetime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnTrafficClass().get_selection()) {
single_value->field_gnTrafficClass = other_value.gnTrafficClass();
} else {
single_value->field_gnTrafficClass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.btpDestinationPort().get_selection()) {
single_value->field_btpDestinationPort = other_value.btpDestinationPort();
} else {
single_value->field_btpDestinationPort.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.btpInfo().get_selection()) {
single_value->field_btpInfo = other_value.btpInfo();
} else {
single_value->field_btpInfo.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MapInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.MapInd.");
break;
}
set_selection(other_value);
}

MapInd_template::MapInd_template()
{
}

MapInd_template::MapInd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MapInd_template::MapInd_template(const MapInd& other_value)
{
copy_value(other_value);
}

MapInd_template::MapInd_template(const OPTIONAL<MapInd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MapInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsMapSpat_TestSystem.MapInd from an unbound optional field.");
}
}

MapInd_template::MapInd_template(const MapInd_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MapInd_template::~MapInd_template()
{
clean_up();
}

MapInd_template& MapInd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MapInd_template& MapInd_template::operator=(const MapInd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MapInd_template& MapInd_template::operator=(const OPTIONAL<MapInd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MapInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsMapSpat_TestSystem.MapInd.");
}
return *this;
}

MapInd_template& MapInd_template::operator=(const MapInd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MapInd_template::match(const MapInd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.msgIn().is_bound()) return FALSE;
if(!single_value->field_msgIn.match(other_value.msgIn(), legacy))return FALSE;
if(!other_value.gnNextHeader().is_bound()) return FALSE;
if((other_value.gnNextHeader().ispresent() ? !single_value->field_gnNextHeader.match((const INTEGER&)other_value.gnNextHeader(), legacy) : !single_value->field_gnNextHeader.match_omit(legacy)))return FALSE;
if(!other_value.gnHeaderType().is_bound()) return FALSE;
if((other_value.gnHeaderType().ispresent() ? !single_value->field_gnHeaderType.match((const INTEGER&)other_value.gnHeaderType(), legacy) : !single_value->field_gnHeaderType.match_omit(legacy)))return FALSE;
if(!other_value.gnHeaderSubtype().is_bound()) return FALSE;
if((other_value.gnHeaderSubtype().ispresent() ? !single_value->field_gnHeaderSubtype.match((const INTEGER&)other_value.gnHeaderSubtype(), legacy) : !single_value->field_gnHeaderSubtype.match_omit(legacy)))return FALSE;
if(!other_value.gnLifetime().is_bound()) return FALSE;
if((other_value.gnLifetime().ispresent() ? !single_value->field_gnLifetime.match((const INTEGER&)other_value.gnLifetime(), legacy) : !single_value->field_gnLifetime.match_omit(legacy)))return FALSE;
if(!other_value.gnTrafficClass().is_bound()) return FALSE;
if((other_value.gnTrafficClass().ispresent() ? !single_value->field_gnTrafficClass.match((const INTEGER&)other_value.gnTrafficClass(), legacy) : !single_value->field_gnTrafficClass.match_omit(legacy)))return FALSE;
if(!other_value.btpDestinationPort().is_bound()) return FALSE;
if((other_value.btpDestinationPort().ispresent() ? !single_value->field_btpDestinationPort.match((const INTEGER&)other_value.btpDestinationPort(), legacy) : !single_value->field_btpDestinationPort.match_omit(legacy)))return FALSE;
if(!other_value.btpInfo().is_bound()) return FALSE;
if((other_value.btpInfo().ispresent() ? !single_value->field_btpInfo.match((const INTEGER&)other_value.btpInfo(), legacy) : !single_value->field_btpInfo.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.MapInd.");
}
return FALSE;
}

boolean MapInd_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_msgIn.is_bound()) return TRUE;
if (single_value->field_gnNextHeader.is_omit() || single_value->field_gnNextHeader.is_bound()) return TRUE;
if (single_value->field_gnHeaderType.is_omit() || single_value->field_gnHeaderType.is_bound()) return TRUE;
if (single_value->field_gnHeaderSubtype.is_omit() || single_value->field_gnHeaderSubtype.is_bound()) return TRUE;
if (single_value->field_gnLifetime.is_omit() || single_value->field_gnLifetime.is_bound()) return TRUE;
if (single_value->field_gnTrafficClass.is_omit() || single_value->field_gnTrafficClass.is_bound()) return TRUE;
if (single_value->field_btpDestinationPort.is_omit() || single_value->field_btpDestinationPort.is_bound()) return TRUE;
if (single_value->field_btpInfo.is_omit() || single_value->field_btpInfo.is_bound()) return TRUE;
return FALSE;
}

boolean MapInd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_msgIn.is_value()) return FALSE;
if (!single_value->field_gnNextHeader.is_omit() && !single_value->field_gnNextHeader.is_value()) return FALSE;
if (!single_value->field_gnHeaderType.is_omit() && !single_value->field_gnHeaderType.is_value()) return FALSE;
if (!single_value->field_gnHeaderSubtype.is_omit() && !single_value->field_gnHeaderSubtype.is_value()) return FALSE;
if (!single_value->field_gnLifetime.is_omit() && !single_value->field_gnLifetime.is_value()) return FALSE;
if (!single_value->field_gnTrafficClass.is_omit() && !single_value->field_gnTrafficClass.is_value()) return FALSE;
if (!single_value->field_btpDestinationPort.is_omit() && !single_value->field_btpDestinationPort.is_value()) return FALSE;
if (!single_value->field_btpInfo.is_omit() && !single_value->field_btpInfo.is_value()) return FALSE;
return TRUE;
}

void MapInd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MapInd MapInd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsMapSpat_TestSystem.MapInd.");
MapInd ret_val;
if (single_value->field_msgIn.is_bound()) {
ret_val.msgIn() = single_value->field_msgIn.valueof();
}
if (single_value->field_gnNextHeader.is_omit()) ret_val.gnNextHeader() = OMIT_VALUE;
else if (single_value->field_gnNextHeader.is_bound()) {
ret_val.gnNextHeader() = single_value->field_gnNextHeader.valueof();
}
if (single_value->field_gnHeaderType.is_omit()) ret_val.gnHeaderType() = OMIT_VALUE;
else if (single_value->field_gnHeaderType.is_bound()) {
ret_val.gnHeaderType() = single_value->field_gnHeaderType.valueof();
}
if (single_value->field_gnHeaderSubtype.is_omit()) ret_val.gnHeaderSubtype() = OMIT_VALUE;
else if (single_value->field_gnHeaderSubtype.is_bound()) {
ret_val.gnHeaderSubtype() = single_value->field_gnHeaderSubtype.valueof();
}
if (single_value->field_gnLifetime.is_omit()) ret_val.gnLifetime() = OMIT_VALUE;
else if (single_value->field_gnLifetime.is_bound()) {
ret_val.gnLifetime() = single_value->field_gnLifetime.valueof();
}
if (single_value->field_gnTrafficClass.is_omit()) ret_val.gnTrafficClass() = OMIT_VALUE;
else if (single_value->field_gnTrafficClass.is_bound()) {
ret_val.gnTrafficClass() = single_value->field_gnTrafficClass.valueof();
}
if (single_value->field_btpDestinationPort.is_omit()) ret_val.btpDestinationPort() = OMIT_VALUE;
else if (single_value->field_btpDestinationPort.is_bound()) {
ret_val.btpDestinationPort() = single_value->field_btpDestinationPort.valueof();
}
if (single_value->field_btpInfo.is_omit()) ret_val.btpInfo() = OMIT_VALUE;
else if (single_value->field_btpInfo.is_bound()) {
ret_val.btpInfo() = single_value->field_btpInfo.valueof();
}
return ret_val;
}

void MapInd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsMapSpat_TestSystem.MapInd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MapInd_template[list_length];
}

MapInd_template& MapInd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsMapSpat_TestSystem.MapInd.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsMapSpat_TestSystem.MapInd.");
return value_list.list_value[list_index];
}

MapMsg_template& MapInd_template::msgIn()
{
set_specific();
return single_value->field_msgIn;
}

const MapMsg_template& MapInd_template::msgIn() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msgIn of a non-specific template of type @LibItsMapSpat_TestSystem.MapInd.");
return single_value->field_msgIn;
}

INTEGER_template& MapInd_template::gnNextHeader()
{
set_specific();
return single_value->field_gnNextHeader;
}

const INTEGER_template& MapInd_template::gnNextHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnNextHeader of a non-specific template of type @LibItsMapSpat_TestSystem.MapInd.");
return single_value->field_gnNextHeader;
}

INTEGER_template& MapInd_template::gnHeaderType()
{
set_specific();
return single_value->field_gnHeaderType;
}

const INTEGER_template& MapInd_template::gnHeaderType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnHeaderType of a non-specific template of type @LibItsMapSpat_TestSystem.MapInd.");
return single_value->field_gnHeaderType;
}

INTEGER_template& MapInd_template::gnHeaderSubtype()
{
set_specific();
return single_value->field_gnHeaderSubtype;
}

const INTEGER_template& MapInd_template::gnHeaderSubtype() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnHeaderSubtype of a non-specific template of type @LibItsMapSpat_TestSystem.MapInd.");
return single_value->field_gnHeaderSubtype;
}

INTEGER_template& MapInd_template::gnLifetime()
{
set_specific();
return single_value->field_gnLifetime;
}

const INTEGER_template& MapInd_template::gnLifetime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnLifetime of a non-specific template of type @LibItsMapSpat_TestSystem.MapInd.");
return single_value->field_gnLifetime;
}

INTEGER_template& MapInd_template::gnTrafficClass()
{
set_specific();
return single_value->field_gnTrafficClass;
}

const INTEGER_template& MapInd_template::gnTrafficClass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnTrafficClass of a non-specific template of type @LibItsMapSpat_TestSystem.MapInd.");
return single_value->field_gnTrafficClass;
}

INTEGER_template& MapInd_template::btpDestinationPort()
{
set_specific();
return single_value->field_btpDestinationPort;
}

const INTEGER_template& MapInd_template::btpDestinationPort() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field btpDestinationPort of a non-specific template of type @LibItsMapSpat_TestSystem.MapInd.");
return single_value->field_btpDestinationPort;
}

INTEGER_template& MapInd_template::btpInfo()
{
set_specific();
return single_value->field_btpInfo;
}

const INTEGER_template& MapInd_template::btpInfo() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field btpInfo of a non-specific template of type @LibItsMapSpat_TestSystem.MapInd.");
return single_value->field_btpInfo;
}

int MapInd_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapInd which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_gnNextHeader.is_present()) ret_val++;
      if (single_value->field_gnHeaderType.is_present()) ret_val++;
      if (single_value->field_gnHeaderSubtype.is_present()) ret_val++;
      if (single_value->field_gnLifetime.is_present()) ret_val++;
      if (single_value->field_gnTrafficClass.is_present()) ret_val++;
      if (single_value->field_btpDestinationPort.is_present()) ret_val++;
      if (single_value->field_btpInfo.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapInd containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapInd containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapInd containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapInd containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapInd containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.MapInd.");
  }
  return 0;
}

void MapInd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ msgIn := ");
single_value->field_msgIn.log();
TTCN_Logger::log_event_str(", gnNextHeader := ");
single_value->field_gnNextHeader.log();
TTCN_Logger::log_event_str(", gnHeaderType := ");
single_value->field_gnHeaderType.log();
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
single_value->field_gnHeaderSubtype.log();
TTCN_Logger::log_event_str(", gnLifetime := ");
single_value->field_gnLifetime.log();
TTCN_Logger::log_event_str(", gnTrafficClass := ");
single_value->field_gnTrafficClass.log();
TTCN_Logger::log_event_str(", btpDestinationPort := ");
single_value->field_btpDestinationPort.log();
TTCN_Logger::log_event_str(", btpInfo := ");
single_value->field_btpInfo.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MapInd_template::log_match(const MapInd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_msgIn.match(match_value.msgIn(), legacy)){
TTCN_Logger::log_logmatch_info(".msgIn");
single_value->field_msgIn.log_match(match_value.msgIn(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.gnNextHeader().ispresent()){
if(!single_value->field_gnNextHeader.match(match_value.gnNextHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".gnNextHeader");
single_value->field_gnNextHeader.log_match(match_value.gnNextHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_gnNextHeader.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".gnNextHeader := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_gnNextHeader.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.gnHeaderType().ispresent()){
if(!single_value->field_gnHeaderType.match(match_value.gnHeaderType(), legacy)){
TTCN_Logger::log_logmatch_info(".gnHeaderType");
single_value->field_gnHeaderType.log_match(match_value.gnHeaderType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_gnHeaderType.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".gnHeaderType := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_gnHeaderType.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.gnHeaderSubtype().ispresent()){
if(!single_value->field_gnHeaderSubtype.match(match_value.gnHeaderSubtype(), legacy)){
TTCN_Logger::log_logmatch_info(".gnHeaderSubtype");
single_value->field_gnHeaderSubtype.log_match(match_value.gnHeaderSubtype(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_gnHeaderSubtype.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".gnHeaderSubtype := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_gnHeaderSubtype.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.gnLifetime().ispresent()){
if(!single_value->field_gnLifetime.match(match_value.gnLifetime(), legacy)){
TTCN_Logger::log_logmatch_info(".gnLifetime");
single_value->field_gnLifetime.log_match(match_value.gnLifetime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_gnLifetime.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".gnLifetime := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_gnLifetime.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.gnTrafficClass().ispresent()){
if(!single_value->field_gnTrafficClass.match(match_value.gnTrafficClass(), legacy)){
TTCN_Logger::log_logmatch_info(".gnTrafficClass");
single_value->field_gnTrafficClass.log_match(match_value.gnTrafficClass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_gnTrafficClass.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".gnTrafficClass := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_gnTrafficClass.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.btpDestinationPort().ispresent()){
if(!single_value->field_btpDestinationPort.match(match_value.btpDestinationPort(), legacy)){
TTCN_Logger::log_logmatch_info(".btpDestinationPort");
single_value->field_btpDestinationPort.log_match(match_value.btpDestinationPort(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_btpDestinationPort.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".btpDestinationPort := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_btpDestinationPort.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.btpInfo().ispresent()){
if(!single_value->field_btpInfo.match(match_value.btpInfo(), legacy)){
TTCN_Logger::log_logmatch_info(".btpInfo");
single_value->field_btpInfo.log_match(match_value.btpInfo(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_btpInfo.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".btpInfo := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_btpInfo.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ msgIn := ");
single_value->field_msgIn.log_match(match_value.msgIn(), legacy);
TTCN_Logger::log_event_str(", gnNextHeader := ");
if (match_value.gnNextHeader().ispresent()) single_value->field_gnNextHeader.log_match(match_value.gnNextHeader(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_gnNextHeader.log();
if (single_value->field_gnNextHeader.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", gnHeaderType := ");
if (match_value.gnHeaderType().ispresent()) single_value->field_gnHeaderType.log_match(match_value.gnHeaderType(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_gnHeaderType.log();
if (single_value->field_gnHeaderType.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
if (match_value.gnHeaderSubtype().ispresent()) single_value->field_gnHeaderSubtype.log_match(match_value.gnHeaderSubtype(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_gnHeaderSubtype.log();
if (single_value->field_gnHeaderSubtype.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", gnLifetime := ");
if (match_value.gnLifetime().ispresent()) single_value->field_gnLifetime.log_match(match_value.gnLifetime(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_gnLifetime.log();
if (single_value->field_gnLifetime.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", gnTrafficClass := ");
if (match_value.gnTrafficClass().ispresent()) single_value->field_gnTrafficClass.log_match(match_value.gnTrafficClass(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_gnTrafficClass.log();
if (single_value->field_gnTrafficClass.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", btpDestinationPort := ");
if (match_value.btpDestinationPort().ispresent()) single_value->field_btpDestinationPort.log_match(match_value.btpDestinationPort(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_btpDestinationPort.log();
if (single_value->field_btpDestinationPort.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", btpInfo := ");
if (match_value.btpInfo().ispresent()) single_value->field_btpInfo.log_match(match_value.btpInfo(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_btpInfo.log();
if (single_value->field_btpInfo.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MapInd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_msgIn.encode_text(text_buf);
single_value->field_gnNextHeader.encode_text(text_buf);
single_value->field_gnHeaderType.encode_text(text_buf);
single_value->field_gnHeaderSubtype.encode_text(text_buf);
single_value->field_gnLifetime.encode_text(text_buf);
single_value->field_gnTrafficClass.encode_text(text_buf);
single_value->field_btpDestinationPort.encode_text(text_buf);
single_value->field_btpInfo.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.MapInd.");
}
}

void MapInd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_msgIn.decode_text(text_buf);
single_value->field_gnNextHeader.decode_text(text_buf);
single_value->field_gnHeaderType.decode_text(text_buf);
single_value->field_gnHeaderSubtype.decode_text(text_buf);
single_value->field_gnLifetime.decode_text(text_buf);
single_value->field_gnTrafficClass.decode_text(text_buf);
single_value->field_btpDestinationPort.decode_text(text_buf);
single_value->field_btpInfo.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MapInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsMapSpat_TestSystem.MapInd.");
}
}

void MapInd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsMapSpat_TestSystem.MapInd'");
    }
    if (strcmp("msgIn", param_field) == 0) {
      msgIn().set_param(param);
      return;
    } else if (strcmp("gnNextHeader", param_field) == 0) {
      gnNextHeader().set_param(param);
      return;
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      gnHeaderType().set_param(param);
      return;
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      gnHeaderSubtype().set_param(param);
      return;
    } else if (strcmp("gnLifetime", param_field) == 0) {
      gnLifetime().set_param(param);
      return;
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      gnTrafficClass().set_param(param);
      return;
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      btpDestinationPort().set_param(param);
      return;
    } else if (strcmp("btpInfo", param_field) == 0) {
      btpInfo().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsMapSpat_TestSystem.MapInd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MapInd_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (8<mp->get_size()) {
      param.error("record template of type @LibItsMapSpat_TestSystem.MapInd has 8 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgIn().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) gnNextHeader().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) gnHeaderType().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) gnHeaderSubtype().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) gnLifetime().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) gnTrafficClass().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) btpDestinationPort().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) btpInfo().set_param(*mp->get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgIn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgIn().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnNextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnNextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderSubtype")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderSubtype().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnTrafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnTrafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpDestinationPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpDestinationPort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpInfo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpInfo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsMapSpat_TestSystem.MapInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsMapSpat_TestSystem.MapInd");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* MapInd_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsMapSpat_TestSystem.MapInd'");
    }
    if (strcmp("msgIn", param_field) == 0) {
      return msgIn().get_param(param_name);
    } else if (strcmp("gnNextHeader", param_field) == 0) {
      return gnNextHeader().get_param(param_name);
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      return gnHeaderType().get_param(param_name);
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      return gnHeaderSubtype().get_param(param_name);
    } else if (strcmp("gnLifetime", param_field) == 0) {
      return gnLifetime().get_param(param_name);
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      return gnTrafficClass().get_param(param_name);
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      return btpDestinationPort().get_param(param_name);
    } else if (strcmp("btpInfo", param_field) == 0) {
      return btpInfo().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.MapInd'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_msgIn = single_value->field_msgIn.get_param(param_name);
    mp_field_msgIn->set_id(new Module_Param_FieldName(mcopystr("msgIn")));
    mp->add_elem(mp_field_msgIn);
    Module_Param* mp_field_gnNextHeader = single_value->field_gnNextHeader.get_param(param_name);
    mp_field_gnNextHeader->set_id(new Module_Param_FieldName(mcopystr("gnNextHeader")));
    mp->add_elem(mp_field_gnNextHeader);
    Module_Param* mp_field_gnHeaderType = single_value->field_gnHeaderType.get_param(param_name);
    mp_field_gnHeaderType->set_id(new Module_Param_FieldName(mcopystr("gnHeaderType")));
    mp->add_elem(mp_field_gnHeaderType);
    Module_Param* mp_field_gnHeaderSubtype = single_value->field_gnHeaderSubtype.get_param(param_name);
    mp_field_gnHeaderSubtype->set_id(new Module_Param_FieldName(mcopystr("gnHeaderSubtype")));
    mp->add_elem(mp_field_gnHeaderSubtype);
    Module_Param* mp_field_gnLifetime = single_value->field_gnLifetime.get_param(param_name);
    mp_field_gnLifetime->set_id(new Module_Param_FieldName(mcopystr("gnLifetime")));
    mp->add_elem(mp_field_gnLifetime);
    Module_Param* mp_field_gnTrafficClass = single_value->field_gnTrafficClass.get_param(param_name);
    mp_field_gnTrafficClass->set_id(new Module_Param_FieldName(mcopystr("gnTrafficClass")));
    mp->add_elem(mp_field_gnTrafficClass);
    Module_Param* mp_field_btpDestinationPort = single_value->field_btpDestinationPort.get_param(param_name);
    mp_field_btpDestinationPort->set_id(new Module_Param_FieldName(mcopystr("btpDestinationPort")));
    mp->add_elem(mp_field_btpDestinationPort);
    Module_Param* mp_field_btpInfo = single_value->field_btpInfo.get_param(param_name);
    mp_field_btpInfo->set_id(new Module_Param_FieldName(mcopystr("btpInfo")));
    mp->add_elem(mp_field_btpInfo);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void MapInd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_msgIn.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.MapInd");
single_value->field_gnNextHeader.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.MapInd");
single_value->field_gnHeaderType.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.MapInd");
single_value->field_gnHeaderSubtype.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.MapInd");
single_value->field_gnLifetime.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.MapInd");
single_value->field_gnTrafficClass.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.MapInd");
single_value->field_btpDestinationPort.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.MapInd");
single_value->field_btpInfo.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.MapInd");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsMapSpat_TestSystem.MapInd");
}

boolean MapInd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MapInd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SpatMsg::SpatMsg()
{
  bound_flag = FALSE;
}

SpatMsg::SpatMsg(const MAP__SPAT__ETSI::SPAT__PDU& par_msgSpat,
    const OCTETSTRING& par_rawData)
  :   field_msgSpat(par_msgSpat),
  field_rawData(par_rawData)
{
  bound_flag = TRUE;
}

SpatMsg::SpatMsg(const SpatMsg& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsMapSpat_TestSystem.SpatMsg.");
bound_flag = TRUE;
if (other_value.msgSpat().is_bound()) field_msgSpat = other_value.msgSpat();
else field_msgSpat.clean_up();
if (other_value.rawData().is_bound()) field_rawData = other_value.rawData();
else field_rawData.clean_up();
}

void SpatMsg::clean_up()
{
field_msgSpat.clean_up();
field_rawData.clean_up();
bound_flag = FALSE;
}

SpatMsg& SpatMsg::operator=(const SpatMsg& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsMapSpat_TestSystem.SpatMsg.");
  bound_flag = TRUE;
  if (other_value.msgSpat().is_bound()) field_msgSpat = other_value.msgSpat();
  else field_msgSpat.clean_up();
  if (other_value.rawData().is_bound()) field_rawData = other_value.rawData();
  else field_rawData.clean_up();
}
return *this;
}

boolean SpatMsg::operator==(const SpatMsg& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_msgSpat==other_value.field_msgSpat
  && field_rawData==other_value.field_rawData;
}

boolean SpatMsg::is_bound() const
{
if (bound_flag) return TRUE;
if(field_msgSpat.is_bound()) return TRUE;
if(field_rawData.is_bound()) return TRUE;
return FALSE;
}
boolean SpatMsg::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_msgSpat.is_value()) return FALSE;
if(!field_rawData.is_value()) return FALSE;
return TRUE;
}
int SpatMsg::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsMapSpat_TestSystem.SpatMsg");
  return 2;
}

void SpatMsg::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ msgSpat := ");
field_msgSpat.log();
TTCN_Logger::log_event_str(", rawData := ");
field_rawData.log();
TTCN_Logger::log_event_str(" }");
}

void SpatMsg::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsMapSpat_TestSystem.SpatMsg'");
    }
    if (strcmp("msgSpat", param_field) == 0) {
      msgSpat().set_param(param);
      return;
    } else if (strcmp("rawData", param_field) == 0) {
      rawData().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.SpatMsg'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsMapSpat_TestSystem.SpatMsg has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgSpat().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) rawData().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgSpat")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgSpat().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawData")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawData().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsMapSpat_TestSystem.SpatMsg: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsMapSpat_TestSystem.SpatMsg");
  }
}

Module_Param* SpatMsg::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsMapSpat_TestSystem.SpatMsg'");
    }
    if (strcmp("msgSpat", param_field) == 0) {
      return msgSpat().get_param(param_name);
    } else if (strcmp("rawData", param_field) == 0) {
      return rawData().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.SpatMsg'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_msgSpat = field_msgSpat.get_param(param_name);
  mp_field_msgSpat->set_id(new Module_Param_FieldName(mcopystr("msgSpat")));
  mp->add_elem(mp_field_msgSpat);
  Module_Param* mp_field_rawData = field_rawData.get_param(param_name);
  mp_field_rawData->set_id(new Module_Param_FieldName(mcopystr("rawData")));
  mp->add_elem(mp_field_rawData);
  return mp;
  }

void SpatMsg::set_implicit_omit()
{
if (msgSpat().is_bound()) msgSpat().set_implicit_omit();
if (rawData().is_bound()) rawData().set_implicit_omit();
}

void SpatMsg::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsMapSpat_TestSystem.SpatMsg.");
field_msgSpat.encode_text(text_buf);
field_rawData.encode_text(text_buf);
}

void SpatMsg::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_msgSpat.decode_text(text_buf);
field_rawData.decode_text(text_buf);
}

struct SpatMsg_template::single_value_struct {
MAP__SPAT__ETSI::SPAT__PDU_template field_msgSpat;
OCTETSTRING_template field_rawData;
};

void SpatMsg_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_msgSpat = ANY_VALUE;
single_value->field_rawData = ANY_VALUE;
}
}
}

void SpatMsg_template::copy_value(const SpatMsg& other_value)
{
single_value = new single_value_struct;
if (other_value.msgSpat().is_bound()) {
  single_value->field_msgSpat = other_value.msgSpat();
} else {
  single_value->field_msgSpat.clean_up();
}
if (other_value.rawData().is_bound()) {
  single_value->field_rawData = other_value.rawData();
} else {
  single_value->field_rawData.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SpatMsg_template::copy_template(const SpatMsg_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.msgSpat().get_selection()) {
single_value->field_msgSpat = other_value.msgSpat();
} else {
single_value->field_msgSpat.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rawData().get_selection()) {
single_value->field_rawData = other_value.rawData();
} else {
single_value->field_rawData.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SpatMsg_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.SpatMsg.");
break;
}
set_selection(other_value);
}

SpatMsg_template::SpatMsg_template()
{
}

SpatMsg_template::SpatMsg_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SpatMsg_template::SpatMsg_template(const SpatMsg& other_value)
{
copy_value(other_value);
}

SpatMsg_template::SpatMsg_template(const OPTIONAL<SpatMsg>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SpatMsg&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsMapSpat_TestSystem.SpatMsg from an unbound optional field.");
}
}

SpatMsg_template::SpatMsg_template(const SpatMsg_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SpatMsg_template::~SpatMsg_template()
{
clean_up();
}

SpatMsg_template& SpatMsg_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SpatMsg_template& SpatMsg_template::operator=(const SpatMsg& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SpatMsg_template& SpatMsg_template::operator=(const OPTIONAL<SpatMsg>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SpatMsg&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsMapSpat_TestSystem.SpatMsg.");
}
return *this;
}

SpatMsg_template& SpatMsg_template::operator=(const SpatMsg_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SpatMsg_template::match(const SpatMsg& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.msgSpat().is_bound()) return FALSE;
if(!single_value->field_msgSpat.match(other_value.msgSpat(), legacy))return FALSE;
if(!other_value.rawData().is_bound()) return FALSE;
if(!single_value->field_rawData.match(other_value.rawData(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.SpatMsg.");
}
return FALSE;
}

boolean SpatMsg_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_msgSpat.is_bound()) return TRUE;
if (single_value->field_rawData.is_bound()) return TRUE;
return FALSE;
}

boolean SpatMsg_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_msgSpat.is_value()) return FALSE;
if (!single_value->field_rawData.is_value()) return FALSE;
return TRUE;
}

void SpatMsg_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SpatMsg SpatMsg_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsMapSpat_TestSystem.SpatMsg.");
SpatMsg ret_val;
if (single_value->field_msgSpat.is_bound()) {
ret_val.msgSpat() = single_value->field_msgSpat.valueof();
}
if (single_value->field_rawData.is_bound()) {
ret_val.rawData() = single_value->field_rawData.valueof();
}
return ret_val;
}

void SpatMsg_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsMapSpat_TestSystem.SpatMsg.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SpatMsg_template[list_length];
}

SpatMsg_template& SpatMsg_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsMapSpat_TestSystem.SpatMsg.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsMapSpat_TestSystem.SpatMsg.");
return value_list.list_value[list_index];
}

MAP__SPAT__ETSI::SPAT__PDU_template& SpatMsg_template::msgSpat()
{
set_specific();
return single_value->field_msgSpat;
}

const MAP__SPAT__ETSI::SPAT__PDU_template& SpatMsg_template::msgSpat() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msgSpat of a non-specific template of type @LibItsMapSpat_TestSystem.SpatMsg.");
return single_value->field_msgSpat;
}

OCTETSTRING_template& SpatMsg_template::rawData()
{
set_specific();
return single_value->field_rawData;
}

const OCTETSTRING_template& SpatMsg_template::rawData() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rawData of a non-specific template of type @LibItsMapSpat_TestSystem.SpatMsg.");
return single_value->field_rawData;
}

int SpatMsg_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatMsg which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatMsg containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatMsg containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatMsg containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatMsg containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatMsg containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.SpatMsg.");
  }
  return 0;
}

void SpatMsg_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ msgSpat := ");
single_value->field_msgSpat.log();
TTCN_Logger::log_event_str(", rawData := ");
single_value->field_rawData.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SpatMsg_template::log_match(const SpatMsg& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_msgSpat.match(match_value.msgSpat(), legacy)){
TTCN_Logger::log_logmatch_info(".msgSpat");
single_value->field_msgSpat.log_match(match_value.msgSpat(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_rawData.match(match_value.rawData(), legacy)){
TTCN_Logger::log_logmatch_info(".rawData");
single_value->field_rawData.log_match(match_value.rawData(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ msgSpat := ");
single_value->field_msgSpat.log_match(match_value.msgSpat(), legacy);
TTCN_Logger::log_event_str(", rawData := ");
single_value->field_rawData.log_match(match_value.rawData(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SpatMsg_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_msgSpat.encode_text(text_buf);
single_value->field_rawData.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.SpatMsg.");
}
}

void SpatMsg_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_msgSpat.decode_text(text_buf);
single_value->field_rawData.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SpatMsg_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsMapSpat_TestSystem.SpatMsg.");
}
}

void SpatMsg_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsMapSpat_TestSystem.SpatMsg'");
    }
    if (strcmp("msgSpat", param_field) == 0) {
      msgSpat().set_param(param);
      return;
    } else if (strcmp("rawData", param_field) == 0) {
      rawData().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsMapSpat_TestSystem.SpatMsg'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SpatMsg_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsMapSpat_TestSystem.SpatMsg has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgSpat().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) rawData().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgSpat")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgSpat().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rawData")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rawData().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsMapSpat_TestSystem.SpatMsg: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsMapSpat_TestSystem.SpatMsg");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SpatMsg_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsMapSpat_TestSystem.SpatMsg'");
    }
    if (strcmp("msgSpat", param_field) == 0) {
      return msgSpat().get_param(param_name);
    } else if (strcmp("rawData", param_field) == 0) {
      return rawData().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.SpatMsg'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_msgSpat = single_value->field_msgSpat.get_param(param_name);
    mp_field_msgSpat->set_id(new Module_Param_FieldName(mcopystr("msgSpat")));
    mp->add_elem(mp_field_msgSpat);
    Module_Param* mp_field_rawData = single_value->field_rawData.get_param(param_name);
    mp_field_rawData->set_id(new Module_Param_FieldName(mcopystr("rawData")));
    mp->add_elem(mp_field_rawData);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SpatMsg_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_msgSpat.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.SpatMsg");
single_value->field_rawData.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.SpatMsg");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsMapSpat_TestSystem.SpatMsg");
}

boolean SpatMsg_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SpatMsg_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SpatInd::SpatInd()
{
  bound_flag = FALSE;
}

SpatInd::SpatInd(const SpatMsg& par_msgIn,
    const OPTIONAL<INTEGER>& par_gnNextHeader,
    const OPTIONAL<INTEGER>& par_gnHeaderType,
    const OPTIONAL<INTEGER>& par_gnHeaderSubtype,
    const OPTIONAL<INTEGER>& par_gnLifetime,
    const OPTIONAL<INTEGER>& par_gnTrafficClass,
    const OPTIONAL<INTEGER>& par_btpDestinationPort,
    const OPTIONAL<INTEGER>& par_btpInfo)
  :   field_msgIn(par_msgIn),
  field_gnNextHeader(par_gnNextHeader),
  field_gnHeaderType(par_gnHeaderType),
  field_gnHeaderSubtype(par_gnHeaderSubtype),
  field_gnLifetime(par_gnLifetime),
  field_gnTrafficClass(par_gnTrafficClass),
  field_btpDestinationPort(par_btpDestinationPort),
  field_btpInfo(par_btpInfo)
{
  bound_flag = TRUE;
}

SpatInd::SpatInd(const SpatInd& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsMapSpat_TestSystem.SpatInd.");
bound_flag = TRUE;
if (other_value.msgIn().is_bound()) field_msgIn = other_value.msgIn();
else field_msgIn.clean_up();
if (other_value.gnNextHeader().is_bound()) field_gnNextHeader = other_value.gnNextHeader();
else field_gnNextHeader.clean_up();
if (other_value.gnHeaderType().is_bound()) field_gnHeaderType = other_value.gnHeaderType();
else field_gnHeaderType.clean_up();
if (other_value.gnHeaderSubtype().is_bound()) field_gnHeaderSubtype = other_value.gnHeaderSubtype();
else field_gnHeaderSubtype.clean_up();
if (other_value.gnLifetime().is_bound()) field_gnLifetime = other_value.gnLifetime();
else field_gnLifetime.clean_up();
if (other_value.gnTrafficClass().is_bound()) field_gnTrafficClass = other_value.gnTrafficClass();
else field_gnTrafficClass.clean_up();
if (other_value.btpDestinationPort().is_bound()) field_btpDestinationPort = other_value.btpDestinationPort();
else field_btpDestinationPort.clean_up();
if (other_value.btpInfo().is_bound()) field_btpInfo = other_value.btpInfo();
else field_btpInfo.clean_up();
}

void SpatInd::clean_up()
{
field_msgIn.clean_up();
field_gnNextHeader.clean_up();
field_gnHeaderType.clean_up();
field_gnHeaderSubtype.clean_up();
field_gnLifetime.clean_up();
field_gnTrafficClass.clean_up();
field_btpDestinationPort.clean_up();
field_btpInfo.clean_up();
bound_flag = FALSE;
}

SpatInd& SpatInd::operator=(const SpatInd& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsMapSpat_TestSystem.SpatInd.");
  bound_flag = TRUE;
  if (other_value.msgIn().is_bound()) field_msgIn = other_value.msgIn();
  else field_msgIn.clean_up();
  if (other_value.gnNextHeader().is_bound()) field_gnNextHeader = other_value.gnNextHeader();
  else field_gnNextHeader.clean_up();
  if (other_value.gnHeaderType().is_bound()) field_gnHeaderType = other_value.gnHeaderType();
  else field_gnHeaderType.clean_up();
  if (other_value.gnHeaderSubtype().is_bound()) field_gnHeaderSubtype = other_value.gnHeaderSubtype();
  else field_gnHeaderSubtype.clean_up();
  if (other_value.gnLifetime().is_bound()) field_gnLifetime = other_value.gnLifetime();
  else field_gnLifetime.clean_up();
  if (other_value.gnTrafficClass().is_bound()) field_gnTrafficClass = other_value.gnTrafficClass();
  else field_gnTrafficClass.clean_up();
  if (other_value.btpDestinationPort().is_bound()) field_btpDestinationPort = other_value.btpDestinationPort();
  else field_btpDestinationPort.clean_up();
  if (other_value.btpInfo().is_bound()) field_btpInfo = other_value.btpInfo();
  else field_btpInfo.clean_up();
}
return *this;
}

boolean SpatInd::operator==(const SpatInd& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_msgIn==other_value.field_msgIn
  && field_gnNextHeader==other_value.field_gnNextHeader
  && field_gnHeaderType==other_value.field_gnHeaderType
  && field_gnHeaderSubtype==other_value.field_gnHeaderSubtype
  && field_gnLifetime==other_value.field_gnLifetime
  && field_gnTrafficClass==other_value.field_gnTrafficClass
  && field_btpDestinationPort==other_value.field_btpDestinationPort
  && field_btpInfo==other_value.field_btpInfo;
}

boolean SpatInd::is_bound() const
{
if (bound_flag) return TRUE;
if(field_msgIn.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_gnNextHeader.get_selection() || field_gnNextHeader.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_gnHeaderType.get_selection() || field_gnHeaderType.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_gnHeaderSubtype.get_selection() || field_gnHeaderSubtype.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_gnLifetime.get_selection() || field_gnLifetime.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_gnTrafficClass.get_selection() || field_gnTrafficClass.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_btpDestinationPort.get_selection() || field_btpDestinationPort.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_btpInfo.get_selection() || field_btpInfo.is_bound()) return TRUE;
return FALSE;
}
boolean SpatInd::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_msgIn.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_gnNextHeader.get_selection() && !field_gnNextHeader.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_gnHeaderType.get_selection() && !field_gnHeaderType.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_gnHeaderSubtype.get_selection() && !field_gnHeaderSubtype.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_gnLifetime.get_selection() && !field_gnLifetime.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_gnTrafficClass.get_selection() && !field_gnTrafficClass.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_btpDestinationPort.get_selection() && !field_btpDestinationPort.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_btpInfo.get_selection() && !field_btpInfo.is_value()) return FALSE;
return TRUE;
}
int SpatInd::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsMapSpat_TestSystem.SpatInd");
  int ret_val = 1;
  if (field_gnNextHeader.ispresent()) ret_val++;
  if (field_gnHeaderType.ispresent()) ret_val++;
  if (field_gnHeaderSubtype.ispresent()) ret_val++;
  if (field_gnLifetime.ispresent()) ret_val++;
  if (field_gnTrafficClass.ispresent()) ret_val++;
  if (field_btpDestinationPort.ispresent()) ret_val++;
  if (field_btpInfo.ispresent()) ret_val++;
  return ret_val;
}

void SpatInd::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ msgIn := ");
field_msgIn.log();
TTCN_Logger::log_event_str(", gnNextHeader := ");
field_gnNextHeader.log();
TTCN_Logger::log_event_str(", gnHeaderType := ");
field_gnHeaderType.log();
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
field_gnHeaderSubtype.log();
TTCN_Logger::log_event_str(", gnLifetime := ");
field_gnLifetime.log();
TTCN_Logger::log_event_str(", gnTrafficClass := ");
field_gnTrafficClass.log();
TTCN_Logger::log_event_str(", btpDestinationPort := ");
field_btpDestinationPort.log();
TTCN_Logger::log_event_str(", btpInfo := ");
field_btpInfo.log();
TTCN_Logger::log_event_str(" }");
}

void SpatInd::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsMapSpat_TestSystem.SpatInd'");
    }
    if (strcmp("msgIn", param_field) == 0) {
      msgIn().set_param(param);
      return;
    } else if (strcmp("gnNextHeader", param_field) == 0) {
      gnNextHeader().set_param(param);
      return;
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      gnHeaderType().set_param(param);
      return;
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      gnHeaderSubtype().set_param(param);
      return;
    } else if (strcmp("gnLifetime", param_field) == 0) {
      gnLifetime().set_param(param);
      return;
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      gnTrafficClass().set_param(param);
      return;
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      btpDestinationPort().set_param(param);
      return;
    } else if (strcmp("btpInfo", param_field) == 0) {
      btpInfo().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.SpatInd'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (8<mp->get_size()) {
      param.error("record value of type @LibItsMapSpat_TestSystem.SpatInd has 8 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgIn().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) gnNextHeader().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) gnHeaderType().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) gnHeaderSubtype().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) gnLifetime().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) gnTrafficClass().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) btpDestinationPort().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) btpInfo().set_param(*mp->get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgIn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgIn().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnNextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnNextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderSubtype")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderSubtype().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnTrafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnTrafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpDestinationPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpDestinationPort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpInfo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpInfo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsMapSpat_TestSystem.SpatInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsMapSpat_TestSystem.SpatInd");
  }
}

Module_Param* SpatInd::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsMapSpat_TestSystem.SpatInd'");
    }
    if (strcmp("msgIn", param_field) == 0) {
      return msgIn().get_param(param_name);
    } else if (strcmp("gnNextHeader", param_field) == 0) {
      return gnNextHeader().get_param(param_name);
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      return gnHeaderType().get_param(param_name);
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      return gnHeaderSubtype().get_param(param_name);
    } else if (strcmp("gnLifetime", param_field) == 0) {
      return gnLifetime().get_param(param_name);
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      return gnTrafficClass().get_param(param_name);
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      return btpDestinationPort().get_param(param_name);
    } else if (strcmp("btpInfo", param_field) == 0) {
      return btpInfo().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.SpatInd'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_msgIn = field_msgIn.get_param(param_name);
  mp_field_msgIn->set_id(new Module_Param_FieldName(mcopystr("msgIn")));
  mp->add_elem(mp_field_msgIn);
  Module_Param* mp_field_gnNextHeader = field_gnNextHeader.get_param(param_name);
  mp_field_gnNextHeader->set_id(new Module_Param_FieldName(mcopystr("gnNextHeader")));
  mp->add_elem(mp_field_gnNextHeader);
  Module_Param* mp_field_gnHeaderType = field_gnHeaderType.get_param(param_name);
  mp_field_gnHeaderType->set_id(new Module_Param_FieldName(mcopystr("gnHeaderType")));
  mp->add_elem(mp_field_gnHeaderType);
  Module_Param* mp_field_gnHeaderSubtype = field_gnHeaderSubtype.get_param(param_name);
  mp_field_gnHeaderSubtype->set_id(new Module_Param_FieldName(mcopystr("gnHeaderSubtype")));
  mp->add_elem(mp_field_gnHeaderSubtype);
  Module_Param* mp_field_gnLifetime = field_gnLifetime.get_param(param_name);
  mp_field_gnLifetime->set_id(new Module_Param_FieldName(mcopystr("gnLifetime")));
  mp->add_elem(mp_field_gnLifetime);
  Module_Param* mp_field_gnTrafficClass = field_gnTrafficClass.get_param(param_name);
  mp_field_gnTrafficClass->set_id(new Module_Param_FieldName(mcopystr("gnTrafficClass")));
  mp->add_elem(mp_field_gnTrafficClass);
  Module_Param* mp_field_btpDestinationPort = field_btpDestinationPort.get_param(param_name);
  mp_field_btpDestinationPort->set_id(new Module_Param_FieldName(mcopystr("btpDestinationPort")));
  mp->add_elem(mp_field_btpDestinationPort);
  Module_Param* mp_field_btpInfo = field_btpInfo.get_param(param_name);
  mp_field_btpInfo->set_id(new Module_Param_FieldName(mcopystr("btpInfo")));
  mp->add_elem(mp_field_btpInfo);
  return mp;
  }

void SpatInd::set_implicit_omit()
{
if (msgIn().is_bound()) msgIn().set_implicit_omit();
if (!gnNextHeader().is_bound()) gnNextHeader() = OMIT_VALUE;
else gnNextHeader().set_implicit_omit();
if (!gnHeaderType().is_bound()) gnHeaderType() = OMIT_VALUE;
else gnHeaderType().set_implicit_omit();
if (!gnHeaderSubtype().is_bound()) gnHeaderSubtype() = OMIT_VALUE;
else gnHeaderSubtype().set_implicit_omit();
if (!gnLifetime().is_bound()) gnLifetime() = OMIT_VALUE;
else gnLifetime().set_implicit_omit();
if (!gnTrafficClass().is_bound()) gnTrafficClass() = OMIT_VALUE;
else gnTrafficClass().set_implicit_omit();
if (!btpDestinationPort().is_bound()) btpDestinationPort() = OMIT_VALUE;
else btpDestinationPort().set_implicit_omit();
if (!btpInfo().is_bound()) btpInfo() = OMIT_VALUE;
else btpInfo().set_implicit_omit();
}

void SpatInd::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsMapSpat_TestSystem.SpatInd.");
field_msgIn.encode_text(text_buf);
field_gnNextHeader.encode_text(text_buf);
field_gnHeaderType.encode_text(text_buf);
field_gnHeaderSubtype.encode_text(text_buf);
field_gnLifetime.encode_text(text_buf);
field_gnTrafficClass.encode_text(text_buf);
field_btpDestinationPort.encode_text(text_buf);
field_btpInfo.encode_text(text_buf);
}

void SpatInd::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_msgIn.decode_text(text_buf);
field_gnNextHeader.decode_text(text_buf);
field_gnHeaderType.decode_text(text_buf);
field_gnHeaderSubtype.decode_text(text_buf);
field_gnLifetime.decode_text(text_buf);
field_gnTrafficClass.decode_text(text_buf);
field_btpDestinationPort.decode_text(text_buf);
field_btpInfo.decode_text(text_buf);
}

struct SpatInd_template::single_value_struct {
SpatMsg_template field_msgIn;
INTEGER_template field_gnNextHeader;
INTEGER_template field_gnHeaderType;
INTEGER_template field_gnHeaderSubtype;
INTEGER_template field_gnLifetime;
INTEGER_template field_gnTrafficClass;
INTEGER_template field_btpDestinationPort;
INTEGER_template field_btpInfo;
};

void SpatInd_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_msgIn = ANY_VALUE;
single_value->field_gnNextHeader = ANY_OR_OMIT;
single_value->field_gnHeaderType = ANY_OR_OMIT;
single_value->field_gnHeaderSubtype = ANY_OR_OMIT;
single_value->field_gnLifetime = ANY_OR_OMIT;
single_value->field_gnTrafficClass = ANY_OR_OMIT;
single_value->field_btpDestinationPort = ANY_OR_OMIT;
single_value->field_btpInfo = ANY_OR_OMIT;
}
}
}

void SpatInd_template::copy_value(const SpatInd& other_value)
{
single_value = new single_value_struct;
if (other_value.msgIn().is_bound()) {
  single_value->field_msgIn = other_value.msgIn();
} else {
  single_value->field_msgIn.clean_up();
}
if (other_value.gnNextHeader().is_bound()) {
  if (other_value.gnNextHeader().ispresent()) single_value->field_gnNextHeader = other_value.gnNextHeader()();
  else single_value->field_gnNextHeader = OMIT_VALUE;
} else {
  single_value->field_gnNextHeader.clean_up();
}
if (other_value.gnHeaderType().is_bound()) {
  if (other_value.gnHeaderType().ispresent()) single_value->field_gnHeaderType = other_value.gnHeaderType()();
  else single_value->field_gnHeaderType = OMIT_VALUE;
} else {
  single_value->field_gnHeaderType.clean_up();
}
if (other_value.gnHeaderSubtype().is_bound()) {
  if (other_value.gnHeaderSubtype().ispresent()) single_value->field_gnHeaderSubtype = other_value.gnHeaderSubtype()();
  else single_value->field_gnHeaderSubtype = OMIT_VALUE;
} else {
  single_value->field_gnHeaderSubtype.clean_up();
}
if (other_value.gnLifetime().is_bound()) {
  if (other_value.gnLifetime().ispresent()) single_value->field_gnLifetime = other_value.gnLifetime()();
  else single_value->field_gnLifetime = OMIT_VALUE;
} else {
  single_value->field_gnLifetime.clean_up();
}
if (other_value.gnTrafficClass().is_bound()) {
  if (other_value.gnTrafficClass().ispresent()) single_value->field_gnTrafficClass = other_value.gnTrafficClass()();
  else single_value->field_gnTrafficClass = OMIT_VALUE;
} else {
  single_value->field_gnTrafficClass.clean_up();
}
if (other_value.btpDestinationPort().is_bound()) {
  if (other_value.btpDestinationPort().ispresent()) single_value->field_btpDestinationPort = other_value.btpDestinationPort()();
  else single_value->field_btpDestinationPort = OMIT_VALUE;
} else {
  single_value->field_btpDestinationPort.clean_up();
}
if (other_value.btpInfo().is_bound()) {
  if (other_value.btpInfo().ispresent()) single_value->field_btpInfo = other_value.btpInfo()();
  else single_value->field_btpInfo = OMIT_VALUE;
} else {
  single_value->field_btpInfo.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SpatInd_template::copy_template(const SpatInd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.msgIn().get_selection()) {
single_value->field_msgIn = other_value.msgIn();
} else {
single_value->field_msgIn.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnNextHeader().get_selection()) {
single_value->field_gnNextHeader = other_value.gnNextHeader();
} else {
single_value->field_gnNextHeader.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnHeaderType().get_selection()) {
single_value->field_gnHeaderType = other_value.gnHeaderType();
} else {
single_value->field_gnHeaderType.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnHeaderSubtype().get_selection()) {
single_value->field_gnHeaderSubtype = other_value.gnHeaderSubtype();
} else {
single_value->field_gnHeaderSubtype.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnLifetime().get_selection()) {
single_value->field_gnLifetime = other_value.gnLifetime();
} else {
single_value->field_gnLifetime.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.gnTrafficClass().get_selection()) {
single_value->field_gnTrafficClass = other_value.gnTrafficClass();
} else {
single_value->field_gnTrafficClass.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.btpDestinationPort().get_selection()) {
single_value->field_btpDestinationPort = other_value.btpDestinationPort();
} else {
single_value->field_btpDestinationPort.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.btpInfo().get_selection()) {
single_value->field_btpInfo = other_value.btpInfo();
} else {
single_value->field_btpInfo.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SpatInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.SpatInd.");
break;
}
set_selection(other_value);
}

SpatInd_template::SpatInd_template()
{
}

SpatInd_template::SpatInd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SpatInd_template::SpatInd_template(const SpatInd& other_value)
{
copy_value(other_value);
}

SpatInd_template::SpatInd_template(const OPTIONAL<SpatInd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SpatInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsMapSpat_TestSystem.SpatInd from an unbound optional field.");
}
}

SpatInd_template::SpatInd_template(const SpatInd_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SpatInd_template::~SpatInd_template()
{
clean_up();
}

SpatInd_template& SpatInd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SpatInd_template& SpatInd_template::operator=(const SpatInd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SpatInd_template& SpatInd_template::operator=(const OPTIONAL<SpatInd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SpatInd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsMapSpat_TestSystem.SpatInd.");
}
return *this;
}

SpatInd_template& SpatInd_template::operator=(const SpatInd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SpatInd_template::match(const SpatInd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.msgIn().is_bound()) return FALSE;
if(!single_value->field_msgIn.match(other_value.msgIn(), legacy))return FALSE;
if(!other_value.gnNextHeader().is_bound()) return FALSE;
if((other_value.gnNextHeader().ispresent() ? !single_value->field_gnNextHeader.match((const INTEGER&)other_value.gnNextHeader(), legacy) : !single_value->field_gnNextHeader.match_omit(legacy)))return FALSE;
if(!other_value.gnHeaderType().is_bound()) return FALSE;
if((other_value.gnHeaderType().ispresent() ? !single_value->field_gnHeaderType.match((const INTEGER&)other_value.gnHeaderType(), legacy) : !single_value->field_gnHeaderType.match_omit(legacy)))return FALSE;
if(!other_value.gnHeaderSubtype().is_bound()) return FALSE;
if((other_value.gnHeaderSubtype().ispresent() ? !single_value->field_gnHeaderSubtype.match((const INTEGER&)other_value.gnHeaderSubtype(), legacy) : !single_value->field_gnHeaderSubtype.match_omit(legacy)))return FALSE;
if(!other_value.gnLifetime().is_bound()) return FALSE;
if((other_value.gnLifetime().ispresent() ? !single_value->field_gnLifetime.match((const INTEGER&)other_value.gnLifetime(), legacy) : !single_value->field_gnLifetime.match_omit(legacy)))return FALSE;
if(!other_value.gnTrafficClass().is_bound()) return FALSE;
if((other_value.gnTrafficClass().ispresent() ? !single_value->field_gnTrafficClass.match((const INTEGER&)other_value.gnTrafficClass(), legacy) : !single_value->field_gnTrafficClass.match_omit(legacy)))return FALSE;
if(!other_value.btpDestinationPort().is_bound()) return FALSE;
if((other_value.btpDestinationPort().ispresent() ? !single_value->field_btpDestinationPort.match((const INTEGER&)other_value.btpDestinationPort(), legacy) : !single_value->field_btpDestinationPort.match_omit(legacy)))return FALSE;
if(!other_value.btpInfo().is_bound()) return FALSE;
if((other_value.btpInfo().ispresent() ? !single_value->field_btpInfo.match((const INTEGER&)other_value.btpInfo(), legacy) : !single_value->field_btpInfo.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.SpatInd.");
}
return FALSE;
}

boolean SpatInd_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_msgIn.is_bound()) return TRUE;
if (single_value->field_gnNextHeader.is_omit() || single_value->field_gnNextHeader.is_bound()) return TRUE;
if (single_value->field_gnHeaderType.is_omit() || single_value->field_gnHeaderType.is_bound()) return TRUE;
if (single_value->field_gnHeaderSubtype.is_omit() || single_value->field_gnHeaderSubtype.is_bound()) return TRUE;
if (single_value->field_gnLifetime.is_omit() || single_value->field_gnLifetime.is_bound()) return TRUE;
if (single_value->field_gnTrafficClass.is_omit() || single_value->field_gnTrafficClass.is_bound()) return TRUE;
if (single_value->field_btpDestinationPort.is_omit() || single_value->field_btpDestinationPort.is_bound()) return TRUE;
if (single_value->field_btpInfo.is_omit() || single_value->field_btpInfo.is_bound()) return TRUE;
return FALSE;
}

boolean SpatInd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_msgIn.is_value()) return FALSE;
if (!single_value->field_gnNextHeader.is_omit() && !single_value->field_gnNextHeader.is_value()) return FALSE;
if (!single_value->field_gnHeaderType.is_omit() && !single_value->field_gnHeaderType.is_value()) return FALSE;
if (!single_value->field_gnHeaderSubtype.is_omit() && !single_value->field_gnHeaderSubtype.is_value()) return FALSE;
if (!single_value->field_gnLifetime.is_omit() && !single_value->field_gnLifetime.is_value()) return FALSE;
if (!single_value->field_gnTrafficClass.is_omit() && !single_value->field_gnTrafficClass.is_value()) return FALSE;
if (!single_value->field_btpDestinationPort.is_omit() && !single_value->field_btpDestinationPort.is_value()) return FALSE;
if (!single_value->field_btpInfo.is_omit() && !single_value->field_btpInfo.is_value()) return FALSE;
return TRUE;
}

void SpatInd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SpatInd SpatInd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsMapSpat_TestSystem.SpatInd.");
SpatInd ret_val;
if (single_value->field_msgIn.is_bound()) {
ret_val.msgIn() = single_value->field_msgIn.valueof();
}
if (single_value->field_gnNextHeader.is_omit()) ret_val.gnNextHeader() = OMIT_VALUE;
else if (single_value->field_gnNextHeader.is_bound()) {
ret_val.gnNextHeader() = single_value->field_gnNextHeader.valueof();
}
if (single_value->field_gnHeaderType.is_omit()) ret_val.gnHeaderType() = OMIT_VALUE;
else if (single_value->field_gnHeaderType.is_bound()) {
ret_val.gnHeaderType() = single_value->field_gnHeaderType.valueof();
}
if (single_value->field_gnHeaderSubtype.is_omit()) ret_val.gnHeaderSubtype() = OMIT_VALUE;
else if (single_value->field_gnHeaderSubtype.is_bound()) {
ret_val.gnHeaderSubtype() = single_value->field_gnHeaderSubtype.valueof();
}
if (single_value->field_gnLifetime.is_omit()) ret_val.gnLifetime() = OMIT_VALUE;
else if (single_value->field_gnLifetime.is_bound()) {
ret_val.gnLifetime() = single_value->field_gnLifetime.valueof();
}
if (single_value->field_gnTrafficClass.is_omit()) ret_val.gnTrafficClass() = OMIT_VALUE;
else if (single_value->field_gnTrafficClass.is_bound()) {
ret_val.gnTrafficClass() = single_value->field_gnTrafficClass.valueof();
}
if (single_value->field_btpDestinationPort.is_omit()) ret_val.btpDestinationPort() = OMIT_VALUE;
else if (single_value->field_btpDestinationPort.is_bound()) {
ret_val.btpDestinationPort() = single_value->field_btpDestinationPort.valueof();
}
if (single_value->field_btpInfo.is_omit()) ret_val.btpInfo() = OMIT_VALUE;
else if (single_value->field_btpInfo.is_bound()) {
ret_val.btpInfo() = single_value->field_btpInfo.valueof();
}
return ret_val;
}

void SpatInd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsMapSpat_TestSystem.SpatInd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SpatInd_template[list_length];
}

SpatInd_template& SpatInd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsMapSpat_TestSystem.SpatInd.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsMapSpat_TestSystem.SpatInd.");
return value_list.list_value[list_index];
}

SpatMsg_template& SpatInd_template::msgIn()
{
set_specific();
return single_value->field_msgIn;
}

const SpatMsg_template& SpatInd_template::msgIn() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msgIn of a non-specific template of type @LibItsMapSpat_TestSystem.SpatInd.");
return single_value->field_msgIn;
}

INTEGER_template& SpatInd_template::gnNextHeader()
{
set_specific();
return single_value->field_gnNextHeader;
}

const INTEGER_template& SpatInd_template::gnNextHeader() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnNextHeader of a non-specific template of type @LibItsMapSpat_TestSystem.SpatInd.");
return single_value->field_gnNextHeader;
}

INTEGER_template& SpatInd_template::gnHeaderType()
{
set_specific();
return single_value->field_gnHeaderType;
}

const INTEGER_template& SpatInd_template::gnHeaderType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnHeaderType of a non-specific template of type @LibItsMapSpat_TestSystem.SpatInd.");
return single_value->field_gnHeaderType;
}

INTEGER_template& SpatInd_template::gnHeaderSubtype()
{
set_specific();
return single_value->field_gnHeaderSubtype;
}

const INTEGER_template& SpatInd_template::gnHeaderSubtype() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnHeaderSubtype of a non-specific template of type @LibItsMapSpat_TestSystem.SpatInd.");
return single_value->field_gnHeaderSubtype;
}

INTEGER_template& SpatInd_template::gnLifetime()
{
set_specific();
return single_value->field_gnLifetime;
}

const INTEGER_template& SpatInd_template::gnLifetime() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnLifetime of a non-specific template of type @LibItsMapSpat_TestSystem.SpatInd.");
return single_value->field_gnLifetime;
}

INTEGER_template& SpatInd_template::gnTrafficClass()
{
set_specific();
return single_value->field_gnTrafficClass;
}

const INTEGER_template& SpatInd_template::gnTrafficClass() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field gnTrafficClass of a non-specific template of type @LibItsMapSpat_TestSystem.SpatInd.");
return single_value->field_gnTrafficClass;
}

INTEGER_template& SpatInd_template::btpDestinationPort()
{
set_specific();
return single_value->field_btpDestinationPort;
}

const INTEGER_template& SpatInd_template::btpDestinationPort() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field btpDestinationPort of a non-specific template of type @LibItsMapSpat_TestSystem.SpatInd.");
return single_value->field_btpDestinationPort;
}

INTEGER_template& SpatInd_template::btpInfo()
{
set_specific();
return single_value->field_btpInfo;
}

const INTEGER_template& SpatInd_template::btpInfo() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field btpInfo of a non-specific template of type @LibItsMapSpat_TestSystem.SpatInd.");
return single_value->field_btpInfo;
}

int SpatInd_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatInd which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_gnNextHeader.is_present()) ret_val++;
      if (single_value->field_gnHeaderType.is_present()) ret_val++;
      if (single_value->field_gnHeaderSubtype.is_present()) ret_val++;
      if (single_value->field_gnLifetime.is_present()) ret_val++;
      if (single_value->field_gnTrafficClass.is_present()) ret_val++;
      if (single_value->field_btpDestinationPort.is_present()) ret_val++;
      if (single_value->field_btpInfo.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatInd containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatInd containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatInd containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatInd containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatInd containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.SpatInd.");
  }
  return 0;
}

void SpatInd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ msgIn := ");
single_value->field_msgIn.log();
TTCN_Logger::log_event_str(", gnNextHeader := ");
single_value->field_gnNextHeader.log();
TTCN_Logger::log_event_str(", gnHeaderType := ");
single_value->field_gnHeaderType.log();
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
single_value->field_gnHeaderSubtype.log();
TTCN_Logger::log_event_str(", gnLifetime := ");
single_value->field_gnLifetime.log();
TTCN_Logger::log_event_str(", gnTrafficClass := ");
single_value->field_gnTrafficClass.log();
TTCN_Logger::log_event_str(", btpDestinationPort := ");
single_value->field_btpDestinationPort.log();
TTCN_Logger::log_event_str(", btpInfo := ");
single_value->field_btpInfo.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SpatInd_template::log_match(const SpatInd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_msgIn.match(match_value.msgIn(), legacy)){
TTCN_Logger::log_logmatch_info(".msgIn");
single_value->field_msgIn.log_match(match_value.msgIn(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.gnNextHeader().ispresent()){
if(!single_value->field_gnNextHeader.match(match_value.gnNextHeader(), legacy)){
TTCN_Logger::log_logmatch_info(".gnNextHeader");
single_value->field_gnNextHeader.log_match(match_value.gnNextHeader(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_gnNextHeader.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".gnNextHeader := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_gnNextHeader.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.gnHeaderType().ispresent()){
if(!single_value->field_gnHeaderType.match(match_value.gnHeaderType(), legacy)){
TTCN_Logger::log_logmatch_info(".gnHeaderType");
single_value->field_gnHeaderType.log_match(match_value.gnHeaderType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_gnHeaderType.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".gnHeaderType := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_gnHeaderType.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.gnHeaderSubtype().ispresent()){
if(!single_value->field_gnHeaderSubtype.match(match_value.gnHeaderSubtype(), legacy)){
TTCN_Logger::log_logmatch_info(".gnHeaderSubtype");
single_value->field_gnHeaderSubtype.log_match(match_value.gnHeaderSubtype(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_gnHeaderSubtype.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".gnHeaderSubtype := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_gnHeaderSubtype.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.gnLifetime().ispresent()){
if(!single_value->field_gnLifetime.match(match_value.gnLifetime(), legacy)){
TTCN_Logger::log_logmatch_info(".gnLifetime");
single_value->field_gnLifetime.log_match(match_value.gnLifetime(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_gnLifetime.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".gnLifetime := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_gnLifetime.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.gnTrafficClass().ispresent()){
if(!single_value->field_gnTrafficClass.match(match_value.gnTrafficClass(), legacy)){
TTCN_Logger::log_logmatch_info(".gnTrafficClass");
single_value->field_gnTrafficClass.log_match(match_value.gnTrafficClass(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_gnTrafficClass.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".gnTrafficClass := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_gnTrafficClass.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.btpDestinationPort().ispresent()){
if(!single_value->field_btpDestinationPort.match(match_value.btpDestinationPort(), legacy)){
TTCN_Logger::log_logmatch_info(".btpDestinationPort");
single_value->field_btpDestinationPort.log_match(match_value.btpDestinationPort(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_btpDestinationPort.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".btpDestinationPort := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_btpDestinationPort.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
if (match_value.btpInfo().ispresent()){
if(!single_value->field_btpInfo.match(match_value.btpInfo(), legacy)){
TTCN_Logger::log_logmatch_info(".btpInfo");
single_value->field_btpInfo.log_match(match_value.btpInfo(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_btpInfo.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".btpInfo := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_btpInfo.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ msgIn := ");
single_value->field_msgIn.log_match(match_value.msgIn(), legacy);
TTCN_Logger::log_event_str(", gnNextHeader := ");
if (match_value.gnNextHeader().ispresent()) single_value->field_gnNextHeader.log_match(match_value.gnNextHeader(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_gnNextHeader.log();
if (single_value->field_gnNextHeader.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", gnHeaderType := ");
if (match_value.gnHeaderType().ispresent()) single_value->field_gnHeaderType.log_match(match_value.gnHeaderType(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_gnHeaderType.log();
if (single_value->field_gnHeaderType.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", gnHeaderSubtype := ");
if (match_value.gnHeaderSubtype().ispresent()) single_value->field_gnHeaderSubtype.log_match(match_value.gnHeaderSubtype(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_gnHeaderSubtype.log();
if (single_value->field_gnHeaderSubtype.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", gnLifetime := ");
if (match_value.gnLifetime().ispresent()) single_value->field_gnLifetime.log_match(match_value.gnLifetime(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_gnLifetime.log();
if (single_value->field_gnLifetime.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", gnTrafficClass := ");
if (match_value.gnTrafficClass().ispresent()) single_value->field_gnTrafficClass.log_match(match_value.gnTrafficClass(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_gnTrafficClass.log();
if (single_value->field_gnTrafficClass.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", btpDestinationPort := ");
if (match_value.btpDestinationPort().ispresent()) single_value->field_btpDestinationPort.log_match(match_value.btpDestinationPort(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_btpDestinationPort.log();
if (single_value->field_btpDestinationPort.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(", btpInfo := ");
if (match_value.btpInfo().ispresent()) single_value->field_btpInfo.log_match(match_value.btpInfo(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_btpInfo.log();
if (single_value->field_btpInfo.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SpatInd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_msgIn.encode_text(text_buf);
single_value->field_gnNextHeader.encode_text(text_buf);
single_value->field_gnHeaderType.encode_text(text_buf);
single_value->field_gnHeaderSubtype.encode_text(text_buf);
single_value->field_gnLifetime.encode_text(text_buf);
single_value->field_gnTrafficClass.encode_text(text_buf);
single_value->field_btpDestinationPort.encode_text(text_buf);
single_value->field_btpInfo.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.SpatInd.");
}
}

void SpatInd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_msgIn.decode_text(text_buf);
single_value->field_gnNextHeader.decode_text(text_buf);
single_value->field_gnHeaderType.decode_text(text_buf);
single_value->field_gnHeaderSubtype.decode_text(text_buf);
single_value->field_gnLifetime.decode_text(text_buf);
single_value->field_gnTrafficClass.decode_text(text_buf);
single_value->field_btpDestinationPort.decode_text(text_buf);
single_value->field_btpInfo.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SpatInd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsMapSpat_TestSystem.SpatInd.");
}
}

void SpatInd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsMapSpat_TestSystem.SpatInd'");
    }
    if (strcmp("msgIn", param_field) == 0) {
      msgIn().set_param(param);
      return;
    } else if (strcmp("gnNextHeader", param_field) == 0) {
      gnNextHeader().set_param(param);
      return;
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      gnHeaderType().set_param(param);
      return;
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      gnHeaderSubtype().set_param(param);
      return;
    } else if (strcmp("gnLifetime", param_field) == 0) {
      gnLifetime().set_param(param);
      return;
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      gnTrafficClass().set_param(param);
      return;
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      btpDestinationPort().set_param(param);
      return;
    } else if (strcmp("btpInfo", param_field) == 0) {
      btpInfo().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsMapSpat_TestSystem.SpatInd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SpatInd_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (8<mp->get_size()) {
      param.error("record template of type @LibItsMapSpat_TestSystem.SpatInd has 8 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgIn().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) gnNextHeader().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) gnHeaderType().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) gnHeaderSubtype().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) gnLifetime().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) gnTrafficClass().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) btpDestinationPort().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) btpInfo().set_param(*mp->get_elem(7));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgIn")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgIn().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnNextHeader")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnNextHeader().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnHeaderSubtype")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnHeaderSubtype().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnLifetime")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnLifetime().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "gnTrafficClass")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          gnTrafficClass().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpDestinationPort")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpDestinationPort().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "btpInfo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          btpInfo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsMapSpat_TestSystem.SpatInd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsMapSpat_TestSystem.SpatInd");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SpatInd_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsMapSpat_TestSystem.SpatInd'");
    }
    if (strcmp("msgIn", param_field) == 0) {
      return msgIn().get_param(param_name);
    } else if (strcmp("gnNextHeader", param_field) == 0) {
      return gnNextHeader().get_param(param_name);
    } else if (strcmp("gnHeaderType", param_field) == 0) {
      return gnHeaderType().get_param(param_name);
    } else if (strcmp("gnHeaderSubtype", param_field) == 0) {
      return gnHeaderSubtype().get_param(param_name);
    } else if (strcmp("gnLifetime", param_field) == 0) {
      return gnLifetime().get_param(param_name);
    } else if (strcmp("gnTrafficClass", param_field) == 0) {
      return gnTrafficClass().get_param(param_name);
    } else if (strcmp("btpDestinationPort", param_field) == 0) {
      return btpDestinationPort().get_param(param_name);
    } else if (strcmp("btpInfo", param_field) == 0) {
      return btpInfo().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.SpatInd'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_msgIn = single_value->field_msgIn.get_param(param_name);
    mp_field_msgIn->set_id(new Module_Param_FieldName(mcopystr("msgIn")));
    mp->add_elem(mp_field_msgIn);
    Module_Param* mp_field_gnNextHeader = single_value->field_gnNextHeader.get_param(param_name);
    mp_field_gnNextHeader->set_id(new Module_Param_FieldName(mcopystr("gnNextHeader")));
    mp->add_elem(mp_field_gnNextHeader);
    Module_Param* mp_field_gnHeaderType = single_value->field_gnHeaderType.get_param(param_name);
    mp_field_gnHeaderType->set_id(new Module_Param_FieldName(mcopystr("gnHeaderType")));
    mp->add_elem(mp_field_gnHeaderType);
    Module_Param* mp_field_gnHeaderSubtype = single_value->field_gnHeaderSubtype.get_param(param_name);
    mp_field_gnHeaderSubtype->set_id(new Module_Param_FieldName(mcopystr("gnHeaderSubtype")));
    mp->add_elem(mp_field_gnHeaderSubtype);
    Module_Param* mp_field_gnLifetime = single_value->field_gnLifetime.get_param(param_name);
    mp_field_gnLifetime->set_id(new Module_Param_FieldName(mcopystr("gnLifetime")));
    mp->add_elem(mp_field_gnLifetime);
    Module_Param* mp_field_gnTrafficClass = single_value->field_gnTrafficClass.get_param(param_name);
    mp_field_gnTrafficClass->set_id(new Module_Param_FieldName(mcopystr("gnTrafficClass")));
    mp->add_elem(mp_field_gnTrafficClass);
    Module_Param* mp_field_btpDestinationPort = single_value->field_btpDestinationPort.get_param(param_name);
    mp_field_btpDestinationPort->set_id(new Module_Param_FieldName(mcopystr("btpDestinationPort")));
    mp->add_elem(mp_field_btpDestinationPort);
    Module_Param* mp_field_btpInfo = single_value->field_btpInfo.get_param(param_name);
    mp_field_btpInfo->set_id(new Module_Param_FieldName(mcopystr("btpInfo")));
    mp->add_elem(mp_field_btpInfo);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SpatInd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_msgIn.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.SpatInd");
single_value->field_gnNextHeader.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.SpatInd");
single_value->field_gnHeaderType.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.SpatInd");
single_value->field_gnHeaderSubtype.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.SpatInd");
single_value->field_gnLifetime.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.SpatInd");
single_value->field_gnTrafficClass.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.SpatInd");
single_value->field_btpDestinationPort.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.SpatInd");
single_value->field_btpInfo.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.SpatInd");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsMapSpat_TestSystem.SpatInd");
}

boolean SpatInd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SpatInd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

MapReq::MapReq()
{
  bound_flag = FALSE;
}

MapReq::MapReq(const MAP__SPAT__ETSI::MAP__PDU& par_msgOut)
  :   field_msgOut(par_msgOut)
{
  bound_flag = TRUE;
}

MapReq::MapReq(const MapReq& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsMapSpat_TestSystem.MapReq.");
bound_flag = TRUE;
if (other_value.msgOut().is_bound()) field_msgOut = other_value.msgOut();
else field_msgOut.clean_up();
}

void MapReq::clean_up()
{
field_msgOut.clean_up();
bound_flag = FALSE;
}

MapReq& MapReq::operator=(const MapReq& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsMapSpat_TestSystem.MapReq.");
  bound_flag = TRUE;
  if (other_value.msgOut().is_bound()) field_msgOut = other_value.msgOut();
  else field_msgOut.clean_up();
}
return *this;
}

boolean MapReq::operator==(const MapReq& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_msgOut==other_value.field_msgOut;
}

boolean MapReq::is_bound() const
{
if (bound_flag) return TRUE;
if(field_msgOut.is_bound()) return TRUE;
return FALSE;
}
boolean MapReq::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_msgOut.is_value()) return FALSE;
return TRUE;
}
int MapReq::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsMapSpat_TestSystem.MapReq");
  return 1;
}

void MapReq::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ msgOut := ");
field_msgOut.log();
TTCN_Logger::log_event_str(" }");
}

void MapReq::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsMapSpat_TestSystem.MapReq'");
    }
    if (strcmp("msgOut", param_field) == 0) {
      msgOut().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.MapReq'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsMapSpat_TestSystem.MapReq has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgOut().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgOut")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgOut().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsMapSpat_TestSystem.MapReq: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsMapSpat_TestSystem.MapReq");
  }
}

Module_Param* MapReq::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsMapSpat_TestSystem.MapReq'");
    }
    if (strcmp("msgOut", param_field) == 0) {
      return msgOut().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.MapReq'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_msgOut = field_msgOut.get_param(param_name);
  mp_field_msgOut->set_id(new Module_Param_FieldName(mcopystr("msgOut")));
  mp->add_elem(mp_field_msgOut);
  return mp;
  }

void MapReq::set_implicit_omit()
{
if (msgOut().is_bound()) msgOut().set_implicit_omit();
}

void MapReq::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsMapSpat_TestSystem.MapReq.");
field_msgOut.encode_text(text_buf);
}

void MapReq::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_msgOut.decode_text(text_buf);
}

struct MapReq_template::single_value_struct {
MAP__SPAT__ETSI::MAP__PDU_template field_msgOut;
};

void MapReq_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_msgOut = ANY_VALUE;
}
}
}

void MapReq_template::copy_value(const MapReq& other_value)
{
single_value = new single_value_struct;
if (other_value.msgOut().is_bound()) {
  single_value->field_msgOut = other_value.msgOut();
} else {
  single_value->field_msgOut.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void MapReq_template::copy_template(const MapReq_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.msgOut().get_selection()) {
single_value->field_msgOut = other_value.msgOut();
} else {
single_value->field_msgOut.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new MapReq_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.MapReq.");
break;
}
set_selection(other_value);
}

MapReq_template::MapReq_template()
{
}

MapReq_template::MapReq_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

MapReq_template::MapReq_template(const MapReq& other_value)
{
copy_value(other_value);
}

MapReq_template::MapReq_template(const OPTIONAL<MapReq>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MapReq&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsMapSpat_TestSystem.MapReq from an unbound optional field.");
}
}

MapReq_template::MapReq_template(const MapReq_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

MapReq_template::~MapReq_template()
{
clean_up();
}

MapReq_template& MapReq_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

MapReq_template& MapReq_template::operator=(const MapReq& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

MapReq_template& MapReq_template::operator=(const OPTIONAL<MapReq>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const MapReq&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsMapSpat_TestSystem.MapReq.");
}
return *this;
}

MapReq_template& MapReq_template::operator=(const MapReq_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean MapReq_template::match(const MapReq& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.msgOut().is_bound()) return FALSE;
if(!single_value->field_msgOut.match(other_value.msgOut(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.MapReq.");
}
return FALSE;
}

boolean MapReq_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_msgOut.is_bound()) return TRUE;
return FALSE;
}

boolean MapReq_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_msgOut.is_value()) return FALSE;
return TRUE;
}

void MapReq_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

MapReq MapReq_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsMapSpat_TestSystem.MapReq.");
MapReq ret_val;
if (single_value->field_msgOut.is_bound()) {
ret_val.msgOut() = single_value->field_msgOut.valueof();
}
return ret_val;
}

void MapReq_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsMapSpat_TestSystem.MapReq.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new MapReq_template[list_length];
}

MapReq_template& MapReq_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsMapSpat_TestSystem.MapReq.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsMapSpat_TestSystem.MapReq.");
return value_list.list_value[list_index];
}

MAP__SPAT__ETSI::MAP__PDU_template& MapReq_template::msgOut()
{
set_specific();
return single_value->field_msgOut;
}

const MAP__SPAT__ETSI::MAP__PDU_template& MapReq_template::msgOut() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msgOut of a non-specific template of type @LibItsMapSpat_TestSystem.MapReq.");
return single_value->field_msgOut;
}

int MapReq_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapReq which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapReq containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapReq containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapReq containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapReq containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.MapReq containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.MapReq.");
  }
  return 0;
}

void MapReq_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ msgOut := ");
single_value->field_msgOut.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void MapReq_template::log_match(const MapReq& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_msgOut.match(match_value.msgOut(), legacy)){
TTCN_Logger::log_logmatch_info(".msgOut");
single_value->field_msgOut.log_match(match_value.msgOut(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ msgOut := ");
single_value->field_msgOut.log_match(match_value.msgOut(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void MapReq_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_msgOut.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.MapReq.");
}
}

void MapReq_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_msgOut.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new MapReq_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsMapSpat_TestSystem.MapReq.");
}
}

void MapReq_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsMapSpat_TestSystem.MapReq'");
    }
    if (strcmp("msgOut", param_field) == 0) {
      msgOut().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsMapSpat_TestSystem.MapReq'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    MapReq_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsMapSpat_TestSystem.MapReq has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgOut().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgOut")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgOut().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsMapSpat_TestSystem.MapReq: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsMapSpat_TestSystem.MapReq");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* MapReq_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsMapSpat_TestSystem.MapReq'");
    }
    if (strcmp("msgOut", param_field) == 0) {
      return msgOut().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.MapReq'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_msgOut = single_value->field_msgOut.get_param(param_name);
    mp_field_msgOut->set_id(new Module_Param_FieldName(mcopystr("msgOut")));
    mp->add_elem(mp_field_msgOut);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void MapReq_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_msgOut.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.MapReq");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsMapSpat_TestSystem.MapReq");
}

boolean MapReq_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean MapReq_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SpatReq::SpatReq()
{
  bound_flag = FALSE;
}

SpatReq::SpatReq(const MAP__SPAT__ETSI::SPAT__PDU& par_msgOut)
  :   field_msgOut(par_msgOut)
{
  bound_flag = TRUE;
}

SpatReq::SpatReq(const SpatReq& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsMapSpat_TestSystem.SpatReq.");
bound_flag = TRUE;
if (other_value.msgOut().is_bound()) field_msgOut = other_value.msgOut();
else field_msgOut.clean_up();
}

void SpatReq::clean_up()
{
field_msgOut.clean_up();
bound_flag = FALSE;
}

SpatReq& SpatReq::operator=(const SpatReq& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsMapSpat_TestSystem.SpatReq.");
  bound_flag = TRUE;
  if (other_value.msgOut().is_bound()) field_msgOut = other_value.msgOut();
  else field_msgOut.clean_up();
}
return *this;
}

boolean SpatReq::operator==(const SpatReq& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_msgOut==other_value.field_msgOut;
}

boolean SpatReq::is_bound() const
{
if (bound_flag) return TRUE;
if(field_msgOut.is_bound()) return TRUE;
return FALSE;
}
boolean SpatReq::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_msgOut.is_value()) return FALSE;
return TRUE;
}
int SpatReq::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsMapSpat_TestSystem.SpatReq");
  return 1;
}

void SpatReq::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ msgOut := ");
field_msgOut.log();
TTCN_Logger::log_event_str(" }");
}

void SpatReq::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsMapSpat_TestSystem.SpatReq'");
    }
    if (strcmp("msgOut", param_field) == 0) {
      msgOut().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.SpatReq'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsMapSpat_TestSystem.SpatReq has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgOut().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgOut")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgOut().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsMapSpat_TestSystem.SpatReq: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsMapSpat_TestSystem.SpatReq");
  }
}

Module_Param* SpatReq::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsMapSpat_TestSystem.SpatReq'");
    }
    if (strcmp("msgOut", param_field) == 0) {
      return msgOut().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.SpatReq'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_msgOut = field_msgOut.get_param(param_name);
  mp_field_msgOut->set_id(new Module_Param_FieldName(mcopystr("msgOut")));
  mp->add_elem(mp_field_msgOut);
  return mp;
  }

void SpatReq::set_implicit_omit()
{
if (msgOut().is_bound()) msgOut().set_implicit_omit();
}

void SpatReq::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsMapSpat_TestSystem.SpatReq.");
field_msgOut.encode_text(text_buf);
}

void SpatReq::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_msgOut.decode_text(text_buf);
}

struct SpatReq_template::single_value_struct {
MAP__SPAT__ETSI::SPAT__PDU_template field_msgOut;
};

void SpatReq_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_msgOut = ANY_VALUE;
}
}
}

void SpatReq_template::copy_value(const SpatReq& other_value)
{
single_value = new single_value_struct;
if (other_value.msgOut().is_bound()) {
  single_value->field_msgOut = other_value.msgOut();
} else {
  single_value->field_msgOut.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SpatReq_template::copy_template(const SpatReq_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.msgOut().get_selection()) {
single_value->field_msgOut = other_value.msgOut();
} else {
single_value->field_msgOut.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SpatReq_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.SpatReq.");
break;
}
set_selection(other_value);
}

SpatReq_template::SpatReq_template()
{
}

SpatReq_template::SpatReq_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SpatReq_template::SpatReq_template(const SpatReq& other_value)
{
copy_value(other_value);
}

SpatReq_template::SpatReq_template(const OPTIONAL<SpatReq>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SpatReq&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsMapSpat_TestSystem.SpatReq from an unbound optional field.");
}
}

SpatReq_template::SpatReq_template(const SpatReq_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SpatReq_template::~SpatReq_template()
{
clean_up();
}

SpatReq_template& SpatReq_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SpatReq_template& SpatReq_template::operator=(const SpatReq& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SpatReq_template& SpatReq_template::operator=(const OPTIONAL<SpatReq>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SpatReq&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsMapSpat_TestSystem.SpatReq.");
}
return *this;
}

SpatReq_template& SpatReq_template::operator=(const SpatReq_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SpatReq_template::match(const SpatReq& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.msgOut().is_bound()) return FALSE;
if(!single_value->field_msgOut.match(other_value.msgOut(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.SpatReq.");
}
return FALSE;
}

boolean SpatReq_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_msgOut.is_bound()) return TRUE;
return FALSE;
}

boolean SpatReq_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_msgOut.is_value()) return FALSE;
return TRUE;
}

void SpatReq_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SpatReq SpatReq_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsMapSpat_TestSystem.SpatReq.");
SpatReq ret_val;
if (single_value->field_msgOut.is_bound()) {
ret_val.msgOut() = single_value->field_msgOut.valueof();
}
return ret_val;
}

void SpatReq_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsMapSpat_TestSystem.SpatReq.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SpatReq_template[list_length];
}

SpatReq_template& SpatReq_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsMapSpat_TestSystem.SpatReq.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsMapSpat_TestSystem.SpatReq.");
return value_list.list_value[list_index];
}

MAP__SPAT__ETSI::SPAT__PDU_template& SpatReq_template::msgOut()
{
set_specific();
return single_value->field_msgOut;
}

const MAP__SPAT__ETSI::SPAT__PDU_template& SpatReq_template::msgOut() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field msgOut of a non-specific template of type @LibItsMapSpat_TestSystem.SpatReq.");
return single_value->field_msgOut;
}

int SpatReq_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatReq which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatReq containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatReq containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatReq containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatReq containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsMapSpat_TestSystem.SpatReq containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.SpatReq.");
  }
  return 0;
}

void SpatReq_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ msgOut := ");
single_value->field_msgOut.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SpatReq_template::log_match(const SpatReq& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_msgOut.match(match_value.msgOut(), legacy)){
TTCN_Logger::log_logmatch_info(".msgOut");
single_value->field_msgOut.log_match(match_value.msgOut(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ msgOut := ");
single_value->field_msgOut.log_match(match_value.msgOut(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SpatReq_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_msgOut.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsMapSpat_TestSystem.SpatReq.");
}
}

void SpatReq_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_msgOut.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SpatReq_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsMapSpat_TestSystem.SpatReq.");
}
}

void SpatReq_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsMapSpat_TestSystem.SpatReq'");
    }
    if (strcmp("msgOut", param_field) == 0) {
      msgOut().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsMapSpat_TestSystem.SpatReq'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SpatReq_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsMapSpat_TestSystem.SpatReq has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) msgOut().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "msgOut")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          msgOut().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsMapSpat_TestSystem.SpatReq: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsMapSpat_TestSystem.SpatReq");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SpatReq_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsMapSpat_TestSystem.SpatReq'");
    }
    if (strcmp("msgOut", param_field) == 0) {
      return msgOut().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsMapSpat_TestSystem.SpatReq'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_msgOut = single_value->field_msgOut.get_param(param_name);
    mp_field_msgOut->set_id(new Module_Param_FieldName(mcopystr("msgOut")));
    mp->add_elem(mp_field_msgOut);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SpatReq_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_msgOut.check_restriction(t_res, t_name ? t_name : "@LibItsMapSpat_TestSystem.SpatReq");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsMapSpat_TestSystem.SpatReq");
}

boolean SpatReq_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SpatReq_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("LibItsMapSpat_TestSystem.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "LibItsMapSpat_TestSystem");
LibItsCommon__TestSystem::module_object.pre_init_module();
LibItsMapSpat__TypesAndValues::module_object.pre_init_module();
}

static void post_init_module()
{
TTCN_Location current_location("LibItsMapSpat_TestSystem.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "LibItsMapSpat_TestSystem");
LibItsCommon__TestSystem::module_object.post_init_module();
LibItsMapSpat__TypesAndValues::module_object.post_init_module();
}

static boolean init_comp_type(const char *component_type, boolean init_base_comps)
{
(void)init_base_comps;
if (!strcmp(component_type, "ItsMapSpatSystem")) {
ItsMapSpatSystem_component_utPort.activate_port();
ItsMapSpatSystem_component_mapSpatPort.activate_port();
return TRUE;
} else if (!strcmp(component_type, "ItsMapSpat")) {
if (init_base_comps) {
Module_List::initialize_component("LibCommon_Sync", "BaseSyncComp", FALSE);
Module_List::initialize_component("LibCommon_Sync", "ClientSyncComp", FALSE);
Module_List::initialize_component("LibCommon_Sync", "SelfSyncComp", FALSE);
Module_List::initialize_component("LibItsCommon_TestSystem", "ItsBaseComponent", FALSE);
}
ItsMapSpat_component_utPort.activate_port();
ItsMapSpat_component_mapSpatPort.activate_port();
ItsMapSpat_component_vc__mapMsg.clean_up();
ItsMapSpat_component_vc__spatMsg.clean_up();
ItsMapSpat_component_vc__utMapEvents = NULL_VALUE;
ItsMapSpat_component_vc__utSpatEvents = NULL_VALUE;
ItsMapSpat_component_vc__default = NULL_COMPREF;
ItsMapSpat_component_vc__mapReceived = FALSE;
ItsMapSpat_component_vc__spatReceived = FALSE;
return TRUE;
} else return FALSE;
}


} /* end of namespace */
