// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "LibItsSecurity_TypesAndValues.hh"

namespace LibItsSecurity__TypesAndValues {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();

/* Literal string constants */

static const unsigned char module_checksum[] = { 0xf7, 0xf5, 0x65, 0xc9, 0x79, 0x41, 0x5a, 0x9f, 0x90, 0xd5, 0x6a, 0x1e, 0xbd, 0x00, 0xe6, 0x3a };

/* Global variable definitions */

const TTCN_RAWdescriptor_t IntX_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       IntX_xer_ = { {"IntX>\n", "IntX>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IntX_descr_ = { "@LibItsSecurity_TypesAndValues.IntX", &INTEGER_ber_, &IntX_raw_, &INTEGER_text_, &IntX_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t PublicKeyAlgorithm_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for PublicKeyAlgorithm
const TTCN_JSONdescriptor_t PublicKeyAlgorithm_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t PublicKeyAlgorithm_descr_ = { "@LibItsSecurity_TypesAndValues.PublicKeyAlgorithm", NULL, &PublicKeyAlgorithm_raw_, NULL, NULL, &PublicKeyAlgorithm_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SymmetricAlgorithm_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SymmetricAlgorithm
const TTCN_JSONdescriptor_t SymmetricAlgorithm_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SymmetricAlgorithm_descr_ = { "@LibItsSecurity_TypesAndValues.SymmetricAlgorithm", NULL, &SymmetricAlgorithm_raw_, NULL, NULL, &SymmetricAlgorithm_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t PublicKeyContainer_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for PublicKeyContainer
const TTCN_JSONdescriptor_t PublicKeyContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t PublicKeyContainer_descr_ = { "@LibItsSecurity_TypesAndValues.PublicKeyContainer", NULL, &PublicKeyContainer_raw_, NULL, NULL, &PublicKeyContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t EccPointType_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for EccPointType
const TTCN_JSONdescriptor_t EccPointType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t EccPointType_descr_ = { "@LibItsSecurity_TypesAndValues.EccPointType", NULL, &EccPointType_raw_, NULL, NULL, &EccPointType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       EccPoint_x_xer_ = { {"x>\n", "x>\n"}, {3, 3}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t EccPoint_x_descr_ = { "@LibItsSecurity_TypesAndValues.EccPoint.x", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &EccPoint_x_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t EccPoint_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for EccPoint
const TTCN_JSONdescriptor_t EccPoint_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t EccPoint_descr_ = { "@LibItsSecurity_TypesAndValues.EccPoint", NULL, &EccPoint_raw_, NULL, NULL, &EccPoint_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t EccPointContainer_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for EccPointContainer
const TTCN_JSONdescriptor_t EccPointContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t EccPointContainer_descr_ = { "@LibItsSecurity_TypesAndValues.EccPointContainer", NULL, &EccPointContainer_raw_, NULL, NULL, &EccPointContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       EccPointContainer_y_xer_ = { {"y>\n", "y>\n"}, {3, 3}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t EccPointContainer_y_descr_ = { "@LibItsSecurity_TypesAndValues.EccPointContainer.y", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &EccPointContainer_y_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       EccPointContainer_data_xer_ = { {"data>\n", "data>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t EccPointContainer_data_descr_ = { "@LibItsSecurity_TypesAndValues.EccPointContainer.data", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &EccPointContainer_data_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AesCcm_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AesCcm
const TTCN_JSONdescriptor_t AesCcm_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AesCcm_descr_ = { "@LibItsSecurity_TypesAndValues.AesCcm", NULL, &AesCcm_raw_, NULL, NULL, &AesCcm_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       PublicKeyContainer_other__key_xer_ = { {"other_key>\n", "other_key>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t PublicKeyContainer_other__key_descr_ = { "@LibItsSecurity_TypesAndValues.PublicKeyContainer.other_key", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &PublicKeyContainer_other__key_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t PublicKey_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for PublicKey
const TTCN_JSONdescriptor_t PublicKey_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t PublicKey_descr_ = { "@LibItsSecurity_TypesAndValues.PublicKey", NULL, &PublicKey_raw_, NULL, NULL, &PublicKey_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t EncryptionParametersContainer_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for EncryptionParametersContainer
const TTCN_JSONdescriptor_t EncryptionParametersContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t EncryptionParametersContainer_descr_ = { "@LibItsSecurity_TypesAndValues.EncryptionParametersContainer", NULL, &EncryptionParametersContainer_raw_, NULL, NULL, &EncryptionParametersContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       EncryptionParametersContainer_nonce_xer_ = { {"nonce>\n", "nonce>\n"}, {7, 7}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t EncryptionParametersContainer_nonce_descr_ = { "@LibItsSecurity_TypesAndValues.EncryptionParametersContainer.nonce", &OCTETSTRING_ber_, &LibCommon__DataStrings::Oct12_raw_, &OCTETSTRING_text_, &EncryptionParametersContainer_nonce_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       EncryptionParametersContainer_params_xer_ = { {"params>\n", "params>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t EncryptionParametersContainer_params_descr_ = { "@LibItsSecurity_TypesAndValues.EncryptionParametersContainer.params", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &EncryptionParametersContainer_params_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t EncryptionParameters_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for EncryptionParameters
const TTCN_JSONdescriptor_t EncryptionParameters_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t EncryptionParameters_descr_ = { "@LibItsSecurity_TypesAndValues.EncryptionParameters", NULL, &EncryptionParameters_raw_, NULL, NULL, &EncryptionParameters_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SignatureContainer_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SignatureContainer
const TTCN_JSONdescriptor_t SignatureContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SignatureContainer_descr_ = { "@LibItsSecurity_TypesAndValues.SignatureContainer", NULL, &SignatureContainer_raw_, NULL, NULL, &SignatureContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       EcdsaSignature_s_xer_ = { {"s>\n", "s>\n"}, {3, 3}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t EcdsaSignature_s_descr_ = { "@LibItsSecurity_TypesAndValues.EcdsaSignature.s", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &EcdsaSignature_s_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t EcdsaSignature_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for EcdsaSignature
const TTCN_JSONdescriptor_t EcdsaSignature_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t EcdsaSignature_descr_ = { "@LibItsSecurity_TypesAndValues.EcdsaSignature", NULL, &EcdsaSignature_raw_, NULL, NULL, &EcdsaSignature_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SignatureContainer_signature___xer_ = { {"signature_>\n", "signature_>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SignatureContainer_signature___descr_ = { "@LibItsSecurity_TypesAndValues.SignatureContainer.signature_", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &SignatureContainer_signature___xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t Signature_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for Signature
const TTCN_JSONdescriptor_t Signature_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Signature_descr_ = { "@LibItsSecurity_TypesAndValues.Signature", NULL, &Signature_raw_, NULL, NULL, &Signature_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SignerInfoType_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SignerInfoType
const TTCN_JSONdescriptor_t SignerInfoType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SignerInfoType_descr_ = { "@LibItsSecurity_TypesAndValues.SignerInfoType", NULL, &SignerInfoType_raw_, NULL, NULL, &SignerInfoType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SignerInfo_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SignerInfo
const TTCN_JSONdescriptor_t SignerInfo_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SignerInfo_descr_ = { "@LibItsSecurity_TypesAndValues.SignerInfo", NULL, &SignerInfo_raw_, NULL, NULL, &SignerInfo_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SignerInfoContainer_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SignerInfoContainer
const TTCN_JSONdescriptor_t SignerInfoContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SignerInfoContainer_descr_ = { "@LibItsSecurity_TypesAndValues.SignerInfoContainer", NULL, &SignerInfoContainer_raw_, NULL, NULL, &SignerInfoContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t HashedId8_raw_ = {64,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,8};
const XERdescriptor_t       HashedId8_xer_ = { {"HashedId8>\n", "HashedId8>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t HashedId8_descr_ = { "@LibItsSecurity_TypesAndValues.HashedId8", &OCTETSTRING_ber_, &HashedId8_raw_, &OCTETSTRING_text_, &HashedId8_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SignerInfoContainer_digest_xer_ = { {"digest>\n", "digest>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SignerInfoContainer_digest_descr_ = { "@LibItsSecurity_TypesAndValues.SignerInfoContainer.digest", &OCTETSTRING_ber_, &HashedId8_raw_, &OCTETSTRING_text_, &SignerInfoContainer_digest_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Certificate_version_xer_ = { {"version>\n", "version>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Certificate_version_descr_ = { "@LibItsSecurity_TypesAndValues.Certificate.version", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &Certificate_version_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SubjectType_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SubjectType
const TTCN_JSONdescriptor_t SubjectType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SubjectType_descr_ = { "@LibItsSecurity_TypesAndValues.SubjectType", NULL, &SubjectType_raw_, NULL, NULL, &SubjectType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SubjectInfo_subject__name_xer_ = { {"subject_name>\n", "subject_name>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SubjectInfo_subject__name_descr_ = { "@LibItsSecurity_TypesAndValues.SubjectInfo.subject_name", &OCTETSTRING_ber_, &LibCommon__DataStrings::Oct0to31_raw_, &OCTETSTRING_text_, &SubjectInfo_subject__name_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SubjectInfo_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SubjectInfo
const TTCN_JSONdescriptor_t SubjectInfo_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SubjectInfo_descr_ = { "@LibItsSecurity_TypesAndValues.SubjectInfo", NULL, &SubjectInfo_raw_, NULL, NULL, &SubjectInfo_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SubjectAttributes_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SubjectAttributes
const TTCN_JSONdescriptor_t SubjectAttributes_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SubjectAttributes_descr_ = { "@LibItsSecurity_TypesAndValues.SubjectAttributes", NULL, &SubjectAttributes_raw_, NULL, NULL, &SubjectAttributes_json_, &SubjectAttribute_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SubjectAttributeType_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SubjectAttributeType
const TTCN_JSONdescriptor_t SubjectAttributeType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SubjectAttributeType_descr_ = { "@LibItsSecurity_TypesAndValues.SubjectAttributeType", NULL, &SubjectAttributeType_raw_, NULL, NULL, &SubjectAttributeType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SubjectAttributeContainer_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SubjectAttributeContainer
const TTCN_JSONdescriptor_t SubjectAttributeContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SubjectAttributeContainer_descr_ = { "@LibItsSecurity_TypesAndValues.SubjectAttributeContainer", NULL, &SubjectAttributeContainer_raw_, NULL, NULL, &SubjectAttributeContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SubjectAssurance_levels_xer_ = { {"levels>\n", "levels>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SubjectAssurance_levels_descr_ = { "@LibItsSecurity_TypesAndValues.SubjectAssurance.levels", &BITSTRING_ber_, &LibCommon__DataStrings::Bit3_raw_, NULL, &SubjectAssurance_levels_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SubjectAssurance_reserved_xer_ = { {"reserved>\n", "reserved>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SubjectAssurance_reserved_descr_ = { "@LibItsSecurity_TypesAndValues.SubjectAssurance.reserved", &BITSTRING_ber_, &LibCommon__DataStrings::Bit3_raw_, NULL, &SubjectAssurance_reserved_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SubjectAssurance_confidence_xer_ = { {"confidence>\n", "confidence>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SubjectAssurance_confidence_descr_ = { "@LibItsSecurity_TypesAndValues.SubjectAssurance.confidence", &BITSTRING_ber_, &LibCommon__DataStrings::Bit2_raw_, NULL, &SubjectAssurance_confidence_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SubjectAssurance_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SubjectAssurance
const TTCN_JSONdescriptor_t SubjectAssurance_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SubjectAssurance_descr_ = { "@LibItsSecurity_TypesAndValues.SubjectAssurance", NULL, &SubjectAssurance_raw_, NULL, NULL, &SubjectAssurance_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IntXs_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IntXs
const TTCN_JSONdescriptor_t IntXs_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t IntXs_descr_ = { "@LibItsSecurity_TypesAndValues.IntXs", NULL, &IntXs_raw_, NULL, NULL, &IntXs_json_, &IntX_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IntXs_0_xer_ = { {"IntX>\n", "IntX>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IntXs_0_descr_ = { "@LibItsSecurity_TypesAndValues.IntXs.<oftype>", &INTEGER_ber_, &IntX_raw_, &INTEGER_text_, &IntXs_0_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ItsAidSsps_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ItsAidSsps
const TTCN_JSONdescriptor_t ItsAidSsps_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ItsAidSsps_descr_ = { "@LibItsSecurity_TypesAndValues.ItsAidSsps", NULL, &ItsAidSsps_raw_, NULL, NULL, &ItsAidSsps_json_, &ItsAidSsp_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ItsAidSsp_its__aid_xer_ = { {"its_aid>\n", "its_aid>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ItsAidSsp_its__aid_descr_ = { "@LibItsSecurity_TypesAndValues.ItsAidSsp.its_aid", &INTEGER_ber_, &IntX_raw_, &INTEGER_text_, &ItsAidSsp_its__aid_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ServiceSpecificPermissions_version_xer_ = { {"version>\n", "version>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ServiceSpecificPermissions_version_descr_ = { "@LibItsSecurity_TypesAndValues.ServiceSpecificPermissions.version", &OCTETSTRING_ber_, &LibCommon__DataStrings::Oct1_raw_, &OCTETSTRING_text_, &ServiceSpecificPermissions_version_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ServiceSpecificPermissions_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ServiceSpecificPermissions
const TTCN_JSONdescriptor_t ServiceSpecificPermissions_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ServiceSpecificPermissions_descr_ = { "@LibItsSecurity_TypesAndValues.ServiceSpecificPermissions", NULL, &ServiceSpecificPermissions_raw_, NULL, NULL, &ServiceSpecificPermissions_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ServiceSpecificPermissionsContainer_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ServiceSpecificPermissionsContainer
const TTCN_JSONdescriptor_t ServiceSpecificPermissionsContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ServiceSpecificPermissionsContainer_descr_ = { "@LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer", NULL, &ServiceSpecificPermissionsContainer_raw_, NULL, NULL, &ServiceSpecificPermissionsContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspCAM_cenDsrcTollingZone_xer_ = { {"cenDsrcTollingZone>\n", "cenDsrcTollingZone>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspCAM_cenDsrcTollingZone_descr_ = { "@LibItsSecurity_TypesAndValues.SspCAM.cenDsrcTollingZone", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspCAM_cenDsrcTollingZone_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspCAM_publicTransport_xer_ = { {"publicTransport>\n", "publicTransport>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspCAM_publicTransport_descr_ = { "@LibItsSecurity_TypesAndValues.SspCAM.publicTransport", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspCAM_publicTransport_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspCAM_specialTransport_xer_ = { {"specialTransport>\n", "specialTransport>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspCAM_specialTransport_descr_ = { "@LibItsSecurity_TypesAndValues.SspCAM.specialTransport", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspCAM_specialTransport_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspCAM_dangerousGoods_xer_ = { {"dangerousGoods>\n", "dangerousGoods>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspCAM_dangerousGoods_descr_ = { "@LibItsSecurity_TypesAndValues.SspCAM.dangerousGoods", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspCAM_dangerousGoods_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspCAM_roadwork_xer_ = { {"roadwork>\n", "roadwork>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspCAM_roadwork_descr_ = { "@LibItsSecurity_TypesAndValues.SspCAM.roadwork", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspCAM_roadwork_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspCAM_rescue_xer_ = { {"rescue>\n", "rescue>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspCAM_rescue_descr_ = { "@LibItsSecurity_TypesAndValues.SspCAM.rescue", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspCAM_rescue_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspCAM_emergency_xer_ = { {"emergency>\n", "emergency>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspCAM_emergency_descr_ = { "@LibItsSecurity_TypesAndValues.SspCAM.emergency", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspCAM_emergency_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspCAM_safetyCar_xer_ = { {"safetyCar>\n", "safetyCar>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspCAM_safetyCar_descr_ = { "@LibItsSecurity_TypesAndValues.SspCAM.safetyCar", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspCAM_safetyCar_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspCAM_closedLanes_xer_ = { {"closedLanes>\n", "closedLanes>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspCAM_closedLanes_descr_ = { "@LibItsSecurity_TypesAndValues.SspCAM.closedLanes", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspCAM_closedLanes_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspCAM_requestForRightOfWay_xer_ = { {"requestForRightOfWay>\n", "requestForRightOfWay>\n"}, {22, 22}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspCAM_requestForRightOfWay_descr_ = { "@LibItsSecurity_TypesAndValues.SspCAM.requestForRightOfWay", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspCAM_requestForRightOfWay_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspCAM_requestForFreeCrossingAtATrafficLight_xer_ = { {"requestForFreeCrossingAtATrafficLight>\n", "requestForFreeCrossingAtATrafficLight>\n"}, {39, 39}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspCAM_requestForFreeCrossingAtATrafficLight_descr_ = { "@LibItsSecurity_TypesAndValues.SspCAM.requestForFreeCrossingAtATrafficLight", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspCAM_requestForFreeCrossingAtATrafficLight_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspCAM_noPassing_xer_ = { {"noPassing>\n", "noPassing>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspCAM_noPassing_descr_ = { "@LibItsSecurity_TypesAndValues.SspCAM.noPassing", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspCAM_noPassing_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspCAM_noPassingForTrucks_xer_ = { {"noPassingForTrucks>\n", "noPassingForTrucks>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspCAM_noPassingForTrucks_descr_ = { "@LibItsSecurity_TypesAndValues.SspCAM.noPassingForTrucks", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspCAM_noPassingForTrucks_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspCAM_speedLimit_xer_ = { {"speedLimit>\n", "speedLimit>\n"}, {12, 12}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspCAM_speedLimit_descr_ = { "@LibItsSecurity_TypesAndValues.SspCAM.speedLimit", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspCAM_speedLimit_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspCAM_reserved1_xer_ = { {"reserved1>\n", "reserved1>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspCAM_reserved1_descr_ = { "@LibItsSecurity_TypesAndValues.SspCAM.reserved1", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspCAM_reserved1_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspCAM_reserved2_xer_ = { {"reserved2>\n", "reserved2>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspCAM_reserved2_descr_ = { "@LibItsSecurity_TypesAndValues.SspCAM.reserved2", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspCAM_reserved2_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SspCAM_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SspCAM
const TTCN_JSONdescriptor_t SspCAM_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SspCAM_descr_ = { "@LibItsSecurity_TypesAndValues.SspCAM", NULL, &SspCAM_raw_, NULL, NULL, &SspCAM_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_trafficCondition_xer_ = { {"trafficCondition>\n", "trafficCondition>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_trafficCondition_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.trafficCondition", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_trafficCondition_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_accident_xer_ = { {"accident>\n", "accident>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_accident_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.accident", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_accident_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_roadworks_xer_ = { {"roadworks>\n", "roadworks>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_roadworks_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.roadworks", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_roadworks_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_adverseWeatherCondition__Adhesion_xer_ = { {"adverseWeatherCondition_Adhesion>\n", "adverseWeatherCondition_Adhesion>\n"}, {34, 34}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_adverseWeatherCondition__Adhesion_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.adverseWeatherCondition_Adhesion", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_adverseWeatherCondition__Adhesion_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_hazardousLocation__SurfaceCondition_xer_ = { {"hazardousLocation_SurfaceCondition>\n", "hazardousLocation_SurfaceCondition>\n"}, {36, 36}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_hazardousLocation__SurfaceCondition_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.hazardousLocation_SurfaceCondition", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_hazardousLocation__SurfaceCondition_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_hazardousLocation__ObstacleOnTheRoad_xer_ = { {"hazardousLocation_ObstacleOnTheRoad>\n", "hazardousLocation_ObstacleOnTheRoad>\n"}, {37, 37}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_hazardousLocation__ObstacleOnTheRoad_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.hazardousLocation_ObstacleOnTheRoad", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_hazardousLocation__ObstacleOnTheRoad_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_hazardousLocation__AnimalOnTheRoad_xer_ = { {"hazardousLocation_AnimalOnTheRoad>\n", "hazardousLocation_AnimalOnTheRoad>\n"}, {35, 35}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_hazardousLocation__AnimalOnTheRoad_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.hazardousLocation_AnimalOnTheRoad", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_hazardousLocation__AnimalOnTheRoad_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_humanPresenceOnTheRoad_xer_ = { {"humanPresenceOnTheRoad>\n", "humanPresenceOnTheRoad>\n"}, {24, 24}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_humanPresenceOnTheRoad_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.humanPresenceOnTheRoad", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_humanPresenceOnTheRoad_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_wrongWayDriving_xer_ = { {"wrongWayDriving>\n", "wrongWayDriving>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_wrongWayDriving_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.wrongWayDriving", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_wrongWayDriving_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_rescueAndRecoveryWorkInProgress_xer_ = { {"rescueAndRecoveryWorkInProgress>\n", "rescueAndRecoveryWorkInProgress>\n"}, {33, 33}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_rescueAndRecoveryWorkInProgress_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.rescueAndRecoveryWorkInProgress", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_rescueAndRecoveryWorkInProgress_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_adverseWeatherCondition__ExtremeWeatherCondition_xer_ = { {"adverseWeatherCondition_ExtremeWeatherCondition>\n", "adverseWeatherCondition_ExtremeWeatherCondition>\n"}, {49, 49}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_adverseWeatherCondition__ExtremeWeatherCondition_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.adverseWeatherCondition_ExtremeWeatherCondition", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_adverseWeatherCondition__ExtremeWeatherCondition_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_adverseWeatherCondition__Visibility_xer_ = { {"adverseWeatherCondition_Visibility>\n", "adverseWeatherCondition_Visibility>\n"}, {36, 36}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_adverseWeatherCondition__Visibility_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.adverseWeatherCondition_Visibility", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_adverseWeatherCondition__Visibility_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_adverseWeatherCondition__Precipitation_xer_ = { {"adverseWeatherCondition_Precipitation>\n", "adverseWeatherCondition_Precipitation>\n"}, {39, 39}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_adverseWeatherCondition__Precipitation_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.adverseWeatherCondition_Precipitation", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_adverseWeatherCondition__Precipitation_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_slowVehicle_xer_ = { {"slowVehicle>\n", "slowVehicle>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_slowVehicle_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.slowVehicle", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_slowVehicle_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_dangerousEndOfQueue_xer_ = { {"dangerousEndOfQueue>\n", "dangerousEndOfQueue>\n"}, {21, 21}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_dangerousEndOfQueue_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.dangerousEndOfQueue", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_dangerousEndOfQueue_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_vehicleBreakdown_xer_ = { {"vehicleBreakdown>\n", "vehicleBreakdown>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_vehicleBreakdown_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.vehicleBreakdown", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_vehicleBreakdown_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_postCrash_xer_ = { {"postCrash>\n", "postCrash>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_postCrash_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.postCrash", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_postCrash_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_humanProblem_xer_ = { {"humanProblem>\n", "humanProblem>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_humanProblem_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.humanProblem", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_humanProblem_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_stationaryVehicle_xer_ = { {"stationaryVehicle>\n", "stationaryVehicle>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_stationaryVehicle_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.stationaryVehicle", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_stationaryVehicle_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_emergencyVehicleApproaching_xer_ = { {"emergencyVehicleApproaching>\n", "emergencyVehicleApproaching>\n"}, {29, 29}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_emergencyVehicleApproaching_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.emergencyVehicleApproaching", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_emergencyVehicleApproaching_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_hazardousLocation__DangerousCurve_xer_ = { {"hazardousLocation_DangerousCurve>\n", "hazardousLocation_DangerousCurve>\n"}, {34, 34}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_hazardousLocation__DangerousCurve_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.hazardousLocation_DangerousCurve", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_hazardousLocation__DangerousCurve_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_collisionRisk_xer_ = { {"collisionRisk>\n", "collisionRisk>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_collisionRisk_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.collisionRisk", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_collisionRisk_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_signalViolation_xer_ = { {"signalViolation>\n", "signalViolation>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_signalViolation_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.signalViolation", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_signalViolation_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SspDENM_dangerousSituation_xer_ = { {"dangerousSituation>\n", "dangerousSituation>\n"}, {20, 20}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SspDENM_dangerousSituation_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM.dangerousSituation", &BITSTRING_ber_, &LibCommon__DataStrings::Bit1_raw_, NULL, &SspDENM_dangerousSituation_xer_, &BITSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SspDENM_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SspDENM
const TTCN_JSONdescriptor_t SspDENM_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SspDENM_descr_ = { "@LibItsSecurity_TypesAndValues.SspDENM", NULL, &SspDENM_raw_, NULL, NULL, &SspDENM_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ServiceSpecificPermissionsContainer_opaque_xer_ = { {"opaque>\n", "opaque>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ServiceSpecificPermissionsContainer_opaque_descr_ = { "@LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.opaque", &OCTETSTRING_ber_, &LibCommon__DataStrings::Oct0to30_raw_, &OCTETSTRING_text_, &ServiceSpecificPermissionsContainer_opaque_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ItsAidSsp_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ItsAidSsp
const TTCN_JSONdescriptor_t ItsAidSsp_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ItsAidSsp_descr_ = { "@LibItsSecurity_TypesAndValues.ItsAidSsp", NULL, &ItsAidSsp_raw_, NULL, NULL, &ItsAidSsp_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SubjectAttributeContainer_other__attribute_xer_ = { {"other_attribute>\n", "other_attribute>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SubjectAttributeContainer_other__attribute_descr_ = { "@LibItsSecurity_TypesAndValues.SubjectAttributeContainer.other_attribute", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &SubjectAttributeContainer_other__attribute_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SubjectAttribute_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SubjectAttribute
const TTCN_JSONdescriptor_t SubjectAttribute_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SubjectAttribute_descr_ = { "@LibItsSecurity_TypesAndValues.SubjectAttribute", NULL, &SubjectAttribute_raw_, NULL, NULL, &SubjectAttribute_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ValidityRestrictions_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ValidityRestrictions
const TTCN_JSONdescriptor_t ValidityRestrictions_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ValidityRestrictions_descr_ = { "@LibItsSecurity_TypesAndValues.ValidityRestrictions", NULL, &ValidityRestrictions_raw_, NULL, NULL, &ValidityRestrictions_json_, &ValidityRestriction_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ValidityRestrictionType_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ValidityRestrictionType
const TTCN_JSONdescriptor_t ValidityRestrictionType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ValidityRestrictionType_descr_ = { "@LibItsSecurity_TypesAndValues.ValidityRestrictionType", NULL, &ValidityRestrictionType_raw_, NULL, NULL, &ValidityRestrictionType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ValidityRestrictionContainer_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ValidityRestrictionContainer
const TTCN_JSONdescriptor_t ValidityRestrictionContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ValidityRestrictionContainer_descr_ = { "@LibItsSecurity_TypesAndValues.ValidityRestrictionContainer", NULL, &ValidityRestrictionContainer_raw_, NULL, NULL, &ValidityRestrictionContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t Time32_raw_ = {32,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       Time32_xer_ = { {"Time32>\n", "Time32>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Time32_descr_ = { "@LibItsSecurity_TypesAndValues.Time32", &INTEGER_ber_, &Time32_raw_, &INTEGER_text_, &Time32_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ValidityRestrictionContainer_end__validity_xer_ = { {"end_validity>\n", "end_validity>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ValidityRestrictionContainer_end__validity_descr_ = { "@LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.end_validity", &INTEGER_ber_, &Time32_raw_, &INTEGER_text_, &ValidityRestrictionContainer_end__validity_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       TimeStartEnd_start__validity_xer_ = { {"start_validity>\n", "start_validity>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t TimeStartEnd_start__validity_descr_ = { "@LibItsSecurity_TypesAndValues.TimeStartEnd.start_validity", &INTEGER_ber_, &Time32_raw_, &INTEGER_text_, &TimeStartEnd_start__validity_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       TimeStartEnd_end__validity_xer_ = { {"end_validity>\n", "end_validity>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t TimeStartEnd_end__validity_descr_ = { "@LibItsSecurity_TypesAndValues.TimeStartEnd.end_validity", &INTEGER_ber_, &Time32_raw_, &INTEGER_text_, &TimeStartEnd_end__validity_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t TimeStartEnd_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for TimeStartEnd
const TTCN_JSONdescriptor_t TimeStartEnd_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t TimeStartEnd_descr_ = { "@LibItsSecurity_TypesAndValues.TimeStartEnd", NULL, &TimeStartEnd_raw_, NULL, NULL, &TimeStartEnd_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       TimeDuration_start__validity_xer_ = { {"start_validity>\n", "start_validity>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t TimeDuration_start__validity_descr_ = { "@LibItsSecurity_TypesAndValues.TimeDuration.start_validity", &INTEGER_ber_, &Time32_raw_, &INTEGER_text_, &TimeDuration_start__validity_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t DurationUnitType_raw_ = {3,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for DurationUnitType
const TTCN_JSONdescriptor_t DurationUnitType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t DurationUnitType_descr_ = { "@LibItsSecurity_TypesAndValues.DurationUnitType", NULL, &DurationUnitType_raw_, NULL, NULL, &DurationUnitType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Duration_duration_xer_ = { {"duration>\n", "duration>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Duration_duration_descr_ = { "@LibItsSecurity_TypesAndValues.Duration.duration", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::Int13_raw_, &INTEGER_text_, &Duration_duration_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t Duration_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for Duration
const TTCN_JSONdescriptor_t Duration_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Duration_descr_ = { "@LibItsSecurity_TypesAndValues.Duration", NULL, &Duration_raw_, NULL, NULL, &Duration_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t TimeDuration_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for TimeDuration
const TTCN_JSONdescriptor_t TimeDuration_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t TimeDuration_descr_ = { "@LibItsSecurity_TypesAndValues.TimeDuration", NULL, &TimeDuration_raw_, NULL, NULL, &TimeDuration_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t RegionType_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for RegionType
const TTCN_JSONdescriptor_t RegionType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RegionType_descr_ = { "@LibItsSecurity_TypesAndValues.RegionType", NULL, &RegionType_raw_, NULL, NULL, &RegionType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeographicRegion_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeographicRegion
const TTCN_JSONdescriptor_t GeographicRegion_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GeographicRegion_descr_ = { "@LibItsSecurity_TypesAndValues.GeographicRegion", NULL, &GeographicRegion_raw_, NULL, NULL, &GeographicRegion_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t GeographicRegionContainer_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for GeographicRegionContainer
const TTCN_JSONdescriptor_t GeographicRegionContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t GeographicRegionContainer_descr_ = { "@LibItsSecurity_TypesAndValues.GeographicRegionContainer", NULL, &GeographicRegionContainer_raw_, NULL, NULL, &GeographicRegionContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t WGSLatitude_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       WGSLatitude_xer_ = { {"WGSLatitude>\n", "WGSLatitude>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t WGSLatitude_descr_ = { "@LibItsSecurity_TypesAndValues.WGSLatitude", &INTEGER_ber_, &WGSLatitude_raw_, &INTEGER_text_, &WGSLatitude_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       TwoDLocation_latitude_xer_ = { {"latitude>\n", "latitude>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t TwoDLocation_latitude_descr_ = { "@LibItsSecurity_TypesAndValues.TwoDLocation.latitude", &INTEGER_ber_, &WGSLatitude_raw_, &INTEGER_text_, &TwoDLocation_latitude_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t WGSLongitude_raw_ = {32,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       WGSLongitude_xer_ = { {"WGSLongitude>\n", "WGSLongitude>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t WGSLongitude_descr_ = { "@LibItsSecurity_TypesAndValues.WGSLongitude", &INTEGER_ber_, &WGSLongitude_raw_, &INTEGER_text_, &WGSLongitude_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       TwoDLocation_longitude_xer_ = { {"longitude>\n", "longitude>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t TwoDLocation_longitude_descr_ = { "@LibItsSecurity_TypesAndValues.TwoDLocation.longitude", &INTEGER_ber_, &WGSLongitude_raw_, &INTEGER_text_, &TwoDLocation_longitude_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t TwoDLocation_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for TwoDLocation
const TTCN_JSONdescriptor_t TwoDLocation_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t TwoDLocation_descr_ = { "@LibItsSecurity_TypesAndValues.TwoDLocation", NULL, &TwoDLocation_raw_, NULL, NULL, &TwoDLocation_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CircularRegion_radius_xer_ = { {"radius>\n", "radius>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t CircularRegion_radius_descr_ = { "@LibItsSecurity_TypesAndValues.CircularRegion.radius", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &CircularRegion_radius_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t CircularRegion_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for CircularRegion
const TTCN_JSONdescriptor_t CircularRegion_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t CircularRegion_descr_ = { "@LibItsSecurity_TypesAndValues.CircularRegion", NULL, &CircularRegion_raw_, NULL, NULL, &CircularRegion_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t RectangularRegions_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for RectangularRegions
const TTCN_JSONdescriptor_t RectangularRegions_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RectangularRegions_descr_ = { "@LibItsSecurity_TypesAndValues.RectangularRegions", NULL, &RectangularRegions_raw_, NULL, NULL, &RectangularRegions_json_, &RectangularRegion_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t RectangularRegion_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for RectangularRegion
const TTCN_JSONdescriptor_t RectangularRegion_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RectangularRegion_descr_ = { "@LibItsSecurity_TypesAndValues.RectangularRegion", NULL, &RectangularRegion_raw_, NULL, NULL, &RectangularRegion_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t PolygonalRegion_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for PolygonalRegion
const TTCN_JSONdescriptor_t PolygonalRegion_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t PolygonalRegion_descr_ = { "@LibItsSecurity_TypesAndValues.PolygonalRegion", NULL, &PolygonalRegion_raw_, NULL, NULL, &PolygonalRegion_json_, &TwoDLocation_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t RegionDictionary_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for RegionDictionary
const TTCN_JSONdescriptor_t RegionDictionary_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RegionDictionary_descr_ = { "@LibItsSecurity_TypesAndValues.RegionDictionary", NULL, &RegionDictionary_raw_, NULL, NULL, &RegionDictionary_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IdentifiedRegion_region__identifier_xer_ = { {"region_identifier>\n", "region_identifier>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IdentifiedRegion_region__identifier_descr_ = { "@LibItsSecurity_TypesAndValues.IdentifiedRegion.region_identifier", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &IdentifiedRegion_region__identifier_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       IdentifiedRegion_local__region_xer_ = { {"local_region>\n", "local_region>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t IdentifiedRegion_local__region_descr_ = { "@LibItsSecurity_TypesAndValues.IdentifiedRegion.local_region", &INTEGER_ber_, &IntX_raw_, &INTEGER_text_, &IdentifiedRegion_local__region_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t IdentifiedRegion_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for IdentifiedRegion
const TTCN_JSONdescriptor_t IdentifiedRegion_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t IdentifiedRegion_descr_ = { "@LibItsSecurity_TypesAndValues.IdentifiedRegion", NULL, &IdentifiedRegion_raw_, NULL, NULL, &IdentifiedRegion_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       GeographicRegionContainer_other__region_xer_ = { {"other_region>\n", "other_region>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t GeographicRegionContainer_other__region_descr_ = { "@LibItsSecurity_TypesAndValues.GeographicRegionContainer.other_region", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &GeographicRegionContainer_other__region_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ValidityRestrictionContainer_data_xer_ = { {"data>\n", "data>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ValidityRestrictionContainer_data_descr_ = { "@LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.data", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &ValidityRestrictionContainer_data_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ValidityRestriction_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ValidityRestriction
const TTCN_JSONdescriptor_t ValidityRestriction_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ValidityRestriction_descr_ = { "@LibItsSecurity_TypesAndValues.ValidityRestriction", NULL, &ValidityRestriction_raw_, NULL, NULL, &ValidityRestriction_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t Certificate_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for Certificate
const TTCN_JSONdescriptor_t Certificate_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Certificate_descr_ = { "@LibItsSecurity_TypesAndValues.Certificate", NULL, &Certificate_raw_, NULL, NULL, &Certificate_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t CertificateChain_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for CertificateChain
const TTCN_JSONdescriptor_t CertificateChain_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t CertificateChain_descr_ = { "@LibItsSecurity_TypesAndValues.CertificateChain", NULL, &CertificateChain_raw_, NULL, NULL, &CertificateChain_json_, &Certificate_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       CertificateWithAlgo_digest_xer_ = { {"digest>\n", "digest>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t CertificateWithAlgo_digest_descr_ = { "@LibItsSecurity_TypesAndValues.CertificateWithAlgo.digest", &OCTETSTRING_ber_, &HashedId8_raw_, &OCTETSTRING_text_, &CertificateWithAlgo_digest_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t CertificateWithAlgo_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for CertificateWithAlgo
const TTCN_JSONdescriptor_t CertificateWithAlgo_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t CertificateWithAlgo_descr_ = { "@LibItsSecurity_TypesAndValues.CertificateWithAlgo", NULL, &CertificateWithAlgo_raw_, NULL, NULL, &CertificateWithAlgo_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SignerInfoContainer_info_xer_ = { {"info>\n", "info>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SignerInfoContainer_info_descr_ = { "@LibItsSecurity_TypesAndValues.SignerInfoContainer.info", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &SignerInfoContainer_info_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t HashedId3_raw_ = {24,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,3};
const XERdescriptor_t       HashedId3_xer_ = { {"HashedId3>\n", "HashedId3>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t HashedId3_descr_ = { "@LibItsSecurity_TypesAndValues.HashedId3", &OCTETSTRING_ber_, &HashedId3_raw_, &OCTETSTRING_text_, &HashedId3_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t Time64_raw_ = {64,SG_NO,ORDER_MSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
const XERdescriptor_t       Time64_xer_ = { {"Time64>\n", "Time64>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Time64_descr_ = { "@LibItsSecurity_TypesAndValues.Time64", &INTEGER_ber_, &Time64_raw_, &INTEGER_text_, &Time64_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Time64WithStandardDeviation_time_xer_ = { {"time>\n", "time>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Time64WithStandardDeviation_time_descr_ = { "@LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.time", &INTEGER_ber_, &Time64_raw_, &INTEGER_text_, &Time64WithStandardDeviation_time_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       Time64WithStandardDeviation_log__std__dev_xer_ = { {"log_std_dev>\n", "log_std_dev>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t Time64WithStandardDeviation_log__std__dev_descr_ = { "@LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.log_std_dev", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &Time64WithStandardDeviation_log__std__dev_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t Time64WithStandardDeviation_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for Time64WithStandardDeviation
const TTCN_JSONdescriptor_t Time64WithStandardDeviation_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t Time64WithStandardDeviation_descr_ = { "@LibItsSecurity_TypesAndValues.Time64WithStandardDeviation", NULL, &Time64WithStandardDeviation_raw_, NULL, NULL, &Time64WithStandardDeviation_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ThreeDLocation_latitude_xer_ = { {"latitude>\n", "latitude>\n"}, {10, 10}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ThreeDLocation_latitude_descr_ = { "@LibItsSecurity_TypesAndValues.ThreeDLocation.latitude", &INTEGER_ber_, &WGSLatitude_raw_, &INTEGER_text_, &ThreeDLocation_latitude_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ThreeDLocation_longitude_xer_ = { {"longitude>\n", "longitude>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ThreeDLocation_longitude_descr_ = { "@LibItsSecurity_TypesAndValues.ThreeDLocation.longitude", &INTEGER_ber_, &WGSLongitude_raw_, &INTEGER_text_, &ThreeDLocation_longitude_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ThreeDLocation_elevation_xer_ = { {"elevation>\n", "elevation>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ThreeDLocation_elevation_descr_ = { "@LibItsSecurity_TypesAndValues.ThreeDLocation.elevation", &OCTETSTRING_ber_, &LibCommon__DataStrings::Oct2_raw_, &OCTETSTRING_text_, &ThreeDLocation_elevation_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ThreeDLocation_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ThreeDLocation
const TTCN_JSONdescriptor_t ThreeDLocation_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ThreeDLocation_descr_ = { "@LibItsSecurity_TypesAndValues.ThreeDLocation", NULL, &ThreeDLocation_raw_, NULL, NULL, &ThreeDLocation_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ThreeDLocations_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ThreeDLocations
const TTCN_Typedescriptor_t ThreeDLocations_descr_ = { "@LibItsSecurity_TypesAndValues.ThreeDLocations", NULL, &ThreeDLocations_raw_, NULL, NULL, NULL, &ThreeDLocation_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t RegionIdentifiers_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for RegionIdentifiers
const TTCN_Typedescriptor_t RegionIdentifiers_descr_ = { "@LibItsSecurity_TypesAndValues.RegionIdentifiers", NULL, &RegionIdentifiers_raw_, NULL, NULL, NULL, &LibCommon__BasicTypesAndValues::UInt16_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       RegionIdentifiers_0_xer_ = { {"UInt16>\n", "UInt16>\n"}, {8, 8}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t RegionIdentifiers_0_descr_ = { "@LibItsSecurity_TypesAndValues.RegionIdentifiers.<oftype>", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt16_raw_, &INTEGER_text_, &RegionIdentifiers_0_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ToBeSignedSecuredMessage_protocol__version_xer_ = { {"protocol_version>\n", "protocol_version>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ToBeSignedSecuredMessage_protocol__version_descr_ = { "@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.protocol_version", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ToBeSignedSecuredMessage_protocol__version_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t HeaderFields_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for HeaderFields
const TTCN_JSONdescriptor_t HeaderFields_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t HeaderFields_descr_ = { "@LibItsSecurity_TypesAndValues.HeaderFields", NULL, &HeaderFields_raw_, NULL, NULL, &HeaderFields_json_, &HeaderField_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t HeaderFieldType_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for HeaderFieldType
const TTCN_JSONdescriptor_t HeaderFieldType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t HeaderFieldType_descr_ = { "@LibItsSecurity_TypesAndValues.HeaderFieldType", NULL, &HeaderFieldType_raw_, NULL, NULL, &HeaderFieldType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t HeaderFieldContainer_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for HeaderFieldContainer
const TTCN_JSONdescriptor_t HeaderFieldContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t HeaderFieldContainer_descr_ = { "@LibItsSecurity_TypesAndValues.HeaderFieldContainer", NULL, &HeaderFieldContainer_raw_, NULL, NULL, &HeaderFieldContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       HeaderFieldContainer_generation__time_xer_ = { {"generation_time>\n", "generation_time>\n"}, {17, 17}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t HeaderFieldContainer_generation__time_descr_ = { "@LibItsSecurity_TypesAndValues.HeaderFieldContainer.generation_time", &INTEGER_ber_, &Time64_raw_, &INTEGER_text_, &HeaderFieldContainer_generation__time_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       HeaderFieldContainer_expiry__time_xer_ = { {"expiry_time>\n", "expiry_time>\n"}, {13, 13}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t HeaderFieldContainer_expiry__time_descr_ = { "@LibItsSecurity_TypesAndValues.HeaderFieldContainer.expiry_time", &INTEGER_ber_, &Time32_raw_, &INTEGER_text_, &HeaderFieldContainer_expiry__time_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t HashedId3s_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for HashedId3s
const TTCN_JSONdescriptor_t HashedId3s_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t HashedId3s_descr_ = { "@LibItsSecurity_TypesAndValues.HashedId3s", NULL, &HashedId3s_raw_, NULL, NULL, &HashedId3s_json_, &HashedId3_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       HashedId3s_0_xer_ = { {"HashedId3>\n", "HashedId3>\n"}, {11, 11}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t HashedId3s_0_descr_ = { "@LibItsSecurity_TypesAndValues.HashedId3s.<oftype>", &OCTETSTRING_ber_, &HashedId3_raw_, &OCTETSTRING_text_, &HashedId3s_0_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       HeaderFieldContainer_its__aid_xer_ = { {"its_aid>\n", "its_aid>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t HeaderFieldContainer_its__aid_descr_ = { "@LibItsSecurity_TypesAndValues.HeaderFieldContainer.its_aid", &INTEGER_ber_, &IntX_raw_, &INTEGER_text_, &HeaderFieldContainer_its__aid_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t RecipientInfos_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for RecipientInfos
const TTCN_JSONdescriptor_t RecipientInfos_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RecipientInfos_descr_ = { "@LibItsSecurity_TypesAndValues.RecipientInfos", NULL, &RecipientInfos_raw_, NULL, NULL, &RecipientInfos_json_, &RecipientInfo_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       RecipientInfo_cert__id_xer_ = { {"cert_id>\n", "cert_id>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t RecipientInfo_cert__id_descr_ = { "@LibItsSecurity_TypesAndValues.RecipientInfo.cert_id", &OCTETSTRING_ber_, &HashedId8_raw_, &OCTETSTRING_text_, &RecipientInfo_cert__id_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t RecipientInfoContainer_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for RecipientInfoContainer
const TTCN_JSONdescriptor_t RecipientInfoContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RecipientInfoContainer_descr_ = { "@LibItsSecurity_TypesAndValues.RecipientInfoContainer", NULL, &RecipientInfoContainer_raw_, NULL, NULL, &RecipientInfoContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       EciesEncryptedKey_c_xer_ = { {"c>\n", "c>\n"}, {3, 3}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t EciesEncryptedKey_c_descr_ = { "@LibItsSecurity_TypesAndValues.EciesEncryptedKey.c", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &EciesEncryptedKey_c_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       EciesEncryptedKey_t_xer_ = { {"t>\n", "t>\n"}, {3, 3}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t EciesEncryptedKey_t_descr_ = { "@LibItsSecurity_TypesAndValues.EciesEncryptedKey.t", &OCTETSTRING_ber_, &LibCommon__DataStrings::Oct16_raw_, &OCTETSTRING_text_, &EciesEncryptedKey_t_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t EciesEncryptedKey_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for EciesEncryptedKey
const TTCN_JSONdescriptor_t EciesEncryptedKey_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t EciesEncryptedKey_descr_ = { "@LibItsSecurity_TypesAndValues.EciesEncryptedKey", NULL, &EciesEncryptedKey_raw_, NULL, NULL, &EciesEncryptedKey_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       RecipientInfoContainer_enc__key__other_xer_ = { {"enc_key_other>\n", "enc_key_other>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t RecipientInfoContainer_enc__key__other_descr_ = { "@LibItsSecurity_TypesAndValues.RecipientInfoContainer.enc_key_other", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &RecipientInfoContainer_enc__key__other_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t RecipientInfo_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for RecipientInfo
const TTCN_JSONdescriptor_t RecipientInfo_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t RecipientInfo_descr_ = { "@LibItsSecurity_TypesAndValues.RecipientInfo", NULL, &RecipientInfo_raw_, NULL, NULL, &RecipientInfo_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       HeaderFieldContainer_other__header_xer_ = { {"other_header>\n", "other_header>\n"}, {14, 14}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t HeaderFieldContainer_other__header_descr_ = { "@LibItsSecurity_TypesAndValues.HeaderFieldContainer.other_header", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &HeaderFieldContainer_other__header_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t HeaderField_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for HeaderField
const TTCN_JSONdescriptor_t HeaderField_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t HeaderField_descr_ = { "@LibItsSecurity_TypesAndValues.HeaderField", NULL, &HeaderField_raw_, NULL, NULL, &HeaderField_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SecPayloadType_raw_ = {8,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SecPayloadType
const TTCN_JSONdescriptor_t SecPayloadType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SecPayloadType_descr_ = { "@LibItsSecurity_TypesAndValues.SecPayloadType", NULL, &SecPayloadType_raw_, NULL, NULL, &SecPayloadType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SecPayload_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SecPayload
const TTCN_JSONdescriptor_t SecPayload_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SecPayload_descr_ = { "@LibItsSecurity_TypesAndValues.SecPayload", NULL, &SecPayload_raw_, NULL, NULL, &SecPayload_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SecPayload_data_xer_ = { {"data>\n", "data>\n"}, {6, 6}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SecPayload_data_descr_ = { "@LibItsSecurity_TypesAndValues.SecPayload.data", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &SecPayload_data_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ToBeSignedSecuredMessage_trailer__fieldsLength_xer_ = { {"trailer_fieldsLength>\n", "trailer_fieldsLength>\n"}, {22, 22}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ToBeSignedSecuredMessage_trailer__fieldsLength_descr_ = { "@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.trailer_fieldsLength", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ToBeSignedSecuredMessage_trailer__fieldsLength_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t TrailerFieldType_raw_ = {1,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for TrailerFieldType
const TTCN_JSONdescriptor_t TrailerFieldType_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t TrailerFieldType_descr_ = { "@LibItsSecurity_TypesAndValues.TrailerFieldType", NULL, &TrailerFieldType_raw_, NULL, NULL, &TrailerFieldType_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ToBeSignedSecuredMessage_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ToBeSignedSecuredMessage
const TTCN_JSONdescriptor_t ToBeSignedSecuredMessage_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ToBeSignedSecuredMessage_descr_ = { "@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage", NULL, &ToBeSignedSecuredMessage_raw_, NULL, NULL, &ToBeSignedSecuredMessage_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       SecuredMessage_protocol__version_xer_ = { {"protocol_version>\n", "protocol_version>\n"}, {18, 18}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t SecuredMessage_protocol__version_descr_ = { "@LibItsSecurity_TypesAndValues.SecuredMessage.protocol_version", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &SecuredMessage_protocol__version_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t TrailerFields_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for TrailerFields
const TTCN_JSONdescriptor_t TrailerFields_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t TrailerFields_descr_ = { "@LibItsSecurity_TypesAndValues.TrailerFields", NULL, &TrailerFields_raw_, NULL, NULL, &TrailerFields_json_, &TrailerField_descr_, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t TrailerFieldContainer_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for TrailerFieldContainer
const TTCN_JSONdescriptor_t TrailerFieldContainer_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t TrailerFieldContainer_descr_ = { "@LibItsSecurity_TypesAndValues.TrailerFieldContainer", NULL, &TrailerFieldContainer_raw_, NULL, NULL, &TrailerFieldContainer_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       TrailerFieldContainer_security__field_xer_ = { {"security_field>\n", "security_field>\n"}, {16, 16}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t TrailerFieldContainer_security__field_descr_ = { "@LibItsSecurity_TypesAndValues.TrailerFieldContainer.security_field", &OCTETSTRING_ber_, &OCTETSTRING_raw_, &OCTETSTRING_text_, &TrailerFieldContainer_security__field_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t TrailerField_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for TrailerField
const TTCN_JSONdescriptor_t TrailerField_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t TrailerField_descr_ = { "@LibItsSecurity_TypesAndValues.TrailerField", NULL, &TrailerField_raw_, NULL, NULL, &TrailerField_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t SecuredMessage_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for SecuredMessage
const TTCN_JSONdescriptor_t SecuredMessage_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t SecuredMessage_descr_ = { "@LibItsSecurity_TypesAndValues.SecuredMessage", NULL, &SecuredMessage_raw_, NULL, NULL, &SecuredMessage_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       ToBeSignedCertificate_version_xer_ = { {"version>\n", "version>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t ToBeSignedCertificate_version_descr_ = { "@LibItsSecurity_TypesAndValues.ToBeSignedCertificate.version", &INTEGER_ber_, &LibCommon__BasicTypesAndValues::UInt8_raw_, &INTEGER_text_, &ToBeSignedCertificate_version_xer_, &INTEGER_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t ToBeSignedCertificate_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for ToBeSignedCertificate
const TTCN_JSONdescriptor_t ToBeSignedCertificate_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t ToBeSignedCertificate_descr_ = { "@LibItsSecurity_TypesAndValues.ToBeSignedCertificate", NULL, &ToBeSignedCertificate_raw_, NULL, NULL, &ToBeSignedCertificate_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       TaConfig_signingPrivateKey_xer_ = { {"signingPrivateKey>\n", "signingPrivateKey>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t TaConfig_signingPrivateKey_descr_ = { "@LibItsSecurity_TypesAndValues.TaConfig.signingPrivateKey", &OCTETSTRING_ber_, &LibCommon__DataStrings::Oct32_raw_, &OCTETSTRING_text_, &TaConfig_signingPrivateKey_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       TaConfig_encryptPrivateKey_xer_ = { {"encryptPrivateKey>\n", "encryptPrivateKey>\n"}, {19, 19}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t TaConfig_encryptPrivateKey_descr_ = { "@LibItsSecurity_TypesAndValues.TaConfig.encryptPrivateKey", &OCTETSTRING_ber_, &LibCommon__DataStrings::Oct32_raw_, &OCTETSTRING_text_, &TaConfig_encryptPrivateKey_xer_, &OCTETSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t TaConfig_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for TaConfig
const TTCN_JSONdescriptor_t TaConfig_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t TaConfig_descr_ = { "@LibItsSecurity_TypesAndValues.TaConfig", NULL, &TaConfig_raw_, NULL, NULL, &TaConfig_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t TaConfigs_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for TaConfigs
const TTCN_Typedescriptor_t TaConfigs_descr_ = { "@LibItsSecurity_TypesAndValues.TaConfigs", NULL, &TaConfigs_raw_, NULL, NULL, NULL, &TaConfig_descr_, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       AcEnableSecurity_certificateId_xer_ = { {"certificateId>\n", "certificateId>\n"}, {15, 15}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t AcEnableSecurity_certificateId_descr_ = { "@LibItsSecurity_TypesAndValues.AcEnableSecurity.certificateId", NULL, &CHARSTRING_raw_, &CHARSTRING_text_, &AcEnableSecurity_certificateId_xer_, &CHARSTRING_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AcEnableSecurity_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AcEnableSecurity
const TTCN_JSONdescriptor_t AcEnableSecurity_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AcEnableSecurity_descr_ = { "@LibItsSecurity_TypesAndValues.AcEnableSecurity", NULL, &AcEnableSecurity_raw_, NULL, NULL, &AcEnableSecurity_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const XERdescriptor_t       AcDisableSecurity_disable_xer_ = { {"disable>\n", "disable>\n"}, {9, 9}, 0 |FORM_UNQUALIFIED, WHITESPACE_PRESERVE,  NULL, &module_object, -1, 0, NULL, NULL };
const TTCN_Typedescriptor_t AcDisableSecurity_disable_descr_ = { "@LibItsSecurity_TypesAndValues.AcDisableSecurity.disable", &BOOLEAN_ber_, &BOOLEAN_raw_, &BOOLEAN_text_, &AcDisableSecurity_disable_xer_, &BOOLEAN_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
const TTCN_RAWdescriptor_t AcDisableSecurity_raw_ = {0,SG_NO,ORDER_LSB,ORDER_LSB,ORDER_LSB,ORDER_LSB,EXT_BIT_NO,ORDER_LSB,ORDER_LSB,TOP_BIT_INHERITED,0,0,0,8,0,NULL,-1};
// No XER for AcDisableSecurity
const TTCN_JSONdescriptor_t AcDisableSecurity_json_ = { false, NULL, false, NULL, false };
const TTCN_Typedescriptor_t AcDisableSecurity_descr_ = { "@LibItsSecurity_TypesAndValues.AcDisableSecurity", NULL, &AcDisableSecurity_raw_, NULL, NULL, &AcDisableSecurity_json_, NULL, TTCN_Typedescriptor_t::DONTCARE };
static const size_t num_namespaces = 0;
TTCN_Module module_object("LibItsSecurity_TypesAndValues", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_5,
  current_runtime_version.requires_minor_version_4,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

PublicKeyAlgorithm::PublicKeyAlgorithm()
{
enum_value = UNBOUND_VALUE;
}

PublicKeyAlgorithm::PublicKeyAlgorithm(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

PublicKeyAlgorithm::PublicKeyAlgorithm(enum_type other_value)
{
enum_value = other_value;
}

PublicKeyAlgorithm::PublicKeyAlgorithm(const PublicKeyAlgorithm& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
enum_value = other_value.enum_value;
}

PublicKeyAlgorithm& PublicKeyAlgorithm::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

PublicKeyAlgorithm& PublicKeyAlgorithm::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

PublicKeyAlgorithm& PublicKeyAlgorithm::operator=(const PublicKeyAlgorithm& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
enum_value = other_value.enum_value;
return *this;
}

boolean PublicKeyAlgorithm::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
return enum_value == other_value;
}

boolean PublicKeyAlgorithm::operator==(const PublicKeyAlgorithm& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
return enum_value == other_value.enum_value;
}

boolean PublicKeyAlgorithm::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
return enum_value < other_value;
}

boolean PublicKeyAlgorithm::operator<(const PublicKeyAlgorithm& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
return enum_value < other_value.enum_value;
}

boolean PublicKeyAlgorithm::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
return enum_value > other_value;
}

boolean PublicKeyAlgorithm::operator>(const PublicKeyAlgorithm& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
return enum_value > other_value.enum_value;
}

const char *PublicKeyAlgorithm::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__ecdsa__nistp256__with__sha256: return "e_ecdsa_nistp256_with_sha256";
case e__ecies__nistp256: return "e_ecies_nistp256";
default: return "<unknown>";
}
}

PublicKeyAlgorithm::enum_type PublicKeyAlgorithm::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_ecdsa_nistp256_with_sha256")) return e__ecdsa__nistp256__with__sha256;
else if (!strcmp(str_par, "e_ecies_nistp256")) return e__ecies__nistp256;
else return UNKNOWN_VALUE;
}

boolean PublicKeyAlgorithm::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
return TRUE;
default:
return FALSE;
}
}

int PublicKeyAlgorithm::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int PublicKeyAlgorithm::enum2int(const PublicKeyAlgorithm& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void PublicKeyAlgorithm::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.", int_val);
enum_value = (enum_type)int_val;
}

PublicKeyAlgorithm::operator PublicKeyAlgorithm::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
return enum_value;
}

void PublicKeyAlgorithm::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void PublicKeyAlgorithm::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsSecurity_TypesAndValues.PublicKeyAlgorithm");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
  }
}

Module_Param* PublicKeyAlgorithm::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void PublicKeyAlgorithm::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
text_buf.push_int(enum_value);
}

void PublicKeyAlgorithm::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.", enum_value);
}

void PublicKeyAlgorithm::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PublicKeyAlgorithm::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PublicKeyAlgorithm::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 2, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int PublicKeyAlgorithm::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 2);
}

int PublicKeyAlgorithm::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int PublicKeyAlgorithm::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void PublicKeyAlgorithm_template::copy_template(const PublicKeyAlgorithm_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PublicKeyAlgorithm_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
}
}

PublicKeyAlgorithm_template::PublicKeyAlgorithm_template()
{
}

PublicKeyAlgorithm_template::PublicKeyAlgorithm_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PublicKeyAlgorithm_template::PublicKeyAlgorithm_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!PublicKeyAlgorithm::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm with unknown numeric value %d.", other_value);
single_value = (PublicKeyAlgorithm::enum_type)other_value;
}

PublicKeyAlgorithm_template::PublicKeyAlgorithm_template(PublicKeyAlgorithm::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

PublicKeyAlgorithm_template::PublicKeyAlgorithm_template(const PublicKeyAlgorithm& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == PublicKeyAlgorithm::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
single_value = other_value.enum_value;
}

PublicKeyAlgorithm_template::PublicKeyAlgorithm_template(const OPTIONAL<PublicKeyAlgorithm>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (PublicKeyAlgorithm::enum_type)(const PublicKeyAlgorithm&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm from an unbound optional field.");
}
}

PublicKeyAlgorithm_template::PublicKeyAlgorithm_template(const PublicKeyAlgorithm_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

PublicKeyAlgorithm_template::~PublicKeyAlgorithm_template()
{
clean_up();
}

boolean PublicKeyAlgorithm_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean PublicKeyAlgorithm_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != PublicKeyAlgorithm::UNBOUND_VALUE;
}

void PublicKeyAlgorithm_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

PublicKeyAlgorithm_template& PublicKeyAlgorithm_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PublicKeyAlgorithm_template& PublicKeyAlgorithm_template::operator=(int other_value)
{
if (!PublicKeyAlgorithm::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (PublicKeyAlgorithm::enum_type)other_value;
return *this;
}

PublicKeyAlgorithm_template& PublicKeyAlgorithm_template::operator=(PublicKeyAlgorithm::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

PublicKeyAlgorithm_template& PublicKeyAlgorithm_template::operator=(const PublicKeyAlgorithm& other_value)
{
if (other_value.enum_value == PublicKeyAlgorithm::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

PublicKeyAlgorithm_template& PublicKeyAlgorithm_template::operator=(const OPTIONAL<PublicKeyAlgorithm>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (PublicKeyAlgorithm::enum_type)(const PublicKeyAlgorithm&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
}
return *this;
}

PublicKeyAlgorithm_template& PublicKeyAlgorithm_template::operator=(const PublicKeyAlgorithm_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PublicKeyAlgorithm_template::match(PublicKeyAlgorithm::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
}
return FALSE;
}

boolean PublicKeyAlgorithm_template::match(const PublicKeyAlgorithm& other_value, boolean) const
{
if (other_value.enum_value == PublicKeyAlgorithm::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm with an unbound value.");
return match(other_value.enum_value);
}

PublicKeyAlgorithm::enum_type PublicKeyAlgorithm_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
return single_value;
}

void PublicKeyAlgorithm_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PublicKeyAlgorithm_template[list_length];
}

PublicKeyAlgorithm_template& PublicKeyAlgorithm_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
return value_list.list_value[list_index];
}

void PublicKeyAlgorithm_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(PublicKeyAlgorithm::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PublicKeyAlgorithm_template::log_match(const PublicKeyAlgorithm& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void PublicKeyAlgorithm_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
}
}

void PublicKeyAlgorithm_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (PublicKeyAlgorithm::enum_type)text_buf.pull_int().get_val();
if (!PublicKeyAlgorithm::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PublicKeyAlgorithm_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
}
}

boolean PublicKeyAlgorithm_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PublicKeyAlgorithm_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PublicKeyAlgorithm_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    PublicKeyAlgorithm::enum_type enum_val = (enum_name != NULL) ? PublicKeyAlgorithm::str_to_enum(enum_name) : PublicKeyAlgorithm::UNKNOWN_VALUE;
    if (PublicKeyAlgorithm::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PublicKeyAlgorithm_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    PublicKeyAlgorithm::enum_type enum_val = PublicKeyAlgorithm::str_to_enum(mp->get_enumerated());
    if (!PublicKeyAlgorithm::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.PublicKeyAlgorithm.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsSecurity_TypesAndValues.PublicKeyAlgorithm");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* PublicKeyAlgorithm_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(PublicKeyAlgorithm::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void PublicKeyAlgorithm_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.PublicKeyAlgorithm");
}

SymmetricAlgorithm::SymmetricAlgorithm()
{
enum_value = UNBOUND_VALUE;
}

SymmetricAlgorithm::SymmetricAlgorithm(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

SymmetricAlgorithm::SymmetricAlgorithm(enum_type other_value)
{
enum_value = other_value;
}

SymmetricAlgorithm::SymmetricAlgorithm(const SymmetricAlgorithm& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
enum_value = other_value.enum_value;
}

SymmetricAlgorithm& SymmetricAlgorithm::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

SymmetricAlgorithm& SymmetricAlgorithm::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

SymmetricAlgorithm& SymmetricAlgorithm::operator=(const SymmetricAlgorithm& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
enum_value = other_value.enum_value;
return *this;
}

boolean SymmetricAlgorithm::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
return enum_value == other_value;
}

boolean SymmetricAlgorithm::operator==(const SymmetricAlgorithm& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
return enum_value == other_value.enum_value;
}

boolean SymmetricAlgorithm::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
return enum_value < other_value;
}

boolean SymmetricAlgorithm::operator<(const SymmetricAlgorithm& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
return enum_value < other_value.enum_value;
}

boolean SymmetricAlgorithm::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
return enum_value > other_value;
}

boolean SymmetricAlgorithm::operator>(const SymmetricAlgorithm& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
return enum_value > other_value.enum_value;
}

const char *SymmetricAlgorithm::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__aes__128__ccm: return "e_aes_128_ccm";
default: return "<unknown>";
}
}

SymmetricAlgorithm::enum_type SymmetricAlgorithm::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_aes_128_ccm")) return e__aes__128__ccm;
else return UNKNOWN_VALUE;
}

boolean SymmetricAlgorithm::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
return TRUE;
default:
return FALSE;
}
}

int SymmetricAlgorithm::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int SymmetricAlgorithm::enum2int(const SymmetricAlgorithm& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void SymmetricAlgorithm::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.", int_val);
enum_value = (enum_type)int_val;
}

SymmetricAlgorithm::operator SymmetricAlgorithm::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
return enum_value;
}

void SymmetricAlgorithm::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void SymmetricAlgorithm::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsSecurity_TypesAndValues.SymmetricAlgorithm");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
  }
}

Module_Param* SymmetricAlgorithm::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void SymmetricAlgorithm::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
text_buf.push_int(enum_value);
}

void SymmetricAlgorithm::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.", enum_value);
}

void SymmetricAlgorithm::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SymmetricAlgorithm::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SymmetricAlgorithm::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 1, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int SymmetricAlgorithm::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 1);
}

int SymmetricAlgorithm::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int SymmetricAlgorithm::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void SymmetricAlgorithm_template::copy_template(const SymmetricAlgorithm_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SymmetricAlgorithm_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
}
}

SymmetricAlgorithm_template::SymmetricAlgorithm_template()
{
}

SymmetricAlgorithm_template::SymmetricAlgorithm_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SymmetricAlgorithm_template::SymmetricAlgorithm_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!SymmetricAlgorithm::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm with unknown numeric value %d.", other_value);
single_value = (SymmetricAlgorithm::enum_type)other_value;
}

SymmetricAlgorithm_template::SymmetricAlgorithm_template(SymmetricAlgorithm::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

SymmetricAlgorithm_template::SymmetricAlgorithm_template(const SymmetricAlgorithm& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == SymmetricAlgorithm::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
single_value = other_value.enum_value;
}

SymmetricAlgorithm_template::SymmetricAlgorithm_template(const OPTIONAL<SymmetricAlgorithm>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SymmetricAlgorithm::enum_type)(const SymmetricAlgorithm&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm from an unbound optional field.");
}
}

SymmetricAlgorithm_template::SymmetricAlgorithm_template(const SymmetricAlgorithm_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

SymmetricAlgorithm_template::~SymmetricAlgorithm_template()
{
clean_up();
}

boolean SymmetricAlgorithm_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean SymmetricAlgorithm_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != SymmetricAlgorithm::UNBOUND_VALUE;
}

void SymmetricAlgorithm_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

SymmetricAlgorithm_template& SymmetricAlgorithm_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SymmetricAlgorithm_template& SymmetricAlgorithm_template::operator=(int other_value)
{
if (!SymmetricAlgorithm::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (SymmetricAlgorithm::enum_type)other_value;
return *this;
}

SymmetricAlgorithm_template& SymmetricAlgorithm_template::operator=(SymmetricAlgorithm::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

SymmetricAlgorithm_template& SymmetricAlgorithm_template::operator=(const SymmetricAlgorithm& other_value)
{
if (other_value.enum_value == SymmetricAlgorithm::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

SymmetricAlgorithm_template& SymmetricAlgorithm_template::operator=(const OPTIONAL<SymmetricAlgorithm>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SymmetricAlgorithm::enum_type)(const SymmetricAlgorithm&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
}
return *this;
}

SymmetricAlgorithm_template& SymmetricAlgorithm_template::operator=(const SymmetricAlgorithm_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SymmetricAlgorithm_template::match(SymmetricAlgorithm::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
}
return FALSE;
}

boolean SymmetricAlgorithm_template::match(const SymmetricAlgorithm& other_value, boolean) const
{
if (other_value.enum_value == SymmetricAlgorithm::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm with an unbound value.");
return match(other_value.enum_value);
}

SymmetricAlgorithm::enum_type SymmetricAlgorithm_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
return single_value;
}

void SymmetricAlgorithm_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SymmetricAlgorithm_template[list_length];
}

SymmetricAlgorithm_template& SymmetricAlgorithm_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
return value_list.list_value[list_index];
}

void SymmetricAlgorithm_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(SymmetricAlgorithm::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SymmetricAlgorithm_template::log_match(const SymmetricAlgorithm& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void SymmetricAlgorithm_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
}
}

void SymmetricAlgorithm_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (SymmetricAlgorithm::enum_type)text_buf.pull_int().get_val();
if (!SymmetricAlgorithm::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SymmetricAlgorithm_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
}
}

boolean SymmetricAlgorithm_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SymmetricAlgorithm_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SymmetricAlgorithm_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    SymmetricAlgorithm::enum_type enum_val = (enum_name != NULL) ? SymmetricAlgorithm::str_to_enum(enum_name) : SymmetricAlgorithm::UNKNOWN_VALUE;
    if (SymmetricAlgorithm::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SymmetricAlgorithm_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    SymmetricAlgorithm::enum_type enum_val = SymmetricAlgorithm::str_to_enum(mp->get_enumerated());
    if (!SymmetricAlgorithm::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.SymmetricAlgorithm.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsSecurity_TypesAndValues.SymmetricAlgorithm");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SymmetricAlgorithm_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(SymmetricAlgorithm::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SymmetricAlgorithm_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.SymmetricAlgorithm");
}

void PublicKeyContainer::copy_value(const PublicKeyContainer& other_value)
{
switch (other_value.union_selection) {
case ALT_eccPoint:
field_eccPoint = new EccPoint(*other_value.field_eccPoint);
break;
case ALT_aesCcm:
field_aesCcm = new AesCcm(*other_value.field_aesCcm);
break;
case ALT_other__key:
field_other__key = new OCTETSTRING(*other_value.field_other__key);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
}
union_selection = other_value.union_selection;
}

PublicKeyContainer::PublicKeyContainer()
{
union_selection = UNBOUND_VALUE;
}

PublicKeyContainer::PublicKeyContainer(const PublicKeyContainer& other_value)
: Base_Type(){
copy_value(other_value);
}

PublicKeyContainer::~PublicKeyContainer()
{
clean_up();
}

PublicKeyContainer& PublicKeyContainer::operator=(const PublicKeyContainer& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean PublicKeyContainer::operator==(const PublicKeyContainer& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_eccPoint:
return *field_eccPoint == *other_value.field_eccPoint;
case ALT_aesCcm:
return *field_aesCcm == *other_value.field_aesCcm;
case ALT_other__key:
return *field_other__key == *other_value.field_other__key;
default:
return FALSE;
}
}

EccPoint& PublicKeyContainer::eccPoint()
{
if (union_selection != ALT_eccPoint) {
clean_up();
field_eccPoint = new EccPoint;
union_selection = ALT_eccPoint;
}
return *field_eccPoint;
}

const EccPoint& PublicKeyContainer::eccPoint() const
{
if (union_selection != ALT_eccPoint) TTCN_error("Using non-selected field eccPoint in a value of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
return *field_eccPoint;
}

AesCcm& PublicKeyContainer::aesCcm()
{
if (union_selection != ALT_aesCcm) {
clean_up();
field_aesCcm = new AesCcm;
union_selection = ALT_aesCcm;
}
return *field_aesCcm;
}

const AesCcm& PublicKeyContainer::aesCcm() const
{
if (union_selection != ALT_aesCcm) TTCN_error("Using non-selected field aesCcm in a value of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
return *field_aesCcm;
}

OCTETSTRING& PublicKeyContainer::other__key()
{
if (union_selection != ALT_other__key) {
clean_up();
field_other__key = new OCTETSTRING;
union_selection = ALT_other__key;
}
return *field_other__key;
}

const OCTETSTRING& PublicKeyContainer::other__key() const
{
if (union_selection != ALT_other__key) TTCN_error("Using non-selected field other_key in a value of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
return *field_other__key;
}

boolean PublicKeyContainer::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
return union_selection == checked_selection;
}

boolean PublicKeyContainer::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean PublicKeyContainer::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_eccPoint: return field_eccPoint->is_value();
case ALT_aesCcm: return field_aesCcm->is_value();
case ALT_other__key: return field_other__key->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void PublicKeyContainer::clean_up()
{
switch (union_selection) {
case ALT_eccPoint:
  delete field_eccPoint;
  break;
case ALT_aesCcm:
  delete field_aesCcm;
  break;
case ALT_other__key:
  delete field_other__key;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void PublicKeyContainer::log() const
{
switch (union_selection) {
case ALT_eccPoint:
TTCN_Logger::log_event_str("{ eccPoint := ");
field_eccPoint->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_aesCcm:
TTCN_Logger::log_event_str("{ aesCcm := ");
field_aesCcm->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_other__key:
TTCN_Logger::log_event_str("{ other_key := ");
field_other__key->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void PublicKeyContainer::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsSecurity_TypesAndValues.PublicKeyContainer'");
    }
    if (strcmp("eccPoint", param_field) == 0) {
      eccPoint().set_param(param);
      return;
    } else if (strcmp("aesCcm", param_field) == 0) {
      aesCcm().set_param(param);
      return;
    } else if (strcmp("other_key", param_field) == 0) {
      other__key().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsSecurity_TypesAndValues.PublicKeyContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "eccPoint")) {
    eccPoint().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "aesCcm")) {
    aesCcm().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "other_key")) {
    other__key().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.PublicKeyContainer.", mp_last->get_id()->get_name());
}

Module_Param* PublicKeyContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsSecurity_TypesAndValues.PublicKeyContainer'");
    }
    if (strcmp("eccPoint", param_field) == 0) {
      return eccPoint().get_param(param_name);
    } else if (strcmp("aesCcm", param_field) == 0) {
      return aesCcm().get_param(param_name);
    } else if (strcmp("other_key", param_field) == 0) {
      return other__key().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `PublicKeyContainer'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_eccPoint:
    mp_field = field_eccPoint->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("eccPoint")));
    break;
  case ALT_aesCcm:
    mp_field = field_aesCcm->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("aesCcm")));
    break;
  case ALT_other__key:
    mp_field = field_other__key->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("other_key")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void PublicKeyContainer::set_implicit_omit()
{
switch (union_selection) {
case ALT_eccPoint:
field_eccPoint->set_implicit_omit(); break;
case ALT_aesCcm:
field_aesCcm->set_implicit_omit(); break;
case ALT_other__key:
field_other__key->set_implicit_omit(); break;
default: break;
}
}

void PublicKeyContainer::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_eccPoint:
field_eccPoint->encode_text(text_buf);
break;
case ALT_aesCcm:
field_aesCcm->encode_text(text_buf);
break;
case ALT_other__key:
field_other__key->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
}
}

void PublicKeyContainer::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_eccPoint:
eccPoint().decode_text(text_buf);
break;
case ALT_aesCcm:
aesCcm().decode_text(text_buf);
break;
case ALT_other__key:
other__key().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
}
}

void PublicKeyContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PublicKeyContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PublicKeyContainer::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = eccPoint().RAW_decode(EccPoint_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = aesCcm().RAW_decode(AesCcm_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 2:
      decoded_length = other__key().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = eccPoint().RAW_decode(EccPoint_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = aesCcm().RAW_decode(AesCcm_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = other__key().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int PublicKeyContainer::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 3;  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  memset(myleaf.body.node.nodes, 0, 3 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_eccPoint:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, EccPoint_descr_.raw);
    encoded_length = field_eccPoint->RAW_encode(EccPoint_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &EccPoint_descr_;
    break;
  case ALT_aesCcm:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, AesCcm_descr_.raw);
    encoded_length = field_aesCcm->RAW_encode(AesCcm_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &AesCcm_descr_;
    break;
  case ALT_other__key:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, OCTETSTRING_descr_.raw);
    encoded_length = field_other__key->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &OCTETSTRING_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int PublicKeyContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_eccPoint:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "eccPoint");
    enc_len += field_eccPoint->JSON_encode(EccPoint_descr_, p_tok);
    break;
  case ALT_aesCcm:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "aesCcm");
    enc_len += field_aesCcm->JSON_encode(AesCcm_descr_, p_tok);
    break;
  case ALT_other__key:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "other_key");
    enc_len += field_other__key->JSON_encode(OCTETSTRING_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int PublicKeyContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "eccPoint", name_len)) {
      int ret_val = eccPoint().JSON_decode(EccPoint_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "eccPoint");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "aesCcm", name_len)) {
      int ret_val = aesCcm().JSON_decode(AesCcm_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "aesCcm");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "other_key", name_len)) {
      int ret_val = other__key().JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "other_key");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void PublicKeyContainer_template::copy_value(const PublicKeyContainer& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case PublicKeyContainer::ALT_eccPoint:
single_value.field_eccPoint = new EccPoint_template(other_value.eccPoint());
break;
case PublicKeyContainer::ALT_aesCcm:
single_value.field_aesCcm = new AesCcm_template(other_value.aesCcm());
break;
case PublicKeyContainer::ALT_other__key:
single_value.field_other__key = new OCTETSTRING_template(other_value.other__key());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
}
set_selection(SPECIFIC_VALUE);
}

void PublicKeyContainer_template::copy_template(const PublicKeyContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case PublicKeyContainer::ALT_eccPoint:
single_value.field_eccPoint = new EccPoint_template(*other_value.single_value.field_eccPoint);
break;
case PublicKeyContainer::ALT_aesCcm:
single_value.field_aesCcm = new AesCcm_template(*other_value.single_value.field_aesCcm);
break;
case PublicKeyContainer::ALT_other__key:
single_value.field_other__key = new OCTETSTRING_template(*other_value.single_value.field_other__key);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PublicKeyContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
}
set_selection(other_value);
}

PublicKeyContainer_template::PublicKeyContainer_template()
{
}

PublicKeyContainer_template::PublicKeyContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PublicKeyContainer_template::PublicKeyContainer_template(const PublicKeyContainer& other_value)
{
copy_value(other_value);
}

PublicKeyContainer_template::PublicKeyContainer_template(const OPTIONAL<PublicKeyContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PublicKeyContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer from an unbound optional field.");
}
}

PublicKeyContainer_template::PublicKeyContainer_template(const PublicKeyContainer_template& other_value)
: Base_Template(){
copy_template(other_value);
}

PublicKeyContainer_template::~PublicKeyContainer_template()
{
clean_up();
}

void PublicKeyContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case PublicKeyContainer::ALT_eccPoint:
delete single_value.field_eccPoint;
break;
case PublicKeyContainer::ALT_aesCcm:
delete single_value.field_aesCcm;
break;
case PublicKeyContainer::ALT_other__key:
delete single_value.field_other__key;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PublicKeyContainer_template& PublicKeyContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PublicKeyContainer_template& PublicKeyContainer_template::operator=(const PublicKeyContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PublicKeyContainer_template& PublicKeyContainer_template::operator=(const OPTIONAL<PublicKeyContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PublicKeyContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
}
return *this;
}

PublicKeyContainer_template& PublicKeyContainer_template::operator=(const PublicKeyContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PublicKeyContainer_template::match(const PublicKeyContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
PublicKeyContainer::union_selection_type value_selection = other_value.get_selection();
if (value_selection == PublicKeyContainer::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case PublicKeyContainer::ALT_eccPoint:
return single_value.field_eccPoint->match(other_value.eccPoint(), legacy);
case PublicKeyContainer::ALT_aesCcm:
return single_value.field_aesCcm->match(other_value.aesCcm(), legacy);
case PublicKeyContainer::ALT_other__key:
return single_value.field_other__key->match(other_value.other__key(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
}
return FALSE;
}

boolean PublicKeyContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case PublicKeyContainer::ALT_eccPoint:
return single_value.field_eccPoint->is_value();
case PublicKeyContainer::ALT_aesCcm:
return single_value.field_aesCcm->is_value();
case PublicKeyContainer::ALT_other__key:
return single_value.field_other__key->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
}
}

PublicKeyContainer PublicKeyContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
PublicKeyContainer ret_val;
switch (single_value.union_selection) {
case PublicKeyContainer::ALT_eccPoint:
ret_val.eccPoint() = single_value.field_eccPoint->valueof();
break;
case PublicKeyContainer::ALT_aesCcm:
ret_val.aesCcm() = single_value.field_aesCcm->valueof();
break;
case PublicKeyContainer::ALT_other__key:
ret_val.other__key() = single_value.field_other__key->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
}
return ret_val;
}

PublicKeyContainer_template& PublicKeyContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
return value_list.list_value[list_index];
}
void PublicKeyContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PublicKeyContainer_template[list_length];
}

EccPoint_template& PublicKeyContainer_template::eccPoint()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PublicKeyContainer::ALT_eccPoint) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_eccPoint = new EccPoint_template(ANY_VALUE);
else single_value.field_eccPoint = new EccPoint_template;
single_value.union_selection = PublicKeyContainer::ALT_eccPoint;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_eccPoint;
}

const EccPoint_template& PublicKeyContainer_template::eccPoint() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field eccPoint in a non-specific template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
if (single_value.union_selection != PublicKeyContainer::ALT_eccPoint) TTCN_error("Accessing non-selected field eccPoint in a template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
return *single_value.field_eccPoint;
}

AesCcm_template& PublicKeyContainer_template::aesCcm()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PublicKeyContainer::ALT_aesCcm) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_aesCcm = new AesCcm_template(ANY_VALUE);
else single_value.field_aesCcm = new AesCcm_template;
single_value.union_selection = PublicKeyContainer::ALT_aesCcm;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_aesCcm;
}

const AesCcm_template& PublicKeyContainer_template::aesCcm() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field aesCcm in a non-specific template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
if (single_value.union_selection != PublicKeyContainer::ALT_aesCcm) TTCN_error("Accessing non-selected field aesCcm in a template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
return *single_value.field_aesCcm;
}

OCTETSTRING_template& PublicKeyContainer_template::other__key()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != PublicKeyContainer::ALT_other__key) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_other__key = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_other__key = new OCTETSTRING_template;
single_value.union_selection = PublicKeyContainer::ALT_other__key;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_other__key;
}

const OCTETSTRING_template& PublicKeyContainer_template::other__key() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field other_key in a non-specific template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
if (single_value.union_selection != PublicKeyContainer::ALT_other__key) TTCN_error("Accessing non-selected field other_key in a template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
return *single_value.field_other__key;
}

boolean PublicKeyContainer_template::ischosen(PublicKeyContainer::union_selection_type checked_selection) const
{
if (checked_selection == PublicKeyContainer::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == PublicKeyContainer::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer");
}
return FALSE;
}

void PublicKeyContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case PublicKeyContainer::ALT_eccPoint:
TTCN_Logger::log_event_str("{ eccPoint := ");
single_value.field_eccPoint->log();
TTCN_Logger::log_event_str(" }");
break;
case PublicKeyContainer::ALT_aesCcm:
TTCN_Logger::log_event_str("{ aesCcm := ");
single_value.field_aesCcm->log();
TTCN_Logger::log_event_str(" }");
break;
case PublicKeyContainer::ALT_other__key:
TTCN_Logger::log_event_str("{ other_key := ");
single_value.field_other__key->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PublicKeyContainer_template::log_match(const PublicKeyContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case PublicKeyContainer::ALT_eccPoint:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".eccPoint");
single_value.field_eccPoint->log_match(match_value.eccPoint(), legacy);
} else {
TTCN_Logger::log_event_str("{ eccPoint := ");
single_value.field_eccPoint->log_match(match_value.eccPoint(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case PublicKeyContainer::ALT_aesCcm:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".aesCcm");
single_value.field_aesCcm->log_match(match_value.aesCcm(), legacy);
} else {
TTCN_Logger::log_event_str("{ aesCcm := ");
single_value.field_aesCcm->log_match(match_value.aesCcm(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case PublicKeyContainer::ALT_other__key:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".other_key");
single_value.field_other__key->log_match(match_value.other__key(), legacy);
} else {
TTCN_Logger::log_event_str("{ other_key := ");
single_value.field_other__key->log_match(match_value.other__key(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PublicKeyContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case PublicKeyContainer::ALT_eccPoint:
single_value.field_eccPoint->encode_text(text_buf);
break;
case PublicKeyContainer::ALT_aesCcm:
single_value.field_aesCcm->encode_text(text_buf);
break;
case PublicKeyContainer::ALT_other__key:
single_value.field_other__key->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
}
}

void PublicKeyContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = PublicKeyContainer::UNBOUND_VALUE;
PublicKeyContainer::union_selection_type new_selection = (PublicKeyContainer::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case PublicKeyContainer::ALT_eccPoint:
single_value.field_eccPoint = new EccPoint_template;
single_value.field_eccPoint->decode_text(text_buf);
break;
case PublicKeyContainer::ALT_aesCcm:
single_value.field_aesCcm = new AesCcm_template;
single_value.field_aesCcm->decode_text(text_buf);
break;
case PublicKeyContainer::ALT_other__key:
single_value.field_other__key = new OCTETSTRING_template;
single_value.field_other__key->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PublicKeyContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
}
}

boolean PublicKeyContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PublicKeyContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PublicKeyContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsSecurity_TypesAndValues.PublicKeyContainer'");
    }
    if (strcmp("eccPoint", param_field) == 0) {
      eccPoint().set_param(param);
      return;
    } else if (strcmp("aesCcm", param_field) == 0) {
      aesCcm().set_param(param);
      return;
    } else if (strcmp("other_key", param_field) == 0) {
      other__key().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsSecurity_TypesAndValues.PublicKeyContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PublicKeyContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.PublicKeyContainer");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "eccPoint")) {
      eccPoint().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "aesCcm")) {
      aesCcm().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "other_key")) {
      other__key().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.PublicKeyContainer.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.PublicKeyContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* PublicKeyContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsSecurity_TypesAndValues.PublicKeyContainer'");
    }
    if (strcmp("eccPoint", param_field) == 0) {
      return eccPoint().get_param(param_name);
    } else if (strcmp("aesCcm", param_field) == 0) {
      return aesCcm().get_param(param_name);
    } else if (strcmp("other_key", param_field) == 0) {
      return other__key().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `PublicKeyContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case PublicKeyContainer::ALT_eccPoint:
      mp_field = single_value.field_eccPoint->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("eccPoint")));
      break;
    case PublicKeyContainer::ALT_aesCcm:
      mp_field = single_value.field_aesCcm->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("aesCcm")));
      break;
    case PublicKeyContainer::ALT_other__key:
      mp_field = single_value.field_other__key->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("other_key")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void PublicKeyContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case PublicKeyContainer::ALT_eccPoint:
single_value.field_eccPoint->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.PublicKeyContainer");
return;
case PublicKeyContainer::ALT_aesCcm:
single_value.field_aesCcm->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.PublicKeyContainer");
return;
case PublicKeyContainer::ALT_other__key:
single_value.field_other__key->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.PublicKeyContainer");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsSecurity_TypesAndValues.PublicKeyContainer.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.PublicKeyContainer");
}

EccPointType::EccPointType()
{
enum_value = UNBOUND_VALUE;
}

EccPointType::EccPointType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsSecurity_TypesAndValues.EccPointType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

EccPointType::EccPointType(enum_type other_value)
{
enum_value = other_value;
}

EccPointType::EccPointType(const EccPointType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
enum_value = other_value.enum_value;
}

EccPointType& EccPointType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

EccPointType& EccPointType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

EccPointType& EccPointType::operator=(const EccPointType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
enum_value = other_value.enum_value;
return *this;
}

boolean EccPointType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
return enum_value == other_value;
}

boolean EccPointType::operator==(const EccPointType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
return enum_value == other_value.enum_value;
}

boolean EccPointType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
return enum_value < other_value;
}

boolean EccPointType::operator<(const EccPointType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
return enum_value < other_value.enum_value;
}

boolean EccPointType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
return enum_value > other_value;
}

boolean EccPointType::operator>(const EccPointType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
return enum_value > other_value.enum_value;
}

const char *EccPointType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__x__coordinate__only: return "e_x_coordinate_only";
case e__compressed__lsb__y__0: return "e_compressed_lsb_y_0";
case e__compressed__lsb__y__1: return "e_compressed_lsb_y_1";
case e__uncompressed: return "e_uncompressed";
default: return "<unknown>";
}
}

EccPointType::enum_type EccPointType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_x_coordinate_only")) return e__x__coordinate__only;
else if (!strcmp(str_par, "e_compressed_lsb_y_0")) return e__compressed__lsb__y__0;
else if (!strcmp(str_par, "e_compressed_lsb_y_1")) return e__compressed__lsb__y__1;
else if (!strcmp(str_par, "e_uncompressed")) return e__uncompressed;
else return UNKNOWN_VALUE;
}

boolean EccPointType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 2:
case 3:
case 4:
return TRUE;
default:
return FALSE;
}
}

int EccPointType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int EccPointType::enum2int(const EccPointType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void EccPointType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.", int_val);
enum_value = (enum_type)int_val;
}

EccPointType::operator EccPointType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
return enum_value;
}

void EccPointType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void EccPointType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsSecurity_TypesAndValues.EccPointType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.EccPointType.");
  }
}

Module_Param* EccPointType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void EccPointType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
text_buf.push_int(enum_value);
}

void EccPointType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsSecurity_TypesAndValues.EccPointType.", enum_value);
}

void EccPointType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void EccPointType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int EccPointType::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int EccPointType::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

int EccPointType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int EccPointType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void EccPointType_template::copy_template(const EccPointType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new EccPointType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
}
}

EccPointType_template::EccPointType_template()
{
}

EccPointType_template::EccPointType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

EccPointType_template::EccPointType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!EccPointType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsSecurity_TypesAndValues.EccPointType with unknown numeric value %d.", other_value);
single_value = (EccPointType::enum_type)other_value;
}

EccPointType_template::EccPointType_template(EccPointType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

EccPointType_template::EccPointType_template(const EccPointType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == EccPointType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
single_value = other_value.enum_value;
}

EccPointType_template::EccPointType_template(const OPTIONAL<EccPointType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (EccPointType::enum_type)(const EccPointType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsSecurity_TypesAndValues.EccPointType from an unbound optional field.");
}
}

EccPointType_template::EccPointType_template(const EccPointType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

EccPointType_template::~EccPointType_template()
{
clean_up();
}

boolean EccPointType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean EccPointType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != EccPointType::UNBOUND_VALUE;
}

void EccPointType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

EccPointType_template& EccPointType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

EccPointType_template& EccPointType_template::operator=(int other_value)
{
if (!EccPointType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (EccPointType::enum_type)other_value;
return *this;
}

EccPointType_template& EccPointType_template::operator=(EccPointType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

EccPointType_template& EccPointType_template::operator=(const EccPointType& other_value)
{
if (other_value.enum_value == EccPointType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.EccPointType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

EccPointType_template& EccPointType_template::operator=(const OPTIONAL<EccPointType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (EccPointType::enum_type)(const EccPointType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
}
return *this;
}

EccPointType_template& EccPointType_template::operator=(const EccPointType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean EccPointType_template::match(EccPointType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
}
return FALSE;
}

boolean EccPointType_template::match(const EccPointType& other_value, boolean) const
{
if (other_value.enum_value == EccPointType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsSecurity_TypesAndValues.EccPointType with an unbound value.");
return match(other_value.enum_value);
}

EccPointType::enum_type EccPointType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
return single_value;
}

void EccPointType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new EccPointType_template[list_length];
}

EccPointType_template& EccPointType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
return value_list.list_value[list_index];
}

void EccPointType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(EccPointType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void EccPointType_template::log_match(const EccPointType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void EccPointType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
}
}

void EccPointType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (EccPointType::enum_type)text_buf.pull_int().get_val();
if (!EccPointType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new EccPointType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsSecurity_TypesAndValues.EccPointType.");
}
}

boolean EccPointType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean EccPointType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void EccPointType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    EccPointType::enum_type enum_val = (enum_name != NULL) ? EccPointType::str_to_enum(enum_name) : EccPointType::UNKNOWN_VALUE;
    if (EccPointType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    EccPointType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    EccPointType::enum_type enum_val = EccPointType::str_to_enum(mp->get_enumerated());
    if (!EccPointType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.EccPointType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsSecurity_TypesAndValues.EccPointType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* EccPointType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(EccPointType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void EccPointType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.EccPointType");
}

EccPoint::EccPoint()
{
  bound_flag = FALSE;
}

EccPoint::EccPoint(const EccPointType& par_type__,
    const OCTETSTRING& par_x,
    const OPTIONAL<EccPointContainer>& par_y)
  :   field_type__(par_type__),
  field_x(par_x),
  field_y(par_y)
{
  bound_flag = TRUE;
}

EccPoint::EccPoint(const EccPoint& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.EccPoint.");
bound_flag = TRUE;
if (other_value.type__().is_bound()) field_type__ = other_value.type__();
else field_type__.clean_up();
if (other_value.x().is_bound()) field_x = other_value.x();
else field_x.clean_up();
if (other_value.y().is_bound()) field_y = other_value.y();
else field_y.clean_up();
}

void EccPoint::clean_up()
{
field_type__.clean_up();
field_x.clean_up();
field_y.clean_up();
bound_flag = FALSE;
}

EccPoint& EccPoint::operator=(const EccPoint& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.EccPoint.");
  bound_flag = TRUE;
  if (other_value.type__().is_bound()) field_type__ = other_value.type__();
  else field_type__.clean_up();
  if (other_value.x().is_bound()) field_x = other_value.x();
  else field_x.clean_up();
  if (other_value.y().is_bound()) field_y = other_value.y();
  else field_y.clean_up();
}
return *this;
}

boolean EccPoint::operator==(const EccPoint& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_type__==other_value.field_type__
  && field_x==other_value.field_x
  && field_y==other_value.field_y;
}

boolean EccPoint::is_bound() const
{
if (bound_flag) return TRUE;
if(field_type__.is_bound()) return TRUE;
if(field_x.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_y.get_selection() || field_y.is_bound()) return TRUE;
return FALSE;
}
boolean EccPoint::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_type__.is_value()) return FALSE;
if(!field_x.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_y.get_selection() && !field_y.is_value()) return FALSE;
return TRUE;
}
int EccPoint::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.EccPoint");
  int ret_val = 2;
  if (field_y.ispresent()) ret_val++;
  return ret_val;
}

void EccPoint::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ type_ := ");
field_type__.log();
TTCN_Logger::log_event_str(", x := ");
field_x.log();
TTCN_Logger::log_event_str(", y := ");
field_y.log();
TTCN_Logger::log_event_str(" }");
}

void EccPoint::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.EccPoint'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("x", param_field) == 0) {
      x().set_param(param);
      return;
    } else if (strcmp("y", param_field) == 0) {
      y().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.EccPoint'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.EccPoint has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) x().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) y().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "x")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          x().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "y")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          y().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.EccPoint: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.EccPoint");
  }
}

Module_Param* EccPoint::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.EccPoint'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("x", param_field) == 0) {
      return x().get_param(param_name);
    } else if (strcmp("y", param_field) == 0) {
      return y().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.EccPoint'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_type__ = field_type__.get_param(param_name);
  mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
  mp->add_elem(mp_field_type__);
  Module_Param* mp_field_x = field_x.get_param(param_name);
  mp_field_x->set_id(new Module_Param_FieldName(mcopystr("x")));
  mp->add_elem(mp_field_x);
  Module_Param* mp_field_y = field_y.get_param(param_name);
  mp_field_y->set_id(new Module_Param_FieldName(mcopystr("y")));
  mp->add_elem(mp_field_y);
  return mp;
  }

void EccPoint::set_implicit_omit()
{
if (type__().is_bound()) type__().set_implicit_omit();
if (x().is_bound()) x().set_implicit_omit();
if (!y().is_bound()) y() = OMIT_VALUE;
else y().set_implicit_omit();
}

void EccPoint::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.EccPoint.");
field_type__.encode_text(text_buf);
field_x.encode_text(text_buf);
field_y.encode_text(text_buf);
}

void EccPoint::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_type__.decode_text(text_buf);
field_x.decode_text(text_buf);
field_y.decode_text(text_buf);
}

void EccPoint::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void EccPoint::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int EccPoint::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_type__.RAW_decode(EccPointType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_x.RAW_decode(OCTETSTRING_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_y().RAW_decode(EccPointContainer_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_y = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_y=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int EccPoint::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, EccPointType_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, OCTETSTRING_descr_.raw);
  if (field_y.ispresent()) {
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, EccPointContainer_descr_.raw);
  }
  else myleaf.body.node.nodes[2] = NULL;
  encoded_length += field_type__.RAW_encode(EccPointType_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_x.RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[1]);
  if (field_y.ispresent()) {
  encoded_length += field_y().RAW_encode(EccPointContainer_descr_, *myleaf.body.node.nodes[2]);
  }
  return myleaf.length = encoded_length;
}

int EccPoint::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.EccPoint.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "type_");
    enc_len += field_type__.JSON_encode(EccPointType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "x");
    enc_len += field_x.JSON_encode(OCTETSTRING_descr_, p_tok);
  }

  if (field_y.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "y");
    enc_len += field_y.JSON_encode(EccPointContainer_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int EccPoint::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (5 == name_len && 0 == strncmp(fld_name, "type_", name_len)) {
         int ret_val = field_type__.JSON_decode(EccPointType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "type_");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (1 == name_len && 0 == strncmp(fld_name, "x", name_len)) {
         int ret_val = field_x.JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "x");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (1 == name_len && 0 == strncmp(fld_name, "y", name_len)) {
         int ret_val = field_y.JSON_decode(EccPointContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "y");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_type__.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "type_");
    return JSON_ERROR_FATAL;
  }
if (!field_x.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "x");
    return JSON_ERROR_FATAL;
  }
if (!field_y.is_bound()) {
    field_y = OMIT_VALUE;
  }

  return dec_len;
}

struct EccPoint_template::single_value_struct {
EccPointType_template field_type__;
OCTETSTRING_template field_x;
EccPointContainer_template field_y;
};

void EccPoint_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_type__ = ANY_VALUE;
single_value->field_x = ANY_VALUE;
single_value->field_y = ANY_OR_OMIT;
}
}
}

void EccPoint_template::copy_value(const EccPoint& other_value)
{
single_value = new single_value_struct;
if (other_value.type__().is_bound()) {
  single_value->field_type__ = other_value.type__();
} else {
  single_value->field_type__.clean_up();
}
if (other_value.x().is_bound()) {
  single_value->field_x = other_value.x();
} else {
  single_value->field_x.clean_up();
}
if (other_value.y().is_bound()) {
  if (other_value.y().ispresent()) single_value->field_y = other_value.y()();
  else single_value->field_y = OMIT_VALUE;
} else {
  single_value->field_y.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void EccPoint_template::copy_template(const EccPoint_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.type__().get_selection()) {
single_value->field_type__ = other_value.type__();
} else {
single_value->field_type__.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.x().get_selection()) {
single_value->field_x = other_value.x();
} else {
single_value->field_x.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.y().get_selection()) {
single_value->field_y = other_value.y();
} else {
single_value->field_y.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new EccPoint_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.EccPoint.");
break;
}
set_selection(other_value);
}

EccPoint_template::EccPoint_template()
{
}

EccPoint_template::EccPoint_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

EccPoint_template::EccPoint_template(const EccPoint& other_value)
{
copy_value(other_value);
}

EccPoint_template::EccPoint_template(const OPTIONAL<EccPoint>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EccPoint&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.EccPoint from an unbound optional field.");
}
}

EccPoint_template::EccPoint_template(const EccPoint_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

EccPoint_template::~EccPoint_template()
{
clean_up();
}

EccPoint_template& EccPoint_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

EccPoint_template& EccPoint_template::operator=(const EccPoint& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

EccPoint_template& EccPoint_template::operator=(const OPTIONAL<EccPoint>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EccPoint&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.EccPoint.");
}
return *this;
}

EccPoint_template& EccPoint_template::operator=(const EccPoint_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean EccPoint_template::match(const EccPoint& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.type__().is_bound()) return FALSE;
if(!single_value->field_type__.match(other_value.type__(), legacy))return FALSE;
if(!other_value.x().is_bound()) return FALSE;
if(!single_value->field_x.match(other_value.x(), legacy))return FALSE;
if(!other_value.y().is_bound()) return FALSE;
if((other_value.y().ispresent() ? !single_value->field_y.match((const EccPointContainer&)other_value.y(), legacy) : !single_value->field_y.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.EccPoint.");
}
return FALSE;
}

boolean EccPoint_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_type__.is_bound()) return TRUE;
if (single_value->field_x.is_bound()) return TRUE;
if (single_value->field_y.is_omit() || single_value->field_y.is_bound()) return TRUE;
return FALSE;
}

boolean EccPoint_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_type__.is_value()) return FALSE;
if (!single_value->field_x.is_value()) return FALSE;
if (!single_value->field_y.is_omit() && !single_value->field_y.is_value()) return FALSE;
return TRUE;
}

void EccPoint_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

EccPoint EccPoint_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.EccPoint.");
EccPoint ret_val;
if (single_value->field_type__.is_bound()) {
ret_val.type__() = single_value->field_type__.valueof();
}
if (single_value->field_x.is_bound()) {
ret_val.x() = single_value->field_x.valueof();
}
if (single_value->field_y.is_omit()) ret_val.y() = OMIT_VALUE;
else if (single_value->field_y.is_bound()) {
ret_val.y() = single_value->field_y.valueof();
}
return ret_val;
}

void EccPoint_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.EccPoint.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new EccPoint_template[list_length];
}

EccPoint_template& EccPoint_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.EccPoint.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.EccPoint.");
return value_list.list_value[list_index];
}

EccPointType_template& EccPoint_template::type__()
{
set_specific();
return single_value->field_type__;
}

const EccPointType_template& EccPoint_template::type__() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field type_ of a non-specific template of type @LibItsSecurity_TypesAndValues.EccPoint.");
return single_value->field_type__;
}

OCTETSTRING_template& EccPoint_template::x()
{
set_specific();
return single_value->field_x;
}

const OCTETSTRING_template& EccPoint_template::x() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field x of a non-specific template of type @LibItsSecurity_TypesAndValues.EccPoint.");
return single_value->field_x;
}

EccPointContainer_template& EccPoint_template::y()
{
set_specific();
return single_value->field_y;
}

const EccPointContainer_template& EccPoint_template::y() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field y of a non-specific template of type @LibItsSecurity_TypesAndValues.EccPoint.");
return single_value->field_y;
}

int EccPoint_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EccPoint which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 2;
      if (single_value->field_y.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EccPoint containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EccPoint containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EccPoint containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EccPoint containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EccPoint containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.EccPoint.");
  }
  return 0;
}

void EccPoint_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log();
TTCN_Logger::log_event_str(", x := ");
single_value->field_x.log();
TTCN_Logger::log_event_str(", y := ");
single_value->field_y.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void EccPoint_template::log_match(const EccPoint& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_type__.match(match_value.type__(), legacy)){
TTCN_Logger::log_logmatch_info(".type_");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_x.match(match_value.x(), legacy)){
TTCN_Logger::log_logmatch_info(".x");
single_value->field_x.log_match(match_value.x(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.y().ispresent()){
if(!single_value->field_y.match(match_value.y(), legacy)){
TTCN_Logger::log_logmatch_info(".y");
single_value->field_y.log_match(match_value.y(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_y.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".y := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_y.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::log_event_str(", x := ");
single_value->field_x.log_match(match_value.x(), legacy);
TTCN_Logger::log_event_str(", y := ");
if (match_value.y().ispresent()) single_value->field_y.log_match(match_value.y(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_y.log();
if (single_value->field_y.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void EccPoint_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_type__.encode_text(text_buf);
single_value->field_x.encode_text(text_buf);
single_value->field_y.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.EccPoint.");
}
}

void EccPoint_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_type__.decode_text(text_buf);
single_value->field_x.decode_text(text_buf);
single_value->field_y.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new EccPoint_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.EccPoint.");
}
}

void EccPoint_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.EccPoint'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("x", param_field) == 0) {
      x().set_param(param);
      return;
    } else if (strcmp("y", param_field) == 0) {
      y().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.EccPoint'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    EccPoint_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.EccPoint has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) x().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) y().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "x")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          x().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "y")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          y().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.EccPoint: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.EccPoint");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* EccPoint_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.EccPoint'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("x", param_field) == 0) {
      return x().get_param(param_name);
    } else if (strcmp("y", param_field) == 0) {
      return y().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.EccPoint'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_type__ = single_value->field_type__.get_param(param_name);
    mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
    mp->add_elem(mp_field_type__);
    Module_Param* mp_field_x = single_value->field_x.get_param(param_name);
    mp_field_x->set_id(new Module_Param_FieldName(mcopystr("x")));
    mp->add_elem(mp_field_x);
    Module_Param* mp_field_y = single_value->field_y.get_param(param_name);
    mp_field_y->set_id(new Module_Param_FieldName(mcopystr("y")));
    mp->add_elem(mp_field_y);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void EccPoint_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_type__.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.EccPoint");
single_value->field_x.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.EccPoint");
single_value->field_y.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.EccPoint");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.EccPoint");
}

boolean EccPoint_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean EccPoint_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void EccPointContainer::copy_value(const EccPointContainer& other_value)
{
switch (other_value.union_selection) {
case ALT_y:
field_y = new OCTETSTRING(*other_value.field_y);
break;
case ALT_data:
field_data = new OCTETSTRING(*other_value.field_data);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsSecurity_TypesAndValues.EccPointContainer.");
}
union_selection = other_value.union_selection;
}

EccPointContainer::EccPointContainer()
{
union_selection = UNBOUND_VALUE;
}

EccPointContainer::EccPointContainer(const EccPointContainer& other_value)
: Base_Type(){
copy_value(other_value);
}

EccPointContainer::~EccPointContainer()
{
clean_up();
}

EccPointContainer& EccPointContainer::operator=(const EccPointContainer& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean EccPointContainer::operator==(const EccPointContainer& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_y:
return *field_y == *other_value.field_y;
case ALT_data:
return *field_data == *other_value.field_data;
default:
return FALSE;
}
}

OCTETSTRING& EccPointContainer::y()
{
if (union_selection != ALT_y) {
clean_up();
field_y = new OCTETSTRING;
union_selection = ALT_y;
}
return *field_y;
}

const OCTETSTRING& EccPointContainer::y() const
{
if (union_selection != ALT_y) TTCN_error("Using non-selected field y in a value of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
return *field_y;
}

OCTETSTRING& EccPointContainer::data()
{
if (union_selection != ALT_data) {
clean_up();
field_data = new OCTETSTRING;
union_selection = ALT_data;
}
return *field_data;
}

const OCTETSTRING& EccPointContainer::data() const
{
if (union_selection != ALT_data) TTCN_error("Using non-selected field data in a value of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
return *field_data;
}

boolean EccPointContainer::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
return union_selection == checked_selection;
}

boolean EccPointContainer::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean EccPointContainer::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_y: return field_y->is_value();
case ALT_data: return field_data->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void EccPointContainer::clean_up()
{
switch (union_selection) {
case ALT_y:
  delete field_y;
  break;
case ALT_data:
  delete field_data;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void EccPointContainer::log() const
{
switch (union_selection) {
case ALT_y:
TTCN_Logger::log_event_str("{ y := ");
field_y->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_data:
TTCN_Logger::log_event_str("{ data := ");
field_data->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void EccPointContainer::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsSecurity_TypesAndValues.EccPointContainer'");
    }
    if (strcmp("y", param_field) == 0) {
      y().set_param(param);
      return;
    } else if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsSecurity_TypesAndValues.EccPointContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "y")) {
    y().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "data")) {
    data().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.EccPointContainer.", mp_last->get_id()->get_name());
}

Module_Param* EccPointContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsSecurity_TypesAndValues.EccPointContainer'");
    }
    if (strcmp("y", param_field) == 0) {
      return y().get_param(param_name);
    } else if (strcmp("data", param_field) == 0) {
      return data().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `EccPointContainer'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_y:
    mp_field = field_y->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("y")));
    break;
  case ALT_data:
    mp_field = field_data->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("data")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void EccPointContainer::set_implicit_omit()
{
switch (union_selection) {
case ALT_y:
field_y->set_implicit_omit(); break;
case ALT_data:
field_data->set_implicit_omit(); break;
default: break;
}
}

void EccPointContainer::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_y:
field_y->encode_text(text_buf);
break;
case ALT_data:
field_data->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
}
}

void EccPointContainer::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_y:
y().decode_text(text_buf);
break;
case ALT_data:
data().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsSecurity_TypesAndValues.EccPointContainer.");
}
}

void EccPointContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void EccPointContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int EccPointContainer::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = y().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = data().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = y().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = data().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int EccPointContainer::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  memset(myleaf.body.node.nodes, 0, 2 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_y:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, OCTETSTRING_descr_.raw);
    encoded_length = field_y->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &OCTETSTRING_descr_;
    break;
  case ALT_data:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, OCTETSTRING_descr_.raw);
    encoded_length = field_data->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &OCTETSTRING_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int EccPointContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_y:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "y");
    enc_len += field_y->JSON_encode(OCTETSTRING_descr_, p_tok);
    break;
  case ALT_data:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "data");
    enc_len += field_data->JSON_encode(OCTETSTRING_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.EccPointContainer.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int EccPointContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "y", name_len)) {
      int ret_val = y().JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "y");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "data", name_len)) {
      int ret_val = data().JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "data");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void EccPointContainer_template::copy_value(const EccPointContainer& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case EccPointContainer::ALT_y:
single_value.field_y = new OCTETSTRING_template(other_value.y());
break;
case EccPointContainer::ALT_data:
single_value.field_data = new OCTETSTRING_template(other_value.data());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsSecurity_TypesAndValues.EccPointContainer.");
}
set_selection(SPECIFIC_VALUE);
}

void EccPointContainer_template::copy_template(const EccPointContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case EccPointContainer::ALT_y:
single_value.field_y = new OCTETSTRING_template(*other_value.single_value.field_y);
break;
case EccPointContainer::ALT_data:
single_value.field_data = new OCTETSTRING_template(*other_value.single_value.field_data);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsSecurity_TypesAndValues.EccPointContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new EccPointContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
}
set_selection(other_value);
}

EccPointContainer_template::EccPointContainer_template()
{
}

EccPointContainer_template::EccPointContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

EccPointContainer_template::EccPointContainer_template(const EccPointContainer& other_value)
{
copy_value(other_value);
}

EccPointContainer_template::EccPointContainer_template(const OPTIONAL<EccPointContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EccPointContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsSecurity_TypesAndValues.EccPointContainer from an unbound optional field.");
}
}

EccPointContainer_template::EccPointContainer_template(const EccPointContainer_template& other_value)
: Base_Template(){
copy_template(other_value);
}

EccPointContainer_template::~EccPointContainer_template()
{
clean_up();
}

void EccPointContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case EccPointContainer::ALT_y:
delete single_value.field_y;
break;
case EccPointContainer::ALT_data:
delete single_value.field_data;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

EccPointContainer_template& EccPointContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

EccPointContainer_template& EccPointContainer_template::operator=(const EccPointContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

EccPointContainer_template& EccPointContainer_template::operator=(const OPTIONAL<EccPointContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EccPointContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
}
return *this;
}

EccPointContainer_template& EccPointContainer_template::operator=(const EccPointContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean EccPointContainer_template::match(const EccPointContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
EccPointContainer::union_selection_type value_selection = other_value.get_selection();
if (value_selection == EccPointContainer::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case EccPointContainer::ALT_y:
return single_value.field_y->match(other_value.y(), legacy);
case EccPointContainer::ALT_data:
return single_value.field_data->match(other_value.data(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
}
return FALSE;
}

boolean EccPointContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case EccPointContainer::ALT_y:
return single_value.field_y->is_value();
case EccPointContainer::ALT_data:
return single_value.field_data->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
}
}

EccPointContainer EccPointContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
EccPointContainer ret_val;
switch (single_value.union_selection) {
case EccPointContainer::ALT_y:
ret_val.y() = single_value.field_y->valueof();
break;
case EccPointContainer::ALT_data:
ret_val.data() = single_value.field_data->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
}
return ret_val;
}

EccPointContainer_template& EccPointContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
return value_list.list_value[list_index];
}
void EccPointContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new EccPointContainer_template[list_length];
}

OCTETSTRING_template& EccPointContainer_template::y()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != EccPointContainer::ALT_y) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_y = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_y = new OCTETSTRING_template;
single_value.union_selection = EccPointContainer::ALT_y;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_y;
}

const OCTETSTRING_template& EccPointContainer_template::y() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field y in a non-specific template of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
if (single_value.union_selection != EccPointContainer::ALT_y) TTCN_error("Accessing non-selected field y in a template of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
return *single_value.field_y;
}

OCTETSTRING_template& EccPointContainer_template::data()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != EccPointContainer::ALT_data) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_data = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_data = new OCTETSTRING_template;
single_value.union_selection = EccPointContainer::ALT_data;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_data;
}

const OCTETSTRING_template& EccPointContainer_template::data() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field data in a non-specific template of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
if (single_value.union_selection != EccPointContainer::ALT_data) TTCN_error("Accessing non-selected field data in a template of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
return *single_value.field_data;
}

boolean EccPointContainer_template::ischosen(EccPointContainer::union_selection_type checked_selection) const
{
if (checked_selection == EccPointContainer::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == EccPointContainer::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.EccPointContainer containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.EccPointContainer, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsSecurity_TypesAndValues.EccPointContainer");
}
return FALSE;
}

void EccPointContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case EccPointContainer::ALT_y:
TTCN_Logger::log_event_str("{ y := ");
single_value.field_y->log();
TTCN_Logger::log_event_str(" }");
break;
case EccPointContainer::ALT_data:
TTCN_Logger::log_event_str("{ data := ");
single_value.field_data->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void EccPointContainer_template::log_match(const EccPointContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case EccPointContainer::ALT_y:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".y");
single_value.field_y->log_match(match_value.y(), legacy);
} else {
TTCN_Logger::log_event_str("{ y := ");
single_value.field_y->log_match(match_value.y(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case EccPointContainer::ALT_data:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".data");
single_value.field_data->log_match(match_value.data(), legacy);
} else {
TTCN_Logger::log_event_str("{ data := ");
single_value.field_data->log_match(match_value.data(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void EccPointContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case EccPointContainer::ALT_y:
single_value.field_y->encode_text(text_buf);
break;
case EccPointContainer::ALT_data:
single_value.field_data->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsSecurity_TypesAndValues.EccPointContainer.");
}
}

void EccPointContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = EccPointContainer::UNBOUND_VALUE;
EccPointContainer::union_selection_type new_selection = (EccPointContainer::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case EccPointContainer::ALT_y:
single_value.field_y = new OCTETSTRING_template;
single_value.field_y->decode_text(text_buf);
break;
case EccPointContainer::ALT_data:
single_value.field_data = new OCTETSTRING_template;
single_value.field_data->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsSecurity_TypesAndValues.EccPointContainer.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new EccPointContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsSecurity_TypesAndValues.EccPointContainer.");
}
}

boolean EccPointContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean EccPointContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void EccPointContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsSecurity_TypesAndValues.EccPointContainer'");
    }
    if (strcmp("y", param_field) == 0) {
      y().set_param(param);
      return;
    } else if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsSecurity_TypesAndValues.EccPointContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    EccPointContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.EccPointContainer");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "y")) {
      y().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "data")) {
      data().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.EccPointContainer.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.EccPointContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* EccPointContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsSecurity_TypesAndValues.EccPointContainer'");
    }
    if (strcmp("y", param_field) == 0) {
      return y().get_param(param_name);
    } else if (strcmp("data", param_field) == 0) {
      return data().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `EccPointContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case EccPointContainer::ALT_y:
      mp_field = single_value.field_y->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("y")));
      break;
    case EccPointContainer::ALT_data:
      mp_field = single_value.field_data->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("data")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void EccPointContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case EccPointContainer::ALT_y:
single_value.field_y->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.EccPointContainer");
return;
case EccPointContainer::ALT_data:
single_value.field_data->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.EccPointContainer");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsSecurity_TypesAndValues.EccPointContainer.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.EccPointContainer");
}

AesCcm::AesCcm()
{
  bound_flag = FALSE;
}

AesCcm::AesCcm(const SymmetricAlgorithm& par_supported__symm__alg,
    const EccPoint& par_eccPoint)
  :   field_supported__symm__alg(par_supported__symm__alg),
  field_eccPoint(par_eccPoint)
{
  bound_flag = TRUE;
}

AesCcm::AesCcm(const AesCcm& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.AesCcm.");
bound_flag = TRUE;
if (other_value.supported__symm__alg().is_bound()) field_supported__symm__alg = other_value.supported__symm__alg();
else field_supported__symm__alg.clean_up();
if (other_value.eccPoint().is_bound()) field_eccPoint = other_value.eccPoint();
else field_eccPoint.clean_up();
}

void AesCcm::clean_up()
{
field_supported__symm__alg.clean_up();
field_eccPoint.clean_up();
bound_flag = FALSE;
}

AesCcm& AesCcm::operator=(const AesCcm& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.AesCcm.");
  bound_flag = TRUE;
  if (other_value.supported__symm__alg().is_bound()) field_supported__symm__alg = other_value.supported__symm__alg();
  else field_supported__symm__alg.clean_up();
  if (other_value.eccPoint().is_bound()) field_eccPoint = other_value.eccPoint();
  else field_eccPoint.clean_up();
}
return *this;
}

boolean AesCcm::operator==(const AesCcm& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_supported__symm__alg==other_value.field_supported__symm__alg
  && field_eccPoint==other_value.field_eccPoint;
}

boolean AesCcm::is_bound() const
{
if (bound_flag) return TRUE;
if(field_supported__symm__alg.is_bound()) return TRUE;
if(field_eccPoint.is_bound()) return TRUE;
return FALSE;
}
boolean AesCcm::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_supported__symm__alg.is_value()) return FALSE;
if(!field_eccPoint.is_value()) return FALSE;
return TRUE;
}
int AesCcm::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.AesCcm");
  return 2;
}

void AesCcm::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ supported_symm_alg := ");
field_supported__symm__alg.log();
TTCN_Logger::log_event_str(", eccPoint := ");
field_eccPoint.log();
TTCN_Logger::log_event_str(" }");
}

void AesCcm::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.AesCcm'");
    }
    if (strcmp("supported_symm_alg", param_field) == 0) {
      supported__symm__alg().set_param(param);
      return;
    } else if (strcmp("eccPoint", param_field) == 0) {
      eccPoint().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.AesCcm'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.AesCcm has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) supported__symm__alg().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) eccPoint().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "supported_symm_alg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          supported__symm__alg().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eccPoint")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eccPoint().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.AesCcm: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.AesCcm");
  }
}

Module_Param* AesCcm::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.AesCcm'");
    }
    if (strcmp("supported_symm_alg", param_field) == 0) {
      return supported__symm__alg().get_param(param_name);
    } else if (strcmp("eccPoint", param_field) == 0) {
      return eccPoint().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.AesCcm'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_supported__symm__alg = field_supported__symm__alg.get_param(param_name);
  mp_field_supported__symm__alg->set_id(new Module_Param_FieldName(mcopystr("supported_symm_alg")));
  mp->add_elem(mp_field_supported__symm__alg);
  Module_Param* mp_field_eccPoint = field_eccPoint.get_param(param_name);
  mp_field_eccPoint->set_id(new Module_Param_FieldName(mcopystr("eccPoint")));
  mp->add_elem(mp_field_eccPoint);
  return mp;
  }

void AesCcm::set_implicit_omit()
{
if (supported__symm__alg().is_bound()) supported__symm__alg().set_implicit_omit();
if (eccPoint().is_bound()) eccPoint().set_implicit_omit();
}

void AesCcm::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.AesCcm.");
field_supported__symm__alg.encode_text(text_buf);
field_eccPoint.encode_text(text_buf);
}

void AesCcm::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_supported__symm__alg.decode_text(text_buf);
field_eccPoint.decode_text(text_buf);
}

void AesCcm::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AesCcm::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AesCcm::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_supported__symm__alg.RAW_decode(SymmetricAlgorithm_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_eccPoint.RAW_decode(EccPoint_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int AesCcm::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, SymmetricAlgorithm_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, EccPoint_descr_.raw);
  encoded_length += field_supported__symm__alg.RAW_encode(SymmetricAlgorithm_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_eccPoint.RAW_encode(EccPoint_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int AesCcm::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.AesCcm.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "supported_symm_alg");
    enc_len += field_supported__symm__alg.JSON_encode(SymmetricAlgorithm_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "eccPoint");
    enc_len += field_eccPoint.JSON_encode(EccPoint_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AesCcm::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (18 == name_len && 0 == strncmp(fld_name, "supported_symm_alg", name_len)) {
         int ret_val = field_supported__symm__alg.JSON_decode(SymmetricAlgorithm_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "supported_symm_alg");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "eccPoint", name_len)) {
         int ret_val = field_eccPoint.JSON_decode(EccPoint_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "eccPoint");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_supported__symm__alg.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "supported_symm_alg");
    return JSON_ERROR_FATAL;
  }
if (!field_eccPoint.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "eccPoint");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct AesCcm_template::single_value_struct {
SymmetricAlgorithm_template field_supported__symm__alg;
EccPoint_template field_eccPoint;
};

void AesCcm_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_supported__symm__alg = ANY_VALUE;
single_value->field_eccPoint = ANY_VALUE;
}
}
}

void AesCcm_template::copy_value(const AesCcm& other_value)
{
single_value = new single_value_struct;
if (other_value.supported__symm__alg().is_bound()) {
  single_value->field_supported__symm__alg = other_value.supported__symm__alg();
} else {
  single_value->field_supported__symm__alg.clean_up();
}
if (other_value.eccPoint().is_bound()) {
  single_value->field_eccPoint = other_value.eccPoint();
} else {
  single_value->field_eccPoint.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void AesCcm_template::copy_template(const AesCcm_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.supported__symm__alg().get_selection()) {
single_value->field_supported__symm__alg = other_value.supported__symm__alg();
} else {
single_value->field_supported__symm__alg.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.eccPoint().get_selection()) {
single_value->field_eccPoint = other_value.eccPoint();
} else {
single_value->field_eccPoint.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AesCcm_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.AesCcm.");
break;
}
set_selection(other_value);
}

AesCcm_template::AesCcm_template()
{
}

AesCcm_template::AesCcm_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AesCcm_template::AesCcm_template(const AesCcm& other_value)
{
copy_value(other_value);
}

AesCcm_template::AesCcm_template(const OPTIONAL<AesCcm>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AesCcm&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.AesCcm from an unbound optional field.");
}
}

AesCcm_template::AesCcm_template(const AesCcm_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

AesCcm_template::~AesCcm_template()
{
clean_up();
}

AesCcm_template& AesCcm_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AesCcm_template& AesCcm_template::operator=(const AesCcm& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AesCcm_template& AesCcm_template::operator=(const OPTIONAL<AesCcm>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AesCcm&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.AesCcm.");
}
return *this;
}

AesCcm_template& AesCcm_template::operator=(const AesCcm_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AesCcm_template::match(const AesCcm& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.supported__symm__alg().is_bound()) return FALSE;
if(!single_value->field_supported__symm__alg.match(other_value.supported__symm__alg(), legacy))return FALSE;
if(!other_value.eccPoint().is_bound()) return FALSE;
if(!single_value->field_eccPoint.match(other_value.eccPoint(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.AesCcm.");
}
return FALSE;
}

boolean AesCcm_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_supported__symm__alg.is_bound()) return TRUE;
if (single_value->field_eccPoint.is_bound()) return TRUE;
return FALSE;
}

boolean AesCcm_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_supported__symm__alg.is_value()) return FALSE;
if (!single_value->field_eccPoint.is_value()) return FALSE;
return TRUE;
}

void AesCcm_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AesCcm AesCcm_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.AesCcm.");
AesCcm ret_val;
if (single_value->field_supported__symm__alg.is_bound()) {
ret_val.supported__symm__alg() = single_value->field_supported__symm__alg.valueof();
}
if (single_value->field_eccPoint.is_bound()) {
ret_val.eccPoint() = single_value->field_eccPoint.valueof();
}
return ret_val;
}

void AesCcm_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.AesCcm.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AesCcm_template[list_length];
}

AesCcm_template& AesCcm_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.AesCcm.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.AesCcm.");
return value_list.list_value[list_index];
}

SymmetricAlgorithm_template& AesCcm_template::supported__symm__alg()
{
set_specific();
return single_value->field_supported__symm__alg;
}

const SymmetricAlgorithm_template& AesCcm_template::supported__symm__alg() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field supported_symm_alg of a non-specific template of type @LibItsSecurity_TypesAndValues.AesCcm.");
return single_value->field_supported__symm__alg;
}

EccPoint_template& AesCcm_template::eccPoint()
{
set_specific();
return single_value->field_eccPoint;
}

const EccPoint_template& AesCcm_template::eccPoint() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field eccPoint of a non-specific template of type @LibItsSecurity_TypesAndValues.AesCcm.");
return single_value->field_eccPoint;
}

int AesCcm_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AesCcm which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AesCcm containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AesCcm containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AesCcm containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AesCcm containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AesCcm containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.AesCcm.");
  }
  return 0;
}

void AesCcm_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ supported_symm_alg := ");
single_value->field_supported__symm__alg.log();
TTCN_Logger::log_event_str(", eccPoint := ");
single_value->field_eccPoint.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AesCcm_template::log_match(const AesCcm& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_supported__symm__alg.match(match_value.supported__symm__alg(), legacy)){
TTCN_Logger::log_logmatch_info(".supported_symm_alg");
single_value->field_supported__symm__alg.log_match(match_value.supported__symm__alg(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_eccPoint.match(match_value.eccPoint(), legacy)){
TTCN_Logger::log_logmatch_info(".eccPoint");
single_value->field_eccPoint.log_match(match_value.eccPoint(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ supported_symm_alg := ");
single_value->field_supported__symm__alg.log_match(match_value.supported__symm__alg(), legacy);
TTCN_Logger::log_event_str(", eccPoint := ");
single_value->field_eccPoint.log_match(match_value.eccPoint(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AesCcm_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_supported__symm__alg.encode_text(text_buf);
single_value->field_eccPoint.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.AesCcm.");
}
}

void AesCcm_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_supported__symm__alg.decode_text(text_buf);
single_value->field_eccPoint.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AesCcm_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.AesCcm.");
}
}

void AesCcm_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.AesCcm'");
    }
    if (strcmp("supported_symm_alg", param_field) == 0) {
      supported__symm__alg().set_param(param);
      return;
    } else if (strcmp("eccPoint", param_field) == 0) {
      eccPoint().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.AesCcm'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AesCcm_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.AesCcm has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) supported__symm__alg().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) eccPoint().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "supported_symm_alg")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          supported__symm__alg().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "eccPoint")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          eccPoint().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.AesCcm: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.AesCcm");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AesCcm_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.AesCcm'");
    }
    if (strcmp("supported_symm_alg", param_field) == 0) {
      return supported__symm__alg().get_param(param_name);
    } else if (strcmp("eccPoint", param_field) == 0) {
      return eccPoint().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.AesCcm'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_supported__symm__alg = single_value->field_supported__symm__alg.get_param(param_name);
    mp_field_supported__symm__alg->set_id(new Module_Param_FieldName(mcopystr("supported_symm_alg")));
    mp->add_elem(mp_field_supported__symm__alg);
    Module_Param* mp_field_eccPoint = single_value->field_eccPoint.get_param(param_name);
    mp_field_eccPoint->set_id(new Module_Param_FieldName(mcopystr("eccPoint")));
    mp->add_elem(mp_field_eccPoint);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AesCcm_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_supported__symm__alg.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.AesCcm");
single_value->field_eccPoint.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.AesCcm");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.AesCcm");
}

boolean AesCcm_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AesCcm_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

PublicKey::PublicKey()
{
  bound_flag = FALSE;
}

PublicKey::PublicKey(const PublicKeyAlgorithm& par_algorithm,
    const PublicKeyContainer& par_public__key)
  :   field_algorithm(par_algorithm),
  field_public__key(par_public__key)
{
  bound_flag = TRUE;
}

PublicKey::PublicKey(const PublicKey& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.PublicKey.");
bound_flag = TRUE;
if (other_value.algorithm().is_bound()) field_algorithm = other_value.algorithm();
else field_algorithm.clean_up();
if (other_value.public__key().is_bound()) field_public__key = other_value.public__key();
else field_public__key.clean_up();
}

void PublicKey::clean_up()
{
field_algorithm.clean_up();
field_public__key.clean_up();
bound_flag = FALSE;
}

PublicKey& PublicKey::operator=(const PublicKey& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.PublicKey.");
  bound_flag = TRUE;
  if (other_value.algorithm().is_bound()) field_algorithm = other_value.algorithm();
  else field_algorithm.clean_up();
  if (other_value.public__key().is_bound()) field_public__key = other_value.public__key();
  else field_public__key.clean_up();
}
return *this;
}

boolean PublicKey::operator==(const PublicKey& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_algorithm==other_value.field_algorithm
  && field_public__key==other_value.field_public__key;
}

boolean PublicKey::is_bound() const
{
if (bound_flag) return TRUE;
if(field_algorithm.is_bound()) return TRUE;
if(field_public__key.is_bound()) return TRUE;
return FALSE;
}
boolean PublicKey::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_algorithm.is_value()) return FALSE;
if(!field_public__key.is_value()) return FALSE;
return TRUE;
}
int PublicKey::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.PublicKey");
  return 2;
}

void PublicKey::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ algorithm := ");
field_algorithm.log();
TTCN_Logger::log_event_str(", public_key := ");
field_public__key.log();
TTCN_Logger::log_event_str(" }");
}

void PublicKey::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.PublicKey'");
    }
    if (strcmp("algorithm", param_field) == 0) {
      algorithm().set_param(param);
      return;
    } else if (strcmp("public_key", param_field) == 0) {
      public__key().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.PublicKey'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.PublicKey has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) algorithm().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) public__key().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "algorithm")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          algorithm().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "public_key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          public__key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.PublicKey: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.PublicKey");
  }
}

Module_Param* PublicKey::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.PublicKey'");
    }
    if (strcmp("algorithm", param_field) == 0) {
      return algorithm().get_param(param_name);
    } else if (strcmp("public_key", param_field) == 0) {
      return public__key().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.PublicKey'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_algorithm = field_algorithm.get_param(param_name);
  mp_field_algorithm->set_id(new Module_Param_FieldName(mcopystr("algorithm")));
  mp->add_elem(mp_field_algorithm);
  Module_Param* mp_field_public__key = field_public__key.get_param(param_name);
  mp_field_public__key->set_id(new Module_Param_FieldName(mcopystr("public_key")));
  mp->add_elem(mp_field_public__key);
  return mp;
  }

void PublicKey::set_implicit_omit()
{
if (algorithm().is_bound()) algorithm().set_implicit_omit();
if (public__key().is_bound()) public__key().set_implicit_omit();
}

void PublicKey::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.PublicKey.");
field_algorithm.encode_text(text_buf);
field_public__key.encode_text(text_buf);
}

void PublicKey::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_algorithm.decode_text(text_buf);
field_public__key.decode_text(text_buf);
}

void PublicKey::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PublicKey::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PublicKey::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_algorithm.RAW_decode(PublicKeyAlgorithm_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_public__key.RAW_decode(PublicKeyContainer_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int PublicKey::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, PublicKeyAlgorithm_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, PublicKeyContainer_descr_.raw);
  encoded_length += field_algorithm.RAW_encode(PublicKeyAlgorithm_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_public__key.RAW_encode(PublicKeyContainer_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int PublicKey::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.PublicKey.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "algorithm");
    enc_len += field_algorithm.JSON_encode(PublicKeyAlgorithm_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "public_key");
    enc_len += field_public__key.JSON_encode(PublicKeyContainer_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int PublicKey::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (9 == name_len && 0 == strncmp(fld_name, "algorithm", name_len)) {
         int ret_val = field_algorithm.JSON_decode(PublicKeyAlgorithm_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "algorithm");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "public_key", name_len)) {
         int ret_val = field_public__key.JSON_decode(PublicKeyContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "public_key");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_algorithm.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "algorithm");
    return JSON_ERROR_FATAL;
  }
if (!field_public__key.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "public_key");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct PublicKey_template::single_value_struct {
PublicKeyAlgorithm_template field_algorithm;
PublicKeyContainer_template field_public__key;
};

void PublicKey_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_algorithm = ANY_VALUE;
single_value->field_public__key = ANY_VALUE;
}
}
}

void PublicKey_template::copy_value(const PublicKey& other_value)
{
single_value = new single_value_struct;
if (other_value.algorithm().is_bound()) {
  single_value->field_algorithm = other_value.algorithm();
} else {
  single_value->field_algorithm.clean_up();
}
if (other_value.public__key().is_bound()) {
  single_value->field_public__key = other_value.public__key();
} else {
  single_value->field_public__key.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void PublicKey_template::copy_template(const PublicKey_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.algorithm().get_selection()) {
single_value->field_algorithm = other_value.algorithm();
} else {
single_value->field_algorithm.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.public__key().get_selection()) {
single_value->field_public__key = other_value.public__key();
} else {
single_value->field_public__key.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PublicKey_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.PublicKey.");
break;
}
set_selection(other_value);
}

PublicKey_template::PublicKey_template()
{
}

PublicKey_template::PublicKey_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

PublicKey_template::PublicKey_template(const PublicKey& other_value)
{
copy_value(other_value);
}

PublicKey_template::PublicKey_template(const OPTIONAL<PublicKey>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PublicKey&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.PublicKey from an unbound optional field.");
}
}

PublicKey_template::PublicKey_template(const PublicKey_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

PublicKey_template::~PublicKey_template()
{
clean_up();
}

PublicKey_template& PublicKey_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PublicKey_template& PublicKey_template::operator=(const PublicKey& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PublicKey_template& PublicKey_template::operator=(const OPTIONAL<PublicKey>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PublicKey&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.PublicKey.");
}
return *this;
}

PublicKey_template& PublicKey_template::operator=(const PublicKey_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean PublicKey_template::match(const PublicKey& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.algorithm().is_bound()) return FALSE;
if(!single_value->field_algorithm.match(other_value.algorithm(), legacy))return FALSE;
if(!other_value.public__key().is_bound()) return FALSE;
if(!single_value->field_public__key.match(other_value.public__key(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.PublicKey.");
}
return FALSE;
}

boolean PublicKey_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_algorithm.is_bound()) return TRUE;
if (single_value->field_public__key.is_bound()) return TRUE;
return FALSE;
}

boolean PublicKey_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_algorithm.is_value()) return FALSE;
if (!single_value->field_public__key.is_value()) return FALSE;
return TRUE;
}

void PublicKey_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PublicKey PublicKey_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.PublicKey.");
PublicKey ret_val;
if (single_value->field_algorithm.is_bound()) {
ret_val.algorithm() = single_value->field_algorithm.valueof();
}
if (single_value->field_public__key.is_bound()) {
ret_val.public__key() = single_value->field_public__key.valueof();
}
return ret_val;
}

void PublicKey_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.PublicKey.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new PublicKey_template[list_length];
}

PublicKey_template& PublicKey_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.PublicKey.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.PublicKey.");
return value_list.list_value[list_index];
}

PublicKeyAlgorithm_template& PublicKey_template::algorithm()
{
set_specific();
return single_value->field_algorithm;
}

const PublicKeyAlgorithm_template& PublicKey_template::algorithm() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field algorithm of a non-specific template of type @LibItsSecurity_TypesAndValues.PublicKey.");
return single_value->field_algorithm;
}

PublicKeyContainer_template& PublicKey_template::public__key()
{
set_specific();
return single_value->field_public__key;
}

const PublicKeyContainer_template& PublicKey_template::public__key() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field public_key of a non-specific template of type @LibItsSecurity_TypesAndValues.PublicKey.");
return single_value->field_public__key;
}

int PublicKey_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.PublicKey which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.PublicKey containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.PublicKey containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.PublicKey containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.PublicKey containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.PublicKey containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.PublicKey.");
  }
  return 0;
}

void PublicKey_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ algorithm := ");
single_value->field_algorithm.log();
TTCN_Logger::log_event_str(", public_key := ");
single_value->field_public__key.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void PublicKey_template::log_match(const PublicKey& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_algorithm.match(match_value.algorithm(), legacy)){
TTCN_Logger::log_logmatch_info(".algorithm");
single_value->field_algorithm.log_match(match_value.algorithm(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_public__key.match(match_value.public__key(), legacy)){
TTCN_Logger::log_logmatch_info(".public_key");
single_value->field_public__key.log_match(match_value.public__key(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ algorithm := ");
single_value->field_algorithm.log_match(match_value.algorithm(), legacy);
TTCN_Logger::log_event_str(", public_key := ");
single_value->field_public__key.log_match(match_value.public__key(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void PublicKey_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_algorithm.encode_text(text_buf);
single_value->field_public__key.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.PublicKey.");
}
}

void PublicKey_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_algorithm.decode_text(text_buf);
single_value->field_public__key.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PublicKey_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.PublicKey.");
}
}

void PublicKey_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.PublicKey'");
    }
    if (strcmp("algorithm", param_field) == 0) {
      algorithm().set_param(param);
      return;
    } else if (strcmp("public_key", param_field) == 0) {
      public__key().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.PublicKey'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PublicKey_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.PublicKey has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) algorithm().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) public__key().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "algorithm")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          algorithm().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "public_key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          public__key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.PublicKey: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.PublicKey");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* PublicKey_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.PublicKey'");
    }
    if (strcmp("algorithm", param_field) == 0) {
      return algorithm().get_param(param_name);
    } else if (strcmp("public_key", param_field) == 0) {
      return public__key().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.PublicKey'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_algorithm = single_value->field_algorithm.get_param(param_name);
    mp_field_algorithm->set_id(new Module_Param_FieldName(mcopystr("algorithm")));
    mp->add_elem(mp_field_algorithm);
    Module_Param* mp_field_public__key = single_value->field_public__key.get_param(param_name);
    mp_field_public__key->set_id(new Module_Param_FieldName(mcopystr("public_key")));
    mp->add_elem(mp_field_public__key);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void PublicKey_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_algorithm.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.PublicKey");
single_value->field_public__key.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.PublicKey");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.PublicKey");
}

boolean PublicKey_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PublicKey_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void EncryptionParametersContainer::copy_value(const EncryptionParametersContainer& other_value)
{
switch (other_value.union_selection) {
case ALT_nonce:
field_nonce = new OCTETSTRING(*other_value.field_nonce);
break;
case ALT_params:
field_params = new OCTETSTRING(*other_value.field_params);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
}
union_selection = other_value.union_selection;
}

EncryptionParametersContainer::EncryptionParametersContainer()
{
union_selection = UNBOUND_VALUE;
}

EncryptionParametersContainer::EncryptionParametersContainer(const EncryptionParametersContainer& other_value)
: Base_Type(){
copy_value(other_value);
}

EncryptionParametersContainer::~EncryptionParametersContainer()
{
clean_up();
}

EncryptionParametersContainer& EncryptionParametersContainer::operator=(const EncryptionParametersContainer& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean EncryptionParametersContainer::operator==(const EncryptionParametersContainer& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_nonce:
return *field_nonce == *other_value.field_nonce;
case ALT_params:
return *field_params == *other_value.field_params;
default:
return FALSE;
}
}

OCTETSTRING& EncryptionParametersContainer::nonce()
{
if (union_selection != ALT_nonce) {
clean_up();
field_nonce = new OCTETSTRING;
union_selection = ALT_nonce;
}
return *field_nonce;
}

const OCTETSTRING& EncryptionParametersContainer::nonce() const
{
if (union_selection != ALT_nonce) TTCN_error("Using non-selected field nonce in a value of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
return *field_nonce;
}

OCTETSTRING& EncryptionParametersContainer::params()
{
if (union_selection != ALT_params) {
clean_up();
field_params = new OCTETSTRING;
union_selection = ALT_params;
}
return *field_params;
}

const OCTETSTRING& EncryptionParametersContainer::params() const
{
if (union_selection != ALT_params) TTCN_error("Using non-selected field params in a value of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
return *field_params;
}

boolean EncryptionParametersContainer::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
return union_selection == checked_selection;
}

boolean EncryptionParametersContainer::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean EncryptionParametersContainer::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_nonce: return field_nonce->is_value();
case ALT_params: return field_params->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void EncryptionParametersContainer::clean_up()
{
switch (union_selection) {
case ALT_nonce:
  delete field_nonce;
  break;
case ALT_params:
  delete field_params;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void EncryptionParametersContainer::log() const
{
switch (union_selection) {
case ALT_nonce:
TTCN_Logger::log_event_str("{ nonce := ");
field_nonce->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_params:
TTCN_Logger::log_event_str("{ params := ");
field_params->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void EncryptionParametersContainer::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsSecurity_TypesAndValues.EncryptionParametersContainer'");
    }
    if (strcmp("nonce", param_field) == 0) {
      nonce().set_param(param);
      return;
    } else if (strcmp("params", param_field) == 0) {
      params().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsSecurity_TypesAndValues.EncryptionParametersContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "nonce")) {
    nonce().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "params")) {
    params().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.", mp_last->get_id()->get_name());
}

Module_Param* EncryptionParametersContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsSecurity_TypesAndValues.EncryptionParametersContainer'");
    }
    if (strcmp("nonce", param_field) == 0) {
      return nonce().get_param(param_name);
    } else if (strcmp("params", param_field) == 0) {
      return params().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `EncryptionParametersContainer'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_nonce:
    mp_field = field_nonce->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("nonce")));
    break;
  case ALT_params:
    mp_field = field_params->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("params")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void EncryptionParametersContainer::set_implicit_omit()
{
switch (union_selection) {
case ALT_nonce:
field_nonce->set_implicit_omit(); break;
case ALT_params:
field_params->set_implicit_omit(); break;
default: break;
}
}

void EncryptionParametersContainer::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_nonce:
field_nonce->encode_text(text_buf);
break;
case ALT_params:
field_params->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
}
}

void EncryptionParametersContainer::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_nonce:
nonce().decode_text(text_buf);
break;
case ALT_params:
params().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
}
}

void EncryptionParametersContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void EncryptionParametersContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int EncryptionParametersContainer::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = nonce().RAW_decode(LibCommon__DataStrings::Oct12_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = params().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = nonce().RAW_decode(LibCommon__DataStrings::Oct12_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = params().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int EncryptionParametersContainer::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  memset(myleaf.body.node.nodes, 0, 2 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_nonce:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, LibCommon__DataStrings::Oct12_descr_.raw);
    encoded_length = field_nonce->RAW_encode(LibCommon__DataStrings::Oct12_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &LibCommon__DataStrings::Oct12_descr_;
    break;
  case ALT_params:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, OCTETSTRING_descr_.raw);
    encoded_length = field_params->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &OCTETSTRING_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int EncryptionParametersContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_nonce:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "nonce");
    enc_len += field_nonce->JSON_encode(LibCommon__DataStrings::Oct12_descr_, p_tok);
    break;
  case ALT_params:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "params");
    enc_len += field_params->JSON_encode(OCTETSTRING_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int EncryptionParametersContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "nonce", name_len)) {
      int ret_val = nonce().JSON_decode(LibCommon__DataStrings::Oct12_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "nonce");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "params", name_len)) {
      int ret_val = params().JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "params");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void EncryptionParametersContainer_template::copy_value(const EncryptionParametersContainer& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case EncryptionParametersContainer::ALT_nonce:
single_value.field_nonce = new OCTETSTRING_template(other_value.nonce());
break;
case EncryptionParametersContainer::ALT_params:
single_value.field_params = new OCTETSTRING_template(other_value.params());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
}
set_selection(SPECIFIC_VALUE);
}

void EncryptionParametersContainer_template::copy_template(const EncryptionParametersContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case EncryptionParametersContainer::ALT_nonce:
single_value.field_nonce = new OCTETSTRING_template(*other_value.single_value.field_nonce);
break;
case EncryptionParametersContainer::ALT_params:
single_value.field_params = new OCTETSTRING_template(*other_value.single_value.field_params);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new EncryptionParametersContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
}
set_selection(other_value);
}

EncryptionParametersContainer_template::EncryptionParametersContainer_template()
{
}

EncryptionParametersContainer_template::EncryptionParametersContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

EncryptionParametersContainer_template::EncryptionParametersContainer_template(const EncryptionParametersContainer& other_value)
{
copy_value(other_value);
}

EncryptionParametersContainer_template::EncryptionParametersContainer_template(const OPTIONAL<EncryptionParametersContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EncryptionParametersContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer from an unbound optional field.");
}
}

EncryptionParametersContainer_template::EncryptionParametersContainer_template(const EncryptionParametersContainer_template& other_value)
: Base_Template(){
copy_template(other_value);
}

EncryptionParametersContainer_template::~EncryptionParametersContainer_template()
{
clean_up();
}

void EncryptionParametersContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case EncryptionParametersContainer::ALT_nonce:
delete single_value.field_nonce;
break;
case EncryptionParametersContainer::ALT_params:
delete single_value.field_params;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

EncryptionParametersContainer_template& EncryptionParametersContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

EncryptionParametersContainer_template& EncryptionParametersContainer_template::operator=(const EncryptionParametersContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

EncryptionParametersContainer_template& EncryptionParametersContainer_template::operator=(const OPTIONAL<EncryptionParametersContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EncryptionParametersContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
}
return *this;
}

EncryptionParametersContainer_template& EncryptionParametersContainer_template::operator=(const EncryptionParametersContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean EncryptionParametersContainer_template::match(const EncryptionParametersContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
EncryptionParametersContainer::union_selection_type value_selection = other_value.get_selection();
if (value_selection == EncryptionParametersContainer::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case EncryptionParametersContainer::ALT_nonce:
return single_value.field_nonce->match(other_value.nonce(), legacy);
case EncryptionParametersContainer::ALT_params:
return single_value.field_params->match(other_value.params(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
}
return FALSE;
}

boolean EncryptionParametersContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case EncryptionParametersContainer::ALT_nonce:
return single_value.field_nonce->is_value();
case EncryptionParametersContainer::ALT_params:
return single_value.field_params->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
}
}

EncryptionParametersContainer EncryptionParametersContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
EncryptionParametersContainer ret_val;
switch (single_value.union_selection) {
case EncryptionParametersContainer::ALT_nonce:
ret_val.nonce() = single_value.field_nonce->valueof();
break;
case EncryptionParametersContainer::ALT_params:
ret_val.params() = single_value.field_params->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
}
return ret_val;
}

EncryptionParametersContainer_template& EncryptionParametersContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
return value_list.list_value[list_index];
}
void EncryptionParametersContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new EncryptionParametersContainer_template[list_length];
}

OCTETSTRING_template& EncryptionParametersContainer_template::nonce()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != EncryptionParametersContainer::ALT_nonce) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_nonce = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_nonce = new OCTETSTRING_template;
single_value.union_selection = EncryptionParametersContainer::ALT_nonce;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_nonce;
}

const OCTETSTRING_template& EncryptionParametersContainer_template::nonce() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field nonce in a non-specific template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
if (single_value.union_selection != EncryptionParametersContainer::ALT_nonce) TTCN_error("Accessing non-selected field nonce in a template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
return *single_value.field_nonce;
}

OCTETSTRING_template& EncryptionParametersContainer_template::params()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != EncryptionParametersContainer::ALT_params) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_params = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_params = new OCTETSTRING_template;
single_value.union_selection = EncryptionParametersContainer::ALT_params;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_params;
}

const OCTETSTRING_template& EncryptionParametersContainer_template::params() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field params in a non-specific template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
if (single_value.union_selection != EncryptionParametersContainer::ALT_params) TTCN_error("Accessing non-selected field params in a template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
return *single_value.field_params;
}

boolean EncryptionParametersContainer_template::ischosen(EncryptionParametersContainer::union_selection_type checked_selection) const
{
if (checked_selection == EncryptionParametersContainer::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == EncryptionParametersContainer::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer");
}
return FALSE;
}

void EncryptionParametersContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case EncryptionParametersContainer::ALT_nonce:
TTCN_Logger::log_event_str("{ nonce := ");
single_value.field_nonce->log();
TTCN_Logger::log_event_str(" }");
break;
case EncryptionParametersContainer::ALT_params:
TTCN_Logger::log_event_str("{ params := ");
single_value.field_params->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void EncryptionParametersContainer_template::log_match(const EncryptionParametersContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case EncryptionParametersContainer::ALT_nonce:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".nonce");
single_value.field_nonce->log_match(match_value.nonce(), legacy);
} else {
TTCN_Logger::log_event_str("{ nonce := ");
single_value.field_nonce->log_match(match_value.nonce(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case EncryptionParametersContainer::ALT_params:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".params");
single_value.field_params->log_match(match_value.params(), legacy);
} else {
TTCN_Logger::log_event_str("{ params := ");
single_value.field_params->log_match(match_value.params(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void EncryptionParametersContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case EncryptionParametersContainer::ALT_nonce:
single_value.field_nonce->encode_text(text_buf);
break;
case EncryptionParametersContainer::ALT_params:
single_value.field_params->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
}
}

void EncryptionParametersContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = EncryptionParametersContainer::UNBOUND_VALUE;
EncryptionParametersContainer::union_selection_type new_selection = (EncryptionParametersContainer::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case EncryptionParametersContainer::ALT_nonce:
single_value.field_nonce = new OCTETSTRING_template;
single_value.field_nonce->decode_text(text_buf);
break;
case EncryptionParametersContainer::ALT_params:
single_value.field_params = new OCTETSTRING_template;
single_value.field_params->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new EncryptionParametersContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
}
}

boolean EncryptionParametersContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean EncryptionParametersContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void EncryptionParametersContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsSecurity_TypesAndValues.EncryptionParametersContainer'");
    }
    if (strcmp("nonce", param_field) == 0) {
      nonce().set_param(param);
      return;
    } else if (strcmp("params", param_field) == 0) {
      params().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsSecurity_TypesAndValues.EncryptionParametersContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    EncryptionParametersContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.EncryptionParametersContainer");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "nonce")) {
      nonce().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "params")) {
      params().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.EncryptionParametersContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* EncryptionParametersContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsSecurity_TypesAndValues.EncryptionParametersContainer'");
    }
    if (strcmp("nonce", param_field) == 0) {
      return nonce().get_param(param_name);
    } else if (strcmp("params", param_field) == 0) {
      return params().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `EncryptionParametersContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case EncryptionParametersContainer::ALT_nonce:
      mp_field = single_value.field_nonce->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("nonce")));
      break;
    case EncryptionParametersContainer::ALT_params:
      mp_field = single_value.field_params->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("params")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void EncryptionParametersContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case EncryptionParametersContainer::ALT_nonce:
single_value.field_nonce->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.EncryptionParametersContainer");
return;
case EncryptionParametersContainer::ALT_params:
single_value.field_params->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.EncryptionParametersContainer");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsSecurity_TypesAndValues.EncryptionParametersContainer.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.EncryptionParametersContainer");
}

EncryptionParameters::EncryptionParameters()
{
  bound_flag = FALSE;
}

EncryptionParameters::EncryptionParameters(const SymmetricAlgorithm& par_symm__algorithm,
    const EncryptionParametersContainer& par_public__key)
  :   field_symm__algorithm(par_symm__algorithm),
  field_public__key(par_public__key)
{
  bound_flag = TRUE;
}

EncryptionParameters::EncryptionParameters(const EncryptionParameters& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.EncryptionParameters.");
bound_flag = TRUE;
if (other_value.symm__algorithm().is_bound()) field_symm__algorithm = other_value.symm__algorithm();
else field_symm__algorithm.clean_up();
if (other_value.public__key().is_bound()) field_public__key = other_value.public__key();
else field_public__key.clean_up();
}

void EncryptionParameters::clean_up()
{
field_symm__algorithm.clean_up();
field_public__key.clean_up();
bound_flag = FALSE;
}

EncryptionParameters& EncryptionParameters::operator=(const EncryptionParameters& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.EncryptionParameters.");
  bound_flag = TRUE;
  if (other_value.symm__algorithm().is_bound()) field_symm__algorithm = other_value.symm__algorithm();
  else field_symm__algorithm.clean_up();
  if (other_value.public__key().is_bound()) field_public__key = other_value.public__key();
  else field_public__key.clean_up();
}
return *this;
}

boolean EncryptionParameters::operator==(const EncryptionParameters& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_symm__algorithm==other_value.field_symm__algorithm
  && field_public__key==other_value.field_public__key;
}

boolean EncryptionParameters::is_bound() const
{
if (bound_flag) return TRUE;
if(field_symm__algorithm.is_bound()) return TRUE;
if(field_public__key.is_bound()) return TRUE;
return FALSE;
}
boolean EncryptionParameters::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_symm__algorithm.is_value()) return FALSE;
if(!field_public__key.is_value()) return FALSE;
return TRUE;
}
int EncryptionParameters::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.EncryptionParameters");
  return 2;
}

void EncryptionParameters::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ symm_algorithm := ");
field_symm__algorithm.log();
TTCN_Logger::log_event_str(", public_key := ");
field_public__key.log();
TTCN_Logger::log_event_str(" }");
}

void EncryptionParameters::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.EncryptionParameters'");
    }
    if (strcmp("symm_algorithm", param_field) == 0) {
      symm__algorithm().set_param(param);
      return;
    } else if (strcmp("public_key", param_field) == 0) {
      public__key().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.EncryptionParameters'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.EncryptionParameters has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) symm__algorithm().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) public__key().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "symm_algorithm")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          symm__algorithm().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "public_key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          public__key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.EncryptionParameters: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.EncryptionParameters");
  }
}

Module_Param* EncryptionParameters::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.EncryptionParameters'");
    }
    if (strcmp("symm_algorithm", param_field) == 0) {
      return symm__algorithm().get_param(param_name);
    } else if (strcmp("public_key", param_field) == 0) {
      return public__key().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.EncryptionParameters'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_symm__algorithm = field_symm__algorithm.get_param(param_name);
  mp_field_symm__algorithm->set_id(new Module_Param_FieldName(mcopystr("symm_algorithm")));
  mp->add_elem(mp_field_symm__algorithm);
  Module_Param* mp_field_public__key = field_public__key.get_param(param_name);
  mp_field_public__key->set_id(new Module_Param_FieldName(mcopystr("public_key")));
  mp->add_elem(mp_field_public__key);
  return mp;
  }

void EncryptionParameters::set_implicit_omit()
{
if (symm__algorithm().is_bound()) symm__algorithm().set_implicit_omit();
if (public__key().is_bound()) public__key().set_implicit_omit();
}

void EncryptionParameters::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.EncryptionParameters.");
field_symm__algorithm.encode_text(text_buf);
field_public__key.encode_text(text_buf);
}

void EncryptionParameters::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_symm__algorithm.decode_text(text_buf);
field_public__key.decode_text(text_buf);
}

void EncryptionParameters::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void EncryptionParameters::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int EncryptionParameters::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_symm__algorithm.RAW_decode(SymmetricAlgorithm_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_public__key.RAW_decode(EncryptionParametersContainer_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int EncryptionParameters::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, SymmetricAlgorithm_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, EncryptionParametersContainer_descr_.raw);
  encoded_length += field_symm__algorithm.RAW_encode(SymmetricAlgorithm_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_public__key.RAW_encode(EncryptionParametersContainer_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int EncryptionParameters::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.EncryptionParameters.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "symm_algorithm");
    enc_len += field_symm__algorithm.JSON_encode(SymmetricAlgorithm_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "public_key");
    enc_len += field_public__key.JSON_encode(EncryptionParametersContainer_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int EncryptionParameters::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (14 == name_len && 0 == strncmp(fld_name, "symm_algorithm", name_len)) {
         int ret_val = field_symm__algorithm.JSON_decode(SymmetricAlgorithm_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "symm_algorithm");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "public_key", name_len)) {
         int ret_val = field_public__key.JSON_decode(EncryptionParametersContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "public_key");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_symm__algorithm.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "symm_algorithm");
    return JSON_ERROR_FATAL;
  }
if (!field_public__key.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "public_key");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct EncryptionParameters_template::single_value_struct {
SymmetricAlgorithm_template field_symm__algorithm;
EncryptionParametersContainer_template field_public__key;
};

void EncryptionParameters_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_symm__algorithm = ANY_VALUE;
single_value->field_public__key = ANY_VALUE;
}
}
}

void EncryptionParameters_template::copy_value(const EncryptionParameters& other_value)
{
single_value = new single_value_struct;
if (other_value.symm__algorithm().is_bound()) {
  single_value->field_symm__algorithm = other_value.symm__algorithm();
} else {
  single_value->field_symm__algorithm.clean_up();
}
if (other_value.public__key().is_bound()) {
  single_value->field_public__key = other_value.public__key();
} else {
  single_value->field_public__key.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void EncryptionParameters_template::copy_template(const EncryptionParameters_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.symm__algorithm().get_selection()) {
single_value->field_symm__algorithm = other_value.symm__algorithm();
} else {
single_value->field_symm__algorithm.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.public__key().get_selection()) {
single_value->field_public__key = other_value.public__key();
} else {
single_value->field_public__key.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new EncryptionParameters_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.EncryptionParameters.");
break;
}
set_selection(other_value);
}

EncryptionParameters_template::EncryptionParameters_template()
{
}

EncryptionParameters_template::EncryptionParameters_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

EncryptionParameters_template::EncryptionParameters_template(const EncryptionParameters& other_value)
{
copy_value(other_value);
}

EncryptionParameters_template::EncryptionParameters_template(const OPTIONAL<EncryptionParameters>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EncryptionParameters&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.EncryptionParameters from an unbound optional field.");
}
}

EncryptionParameters_template::EncryptionParameters_template(const EncryptionParameters_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

EncryptionParameters_template::~EncryptionParameters_template()
{
clean_up();
}

EncryptionParameters_template& EncryptionParameters_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

EncryptionParameters_template& EncryptionParameters_template::operator=(const EncryptionParameters& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

EncryptionParameters_template& EncryptionParameters_template::operator=(const OPTIONAL<EncryptionParameters>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EncryptionParameters&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.EncryptionParameters.");
}
return *this;
}

EncryptionParameters_template& EncryptionParameters_template::operator=(const EncryptionParameters_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean EncryptionParameters_template::match(const EncryptionParameters& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.symm__algorithm().is_bound()) return FALSE;
if(!single_value->field_symm__algorithm.match(other_value.symm__algorithm(), legacy))return FALSE;
if(!other_value.public__key().is_bound()) return FALSE;
if(!single_value->field_public__key.match(other_value.public__key(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.EncryptionParameters.");
}
return FALSE;
}

boolean EncryptionParameters_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_symm__algorithm.is_bound()) return TRUE;
if (single_value->field_public__key.is_bound()) return TRUE;
return FALSE;
}

boolean EncryptionParameters_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_symm__algorithm.is_value()) return FALSE;
if (!single_value->field_public__key.is_value()) return FALSE;
return TRUE;
}

void EncryptionParameters_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

EncryptionParameters EncryptionParameters_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.EncryptionParameters.");
EncryptionParameters ret_val;
if (single_value->field_symm__algorithm.is_bound()) {
ret_val.symm__algorithm() = single_value->field_symm__algorithm.valueof();
}
if (single_value->field_public__key.is_bound()) {
ret_val.public__key() = single_value->field_public__key.valueof();
}
return ret_val;
}

void EncryptionParameters_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.EncryptionParameters.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new EncryptionParameters_template[list_length];
}

EncryptionParameters_template& EncryptionParameters_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.EncryptionParameters.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.EncryptionParameters.");
return value_list.list_value[list_index];
}

SymmetricAlgorithm_template& EncryptionParameters_template::symm__algorithm()
{
set_specific();
return single_value->field_symm__algorithm;
}

const SymmetricAlgorithm_template& EncryptionParameters_template::symm__algorithm() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field symm_algorithm of a non-specific template of type @LibItsSecurity_TypesAndValues.EncryptionParameters.");
return single_value->field_symm__algorithm;
}

EncryptionParametersContainer_template& EncryptionParameters_template::public__key()
{
set_specific();
return single_value->field_public__key;
}

const EncryptionParametersContainer_template& EncryptionParameters_template::public__key() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field public_key of a non-specific template of type @LibItsSecurity_TypesAndValues.EncryptionParameters.");
return single_value->field_public__key;
}

int EncryptionParameters_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EncryptionParameters which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EncryptionParameters containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EncryptionParameters containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EncryptionParameters containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EncryptionParameters containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EncryptionParameters containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.EncryptionParameters.");
  }
  return 0;
}

void EncryptionParameters_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ symm_algorithm := ");
single_value->field_symm__algorithm.log();
TTCN_Logger::log_event_str(", public_key := ");
single_value->field_public__key.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void EncryptionParameters_template::log_match(const EncryptionParameters& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_symm__algorithm.match(match_value.symm__algorithm(), legacy)){
TTCN_Logger::log_logmatch_info(".symm_algorithm");
single_value->field_symm__algorithm.log_match(match_value.symm__algorithm(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_public__key.match(match_value.public__key(), legacy)){
TTCN_Logger::log_logmatch_info(".public_key");
single_value->field_public__key.log_match(match_value.public__key(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ symm_algorithm := ");
single_value->field_symm__algorithm.log_match(match_value.symm__algorithm(), legacy);
TTCN_Logger::log_event_str(", public_key := ");
single_value->field_public__key.log_match(match_value.public__key(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void EncryptionParameters_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_symm__algorithm.encode_text(text_buf);
single_value->field_public__key.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.EncryptionParameters.");
}
}

void EncryptionParameters_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_symm__algorithm.decode_text(text_buf);
single_value->field_public__key.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new EncryptionParameters_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.EncryptionParameters.");
}
}

void EncryptionParameters_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.EncryptionParameters'");
    }
    if (strcmp("symm_algorithm", param_field) == 0) {
      symm__algorithm().set_param(param);
      return;
    } else if (strcmp("public_key", param_field) == 0) {
      public__key().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.EncryptionParameters'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    EncryptionParameters_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.EncryptionParameters has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) symm__algorithm().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) public__key().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "symm_algorithm")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          symm__algorithm().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "public_key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          public__key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.EncryptionParameters: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.EncryptionParameters");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* EncryptionParameters_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.EncryptionParameters'");
    }
    if (strcmp("symm_algorithm", param_field) == 0) {
      return symm__algorithm().get_param(param_name);
    } else if (strcmp("public_key", param_field) == 0) {
      return public__key().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.EncryptionParameters'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_symm__algorithm = single_value->field_symm__algorithm.get_param(param_name);
    mp_field_symm__algorithm->set_id(new Module_Param_FieldName(mcopystr("symm_algorithm")));
    mp->add_elem(mp_field_symm__algorithm);
    Module_Param* mp_field_public__key = single_value->field_public__key.get_param(param_name);
    mp_field_public__key->set_id(new Module_Param_FieldName(mcopystr("public_key")));
    mp->add_elem(mp_field_public__key);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void EncryptionParameters_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_symm__algorithm.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.EncryptionParameters");
single_value->field_public__key.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.EncryptionParameters");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.EncryptionParameters");
}

boolean EncryptionParameters_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean EncryptionParameters_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SignatureContainer::copy_value(const SignatureContainer& other_value)
{
switch (other_value.union_selection) {
case ALT_ecdsa__signature:
field_ecdsa__signature = new EcdsaSignature(*other_value.field_ecdsa__signature);
break;
case ALT_signature__:
field_signature__ = new OCTETSTRING(*other_value.field_signature__);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsSecurity_TypesAndValues.SignatureContainer.");
}
union_selection = other_value.union_selection;
}

SignatureContainer::SignatureContainer()
{
union_selection = UNBOUND_VALUE;
}

SignatureContainer::SignatureContainer(const SignatureContainer& other_value)
: Base_Type(){
copy_value(other_value);
}

SignatureContainer::~SignatureContainer()
{
clean_up();
}

SignatureContainer& SignatureContainer::operator=(const SignatureContainer& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean SignatureContainer::operator==(const SignatureContainer& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_ecdsa__signature:
return *field_ecdsa__signature == *other_value.field_ecdsa__signature;
case ALT_signature__:
return *field_signature__ == *other_value.field_signature__;
default:
return FALSE;
}
}

EcdsaSignature& SignatureContainer::ecdsa__signature()
{
if (union_selection != ALT_ecdsa__signature) {
clean_up();
field_ecdsa__signature = new EcdsaSignature;
union_selection = ALT_ecdsa__signature;
}
return *field_ecdsa__signature;
}

const EcdsaSignature& SignatureContainer::ecdsa__signature() const
{
if (union_selection != ALT_ecdsa__signature) TTCN_error("Using non-selected field ecdsa_signature in a value of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
return *field_ecdsa__signature;
}

OCTETSTRING& SignatureContainer::signature__()
{
if (union_selection != ALT_signature__) {
clean_up();
field_signature__ = new OCTETSTRING;
union_selection = ALT_signature__;
}
return *field_signature__;
}

const OCTETSTRING& SignatureContainer::signature__() const
{
if (union_selection != ALT_signature__) TTCN_error("Using non-selected field signature_ in a value of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
return *field_signature__;
}

boolean SignatureContainer::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
return union_selection == checked_selection;
}

boolean SignatureContainer::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean SignatureContainer::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_ecdsa__signature: return field_ecdsa__signature->is_value();
case ALT_signature__: return field_signature__->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void SignatureContainer::clean_up()
{
switch (union_selection) {
case ALT_ecdsa__signature:
  delete field_ecdsa__signature;
  break;
case ALT_signature__:
  delete field_signature__;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void SignatureContainer::log() const
{
switch (union_selection) {
case ALT_ecdsa__signature:
TTCN_Logger::log_event_str("{ ecdsa_signature := ");
field_ecdsa__signature->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_signature__:
TTCN_Logger::log_event_str("{ signature_ := ");
field_signature__->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void SignatureContainer::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsSecurity_TypesAndValues.SignatureContainer'");
    }
    if (strcmp("ecdsa_signature", param_field) == 0) {
      ecdsa__signature().set_param(param);
      return;
    } else if (strcmp("signature_", param_field) == 0) {
      signature__().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsSecurity_TypesAndValues.SignatureContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "ecdsa_signature")) {
    ecdsa__signature().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "signature_")) {
    signature__().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.SignatureContainer.", mp_last->get_id()->get_name());
}

Module_Param* SignatureContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsSecurity_TypesAndValues.SignatureContainer'");
    }
    if (strcmp("ecdsa_signature", param_field) == 0) {
      return ecdsa__signature().get_param(param_name);
    } else if (strcmp("signature_", param_field) == 0) {
      return signature__().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `SignatureContainer'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_ecdsa__signature:
    mp_field = field_ecdsa__signature->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("ecdsa_signature")));
    break;
  case ALT_signature__:
    mp_field = field_signature__->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("signature_")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void SignatureContainer::set_implicit_omit()
{
switch (union_selection) {
case ALT_ecdsa__signature:
field_ecdsa__signature->set_implicit_omit(); break;
case ALT_signature__:
field_signature__->set_implicit_omit(); break;
default: break;
}
}

void SignatureContainer::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_ecdsa__signature:
field_ecdsa__signature->encode_text(text_buf);
break;
case ALT_signature__:
field_signature__->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
}
}

void SignatureContainer::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_ecdsa__signature:
ecdsa__signature().decode_text(text_buf);
break;
case ALT_signature__:
signature__().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsSecurity_TypesAndValues.SignatureContainer.");
}
}

void SignatureContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SignatureContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SignatureContainer::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = ecdsa__signature().RAW_decode(EcdsaSignature_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = signature__().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = ecdsa__signature().RAW_decode(EcdsaSignature_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = signature__().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int SignatureContainer::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  memset(myleaf.body.node.nodes, 0, 2 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_ecdsa__signature:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, EcdsaSignature_descr_.raw);
    encoded_length = field_ecdsa__signature->RAW_encode(EcdsaSignature_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &EcdsaSignature_descr_;
    break;
  case ALT_signature__:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, OCTETSTRING_descr_.raw);
    encoded_length = field_signature__->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &OCTETSTRING_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int SignatureContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_ecdsa__signature:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "ecdsa_signature");
    enc_len += field_ecdsa__signature->JSON_encode(EcdsaSignature_descr_, p_tok);
    break;
  case ALT_signature__:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "signature_");
    enc_len += field_signature__->JSON_encode(OCTETSTRING_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.SignatureContainer.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SignatureContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "ecdsa_signature", name_len)) {
      int ret_val = ecdsa__signature().JSON_decode(EcdsaSignature_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "ecdsa_signature");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "signature_", name_len)) {
      int ret_val = signature__().JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "signature_");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void SignatureContainer_template::copy_value(const SignatureContainer& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case SignatureContainer::ALT_ecdsa__signature:
single_value.field_ecdsa__signature = new EcdsaSignature_template(other_value.ecdsa__signature());
break;
case SignatureContainer::ALT_signature__:
single_value.field_signature__ = new OCTETSTRING_template(other_value.signature__());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsSecurity_TypesAndValues.SignatureContainer.");
}
set_selection(SPECIFIC_VALUE);
}

void SignatureContainer_template::copy_template(const SignatureContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case SignatureContainer::ALT_ecdsa__signature:
single_value.field_ecdsa__signature = new EcdsaSignature_template(*other_value.single_value.field_ecdsa__signature);
break;
case SignatureContainer::ALT_signature__:
single_value.field_signature__ = new OCTETSTRING_template(*other_value.single_value.field_signature__);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsSecurity_TypesAndValues.SignatureContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SignatureContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
}
set_selection(other_value);
}

SignatureContainer_template::SignatureContainer_template()
{
}

SignatureContainer_template::SignatureContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SignatureContainer_template::SignatureContainer_template(const SignatureContainer& other_value)
{
copy_value(other_value);
}

SignatureContainer_template::SignatureContainer_template(const OPTIONAL<SignatureContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SignatureContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsSecurity_TypesAndValues.SignatureContainer from an unbound optional field.");
}
}

SignatureContainer_template::SignatureContainer_template(const SignatureContainer_template& other_value)
: Base_Template(){
copy_template(other_value);
}

SignatureContainer_template::~SignatureContainer_template()
{
clean_up();
}

void SignatureContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case SignatureContainer::ALT_ecdsa__signature:
delete single_value.field_ecdsa__signature;
break;
case SignatureContainer::ALT_signature__:
delete single_value.field_signature__;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SignatureContainer_template& SignatureContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SignatureContainer_template& SignatureContainer_template::operator=(const SignatureContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SignatureContainer_template& SignatureContainer_template::operator=(const OPTIONAL<SignatureContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SignatureContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
}
return *this;
}

SignatureContainer_template& SignatureContainer_template::operator=(const SignatureContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SignatureContainer_template::match(const SignatureContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
SignatureContainer::union_selection_type value_selection = other_value.get_selection();
if (value_selection == SignatureContainer::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case SignatureContainer::ALT_ecdsa__signature:
return single_value.field_ecdsa__signature->match(other_value.ecdsa__signature(), legacy);
case SignatureContainer::ALT_signature__:
return single_value.field_signature__->match(other_value.signature__(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
}
return FALSE;
}

boolean SignatureContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case SignatureContainer::ALT_ecdsa__signature:
return single_value.field_ecdsa__signature->is_value();
case SignatureContainer::ALT_signature__:
return single_value.field_signature__->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
}
}

SignatureContainer SignatureContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
SignatureContainer ret_val;
switch (single_value.union_selection) {
case SignatureContainer::ALT_ecdsa__signature:
ret_val.ecdsa__signature() = single_value.field_ecdsa__signature->valueof();
break;
case SignatureContainer::ALT_signature__:
ret_val.signature__() = single_value.field_signature__->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
}
return ret_val;
}

SignatureContainer_template& SignatureContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
return value_list.list_value[list_index];
}
void SignatureContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SignatureContainer_template[list_length];
}

EcdsaSignature_template& SignatureContainer_template::ecdsa__signature()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SignatureContainer::ALT_ecdsa__signature) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_ecdsa__signature = new EcdsaSignature_template(ANY_VALUE);
else single_value.field_ecdsa__signature = new EcdsaSignature_template;
single_value.union_selection = SignatureContainer::ALT_ecdsa__signature;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_ecdsa__signature;
}

const EcdsaSignature_template& SignatureContainer_template::ecdsa__signature() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field ecdsa_signature in a non-specific template of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
if (single_value.union_selection != SignatureContainer::ALT_ecdsa__signature) TTCN_error("Accessing non-selected field ecdsa_signature in a template of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
return *single_value.field_ecdsa__signature;
}

OCTETSTRING_template& SignatureContainer_template::signature__()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SignatureContainer::ALT_signature__) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_signature__ = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_signature__ = new OCTETSTRING_template;
single_value.union_selection = SignatureContainer::ALT_signature__;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_signature__;
}

const OCTETSTRING_template& SignatureContainer_template::signature__() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field signature_ in a non-specific template of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
if (single_value.union_selection != SignatureContainer::ALT_signature__) TTCN_error("Accessing non-selected field signature_ in a template of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
return *single_value.field_signature__;
}

boolean SignatureContainer_template::ischosen(SignatureContainer::union_selection_type checked_selection) const
{
if (checked_selection == SignatureContainer::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == SignatureContainer::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.SignatureContainer containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.SignatureContainer, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsSecurity_TypesAndValues.SignatureContainer");
}
return FALSE;
}

void SignatureContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case SignatureContainer::ALT_ecdsa__signature:
TTCN_Logger::log_event_str("{ ecdsa_signature := ");
single_value.field_ecdsa__signature->log();
TTCN_Logger::log_event_str(" }");
break;
case SignatureContainer::ALT_signature__:
TTCN_Logger::log_event_str("{ signature_ := ");
single_value.field_signature__->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SignatureContainer_template::log_match(const SignatureContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case SignatureContainer::ALT_ecdsa__signature:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".ecdsa_signature");
single_value.field_ecdsa__signature->log_match(match_value.ecdsa__signature(), legacy);
} else {
TTCN_Logger::log_event_str("{ ecdsa_signature := ");
single_value.field_ecdsa__signature->log_match(match_value.ecdsa__signature(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SignatureContainer::ALT_signature__:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".signature_");
single_value.field_signature__->log_match(match_value.signature__(), legacy);
} else {
TTCN_Logger::log_event_str("{ signature_ := ");
single_value.field_signature__->log_match(match_value.signature__(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SignatureContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case SignatureContainer::ALT_ecdsa__signature:
single_value.field_ecdsa__signature->encode_text(text_buf);
break;
case SignatureContainer::ALT_signature__:
single_value.field_signature__->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsSecurity_TypesAndValues.SignatureContainer.");
}
}

void SignatureContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = SignatureContainer::UNBOUND_VALUE;
SignatureContainer::union_selection_type new_selection = (SignatureContainer::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case SignatureContainer::ALT_ecdsa__signature:
single_value.field_ecdsa__signature = new EcdsaSignature_template;
single_value.field_ecdsa__signature->decode_text(text_buf);
break;
case SignatureContainer::ALT_signature__:
single_value.field_signature__ = new OCTETSTRING_template;
single_value.field_signature__->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsSecurity_TypesAndValues.SignatureContainer.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SignatureContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsSecurity_TypesAndValues.SignatureContainer.");
}
}

boolean SignatureContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SignatureContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SignatureContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsSecurity_TypesAndValues.SignatureContainer'");
    }
    if (strcmp("ecdsa_signature", param_field) == 0) {
      ecdsa__signature().set_param(param);
      return;
    } else if (strcmp("signature_", param_field) == 0) {
      signature__().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsSecurity_TypesAndValues.SignatureContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SignatureContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.SignatureContainer");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "ecdsa_signature")) {
      ecdsa__signature().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "signature_")) {
      signature__().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.SignatureContainer.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.SignatureContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SignatureContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsSecurity_TypesAndValues.SignatureContainer'");
    }
    if (strcmp("ecdsa_signature", param_field) == 0) {
      return ecdsa__signature().get_param(param_name);
    } else if (strcmp("signature_", param_field) == 0) {
      return signature__().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `SignatureContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case SignatureContainer::ALT_ecdsa__signature:
      mp_field = single_value.field_ecdsa__signature->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("ecdsa_signature")));
      break;
    case SignatureContainer::ALT_signature__:
      mp_field = single_value.field_signature__->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("signature_")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SignatureContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case SignatureContainer::ALT_ecdsa__signature:
single_value.field_ecdsa__signature->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SignatureContainer");
return;
case SignatureContainer::ALT_signature__:
single_value.field_signature__->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SignatureContainer");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsSecurity_TypesAndValues.SignatureContainer.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.SignatureContainer");
}

EcdsaSignature::EcdsaSignature()
{
  bound_flag = FALSE;
}

EcdsaSignature::EcdsaSignature(const EccPoint& par_r,
    const OCTETSTRING& par_s)
  :   field_r(par_r),
  field_s(par_s)
{
  bound_flag = TRUE;
}

EcdsaSignature::EcdsaSignature(const EcdsaSignature& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.EcdsaSignature.");
bound_flag = TRUE;
if (other_value.r().is_bound()) field_r = other_value.r();
else field_r.clean_up();
if (other_value.s().is_bound()) field_s = other_value.s();
else field_s.clean_up();
}

void EcdsaSignature::clean_up()
{
field_r.clean_up();
field_s.clean_up();
bound_flag = FALSE;
}

EcdsaSignature& EcdsaSignature::operator=(const EcdsaSignature& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.EcdsaSignature.");
  bound_flag = TRUE;
  if (other_value.r().is_bound()) field_r = other_value.r();
  else field_r.clean_up();
  if (other_value.s().is_bound()) field_s = other_value.s();
  else field_s.clean_up();
}
return *this;
}

boolean EcdsaSignature::operator==(const EcdsaSignature& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_r==other_value.field_r
  && field_s==other_value.field_s;
}

boolean EcdsaSignature::is_bound() const
{
if (bound_flag) return TRUE;
if(field_r.is_bound()) return TRUE;
if(field_s.is_bound()) return TRUE;
return FALSE;
}
boolean EcdsaSignature::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_r.is_value()) return FALSE;
if(!field_s.is_value()) return FALSE;
return TRUE;
}
int EcdsaSignature::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.EcdsaSignature");
  return 2;
}

void EcdsaSignature::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ r := ");
field_r.log();
TTCN_Logger::log_event_str(", s := ");
field_s.log();
TTCN_Logger::log_event_str(" }");
}

void EcdsaSignature::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.EcdsaSignature'");
    }
    if (strcmp("r", param_field) == 0) {
      r().set_param(param);
      return;
    } else if (strcmp("s", param_field) == 0) {
      s().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.EcdsaSignature'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.EcdsaSignature has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) r().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) s().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "r")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          r().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "s")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          s().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.EcdsaSignature: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.EcdsaSignature");
  }
}

Module_Param* EcdsaSignature::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.EcdsaSignature'");
    }
    if (strcmp("r", param_field) == 0) {
      return r().get_param(param_name);
    } else if (strcmp("s", param_field) == 0) {
      return s().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.EcdsaSignature'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_r = field_r.get_param(param_name);
  mp_field_r->set_id(new Module_Param_FieldName(mcopystr("r")));
  mp->add_elem(mp_field_r);
  Module_Param* mp_field_s = field_s.get_param(param_name);
  mp_field_s->set_id(new Module_Param_FieldName(mcopystr("s")));
  mp->add_elem(mp_field_s);
  return mp;
  }

void EcdsaSignature::set_implicit_omit()
{
if (r().is_bound()) r().set_implicit_omit();
if (s().is_bound()) s().set_implicit_omit();
}

void EcdsaSignature::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.EcdsaSignature.");
field_r.encode_text(text_buf);
field_s.encode_text(text_buf);
}

void EcdsaSignature::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_r.decode_text(text_buf);
field_s.decode_text(text_buf);
}

void EcdsaSignature::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void EcdsaSignature::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int EcdsaSignature::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_r.RAW_decode(EccPoint_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_s.RAW_decode(OCTETSTRING_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int EcdsaSignature::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, EccPoint_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, OCTETSTRING_descr_.raw);
  encoded_length += field_r.RAW_encode(EccPoint_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_s.RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int EcdsaSignature::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.EcdsaSignature.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "r");
    enc_len += field_r.JSON_encode(EccPoint_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "s");
    enc_len += field_s.JSON_encode(OCTETSTRING_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int EcdsaSignature::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (1 == name_len && 0 == strncmp(fld_name, "r", name_len)) {
         int ret_val = field_r.JSON_decode(EccPoint_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "r");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (1 == name_len && 0 == strncmp(fld_name, "s", name_len)) {
         int ret_val = field_s.JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "s");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_r.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "r");
    return JSON_ERROR_FATAL;
  }
if (!field_s.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "s");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct EcdsaSignature_template::single_value_struct {
EccPoint_template field_r;
OCTETSTRING_template field_s;
};

void EcdsaSignature_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_r = ANY_VALUE;
single_value->field_s = ANY_VALUE;
}
}
}

void EcdsaSignature_template::copy_value(const EcdsaSignature& other_value)
{
single_value = new single_value_struct;
if (other_value.r().is_bound()) {
  single_value->field_r = other_value.r();
} else {
  single_value->field_r.clean_up();
}
if (other_value.s().is_bound()) {
  single_value->field_s = other_value.s();
} else {
  single_value->field_s.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void EcdsaSignature_template::copy_template(const EcdsaSignature_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.r().get_selection()) {
single_value->field_r = other_value.r();
} else {
single_value->field_r.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.s().get_selection()) {
single_value->field_s = other_value.s();
} else {
single_value->field_s.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new EcdsaSignature_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.EcdsaSignature.");
break;
}
set_selection(other_value);
}

EcdsaSignature_template::EcdsaSignature_template()
{
}

EcdsaSignature_template::EcdsaSignature_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

EcdsaSignature_template::EcdsaSignature_template(const EcdsaSignature& other_value)
{
copy_value(other_value);
}

EcdsaSignature_template::EcdsaSignature_template(const OPTIONAL<EcdsaSignature>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EcdsaSignature&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.EcdsaSignature from an unbound optional field.");
}
}

EcdsaSignature_template::EcdsaSignature_template(const EcdsaSignature_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

EcdsaSignature_template::~EcdsaSignature_template()
{
clean_up();
}

EcdsaSignature_template& EcdsaSignature_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

EcdsaSignature_template& EcdsaSignature_template::operator=(const EcdsaSignature& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

EcdsaSignature_template& EcdsaSignature_template::operator=(const OPTIONAL<EcdsaSignature>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EcdsaSignature&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.EcdsaSignature.");
}
return *this;
}

EcdsaSignature_template& EcdsaSignature_template::operator=(const EcdsaSignature_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean EcdsaSignature_template::match(const EcdsaSignature& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.r().is_bound()) return FALSE;
if(!single_value->field_r.match(other_value.r(), legacy))return FALSE;
if(!other_value.s().is_bound()) return FALSE;
if(!single_value->field_s.match(other_value.s(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.EcdsaSignature.");
}
return FALSE;
}

boolean EcdsaSignature_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_r.is_bound()) return TRUE;
if (single_value->field_s.is_bound()) return TRUE;
return FALSE;
}

boolean EcdsaSignature_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_r.is_value()) return FALSE;
if (!single_value->field_s.is_value()) return FALSE;
return TRUE;
}

void EcdsaSignature_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

EcdsaSignature EcdsaSignature_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.EcdsaSignature.");
EcdsaSignature ret_val;
if (single_value->field_r.is_bound()) {
ret_val.r() = single_value->field_r.valueof();
}
if (single_value->field_s.is_bound()) {
ret_val.s() = single_value->field_s.valueof();
}
return ret_val;
}

void EcdsaSignature_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.EcdsaSignature.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new EcdsaSignature_template[list_length];
}

EcdsaSignature_template& EcdsaSignature_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.EcdsaSignature.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.EcdsaSignature.");
return value_list.list_value[list_index];
}

EccPoint_template& EcdsaSignature_template::r()
{
set_specific();
return single_value->field_r;
}

const EccPoint_template& EcdsaSignature_template::r() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field r of a non-specific template of type @LibItsSecurity_TypesAndValues.EcdsaSignature.");
return single_value->field_r;
}

OCTETSTRING_template& EcdsaSignature_template::s()
{
set_specific();
return single_value->field_s;
}

const OCTETSTRING_template& EcdsaSignature_template::s() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field s of a non-specific template of type @LibItsSecurity_TypesAndValues.EcdsaSignature.");
return single_value->field_s;
}

int EcdsaSignature_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EcdsaSignature which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EcdsaSignature containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EcdsaSignature containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EcdsaSignature containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EcdsaSignature containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EcdsaSignature containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.EcdsaSignature.");
  }
  return 0;
}

void EcdsaSignature_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ r := ");
single_value->field_r.log();
TTCN_Logger::log_event_str(", s := ");
single_value->field_s.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void EcdsaSignature_template::log_match(const EcdsaSignature& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_r.match(match_value.r(), legacy)){
TTCN_Logger::log_logmatch_info(".r");
single_value->field_r.log_match(match_value.r(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_s.match(match_value.s(), legacy)){
TTCN_Logger::log_logmatch_info(".s");
single_value->field_s.log_match(match_value.s(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ r := ");
single_value->field_r.log_match(match_value.r(), legacy);
TTCN_Logger::log_event_str(", s := ");
single_value->field_s.log_match(match_value.s(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void EcdsaSignature_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_r.encode_text(text_buf);
single_value->field_s.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.EcdsaSignature.");
}
}

void EcdsaSignature_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_r.decode_text(text_buf);
single_value->field_s.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new EcdsaSignature_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.EcdsaSignature.");
}
}

void EcdsaSignature_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.EcdsaSignature'");
    }
    if (strcmp("r", param_field) == 0) {
      r().set_param(param);
      return;
    } else if (strcmp("s", param_field) == 0) {
      s().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.EcdsaSignature'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    EcdsaSignature_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.EcdsaSignature has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) r().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) s().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "r")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          r().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "s")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          s().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.EcdsaSignature: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.EcdsaSignature");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* EcdsaSignature_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.EcdsaSignature'");
    }
    if (strcmp("r", param_field) == 0) {
      return r().get_param(param_name);
    } else if (strcmp("s", param_field) == 0) {
      return s().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.EcdsaSignature'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_r = single_value->field_r.get_param(param_name);
    mp_field_r->set_id(new Module_Param_FieldName(mcopystr("r")));
    mp->add_elem(mp_field_r);
    Module_Param* mp_field_s = single_value->field_s.get_param(param_name);
    mp_field_s->set_id(new Module_Param_FieldName(mcopystr("s")));
    mp->add_elem(mp_field_s);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void EcdsaSignature_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_r.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.EcdsaSignature");
single_value->field_s.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.EcdsaSignature");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.EcdsaSignature");
}

boolean EcdsaSignature_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean EcdsaSignature_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

Signature::Signature()
{
  bound_flag = FALSE;
}

Signature::Signature(const PublicKeyAlgorithm& par_algorithm,
    const SignatureContainer& par_signature__)
  :   field_algorithm(par_algorithm),
  field_signature__(par_signature__)
{
  bound_flag = TRUE;
}

Signature::Signature(const Signature& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.Signature.");
bound_flag = TRUE;
if (other_value.algorithm().is_bound()) field_algorithm = other_value.algorithm();
else field_algorithm.clean_up();
if (other_value.signature__().is_bound()) field_signature__ = other_value.signature__();
else field_signature__.clean_up();
}

void Signature::clean_up()
{
field_algorithm.clean_up();
field_signature__.clean_up();
bound_flag = FALSE;
}

Signature& Signature::operator=(const Signature& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.Signature.");
  bound_flag = TRUE;
  if (other_value.algorithm().is_bound()) field_algorithm = other_value.algorithm();
  else field_algorithm.clean_up();
  if (other_value.signature__().is_bound()) field_signature__ = other_value.signature__();
  else field_signature__.clean_up();
}
return *this;
}

boolean Signature::operator==(const Signature& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_algorithm==other_value.field_algorithm
  && field_signature__==other_value.field_signature__;
}

boolean Signature::is_bound() const
{
if (bound_flag) return TRUE;
if(field_algorithm.is_bound()) return TRUE;
if(field_signature__.is_bound()) return TRUE;
return FALSE;
}
boolean Signature::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_algorithm.is_value()) return FALSE;
if(!field_signature__.is_value()) return FALSE;
return TRUE;
}
int Signature::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.Signature");
  return 2;
}

void Signature::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ algorithm := ");
field_algorithm.log();
TTCN_Logger::log_event_str(", signature_ := ");
field_signature__.log();
TTCN_Logger::log_event_str(" }");
}

void Signature::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.Signature'");
    }
    if (strcmp("algorithm", param_field) == 0) {
      algorithm().set_param(param);
      return;
    } else if (strcmp("signature_", param_field) == 0) {
      signature__().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.Signature'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.Signature has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) algorithm().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) signature__().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "algorithm")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          algorithm().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signature_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signature__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.Signature: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.Signature");
  }
}

Module_Param* Signature::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.Signature'");
    }
    if (strcmp("algorithm", param_field) == 0) {
      return algorithm().get_param(param_name);
    } else if (strcmp("signature_", param_field) == 0) {
      return signature__().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.Signature'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_algorithm = field_algorithm.get_param(param_name);
  mp_field_algorithm->set_id(new Module_Param_FieldName(mcopystr("algorithm")));
  mp->add_elem(mp_field_algorithm);
  Module_Param* mp_field_signature__ = field_signature__.get_param(param_name);
  mp_field_signature__->set_id(new Module_Param_FieldName(mcopystr("signature_")));
  mp->add_elem(mp_field_signature__);
  return mp;
  }

void Signature::set_implicit_omit()
{
if (algorithm().is_bound()) algorithm().set_implicit_omit();
if (signature__().is_bound()) signature__().set_implicit_omit();
}

void Signature::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.Signature.");
field_algorithm.encode_text(text_buf);
field_signature__.encode_text(text_buf);
}

void Signature::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_algorithm.decode_text(text_buf);
field_signature__.decode_text(text_buf);
}

void Signature::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Signature::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int Signature::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_algorithm.RAW_decode(PublicKeyAlgorithm_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_signature__.RAW_decode(SignatureContainer_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int Signature::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, PublicKeyAlgorithm_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, SignatureContainer_descr_.raw);
  encoded_length += field_algorithm.RAW_encode(PublicKeyAlgorithm_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_signature__.RAW_encode(SignatureContainer_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int Signature::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.Signature.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "algorithm");
    enc_len += field_algorithm.JSON_encode(PublicKeyAlgorithm_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "signature_");
    enc_len += field_signature__.JSON_encode(SignatureContainer_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Signature::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (9 == name_len && 0 == strncmp(fld_name, "algorithm", name_len)) {
         int ret_val = field_algorithm.JSON_decode(PublicKeyAlgorithm_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "algorithm");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "signature_", name_len)) {
         int ret_val = field_signature__.JSON_decode(SignatureContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "signature_");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_algorithm.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "algorithm");
    return JSON_ERROR_FATAL;
  }
if (!field_signature__.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "signature_");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct Signature_template::single_value_struct {
PublicKeyAlgorithm_template field_algorithm;
SignatureContainer_template field_signature__;
};

void Signature_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_algorithm = ANY_VALUE;
single_value->field_signature__ = ANY_VALUE;
}
}
}

void Signature_template::copy_value(const Signature& other_value)
{
single_value = new single_value_struct;
if (other_value.algorithm().is_bound()) {
  single_value->field_algorithm = other_value.algorithm();
} else {
  single_value->field_algorithm.clean_up();
}
if (other_value.signature__().is_bound()) {
  single_value->field_signature__ = other_value.signature__();
} else {
  single_value->field_signature__.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Signature_template::copy_template(const Signature_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.algorithm().get_selection()) {
single_value->field_algorithm = other_value.algorithm();
} else {
single_value->field_algorithm.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.signature__().get_selection()) {
single_value->field_signature__ = other_value.signature__();
} else {
single_value->field_signature__.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Signature_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.Signature.");
break;
}
set_selection(other_value);
}

Signature_template::Signature_template()
{
}

Signature_template::Signature_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Signature_template::Signature_template(const Signature& other_value)
{
copy_value(other_value);
}

Signature_template::Signature_template(const OPTIONAL<Signature>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Signature&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.Signature from an unbound optional field.");
}
}

Signature_template::Signature_template(const Signature_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Signature_template::~Signature_template()
{
clean_up();
}

Signature_template& Signature_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Signature_template& Signature_template::operator=(const Signature& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Signature_template& Signature_template::operator=(const OPTIONAL<Signature>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Signature&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.Signature.");
}
return *this;
}

Signature_template& Signature_template::operator=(const Signature_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Signature_template::match(const Signature& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.algorithm().is_bound()) return FALSE;
if(!single_value->field_algorithm.match(other_value.algorithm(), legacy))return FALSE;
if(!other_value.signature__().is_bound()) return FALSE;
if(!single_value->field_signature__.match(other_value.signature__(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.Signature.");
}
return FALSE;
}

boolean Signature_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_algorithm.is_bound()) return TRUE;
if (single_value->field_signature__.is_bound()) return TRUE;
return FALSE;
}

boolean Signature_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_algorithm.is_value()) return FALSE;
if (!single_value->field_signature__.is_value()) return FALSE;
return TRUE;
}

void Signature_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Signature Signature_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.Signature.");
Signature ret_val;
if (single_value->field_algorithm.is_bound()) {
ret_val.algorithm() = single_value->field_algorithm.valueof();
}
if (single_value->field_signature__.is_bound()) {
ret_val.signature__() = single_value->field_signature__.valueof();
}
return ret_val;
}

void Signature_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.Signature.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Signature_template[list_length];
}

Signature_template& Signature_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.Signature.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.Signature.");
return value_list.list_value[list_index];
}

PublicKeyAlgorithm_template& Signature_template::algorithm()
{
set_specific();
return single_value->field_algorithm;
}

const PublicKeyAlgorithm_template& Signature_template::algorithm() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field algorithm of a non-specific template of type @LibItsSecurity_TypesAndValues.Signature.");
return single_value->field_algorithm;
}

SignatureContainer_template& Signature_template::signature__()
{
set_specific();
return single_value->field_signature__;
}

const SignatureContainer_template& Signature_template::signature__() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field signature_ of a non-specific template of type @LibItsSecurity_TypesAndValues.Signature.");
return single_value->field_signature__;
}

int Signature_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Signature which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Signature containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Signature containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Signature containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Signature containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Signature containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.Signature.");
  }
  return 0;
}

void Signature_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ algorithm := ");
single_value->field_algorithm.log();
TTCN_Logger::log_event_str(", signature_ := ");
single_value->field_signature__.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Signature_template::log_match(const Signature& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_algorithm.match(match_value.algorithm(), legacy)){
TTCN_Logger::log_logmatch_info(".algorithm");
single_value->field_algorithm.log_match(match_value.algorithm(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_signature__.match(match_value.signature__(), legacy)){
TTCN_Logger::log_logmatch_info(".signature_");
single_value->field_signature__.log_match(match_value.signature__(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ algorithm := ");
single_value->field_algorithm.log_match(match_value.algorithm(), legacy);
TTCN_Logger::log_event_str(", signature_ := ");
single_value->field_signature__.log_match(match_value.signature__(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Signature_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_algorithm.encode_text(text_buf);
single_value->field_signature__.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.Signature.");
}
}

void Signature_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_algorithm.decode_text(text_buf);
single_value->field_signature__.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Signature_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.Signature.");
}
}

void Signature_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.Signature'");
    }
    if (strcmp("algorithm", param_field) == 0) {
      algorithm().set_param(param);
      return;
    } else if (strcmp("signature_", param_field) == 0) {
      signature__().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.Signature'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Signature_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.Signature has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) algorithm().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) signature__().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "algorithm")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          algorithm().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signature_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signature__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.Signature: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.Signature");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Signature_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.Signature'");
    }
    if (strcmp("algorithm", param_field) == 0) {
      return algorithm().get_param(param_name);
    } else if (strcmp("signature_", param_field) == 0) {
      return signature__().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.Signature'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_algorithm = single_value->field_algorithm.get_param(param_name);
    mp_field_algorithm->set_id(new Module_Param_FieldName(mcopystr("algorithm")));
    mp->add_elem(mp_field_algorithm);
    Module_Param* mp_field_signature__ = single_value->field_signature__.get_param(param_name);
    mp_field_signature__->set_id(new Module_Param_FieldName(mcopystr("signature_")));
    mp->add_elem(mp_field_signature__);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Signature_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_algorithm.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.Signature");
single_value->field_signature__.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.Signature");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.Signature");
}

boolean Signature_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Signature_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SignerInfoType::SignerInfoType()
{
enum_value = UNBOUND_VALUE;
}

SignerInfoType::SignerInfoType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

SignerInfoType::SignerInfoType(enum_type other_value)
{
enum_value = other_value;
}

SignerInfoType::SignerInfoType(const SignerInfoType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
enum_value = other_value.enum_value;
}

SignerInfoType& SignerInfoType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

SignerInfoType& SignerInfoType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

SignerInfoType& SignerInfoType::operator=(const SignerInfoType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
enum_value = other_value.enum_value;
return *this;
}

boolean SignerInfoType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
return enum_value == other_value;
}

boolean SignerInfoType::operator==(const SignerInfoType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
return enum_value == other_value.enum_value;
}

boolean SignerInfoType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
return enum_value < other_value;
}

boolean SignerInfoType::operator<(const SignerInfoType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
return enum_value < other_value.enum_value;
}

boolean SignerInfoType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
return enum_value > other_value;
}

boolean SignerInfoType::operator>(const SignerInfoType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
return enum_value > other_value.enum_value;
}

const char *SignerInfoType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__self: return "e_self";
case e__certificate__digest__with__sha256: return "e_certificate_digest_with_sha256";
case e__certificate: return "e_certificate";
case e__certificate__chain: return "e_certificate_chain";
case e__certificate__digest__with__other__algorithm: return "e_certificate_digest_with_other_algorithm";
default: return "<unknown>";
}
}

SignerInfoType::enum_type SignerInfoType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_self")) return e__self;
else if (!strcmp(str_par, "e_certificate_digest_with_sha256")) return e__certificate__digest__with__sha256;
else if (!strcmp(str_par, "e_certificate")) return e__certificate;
else if (!strcmp(str_par, "e_certificate_chain")) return e__certificate__chain;
else if (!strcmp(str_par, "e_certificate_digest_with_other_algorithm")) return e__certificate__digest__with__other__algorithm;
else return UNKNOWN_VALUE;
}

boolean SignerInfoType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
return TRUE;
default:
return FALSE;
}
}

int SignerInfoType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int SignerInfoType::enum2int(const SignerInfoType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void SignerInfoType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.", int_val);
enum_value = (enum_type)int_val;
}

SignerInfoType::operator SignerInfoType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
return enum_value;
}

void SignerInfoType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void SignerInfoType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsSecurity_TypesAndValues.SignerInfoType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.SignerInfoType.");
  }
}

Module_Param* SignerInfoType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void SignerInfoType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
text_buf.push_int(enum_value);
}

void SignerInfoType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.", enum_value);
}

void SignerInfoType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SignerInfoType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SignerInfoType::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int SignerInfoType::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

int SignerInfoType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int SignerInfoType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void SignerInfoType_template::copy_template(const SignerInfoType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SignerInfoType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
}
}

SignerInfoType_template::SignerInfoType_template()
{
}

SignerInfoType_template::SignerInfoType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SignerInfoType_template::SignerInfoType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!SignerInfoType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType with unknown numeric value %d.", other_value);
single_value = (SignerInfoType::enum_type)other_value;
}

SignerInfoType_template::SignerInfoType_template(SignerInfoType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

SignerInfoType_template::SignerInfoType_template(const SignerInfoType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == SignerInfoType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
single_value = other_value.enum_value;
}

SignerInfoType_template::SignerInfoType_template(const OPTIONAL<SignerInfoType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SignerInfoType::enum_type)(const SignerInfoType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType from an unbound optional field.");
}
}

SignerInfoType_template::SignerInfoType_template(const SignerInfoType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

SignerInfoType_template::~SignerInfoType_template()
{
clean_up();
}

boolean SignerInfoType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean SignerInfoType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != SignerInfoType::UNBOUND_VALUE;
}

void SignerInfoType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

SignerInfoType_template& SignerInfoType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SignerInfoType_template& SignerInfoType_template::operator=(int other_value)
{
if (!SignerInfoType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (SignerInfoType::enum_type)other_value;
return *this;
}

SignerInfoType_template& SignerInfoType_template::operator=(SignerInfoType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

SignerInfoType_template& SignerInfoType_template::operator=(const SignerInfoType& other_value)
{
if (other_value.enum_value == SignerInfoType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

SignerInfoType_template& SignerInfoType_template::operator=(const OPTIONAL<SignerInfoType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SignerInfoType::enum_type)(const SignerInfoType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
}
return *this;
}

SignerInfoType_template& SignerInfoType_template::operator=(const SignerInfoType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SignerInfoType_template::match(SignerInfoType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
}
return FALSE;
}

boolean SignerInfoType_template::match(const SignerInfoType& other_value, boolean) const
{
if (other_value.enum_value == SignerInfoType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType with an unbound value.");
return match(other_value.enum_value);
}

SignerInfoType::enum_type SignerInfoType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
return single_value;
}

void SignerInfoType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SignerInfoType_template[list_length];
}

SignerInfoType_template& SignerInfoType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
return value_list.list_value[list_index];
}

void SignerInfoType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(SignerInfoType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SignerInfoType_template::log_match(const SignerInfoType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void SignerInfoType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
}
}

void SignerInfoType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (SignerInfoType::enum_type)text_buf.pull_int().get_val();
if (!SignerInfoType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SignerInfoType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsSecurity_TypesAndValues.SignerInfoType.");
}
}

boolean SignerInfoType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SignerInfoType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SignerInfoType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    SignerInfoType::enum_type enum_val = (enum_name != NULL) ? SignerInfoType::str_to_enum(enum_name) : SignerInfoType::UNKNOWN_VALUE;
    if (SignerInfoType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SignerInfoType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    SignerInfoType::enum_type enum_val = SignerInfoType::str_to_enum(mp->get_enumerated());
    if (!SignerInfoType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.SignerInfoType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsSecurity_TypesAndValues.SignerInfoType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SignerInfoType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(SignerInfoType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SignerInfoType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.SignerInfoType");
}

SignerInfo::SignerInfo()
{
  bound_flag = FALSE;
}

SignerInfo::SignerInfo(const SignerInfoType& par_type__,
    const OPTIONAL<SignerInfoContainer>& par_signerInfo)
  :   field_type__(par_type__),
  field_signerInfo(par_signerInfo)
{
  bound_flag = TRUE;
}

SignerInfo::SignerInfo(const SignerInfo& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.SignerInfo.");
bound_flag = TRUE;
if (other_value.type__().is_bound()) field_type__ = other_value.type__();
else field_type__.clean_up();
if (other_value.signerInfo().is_bound()) field_signerInfo = other_value.signerInfo();
else field_signerInfo.clean_up();
}

void SignerInfo::clean_up()
{
field_type__.clean_up();
field_signerInfo.clean_up();
bound_flag = FALSE;
}

SignerInfo& SignerInfo::operator=(const SignerInfo& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.SignerInfo.");
  bound_flag = TRUE;
  if (other_value.type__().is_bound()) field_type__ = other_value.type__();
  else field_type__.clean_up();
  if (other_value.signerInfo().is_bound()) field_signerInfo = other_value.signerInfo();
  else field_signerInfo.clean_up();
}
return *this;
}

boolean SignerInfo::operator==(const SignerInfo& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_type__==other_value.field_type__
  && field_signerInfo==other_value.field_signerInfo;
}

boolean SignerInfo::is_bound() const
{
if (bound_flag) return TRUE;
if(field_type__.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_signerInfo.get_selection() || field_signerInfo.is_bound()) return TRUE;
return FALSE;
}
boolean SignerInfo::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_type__.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_signerInfo.get_selection() && !field_signerInfo.is_value()) return FALSE;
return TRUE;
}
int SignerInfo::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.SignerInfo");
  int ret_val = 1;
  if (field_signerInfo.ispresent()) ret_val++;
  return ret_val;
}

void SignerInfo::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ type_ := ");
field_type__.log();
TTCN_Logger::log_event_str(", signerInfo := ");
field_signerInfo.log();
TTCN_Logger::log_event_str(" }");
}

void SignerInfo::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.SignerInfo'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("signerInfo", param_field) == 0) {
      signerInfo().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SignerInfo'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.SignerInfo has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) signerInfo().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signerInfo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signerInfo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.SignerInfo: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.SignerInfo");
  }
}

Module_Param* SignerInfo::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.SignerInfo'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("signerInfo", param_field) == 0) {
      return signerInfo().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SignerInfo'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_type__ = field_type__.get_param(param_name);
  mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
  mp->add_elem(mp_field_type__);
  Module_Param* mp_field_signerInfo = field_signerInfo.get_param(param_name);
  mp_field_signerInfo->set_id(new Module_Param_FieldName(mcopystr("signerInfo")));
  mp->add_elem(mp_field_signerInfo);
  return mp;
  }

void SignerInfo::set_implicit_omit()
{
if (type__().is_bound()) type__().set_implicit_omit();
if (!signerInfo().is_bound()) signerInfo() = OMIT_VALUE;
else signerInfo().set_implicit_omit();
}

void SignerInfo::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.SignerInfo.");
field_type__.encode_text(text_buf);
field_signerInfo.encode_text(text_buf);
}

void SignerInfo::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_type__.decode_text(text_buf);
field_signerInfo.decode_text(text_buf);
}

void SignerInfo::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SignerInfo::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SignerInfo::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_type__.RAW_decode(SignerInfoType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_signerInfo().RAW_decode(SignerInfoContainer_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_signerInfo = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_signerInfo=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int SignerInfo::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, SignerInfoType_descr_.raw);
  if (field_signerInfo.ispresent()) {
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, SignerInfoContainer_descr_.raw);
  }
  else myleaf.body.node.nodes[1] = NULL;
  encoded_length += field_type__.RAW_encode(SignerInfoType_descr_, *myleaf.body.node.nodes[0]);
  if (field_signerInfo.ispresent()) {
  encoded_length += field_signerInfo().RAW_encode(SignerInfoContainer_descr_, *myleaf.body.node.nodes[1]);
  }
  return myleaf.length = encoded_length;
}

int SignerInfo::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.SignerInfo.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "type_");
    enc_len += field_type__.JSON_encode(SignerInfoType_descr_, p_tok);
  }

  if (field_signerInfo.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "signerInfo");
    enc_len += field_signerInfo.JSON_encode(SignerInfoContainer_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SignerInfo::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (5 == name_len && 0 == strncmp(fld_name, "type_", name_len)) {
         int ret_val = field_type__.JSON_decode(SignerInfoType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "type_");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "signerInfo", name_len)) {
         int ret_val = field_signerInfo.JSON_decode(SignerInfoContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "signerInfo");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_type__.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "type_");
    return JSON_ERROR_FATAL;
  }
if (!field_signerInfo.is_bound()) {
    field_signerInfo = OMIT_VALUE;
  }

  return dec_len;
}

struct SignerInfo_template::single_value_struct {
SignerInfoType_template field_type__;
SignerInfoContainer_template field_signerInfo;
};

void SignerInfo_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_type__ = ANY_VALUE;
single_value->field_signerInfo = ANY_OR_OMIT;
}
}
}

void SignerInfo_template::copy_value(const SignerInfo& other_value)
{
single_value = new single_value_struct;
if (other_value.type__().is_bound()) {
  single_value->field_type__ = other_value.type__();
} else {
  single_value->field_type__.clean_up();
}
if (other_value.signerInfo().is_bound()) {
  if (other_value.signerInfo().ispresent()) single_value->field_signerInfo = other_value.signerInfo()();
  else single_value->field_signerInfo = OMIT_VALUE;
} else {
  single_value->field_signerInfo.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SignerInfo_template::copy_template(const SignerInfo_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.type__().get_selection()) {
single_value->field_type__ = other_value.type__();
} else {
single_value->field_type__.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.signerInfo().get_selection()) {
single_value->field_signerInfo = other_value.signerInfo();
} else {
single_value->field_signerInfo.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SignerInfo_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SignerInfo.");
break;
}
set_selection(other_value);
}

SignerInfo_template::SignerInfo_template()
{
}

SignerInfo_template::SignerInfo_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SignerInfo_template::SignerInfo_template(const SignerInfo& other_value)
{
copy_value(other_value);
}

SignerInfo_template::SignerInfo_template(const OPTIONAL<SignerInfo>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SignerInfo&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.SignerInfo from an unbound optional field.");
}
}

SignerInfo_template::SignerInfo_template(const SignerInfo_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SignerInfo_template::~SignerInfo_template()
{
clean_up();
}

SignerInfo_template& SignerInfo_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SignerInfo_template& SignerInfo_template::operator=(const SignerInfo& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SignerInfo_template& SignerInfo_template::operator=(const OPTIONAL<SignerInfo>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SignerInfo&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.SignerInfo.");
}
return *this;
}

SignerInfo_template& SignerInfo_template::operator=(const SignerInfo_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SignerInfo_template::match(const SignerInfo& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.type__().is_bound()) return FALSE;
if(!single_value->field_type__.match(other_value.type__(), legacy))return FALSE;
if(!other_value.signerInfo().is_bound()) return FALSE;
if((other_value.signerInfo().ispresent() ? !single_value->field_signerInfo.match((const SignerInfoContainer&)other_value.signerInfo(), legacy) : !single_value->field_signerInfo.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SignerInfo.");
}
return FALSE;
}

boolean SignerInfo_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_type__.is_bound()) return TRUE;
if (single_value->field_signerInfo.is_omit() || single_value->field_signerInfo.is_bound()) return TRUE;
return FALSE;
}

boolean SignerInfo_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_type__.is_value()) return FALSE;
if (!single_value->field_signerInfo.is_omit() && !single_value->field_signerInfo.is_value()) return FALSE;
return TRUE;
}

void SignerInfo_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SignerInfo SignerInfo_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.SignerInfo.");
SignerInfo ret_val;
if (single_value->field_type__.is_bound()) {
ret_val.type__() = single_value->field_type__.valueof();
}
if (single_value->field_signerInfo.is_omit()) ret_val.signerInfo() = OMIT_VALUE;
else if (single_value->field_signerInfo.is_bound()) {
ret_val.signerInfo() = single_value->field_signerInfo.valueof();
}
return ret_val;
}

void SignerInfo_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.SignerInfo.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SignerInfo_template[list_length];
}

SignerInfo_template& SignerInfo_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.SignerInfo.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.SignerInfo.");
return value_list.list_value[list_index];
}

SignerInfoType_template& SignerInfo_template::type__()
{
set_specific();
return single_value->field_type__;
}

const SignerInfoType_template& SignerInfo_template::type__() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field type_ of a non-specific template of type @LibItsSecurity_TypesAndValues.SignerInfo.");
return single_value->field_type__;
}

SignerInfoContainer_template& SignerInfo_template::signerInfo()
{
set_specific();
return single_value->field_signerInfo;
}

const SignerInfoContainer_template& SignerInfo_template::signerInfo() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field signerInfo of a non-specific template of type @LibItsSecurity_TypesAndValues.SignerInfo.");
return single_value->field_signerInfo;
}

int SignerInfo_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SignerInfo which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_signerInfo.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SignerInfo containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SignerInfo containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SignerInfo containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SignerInfo containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SignerInfo containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SignerInfo.");
  }
  return 0;
}

void SignerInfo_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log();
TTCN_Logger::log_event_str(", signerInfo := ");
single_value->field_signerInfo.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SignerInfo_template::log_match(const SignerInfo& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_type__.match(match_value.type__(), legacy)){
TTCN_Logger::log_logmatch_info(".type_");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.signerInfo().ispresent()){
if(!single_value->field_signerInfo.match(match_value.signerInfo(), legacy)){
TTCN_Logger::log_logmatch_info(".signerInfo");
single_value->field_signerInfo.log_match(match_value.signerInfo(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_signerInfo.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".signerInfo := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_signerInfo.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::log_event_str(", signerInfo := ");
if (match_value.signerInfo().ispresent()) single_value->field_signerInfo.log_match(match_value.signerInfo(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_signerInfo.log();
if (single_value->field_signerInfo.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SignerInfo_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_type__.encode_text(text_buf);
single_value->field_signerInfo.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SignerInfo.");
}
}

void SignerInfo_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_type__.decode_text(text_buf);
single_value->field_signerInfo.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SignerInfo_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.SignerInfo.");
}
}

void SignerInfo_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.SignerInfo'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("signerInfo", param_field) == 0) {
      signerInfo().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.SignerInfo'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SignerInfo_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.SignerInfo has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) signerInfo().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signerInfo")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signerInfo().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.SignerInfo: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.SignerInfo");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SignerInfo_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.SignerInfo'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("signerInfo", param_field) == 0) {
      return signerInfo().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SignerInfo'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_type__ = single_value->field_type__.get_param(param_name);
    mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
    mp->add_elem(mp_field_type__);
    Module_Param* mp_field_signerInfo = single_value->field_signerInfo.get_param(param_name);
    mp_field_signerInfo->set_id(new Module_Param_FieldName(mcopystr("signerInfo")));
    mp->add_elem(mp_field_signerInfo);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SignerInfo_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_type__.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SignerInfo");
single_value->field_signerInfo.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SignerInfo");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.SignerInfo");
}

boolean SignerInfo_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SignerInfo_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SignerInfoContainer::copy_value(const SignerInfoContainer& other_value)
{
switch (other_value.union_selection) {
case ALT_digest:
field_digest = new OCTETSTRING(*other_value.field_digest);
break;
case ALT_certificate:
field_certificate = new Certificate(*other_value.field_certificate);
break;
case ALT_certificates:
field_certificates = new CertificateChain(*other_value.field_certificates);
break;
case ALT_certificateWithAlgo:
field_certificateWithAlgo = new CertificateWithAlgo(*other_value.field_certificateWithAlgo);
break;
case ALT_info:
field_info = new OCTETSTRING(*other_value.field_info);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
}
union_selection = other_value.union_selection;
}

SignerInfoContainer::SignerInfoContainer()
{
union_selection = UNBOUND_VALUE;
}

SignerInfoContainer::SignerInfoContainer(const SignerInfoContainer& other_value)
: Base_Type(){
copy_value(other_value);
}

SignerInfoContainer::~SignerInfoContainer()
{
clean_up();
}

SignerInfoContainer& SignerInfoContainer::operator=(const SignerInfoContainer& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean SignerInfoContainer::operator==(const SignerInfoContainer& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_digest:
return *field_digest == *other_value.field_digest;
case ALT_certificate:
return *field_certificate == *other_value.field_certificate;
case ALT_certificates:
return *field_certificates == *other_value.field_certificates;
case ALT_certificateWithAlgo:
return *field_certificateWithAlgo == *other_value.field_certificateWithAlgo;
case ALT_info:
return *field_info == *other_value.field_info;
default:
return FALSE;
}
}

OCTETSTRING& SignerInfoContainer::digest()
{
if (union_selection != ALT_digest) {
clean_up();
field_digest = new OCTETSTRING;
union_selection = ALT_digest;
}
return *field_digest;
}

const OCTETSTRING& SignerInfoContainer::digest() const
{
if (union_selection != ALT_digest) TTCN_error("Using non-selected field digest in a value of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
return *field_digest;
}

Certificate& SignerInfoContainer::certificate()
{
if (union_selection != ALT_certificate) {
clean_up();
field_certificate = new Certificate;
union_selection = ALT_certificate;
}
return *field_certificate;
}

const Certificate& SignerInfoContainer::certificate() const
{
if (union_selection != ALT_certificate) TTCN_error("Using non-selected field certificate in a value of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
return *field_certificate;
}

CertificateChain& SignerInfoContainer::certificates()
{
if (union_selection != ALT_certificates) {
clean_up();
field_certificates = new CertificateChain;
union_selection = ALT_certificates;
}
return *field_certificates;
}

const CertificateChain& SignerInfoContainer::certificates() const
{
if (union_selection != ALT_certificates) TTCN_error("Using non-selected field certificates in a value of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
return *field_certificates;
}

CertificateWithAlgo& SignerInfoContainer::certificateWithAlgo()
{
if (union_selection != ALT_certificateWithAlgo) {
clean_up();
field_certificateWithAlgo = new CertificateWithAlgo;
union_selection = ALT_certificateWithAlgo;
}
return *field_certificateWithAlgo;
}

const CertificateWithAlgo& SignerInfoContainer::certificateWithAlgo() const
{
if (union_selection != ALT_certificateWithAlgo) TTCN_error("Using non-selected field certificateWithAlgo in a value of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
return *field_certificateWithAlgo;
}

OCTETSTRING& SignerInfoContainer::info()
{
if (union_selection != ALT_info) {
clean_up();
field_info = new OCTETSTRING;
union_selection = ALT_info;
}
return *field_info;
}

const OCTETSTRING& SignerInfoContainer::info() const
{
if (union_selection != ALT_info) TTCN_error("Using non-selected field info in a value of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
return *field_info;
}

boolean SignerInfoContainer::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
return union_selection == checked_selection;
}

boolean SignerInfoContainer::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean SignerInfoContainer::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_digest: return field_digest->is_value();
case ALT_certificate: return field_certificate->is_value();
case ALT_certificates: return field_certificates->is_value();
case ALT_certificateWithAlgo: return field_certificateWithAlgo->is_value();
case ALT_info: return field_info->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void SignerInfoContainer::clean_up()
{
switch (union_selection) {
case ALT_digest:
  delete field_digest;
  break;
case ALT_certificate:
  delete field_certificate;
  break;
case ALT_certificates:
  delete field_certificates;
  break;
case ALT_certificateWithAlgo:
  delete field_certificateWithAlgo;
  break;
case ALT_info:
  delete field_info;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void SignerInfoContainer::log() const
{
switch (union_selection) {
case ALT_digest:
TTCN_Logger::log_event_str("{ digest := ");
field_digest->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_certificate:
TTCN_Logger::log_event_str("{ certificate := ");
field_certificate->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_certificates:
TTCN_Logger::log_event_str("{ certificates := ");
field_certificates->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_certificateWithAlgo:
TTCN_Logger::log_event_str("{ certificateWithAlgo := ");
field_certificateWithAlgo->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_info:
TTCN_Logger::log_event_str("{ info := ");
field_info->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void SignerInfoContainer::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsSecurity_TypesAndValues.SignerInfoContainer'");
    }
    if (strcmp("digest", param_field) == 0) {
      digest().set_param(param);
      return;
    } else if (strcmp("certificate", param_field) == 0) {
      certificate().set_param(param);
      return;
    } else if (strcmp("certificates", param_field) == 0) {
      certificates().set_param(param);
      return;
    } else if (strcmp("certificateWithAlgo", param_field) == 0) {
      certificateWithAlgo().set_param(param);
      return;
    } else if (strcmp("info", param_field) == 0) {
      info().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsSecurity_TypesAndValues.SignerInfoContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "digest")) {
    digest().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "certificate")) {
    certificate().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "certificates")) {
    certificates().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "certificateWithAlgo")) {
    certificateWithAlgo().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "info")) {
    info().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.SignerInfoContainer.", mp_last->get_id()->get_name());
}

Module_Param* SignerInfoContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsSecurity_TypesAndValues.SignerInfoContainer'");
    }
    if (strcmp("digest", param_field) == 0) {
      return digest().get_param(param_name);
    } else if (strcmp("certificate", param_field) == 0) {
      return certificate().get_param(param_name);
    } else if (strcmp("certificates", param_field) == 0) {
      return certificates().get_param(param_name);
    } else if (strcmp("certificateWithAlgo", param_field) == 0) {
      return certificateWithAlgo().get_param(param_name);
    } else if (strcmp("info", param_field) == 0) {
      return info().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `SignerInfoContainer'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_digest:
    mp_field = field_digest->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("digest")));
    break;
  case ALT_certificate:
    mp_field = field_certificate->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("certificate")));
    break;
  case ALT_certificates:
    mp_field = field_certificates->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("certificates")));
    break;
  case ALT_certificateWithAlgo:
    mp_field = field_certificateWithAlgo->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("certificateWithAlgo")));
    break;
  case ALT_info:
    mp_field = field_info->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("info")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void SignerInfoContainer::set_implicit_omit()
{
switch (union_selection) {
case ALT_digest:
field_digest->set_implicit_omit(); break;
case ALT_certificate:
field_certificate->set_implicit_omit(); break;
case ALT_certificates:
field_certificates->set_implicit_omit(); break;
case ALT_certificateWithAlgo:
field_certificateWithAlgo->set_implicit_omit(); break;
case ALT_info:
field_info->set_implicit_omit(); break;
default: break;
}
}

void SignerInfoContainer::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_digest:
field_digest->encode_text(text_buf);
break;
case ALT_certificate:
field_certificate->encode_text(text_buf);
break;
case ALT_certificates:
field_certificates->encode_text(text_buf);
break;
case ALT_certificateWithAlgo:
field_certificateWithAlgo->encode_text(text_buf);
break;
case ALT_info:
field_info->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
}
}

void SignerInfoContainer::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_digest:
digest().decode_text(text_buf);
break;
case ALT_certificate:
certificate().decode_text(text_buf);
break;
case ALT_certificates:
certificates().decode_text(text_buf);
break;
case ALT_certificateWithAlgo:
certificateWithAlgo().decode_text(text_buf);
break;
case ALT_info:
info().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
}
}

void SignerInfoContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SignerInfoContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SignerInfoContainer::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = digest().RAW_decode(HashedId8_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = certificate().RAW_decode(Certificate_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 2:
      decoded_length = certificates().RAW_decode(CertificateChain_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 3:
      decoded_length = certificateWithAlgo().RAW_decode(CertificateWithAlgo_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 4:
      decoded_length = info().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = digest().RAW_decode(HashedId8_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = certificate().RAW_decode(Certificate_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = certificates().RAW_decode(CertificateChain_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = certificateWithAlgo().RAW_decode(CertificateWithAlgo_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = info().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int SignerInfoContainer::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 5;  myleaf.body.node.nodes = init_nodes_of_enc_tree(5);
  memset(myleaf.body.node.nodes, 0, 5 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_digest:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, HashedId8_descr_.raw);
    encoded_length = field_digest->RAW_encode(HashedId8_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &HashedId8_descr_;
    break;
  case ALT_certificate:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, Certificate_descr_.raw);
    encoded_length = field_certificate->RAW_encode(Certificate_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &Certificate_descr_;
    break;
  case ALT_certificates:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, CertificateChain_descr_.raw);
    encoded_length = field_certificates->RAW_encode(CertificateChain_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &CertificateChain_descr_;
    break;
  case ALT_certificateWithAlgo:
    myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 3, CertificateWithAlgo_descr_.raw);
    encoded_length = field_certificateWithAlgo->RAW_encode(CertificateWithAlgo_descr_, *myleaf.body.node.nodes[3]);
    myleaf.body.node.nodes[3]->coding_descr = &CertificateWithAlgo_descr_;
    break;
  case ALT_info:
    myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 4, OCTETSTRING_descr_.raw);
    encoded_length = field_info->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[4]);
    myleaf.body.node.nodes[4]->coding_descr = &OCTETSTRING_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int SignerInfoContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_digest:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "digest");
    enc_len += field_digest->JSON_encode(HashedId8_descr_, p_tok);
    break;
  case ALT_certificate:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "certificate");
    enc_len += field_certificate->JSON_encode(Certificate_descr_, p_tok);
    break;
  case ALT_certificates:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "certificates");
    enc_len += field_certificates->JSON_encode(CertificateChain_descr_, p_tok);
    break;
  case ALT_certificateWithAlgo:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "certificateWithAlgo");
    enc_len += field_certificateWithAlgo->JSON_encode(CertificateWithAlgo_descr_, p_tok);
    break;
  case ALT_info:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "info");
    enc_len += field_info->JSON_encode(OCTETSTRING_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SignerInfoContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "digest", name_len)) {
      int ret_val = digest().JSON_decode(HashedId8_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "digest");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "certificate", name_len)) {
      int ret_val = certificate().JSON_decode(Certificate_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "certificate");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "certificates", name_len)) {
      int ret_val = certificates().JSON_decode(CertificateChain_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "certificates");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "certificateWithAlgo", name_len)) {
      int ret_val = certificateWithAlgo().JSON_decode(CertificateWithAlgo_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "certificateWithAlgo");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "info", name_len)) {
      int ret_val = info().JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "info");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void SignerInfoContainer_template::copy_value(const SignerInfoContainer& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case SignerInfoContainer::ALT_digest:
single_value.field_digest = new OCTETSTRING_template(other_value.digest());
break;
case SignerInfoContainer::ALT_certificate:
single_value.field_certificate = new Certificate_template(other_value.certificate());
break;
case SignerInfoContainer::ALT_certificates:
single_value.field_certificates = new CertificateChain_template(other_value.certificates());
break;
case SignerInfoContainer::ALT_certificateWithAlgo:
single_value.field_certificateWithAlgo = new CertificateWithAlgo_template(other_value.certificateWithAlgo());
break;
case SignerInfoContainer::ALT_info:
single_value.field_info = new OCTETSTRING_template(other_value.info());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
}
set_selection(SPECIFIC_VALUE);
}

void SignerInfoContainer_template::copy_template(const SignerInfoContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case SignerInfoContainer::ALT_digest:
single_value.field_digest = new OCTETSTRING_template(*other_value.single_value.field_digest);
break;
case SignerInfoContainer::ALT_certificate:
single_value.field_certificate = new Certificate_template(*other_value.single_value.field_certificate);
break;
case SignerInfoContainer::ALT_certificates:
single_value.field_certificates = new CertificateChain_template(*other_value.single_value.field_certificates);
break;
case SignerInfoContainer::ALT_certificateWithAlgo:
single_value.field_certificateWithAlgo = new CertificateWithAlgo_template(*other_value.single_value.field_certificateWithAlgo);
break;
case SignerInfoContainer::ALT_info:
single_value.field_info = new OCTETSTRING_template(*other_value.single_value.field_info);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SignerInfoContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
}
set_selection(other_value);
}

SignerInfoContainer_template::SignerInfoContainer_template()
{
}

SignerInfoContainer_template::SignerInfoContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SignerInfoContainer_template::SignerInfoContainer_template(const SignerInfoContainer& other_value)
{
copy_value(other_value);
}

SignerInfoContainer_template::SignerInfoContainer_template(const OPTIONAL<SignerInfoContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SignerInfoContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer from an unbound optional field.");
}
}

SignerInfoContainer_template::SignerInfoContainer_template(const SignerInfoContainer_template& other_value)
: Base_Template(){
copy_template(other_value);
}

SignerInfoContainer_template::~SignerInfoContainer_template()
{
clean_up();
}

void SignerInfoContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case SignerInfoContainer::ALT_digest:
delete single_value.field_digest;
break;
case SignerInfoContainer::ALT_certificate:
delete single_value.field_certificate;
break;
case SignerInfoContainer::ALT_certificates:
delete single_value.field_certificates;
break;
case SignerInfoContainer::ALT_certificateWithAlgo:
delete single_value.field_certificateWithAlgo;
break;
case SignerInfoContainer::ALT_info:
delete single_value.field_info;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SignerInfoContainer_template& SignerInfoContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SignerInfoContainer_template& SignerInfoContainer_template::operator=(const SignerInfoContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SignerInfoContainer_template& SignerInfoContainer_template::operator=(const OPTIONAL<SignerInfoContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SignerInfoContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
}
return *this;
}

SignerInfoContainer_template& SignerInfoContainer_template::operator=(const SignerInfoContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SignerInfoContainer_template::match(const SignerInfoContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
SignerInfoContainer::union_selection_type value_selection = other_value.get_selection();
if (value_selection == SignerInfoContainer::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case SignerInfoContainer::ALT_digest:
return single_value.field_digest->match(other_value.digest(), legacy);
case SignerInfoContainer::ALT_certificate:
return single_value.field_certificate->match(other_value.certificate(), legacy);
case SignerInfoContainer::ALT_certificates:
return single_value.field_certificates->match(other_value.certificates(), legacy);
case SignerInfoContainer::ALT_certificateWithAlgo:
return single_value.field_certificateWithAlgo->match(other_value.certificateWithAlgo(), legacy);
case SignerInfoContainer::ALT_info:
return single_value.field_info->match(other_value.info(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
}
return FALSE;
}

boolean SignerInfoContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case SignerInfoContainer::ALT_digest:
return single_value.field_digest->is_value();
case SignerInfoContainer::ALT_certificate:
return single_value.field_certificate->is_value();
case SignerInfoContainer::ALT_certificates:
return single_value.field_certificates->is_value();
case SignerInfoContainer::ALT_certificateWithAlgo:
return single_value.field_certificateWithAlgo->is_value();
case SignerInfoContainer::ALT_info:
return single_value.field_info->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
}
}

SignerInfoContainer SignerInfoContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
SignerInfoContainer ret_val;
switch (single_value.union_selection) {
case SignerInfoContainer::ALT_digest:
ret_val.digest() = single_value.field_digest->valueof();
break;
case SignerInfoContainer::ALT_certificate:
ret_val.certificate() = single_value.field_certificate->valueof();
break;
case SignerInfoContainer::ALT_certificates:
ret_val.certificates() = single_value.field_certificates->valueof();
break;
case SignerInfoContainer::ALT_certificateWithAlgo:
ret_val.certificateWithAlgo() = single_value.field_certificateWithAlgo->valueof();
break;
case SignerInfoContainer::ALT_info:
ret_val.info() = single_value.field_info->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
}
return ret_val;
}

SignerInfoContainer_template& SignerInfoContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
return value_list.list_value[list_index];
}
void SignerInfoContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SignerInfoContainer_template[list_length];
}

OCTETSTRING_template& SignerInfoContainer_template::digest()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SignerInfoContainer::ALT_digest) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_digest = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_digest = new OCTETSTRING_template;
single_value.union_selection = SignerInfoContainer::ALT_digest;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_digest;
}

const OCTETSTRING_template& SignerInfoContainer_template::digest() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field digest in a non-specific template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
if (single_value.union_selection != SignerInfoContainer::ALT_digest) TTCN_error("Accessing non-selected field digest in a template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
return *single_value.field_digest;
}

Certificate_template& SignerInfoContainer_template::certificate()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SignerInfoContainer::ALT_certificate) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_certificate = new Certificate_template(ANY_VALUE);
else single_value.field_certificate = new Certificate_template;
single_value.union_selection = SignerInfoContainer::ALT_certificate;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_certificate;
}

const Certificate_template& SignerInfoContainer_template::certificate() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field certificate in a non-specific template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
if (single_value.union_selection != SignerInfoContainer::ALT_certificate) TTCN_error("Accessing non-selected field certificate in a template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
return *single_value.field_certificate;
}

CertificateChain_template& SignerInfoContainer_template::certificates()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SignerInfoContainer::ALT_certificates) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_certificates = new CertificateChain_template(ANY_VALUE);
else single_value.field_certificates = new CertificateChain_template;
single_value.union_selection = SignerInfoContainer::ALT_certificates;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_certificates;
}

const CertificateChain_template& SignerInfoContainer_template::certificates() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field certificates in a non-specific template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
if (single_value.union_selection != SignerInfoContainer::ALT_certificates) TTCN_error("Accessing non-selected field certificates in a template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
return *single_value.field_certificates;
}

CertificateWithAlgo_template& SignerInfoContainer_template::certificateWithAlgo()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SignerInfoContainer::ALT_certificateWithAlgo) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_certificateWithAlgo = new CertificateWithAlgo_template(ANY_VALUE);
else single_value.field_certificateWithAlgo = new CertificateWithAlgo_template;
single_value.union_selection = SignerInfoContainer::ALT_certificateWithAlgo;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_certificateWithAlgo;
}

const CertificateWithAlgo_template& SignerInfoContainer_template::certificateWithAlgo() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field certificateWithAlgo in a non-specific template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
if (single_value.union_selection != SignerInfoContainer::ALT_certificateWithAlgo) TTCN_error("Accessing non-selected field certificateWithAlgo in a template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
return *single_value.field_certificateWithAlgo;
}

OCTETSTRING_template& SignerInfoContainer_template::info()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SignerInfoContainer::ALT_info) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_info = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_info = new OCTETSTRING_template;
single_value.union_selection = SignerInfoContainer::ALT_info;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_info;
}

const OCTETSTRING_template& SignerInfoContainer_template::info() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field info in a non-specific template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
if (single_value.union_selection != SignerInfoContainer::ALT_info) TTCN_error("Accessing non-selected field info in a template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
return *single_value.field_info;
}

boolean SignerInfoContainer_template::ischosen(SignerInfoContainer::union_selection_type checked_selection) const
{
if (checked_selection == SignerInfoContainer::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == SignerInfoContainer::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer");
}
return FALSE;
}

void SignerInfoContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case SignerInfoContainer::ALT_digest:
TTCN_Logger::log_event_str("{ digest := ");
single_value.field_digest->log();
TTCN_Logger::log_event_str(" }");
break;
case SignerInfoContainer::ALT_certificate:
TTCN_Logger::log_event_str("{ certificate := ");
single_value.field_certificate->log();
TTCN_Logger::log_event_str(" }");
break;
case SignerInfoContainer::ALT_certificates:
TTCN_Logger::log_event_str("{ certificates := ");
single_value.field_certificates->log();
TTCN_Logger::log_event_str(" }");
break;
case SignerInfoContainer::ALT_certificateWithAlgo:
TTCN_Logger::log_event_str("{ certificateWithAlgo := ");
single_value.field_certificateWithAlgo->log();
TTCN_Logger::log_event_str(" }");
break;
case SignerInfoContainer::ALT_info:
TTCN_Logger::log_event_str("{ info := ");
single_value.field_info->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SignerInfoContainer_template::log_match(const SignerInfoContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case SignerInfoContainer::ALT_digest:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".digest");
single_value.field_digest->log_match(match_value.digest(), legacy);
} else {
TTCN_Logger::log_event_str("{ digest := ");
single_value.field_digest->log_match(match_value.digest(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SignerInfoContainer::ALT_certificate:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".certificate");
single_value.field_certificate->log_match(match_value.certificate(), legacy);
} else {
TTCN_Logger::log_event_str("{ certificate := ");
single_value.field_certificate->log_match(match_value.certificate(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SignerInfoContainer::ALT_certificates:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".certificates");
single_value.field_certificates->log_match(match_value.certificates(), legacy);
} else {
TTCN_Logger::log_event_str("{ certificates := ");
single_value.field_certificates->log_match(match_value.certificates(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SignerInfoContainer::ALT_certificateWithAlgo:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".certificateWithAlgo");
single_value.field_certificateWithAlgo->log_match(match_value.certificateWithAlgo(), legacy);
} else {
TTCN_Logger::log_event_str("{ certificateWithAlgo := ");
single_value.field_certificateWithAlgo->log_match(match_value.certificateWithAlgo(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SignerInfoContainer::ALT_info:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".info");
single_value.field_info->log_match(match_value.info(), legacy);
} else {
TTCN_Logger::log_event_str("{ info := ");
single_value.field_info->log_match(match_value.info(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SignerInfoContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case SignerInfoContainer::ALT_digest:
single_value.field_digest->encode_text(text_buf);
break;
case SignerInfoContainer::ALT_certificate:
single_value.field_certificate->encode_text(text_buf);
break;
case SignerInfoContainer::ALT_certificates:
single_value.field_certificates->encode_text(text_buf);
break;
case SignerInfoContainer::ALT_certificateWithAlgo:
single_value.field_certificateWithAlgo->encode_text(text_buf);
break;
case SignerInfoContainer::ALT_info:
single_value.field_info->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
}
}

void SignerInfoContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = SignerInfoContainer::UNBOUND_VALUE;
SignerInfoContainer::union_selection_type new_selection = (SignerInfoContainer::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case SignerInfoContainer::ALT_digest:
single_value.field_digest = new OCTETSTRING_template;
single_value.field_digest->decode_text(text_buf);
break;
case SignerInfoContainer::ALT_certificate:
single_value.field_certificate = new Certificate_template;
single_value.field_certificate->decode_text(text_buf);
break;
case SignerInfoContainer::ALT_certificates:
single_value.field_certificates = new CertificateChain_template;
single_value.field_certificates->decode_text(text_buf);
break;
case SignerInfoContainer::ALT_certificateWithAlgo:
single_value.field_certificateWithAlgo = new CertificateWithAlgo_template;
single_value.field_certificateWithAlgo->decode_text(text_buf);
break;
case SignerInfoContainer::ALT_info:
single_value.field_info = new OCTETSTRING_template;
single_value.field_info->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SignerInfoContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
}
}

boolean SignerInfoContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SignerInfoContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SignerInfoContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsSecurity_TypesAndValues.SignerInfoContainer'");
    }
    if (strcmp("digest", param_field) == 0) {
      digest().set_param(param);
      return;
    } else if (strcmp("certificate", param_field) == 0) {
      certificate().set_param(param);
      return;
    } else if (strcmp("certificates", param_field) == 0) {
      certificates().set_param(param);
      return;
    } else if (strcmp("certificateWithAlgo", param_field) == 0) {
      certificateWithAlgo().set_param(param);
      return;
    } else if (strcmp("info", param_field) == 0) {
      info().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsSecurity_TypesAndValues.SignerInfoContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SignerInfoContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.SignerInfoContainer");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "digest")) {
      digest().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "certificate")) {
      certificate().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "certificates")) {
      certificates().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "certificateWithAlgo")) {
      certificateWithAlgo().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "info")) {
      info().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.SignerInfoContainer.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.SignerInfoContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SignerInfoContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsSecurity_TypesAndValues.SignerInfoContainer'");
    }
    if (strcmp("digest", param_field) == 0) {
      return digest().get_param(param_name);
    } else if (strcmp("certificate", param_field) == 0) {
      return certificate().get_param(param_name);
    } else if (strcmp("certificates", param_field) == 0) {
      return certificates().get_param(param_name);
    } else if (strcmp("certificateWithAlgo", param_field) == 0) {
      return certificateWithAlgo().get_param(param_name);
    } else if (strcmp("info", param_field) == 0) {
      return info().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `SignerInfoContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case SignerInfoContainer::ALT_digest:
      mp_field = single_value.field_digest->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("digest")));
      break;
    case SignerInfoContainer::ALT_certificate:
      mp_field = single_value.field_certificate->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("certificate")));
      break;
    case SignerInfoContainer::ALT_certificates:
      mp_field = single_value.field_certificates->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("certificates")));
      break;
    case SignerInfoContainer::ALT_certificateWithAlgo:
      mp_field = single_value.field_certificateWithAlgo->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("certificateWithAlgo")));
      break;
    case SignerInfoContainer::ALT_info:
      mp_field = single_value.field_info->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("info")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SignerInfoContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case SignerInfoContainer::ALT_digest:
single_value.field_digest->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SignerInfoContainer");
return;
case SignerInfoContainer::ALT_certificate:
single_value.field_certificate->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SignerInfoContainer");
return;
case SignerInfoContainer::ALT_certificates:
single_value.field_certificates->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SignerInfoContainer");
return;
case SignerInfoContainer::ALT_certificateWithAlgo:
single_value.field_certificateWithAlgo->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SignerInfoContainer");
return;
case SignerInfoContainer::ALT_info:
single_value.field_info->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SignerInfoContainer");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsSecurity_TypesAndValues.SignerInfoContainer.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.SignerInfoContainer");
}

SubjectType::SubjectType()
{
enum_value = UNBOUND_VALUE;
}

SubjectType::SubjectType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsSecurity_TypesAndValues.SubjectType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

SubjectType::SubjectType(enum_type other_value)
{
enum_value = other_value;
}

SubjectType::SubjectType(const SubjectType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
enum_value = other_value.enum_value;
}

SubjectType& SubjectType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

SubjectType& SubjectType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

SubjectType& SubjectType::operator=(const SubjectType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
enum_value = other_value.enum_value;
return *this;
}

boolean SubjectType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
return enum_value == other_value;
}

boolean SubjectType::operator==(const SubjectType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
return enum_value == other_value.enum_value;
}

boolean SubjectType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
return enum_value < other_value;
}

boolean SubjectType::operator<(const SubjectType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
return enum_value < other_value.enum_value;
}

boolean SubjectType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
return enum_value > other_value;
}

boolean SubjectType::operator>(const SubjectType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
return enum_value > other_value.enum_value;
}

const char *SubjectType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__enrollment__credential: return "e_enrollment_credential";
case e__authorization__ticket: return "e_authorization_ticket";
case e__authorization__authority: return "e_authorization_authority";
case e__enrollment__authority: return "e_enrollment_authority";
case e__root__ca: return "e_root_ca";
case e__crl__signer: return "e_crl_signer";
default: return "<unknown>";
}
}

SubjectType::enum_type SubjectType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_enrollment_credential")) return e__enrollment__credential;
else if (!strcmp(str_par, "e_authorization_ticket")) return e__authorization__ticket;
else if (!strcmp(str_par, "e_authorization_authority")) return e__authorization__authority;
else if (!strcmp(str_par, "e_enrollment_authority")) return e__enrollment__authority;
else if (!strcmp(str_par, "e_root_ca")) return e__root__ca;
else if (!strcmp(str_par, "e_crl_signer")) return e__crl__signer;
else return UNKNOWN_VALUE;
}

boolean SubjectType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
return TRUE;
default:
return FALSE;
}
}

int SubjectType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int SubjectType::enum2int(const SubjectType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void SubjectType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.", int_val);
enum_value = (enum_type)int_val;
}

SubjectType::operator SubjectType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
return enum_value;
}

void SubjectType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void SubjectType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsSecurity_TypesAndValues.SubjectType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.SubjectType.");
  }
}

Module_Param* SubjectType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void SubjectType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
text_buf.push_int(enum_value);
}

void SubjectType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsSecurity_TypesAndValues.SubjectType.", enum_value);
}

void SubjectType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SubjectType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SubjectType::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int SubjectType::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

int SubjectType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int SubjectType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void SubjectType_template::copy_template(const SubjectType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SubjectType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
}
}

SubjectType_template::SubjectType_template()
{
}

SubjectType_template::SubjectType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SubjectType_template::SubjectType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!SubjectType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsSecurity_TypesAndValues.SubjectType with unknown numeric value %d.", other_value);
single_value = (SubjectType::enum_type)other_value;
}

SubjectType_template::SubjectType_template(SubjectType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

SubjectType_template::SubjectType_template(const SubjectType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == SubjectType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
single_value = other_value.enum_value;
}

SubjectType_template::SubjectType_template(const OPTIONAL<SubjectType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SubjectType::enum_type)(const SubjectType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsSecurity_TypesAndValues.SubjectType from an unbound optional field.");
}
}

SubjectType_template::SubjectType_template(const SubjectType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

SubjectType_template::~SubjectType_template()
{
clean_up();
}

boolean SubjectType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean SubjectType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != SubjectType::UNBOUND_VALUE;
}

void SubjectType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

SubjectType_template& SubjectType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SubjectType_template& SubjectType_template::operator=(int other_value)
{
if (!SubjectType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (SubjectType::enum_type)other_value;
return *this;
}

SubjectType_template& SubjectType_template::operator=(SubjectType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

SubjectType_template& SubjectType_template::operator=(const SubjectType& other_value)
{
if (other_value.enum_value == SubjectType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

SubjectType_template& SubjectType_template::operator=(const OPTIONAL<SubjectType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SubjectType::enum_type)(const SubjectType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
}
return *this;
}

SubjectType_template& SubjectType_template::operator=(const SubjectType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SubjectType_template::match(SubjectType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
}
return FALSE;
}

boolean SubjectType_template::match(const SubjectType& other_value, boolean) const
{
if (other_value.enum_value == SubjectType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsSecurity_TypesAndValues.SubjectType with an unbound value.");
return match(other_value.enum_value);
}

SubjectType::enum_type SubjectType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
return single_value;
}

void SubjectType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SubjectType_template[list_length];
}

SubjectType_template& SubjectType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
return value_list.list_value[list_index];
}

void SubjectType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(SubjectType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SubjectType_template::log_match(const SubjectType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void SubjectType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
}
}

void SubjectType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (SubjectType::enum_type)text_buf.pull_int().get_val();
if (!SubjectType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SubjectType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsSecurity_TypesAndValues.SubjectType.");
}
}

boolean SubjectType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SubjectType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SubjectType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    SubjectType::enum_type enum_val = (enum_name != NULL) ? SubjectType::str_to_enum(enum_name) : SubjectType::UNKNOWN_VALUE;
    if (SubjectType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SubjectType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    SubjectType::enum_type enum_val = SubjectType::str_to_enum(mp->get_enumerated());
    if (!SubjectType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.SubjectType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsSecurity_TypesAndValues.SubjectType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SubjectType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(SubjectType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SubjectType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectType");
}

SubjectInfo::SubjectInfo()
{
  bound_flag = FALSE;
}

SubjectInfo::SubjectInfo(const SubjectType& par_subject__type,
    const OCTETSTRING& par_subject__name)
  :   field_subject__type(par_subject__type),
  field_subject__name(par_subject__name)
{
  bound_flag = TRUE;
}

SubjectInfo::SubjectInfo(const SubjectInfo& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.SubjectInfo.");
bound_flag = TRUE;
if (other_value.subject__type().is_bound()) field_subject__type = other_value.subject__type();
else field_subject__type.clean_up();
if (other_value.subject__name().is_bound()) field_subject__name = other_value.subject__name();
else field_subject__name.clean_up();
}

void SubjectInfo::clean_up()
{
field_subject__type.clean_up();
field_subject__name.clean_up();
bound_flag = FALSE;
}

SubjectInfo& SubjectInfo::operator=(const SubjectInfo& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.SubjectInfo.");
  bound_flag = TRUE;
  if (other_value.subject__type().is_bound()) field_subject__type = other_value.subject__type();
  else field_subject__type.clean_up();
  if (other_value.subject__name().is_bound()) field_subject__name = other_value.subject__name();
  else field_subject__name.clean_up();
}
return *this;
}

boolean SubjectInfo::operator==(const SubjectInfo& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_subject__type==other_value.field_subject__type
  && field_subject__name==other_value.field_subject__name;
}

boolean SubjectInfo::is_bound() const
{
if (bound_flag) return TRUE;
if(field_subject__type.is_bound()) return TRUE;
if(field_subject__name.is_bound()) return TRUE;
return FALSE;
}
boolean SubjectInfo::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_subject__type.is_value()) return FALSE;
if(!field_subject__name.is_value()) return FALSE;
return TRUE;
}
int SubjectInfo::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.SubjectInfo");
  return 2;
}

void SubjectInfo::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ subject_type := ");
field_subject__type.log();
TTCN_Logger::log_event_str(", subject_name := ");
field_subject__name.log();
TTCN_Logger::log_event_str(" }");
}

void SubjectInfo::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.SubjectInfo'");
    }
    if (strcmp("subject_type", param_field) == 0) {
      subject__type().set_param(param);
      return;
    } else if (strcmp("subject_name", param_field) == 0) {
      subject__name().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SubjectInfo'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.SubjectInfo has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) subject__type().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) subject__name().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "subject_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          subject__type().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "subject_name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          subject__name().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.SubjectInfo: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.SubjectInfo");
  }
}

Module_Param* SubjectInfo::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.SubjectInfo'");
    }
    if (strcmp("subject_type", param_field) == 0) {
      return subject__type().get_param(param_name);
    } else if (strcmp("subject_name", param_field) == 0) {
      return subject__name().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SubjectInfo'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_subject__type = field_subject__type.get_param(param_name);
  mp_field_subject__type->set_id(new Module_Param_FieldName(mcopystr("subject_type")));
  mp->add_elem(mp_field_subject__type);
  Module_Param* mp_field_subject__name = field_subject__name.get_param(param_name);
  mp_field_subject__name->set_id(new Module_Param_FieldName(mcopystr("subject_name")));
  mp->add_elem(mp_field_subject__name);
  return mp;
  }

void SubjectInfo::set_implicit_omit()
{
if (subject__type().is_bound()) subject__type().set_implicit_omit();
if (subject__name().is_bound()) subject__name().set_implicit_omit();
}

void SubjectInfo::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.SubjectInfo.");
field_subject__type.encode_text(text_buf);
field_subject__name.encode_text(text_buf);
}

void SubjectInfo::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_subject__type.decode_text(text_buf);
field_subject__name.decode_text(text_buf);
}

void SubjectInfo::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SubjectInfo::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SubjectInfo::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_subject__type.RAW_decode(SubjectType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_subject__name.RAW_decode(LibCommon__DataStrings::Oct0to31_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int SubjectInfo::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, SubjectType_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__DataStrings::Oct0to31_descr_.raw);
  encoded_length += field_subject__type.RAW_encode(SubjectType_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_subject__name.RAW_encode(LibCommon__DataStrings::Oct0to31_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int SubjectInfo::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.SubjectInfo.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "subject_type");
    enc_len += field_subject__type.JSON_encode(SubjectType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "subject_name");
    enc_len += field_subject__name.JSON_encode(LibCommon__DataStrings::Oct0to31_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SubjectInfo::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (12 == name_len && 0 == strncmp(fld_name, "subject_type", name_len)) {
         int ret_val = field_subject__type.JSON_decode(SubjectType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "subject_type");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "subject_name", name_len)) {
         int ret_val = field_subject__name.JSON_decode(LibCommon__DataStrings::Oct0to31_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "subject_name");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_subject__type.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "subject_type");
    return JSON_ERROR_FATAL;
  }
if (!field_subject__name.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "subject_name");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct SubjectInfo_template::single_value_struct {
SubjectType_template field_subject__type;
OCTETSTRING_template field_subject__name;
};

void SubjectInfo_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_subject__type = ANY_VALUE;
single_value->field_subject__name = ANY_VALUE;
}
}
}

void SubjectInfo_template::copy_value(const SubjectInfo& other_value)
{
single_value = new single_value_struct;
if (other_value.subject__type().is_bound()) {
  single_value->field_subject__type = other_value.subject__type();
} else {
  single_value->field_subject__type.clean_up();
}
if (other_value.subject__name().is_bound()) {
  single_value->field_subject__name = other_value.subject__name();
} else {
  single_value->field_subject__name.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SubjectInfo_template::copy_template(const SubjectInfo_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.subject__type().get_selection()) {
single_value->field_subject__type = other_value.subject__type();
} else {
single_value->field_subject__type.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.subject__name().get_selection()) {
single_value->field_subject__name = other_value.subject__name();
} else {
single_value->field_subject__name.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SubjectInfo_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SubjectInfo.");
break;
}
set_selection(other_value);
}

SubjectInfo_template::SubjectInfo_template()
{
}

SubjectInfo_template::SubjectInfo_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SubjectInfo_template::SubjectInfo_template(const SubjectInfo& other_value)
{
copy_value(other_value);
}

SubjectInfo_template::SubjectInfo_template(const OPTIONAL<SubjectInfo>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SubjectInfo&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.SubjectInfo from an unbound optional field.");
}
}

SubjectInfo_template::SubjectInfo_template(const SubjectInfo_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SubjectInfo_template::~SubjectInfo_template()
{
clean_up();
}

SubjectInfo_template& SubjectInfo_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SubjectInfo_template& SubjectInfo_template::operator=(const SubjectInfo& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SubjectInfo_template& SubjectInfo_template::operator=(const OPTIONAL<SubjectInfo>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SubjectInfo&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.SubjectInfo.");
}
return *this;
}

SubjectInfo_template& SubjectInfo_template::operator=(const SubjectInfo_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SubjectInfo_template::match(const SubjectInfo& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.subject__type().is_bound()) return FALSE;
if(!single_value->field_subject__type.match(other_value.subject__type(), legacy))return FALSE;
if(!other_value.subject__name().is_bound()) return FALSE;
if(!single_value->field_subject__name.match(other_value.subject__name(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SubjectInfo.");
}
return FALSE;
}

boolean SubjectInfo_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_subject__type.is_bound()) return TRUE;
if (single_value->field_subject__name.is_bound()) return TRUE;
return FALSE;
}

boolean SubjectInfo_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_subject__type.is_value()) return FALSE;
if (!single_value->field_subject__name.is_value()) return FALSE;
return TRUE;
}

void SubjectInfo_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SubjectInfo SubjectInfo_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.SubjectInfo.");
SubjectInfo ret_val;
if (single_value->field_subject__type.is_bound()) {
ret_val.subject__type() = single_value->field_subject__type.valueof();
}
if (single_value->field_subject__name.is_bound()) {
ret_val.subject__name() = single_value->field_subject__name.valueof();
}
return ret_val;
}

void SubjectInfo_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.SubjectInfo.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SubjectInfo_template[list_length];
}

SubjectInfo_template& SubjectInfo_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.SubjectInfo.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.SubjectInfo.");
return value_list.list_value[list_index];
}

SubjectType_template& SubjectInfo_template::subject__type()
{
set_specific();
return single_value->field_subject__type;
}

const SubjectType_template& SubjectInfo_template::subject__type() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field subject_type of a non-specific template of type @LibItsSecurity_TypesAndValues.SubjectInfo.");
return single_value->field_subject__type;
}

OCTETSTRING_template& SubjectInfo_template::subject__name()
{
set_specific();
return single_value->field_subject__name;
}

const OCTETSTRING_template& SubjectInfo_template::subject__name() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field subject_name of a non-specific template of type @LibItsSecurity_TypesAndValues.SubjectInfo.");
return single_value->field_subject__name;
}

int SubjectInfo_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectInfo which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectInfo containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectInfo containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectInfo containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectInfo containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectInfo containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SubjectInfo.");
  }
  return 0;
}

void SubjectInfo_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ subject_type := ");
single_value->field_subject__type.log();
TTCN_Logger::log_event_str(", subject_name := ");
single_value->field_subject__name.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SubjectInfo_template::log_match(const SubjectInfo& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_subject__type.match(match_value.subject__type(), legacy)){
TTCN_Logger::log_logmatch_info(".subject_type");
single_value->field_subject__type.log_match(match_value.subject__type(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_subject__name.match(match_value.subject__name(), legacy)){
TTCN_Logger::log_logmatch_info(".subject_name");
single_value->field_subject__name.log_match(match_value.subject__name(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ subject_type := ");
single_value->field_subject__type.log_match(match_value.subject__type(), legacy);
TTCN_Logger::log_event_str(", subject_name := ");
single_value->field_subject__name.log_match(match_value.subject__name(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SubjectInfo_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_subject__type.encode_text(text_buf);
single_value->field_subject__name.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SubjectInfo.");
}
}

void SubjectInfo_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_subject__type.decode_text(text_buf);
single_value->field_subject__name.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SubjectInfo_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.SubjectInfo.");
}
}

void SubjectInfo_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.SubjectInfo'");
    }
    if (strcmp("subject_type", param_field) == 0) {
      subject__type().set_param(param);
      return;
    } else if (strcmp("subject_name", param_field) == 0) {
      subject__name().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.SubjectInfo'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SubjectInfo_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.SubjectInfo has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) subject__type().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) subject__name().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "subject_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          subject__type().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "subject_name")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          subject__name().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.SubjectInfo: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.SubjectInfo");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SubjectInfo_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.SubjectInfo'");
    }
    if (strcmp("subject_type", param_field) == 0) {
      return subject__type().get_param(param_name);
    } else if (strcmp("subject_name", param_field) == 0) {
      return subject__name().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SubjectInfo'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_subject__type = single_value->field_subject__type.get_param(param_name);
    mp_field_subject__type->set_id(new Module_Param_FieldName(mcopystr("subject_type")));
    mp->add_elem(mp_field_subject__type);
    Module_Param* mp_field_subject__name = single_value->field_subject__name.get_param(param_name);
    mp_field_subject__name->set_id(new Module_Param_FieldName(mcopystr("subject_name")));
    mp->add_elem(mp_field_subject__name);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SubjectInfo_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_subject__type.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectInfo");
single_value->field_subject__name.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectInfo");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectInfo");
}

boolean SubjectInfo_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SubjectInfo_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const SubjectAttribute SubjectAttributes::UNBOUND_ELEM;
boolean SubjectAttributes::compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index)
{
if (((const SubjectAttributes*)left_ptr)->val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
if (((const SubjectAttributes*)right_ptr)->val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
if (((const SubjectAttributes*)left_ptr)->val_ptr->value_elements[left_index] != NULL){
if (((const SubjectAttributes*)right_ptr)->val_ptr->value_elements[right_index] != NULL){
return *((const SubjectAttributes*)left_ptr)->val_ptr->value_elements[left_index] == *((const SubjectAttributes*)right_ptr)->val_ptr->value_elements[right_index];
} else return FALSE;
} else {
return ((const SubjectAttributes*)right_ptr)->val_ptr->value_elements[right_index] == NULL;
}
}

SubjectAttributes::SubjectAttributes()
{
val_ptr = NULL;
}

SubjectAttributes::SubjectAttributes(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

SubjectAttributes::SubjectAttributes(const SubjectAttributes& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

SubjectAttributes::~SubjectAttributes()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void SubjectAttributes::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

SubjectAttributes& SubjectAttributes::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

SubjectAttributes& SubjectAttributes::operator=(const SubjectAttributes& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean SubjectAttributes::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
return val_ptr->n_elements == 0 ;
}

boolean SubjectAttributes::operator==(const SubjectAttributes& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
if (val_ptr == other_value.val_ptr) return TRUE;
return compare_set_of(this, val_ptr->n_elements, &other_value, (other_value.val_ptr)->n_elements, compare_function);
}

SubjectAttribute& SubjectAttributes::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.SubjectAttributes using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (SubjectAttribute**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new SubjectAttribute(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new SubjectAttribute;
}
return *val_ptr->value_elements[index_value];
}

SubjectAttribute& SubjectAttributes::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
return (*this)[(int)index_value];
}

const SubjectAttribute& SubjectAttributes::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.SubjectAttributes using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsSecurity_TypesAndValues.SubjectAttributes: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const SubjectAttribute& SubjectAttributes::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
return (*this)[(int)index_value];
}

SubjectAttributes SubjectAttributes::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

SubjectAttributes SubjectAttributes::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

SubjectAttributes SubjectAttributes::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

SubjectAttributes SubjectAttributes::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
SubjectAttributes ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new SubjectAttribute(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

SubjectAttributes SubjectAttributes::operator+(const SubjectAttributes& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsSecurity_TypesAndValues.SubjectAttributes concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
SubjectAttributes ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new SubjectAttribute(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new SubjectAttribute(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

SubjectAttributes SubjectAttributes::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsSecurity_TypesAndValues.SubjectAttributes","element");
SubjectAttributes ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new SubjectAttribute(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

SubjectAttributes SubjectAttributes::replace(int index, int len, const SubjectAttributes& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsSecurity_TypesAndValues.SubjectAttributes","element");
SubjectAttributes ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new SubjectAttribute(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new SubjectAttribute(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new SubjectAttribute(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

SubjectAttributes SubjectAttributes::replace(int index, int len, const SubjectAttributes_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void SubjectAttributes::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (SubjectAttribute**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new SubjectAttribute(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (SubjectAttribute**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsSecurity_TypesAndValues.SubjectAttributes: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (SubjectAttribute**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean SubjectAttributes::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int SubjectAttributes::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
return val_ptr->n_elements;
}

int SubjectAttributes::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void SubjectAttributes::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void SubjectAttributes::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set of type `@LibItsSecurity_TypesAndValues.SubjectAttributes'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "set of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.SubjectAttributes");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.SubjectAttributes");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* SubjectAttributes::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of type `@LibItsSecurity_TypesAndValues.SubjectAttributes'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void SubjectAttributes::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void SubjectAttributes::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void SubjectAttributes::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
val_ptr->value_elements = (SubjectAttribute**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new SubjectAttribute;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void SubjectAttributes::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SubjectAttributes::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SubjectAttributes::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int SubjectAttributes::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

int SubjectAttributes::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int SubjectAttributes::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    SubjectAttribute* val = new SubjectAttribute;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (SubjectAttribute**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void SubjectAttributes_template::copy_value(const SubjectAttributes& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (SubjectAttribute_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new SubjectAttribute_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new SubjectAttribute_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void SubjectAttributes_template::copy_template(const SubjectAttributes_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (SubjectAttribute_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new SubjectAttribute_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new SubjectAttribute_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SubjectAttributes_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = other_value.value_set.n_items;
value_set.set_items = new SubjectAttribute_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count] = other_value.value_set.set_items[set_count];
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
break;
}
set_selection(other_value);
}

boolean SubjectAttributes_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const SubjectAttributes_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const SubjectAttributes*)value_ptr)[value_index], legacy);
else return ((const SubjectAttributes_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

boolean SubjectAttributes_template::match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const SubjectAttributes_template*)template_ptr)->value_set.set_items[template_index].match((*(const SubjectAttributes*)value_ptr)[value_index], legacy);
else return ((const SubjectAttributes_template*)template_ptr)->value_set.set_items[template_index].is_any_or_omit();
}

void SubjectAttributes_template::log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy)
{
if (value_ptr != NULL && template_ptr != NULL)((const SubjectAttributes_template*)template_ptr)->single_value.value_elements[index_template]->log_match((*(const SubjectAttributes*)value_ptr)[index_value], legacy);
else if (value_ptr != NULL) (*(const SubjectAttributes*)value_ptr)[index_value].log();
else if (template_ptr != NULL) ((const SubjectAttributes_template*)template_ptr)->single_value.value_elements[index_template]->log();
}

SubjectAttributes_template::SubjectAttributes_template()
{
}

SubjectAttributes_template::SubjectAttributes_template(template_sel other_value)
 : Restricted_Length_Template(other_value)
{
check_single_selection(other_value);
}

SubjectAttributes_template::SubjectAttributes_template(null_type)
 : Restricted_Length_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

SubjectAttributes_template::SubjectAttributes_template(const SubjectAttributes& other_value)
{
copy_value(other_value);
}

SubjectAttributes_template::SubjectAttributes_template(const OPTIONAL<SubjectAttributes>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SubjectAttributes&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes from an unbound optional field.");
}
}

SubjectAttributes_template::SubjectAttributes_template(const SubjectAttributes_template& other_value)
 : Restricted_Length_Template()
{
copy_template(other_value);
}

SubjectAttributes_template::~SubjectAttributes_template()
{
clean_up();
}

void SubjectAttributes_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
delete [] value_set.set_items;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SubjectAttributes_template& SubjectAttributes_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SubjectAttributes_template& SubjectAttributes_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

SubjectAttributes_template& SubjectAttributes_template::operator=(const SubjectAttributes& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SubjectAttributes_template& SubjectAttributes_template::operator=(const OPTIONAL<SubjectAttributes>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SubjectAttributes&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
}
return *this;
}

SubjectAttributes_template& SubjectAttributes_template::operator=(const SubjectAttributes_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

SubjectAttribute_template& SubjectAttributes_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.SubjectAttributes using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
    break;
}
return *single_value.value_elements[index_value];
}

SubjectAttribute_template& SubjectAttributes_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
return (*this)[(int)index_value];
}

const SubjectAttribute_template& SubjectAttributes_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.SubjectAttributes using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const SubjectAttribute_template& SubjectAttributes_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
return (*this)[(int)index_value];
}

void SubjectAttributes_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (SubjectAttribute_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new SubjectAttribute_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new SubjectAttribute_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (SubjectAttribute_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int SubjectAttributes_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int SubjectAttributes_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case SUPERSET_MATCH:
case SUBSET_MATCH: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = value_set.n_items;
  if (!is_size) { while (elem_count>0 && !value_set.set_items[elem_count-1].is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (value_set.set_items[i].get_selection())
    {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
  if (template_selection==SUPERSET_MATCH) {
    has_any_or_none = TRUE;
   } else {
    int max_size = min_size;
    min_size = 0;
    if (!has_any_or_none) { // [0,max_size]
      switch (length_restriction_type) {
      case NO_LENGTH_RESTRICTION:
        if (max_size==0) return 0;
        TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes with no exact size.", op_name);
      case SINGLE_LENGTH_RESTRICTION:
        if (length_restriction.single_length<=max_size)
          return length_restriction.single_length;
        TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.SubjectAttributes. The maximum size (%d) contradicts the length restriction (%d).", op_name, max_size, length_restriction.single_length);
      case RANGE_LENGTH_RESTRICTION:
        if (max_size==length_restriction.range_length.min_length) {
          return max_size;
        } else if (max_size>length_restriction.range_length.min_length){
          TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes with no exact size.", op_name);
        } else
          TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.SubjectAttributes. Maximum size (%d) contradicts the length restriction (%d..%d).", op_name, max_size, length_restriction.range_length.min_length, length_restriction.range_length.max_length);
      default:
        TTCN_error("Internal error: Template has invalid length restriction type.");
      }
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SubjectAttributes.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsSecurity_TypesAndValues.SubjectAttributes");
}

boolean SubjectAttributes_template::match(const SubjectAttributes& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_set_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case SUPERSET_MATCH:
case SUBSET_MATCH:
return match_set_of(&other_value, value_length, this, value_set.n_items, match_function_set, legacy);
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
}
return FALSE;
}

boolean SubjectAttributes_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

SubjectAttributes SubjectAttributes_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
SubjectAttributes ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

SubjectAttributes SubjectAttributes_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

SubjectAttributes SubjectAttributes_template::replace(int index, int len, const SubjectAttributes_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

SubjectAttributes SubjectAttributes_template::replace(int index, int len, const SubjectAttributes& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void SubjectAttributes_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new SubjectAttributes_template[list_length];
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = list_length;
value_set.set_items = new SubjectAttribute_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
}
set_selection(template_type);
}

SubjectAttributes_template& SubjectAttributes_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
return value_list.list_value[list_index];
}

SubjectAttribute_template& SubjectAttributes_template::set_item(unsigned int set_index)
{
if (template_selection != SUPERSET_MATCH && template_selection != SUBSET_MATCH) TTCN_error("Internal error: Accessing a set element of a non-set template of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
if (set_index >= value_set.n_items) TTCN_error("Internal error: Index overflow in a set template of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
return value_set.set_items[set_index];
}

void SubjectAttributes_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log();
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
TTCN_Logger::log_event("%s(", template_selection == SUPERSET_MATCH ? "superset" : "subset");
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++) {
if (set_count > 0) TTCN_Logger::log_event_str(", ");
value_set.set_items[set_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void SubjectAttributes_template::log_match(const SubjectAttributes& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (template_selection == SPECIFIC_VALUE)
  log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
else{
if(previous_size != 0){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::set_logmatch_buffer_len(previous_size);
TTCN_Logger::log_event_str(":=");
}
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
return;
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else {
TTCN_Logger::log_event_str(" unmatched");
if (template_selection == SPECIFIC_VALUE) log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
}
}

void SubjectAttributes_template::encode_text(Text_Buf& text_buf) const
{
encode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
text_buf.push_int(value_set.n_items);
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
}
}

void SubjectAttributes_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
single_value.value_elements = (SubjectAttribute_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new SubjectAttribute_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SubjectAttributes_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = text_buf.pull_int().get_val();
value_set.set_items = new SubjectAttribute_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
}
}

boolean SubjectAttributes_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SubjectAttributes_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SubjectAttributes_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set template type `@LibItsSecurity_TypesAndValues.SubjectAttributes'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "set of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SubjectAttributes_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    set_size(mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      if (mp->get_elem(p_i)->get_type()!=Module_Param::MP_NotUsed) {
        (*this)[p_i].set_param(*mp->get_elem(p_i));
      }
    }
    break;
  case Module_Param::MP_Superset_Template:
  case Module_Param::MP_Subset_Template:
    set_type(mp->get_type()==Module_Param::MP_Superset_Template ? SUPERSET_MATCH : SUBSET_MATCH, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      set_item(p_i).set_param(*mp->get_elem(p_i));
    }
    break;
  default:
    param.type_error("set of template", "@LibItsSecurity_TypesAndValues.SubjectAttributes");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* SubjectAttributes_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of template type `@LibItsSecurity_TypesAndValues.SubjectAttributes'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void SubjectAttributes_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectAttributes");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectAttributes");
}

SubjectAttributeType::SubjectAttributeType()
{
enum_value = UNBOUND_VALUE;
}

SubjectAttributeType::SubjectAttributeType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

SubjectAttributeType::SubjectAttributeType(enum_type other_value)
{
enum_value = other_value;
}

SubjectAttributeType::SubjectAttributeType(const SubjectAttributeType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
enum_value = other_value.enum_value;
}

SubjectAttributeType& SubjectAttributeType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

SubjectAttributeType& SubjectAttributeType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

SubjectAttributeType& SubjectAttributeType::operator=(const SubjectAttributeType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
enum_value = other_value.enum_value;
return *this;
}

boolean SubjectAttributeType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
return enum_value == other_value;
}

boolean SubjectAttributeType::operator==(const SubjectAttributeType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
return enum_value == other_value.enum_value;
}

boolean SubjectAttributeType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
return enum_value < other_value;
}

boolean SubjectAttributeType::operator<(const SubjectAttributeType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
return enum_value < other_value.enum_value;
}

boolean SubjectAttributeType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
return enum_value > other_value;
}

boolean SubjectAttributeType::operator>(const SubjectAttributeType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
return enum_value > other_value.enum_value;
}

const char *SubjectAttributeType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__verification__key: return "e_verification_key";
case e__encryption__key: return "e_encryption_key";
case e__assurance__level: return "e_assurance_level";
case e__reconstruction__value: return "e_reconstruction_value";
case e__its__aid__list: return "e_its_aid_list";
case e__its__aid__ssp__list: return "e_its_aid_ssp_list";
default: return "<unknown>";
}
}

SubjectAttributeType::enum_type SubjectAttributeType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_verification_key")) return e__verification__key;
else if (!strcmp(str_par, "e_encryption_key")) return e__encryption__key;
else if (!strcmp(str_par, "e_assurance_level")) return e__assurance__level;
else if (!strcmp(str_par, "e_reconstruction_value")) return e__reconstruction__value;
else if (!strcmp(str_par, "e_its_aid_list")) return e__its__aid__list;
else if (!strcmp(str_par, "e_its_aid_ssp_list")) return e__its__aid__ssp__list;
else return UNKNOWN_VALUE;
}

boolean SubjectAttributeType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 32:
case 33:
return TRUE;
default:
return FALSE;
}
}

int SubjectAttributeType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int SubjectAttributeType::enum2int(const SubjectAttributeType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void SubjectAttributeType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.", int_val);
enum_value = (enum_type)int_val;
}

SubjectAttributeType::operator SubjectAttributeType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
return enum_value;
}

void SubjectAttributeType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void SubjectAttributeType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsSecurity_TypesAndValues.SubjectAttributeType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
  }
}

Module_Param* SubjectAttributeType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void SubjectAttributeType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
text_buf.push_int(enum_value);
}

void SubjectAttributeType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.", enum_value);
}

void SubjectAttributeType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SubjectAttributeType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SubjectAttributeType::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 6, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int SubjectAttributeType::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 6);
}

int SubjectAttributeType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int SubjectAttributeType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void SubjectAttributeType_template::copy_template(const SubjectAttributeType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SubjectAttributeType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
}
}

SubjectAttributeType_template::SubjectAttributeType_template()
{
}

SubjectAttributeType_template::SubjectAttributeType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SubjectAttributeType_template::SubjectAttributeType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!SubjectAttributeType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType with unknown numeric value %d.", other_value);
single_value = (SubjectAttributeType::enum_type)other_value;
}

SubjectAttributeType_template::SubjectAttributeType_template(SubjectAttributeType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

SubjectAttributeType_template::SubjectAttributeType_template(const SubjectAttributeType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == SubjectAttributeType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
single_value = other_value.enum_value;
}

SubjectAttributeType_template::SubjectAttributeType_template(const OPTIONAL<SubjectAttributeType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SubjectAttributeType::enum_type)(const SubjectAttributeType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType from an unbound optional field.");
}
}

SubjectAttributeType_template::SubjectAttributeType_template(const SubjectAttributeType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

SubjectAttributeType_template::~SubjectAttributeType_template()
{
clean_up();
}

boolean SubjectAttributeType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean SubjectAttributeType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != SubjectAttributeType::UNBOUND_VALUE;
}

void SubjectAttributeType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

SubjectAttributeType_template& SubjectAttributeType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SubjectAttributeType_template& SubjectAttributeType_template::operator=(int other_value)
{
if (!SubjectAttributeType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (SubjectAttributeType::enum_type)other_value;
return *this;
}

SubjectAttributeType_template& SubjectAttributeType_template::operator=(SubjectAttributeType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

SubjectAttributeType_template& SubjectAttributeType_template::operator=(const SubjectAttributeType& other_value)
{
if (other_value.enum_value == SubjectAttributeType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

SubjectAttributeType_template& SubjectAttributeType_template::operator=(const OPTIONAL<SubjectAttributeType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SubjectAttributeType::enum_type)(const SubjectAttributeType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
}
return *this;
}

SubjectAttributeType_template& SubjectAttributeType_template::operator=(const SubjectAttributeType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SubjectAttributeType_template::match(SubjectAttributeType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
}
return FALSE;
}

boolean SubjectAttributeType_template::match(const SubjectAttributeType& other_value, boolean) const
{
if (other_value.enum_value == SubjectAttributeType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType with an unbound value.");
return match(other_value.enum_value);
}

SubjectAttributeType::enum_type SubjectAttributeType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
return single_value;
}

void SubjectAttributeType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SubjectAttributeType_template[list_length];
}

SubjectAttributeType_template& SubjectAttributeType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
return value_list.list_value[list_index];
}

void SubjectAttributeType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(SubjectAttributeType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SubjectAttributeType_template::log_match(const SubjectAttributeType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void SubjectAttributeType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
}
}

void SubjectAttributeType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (SubjectAttributeType::enum_type)text_buf.pull_int().get_val();
if (!SubjectAttributeType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SubjectAttributeType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
}
}

boolean SubjectAttributeType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SubjectAttributeType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SubjectAttributeType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    SubjectAttributeType::enum_type enum_val = (enum_name != NULL) ? SubjectAttributeType::str_to_enum(enum_name) : SubjectAttributeType::UNKNOWN_VALUE;
    if (SubjectAttributeType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SubjectAttributeType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    SubjectAttributeType::enum_type enum_val = SubjectAttributeType::str_to_enum(mp->get_enumerated());
    if (!SubjectAttributeType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.SubjectAttributeType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsSecurity_TypesAndValues.SubjectAttributeType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SubjectAttributeType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(SubjectAttributeType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SubjectAttributeType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectAttributeType");
}

void SubjectAttributeContainer::copy_value(const SubjectAttributeContainer& other_value)
{
switch (other_value.union_selection) {
case ALT_key:
field_key = new PublicKey(*other_value.field_key);
break;
case ALT_rv:
field_rv = new EccPoint(*other_value.field_rv);
break;
case ALT_assurance__level:
field_assurance__level = new SubjectAssurance(*other_value.field_assurance__level);
break;
case ALT_its__aid__list:
field_its__aid__list = new IntXs(*other_value.field_its__aid__list);
break;
case ALT_its__aid__ssp__list:
field_its__aid__ssp__list = new ItsAidSsps(*other_value.field_its__aid__ssp__list);
break;
case ALT_other__attribute:
field_other__attribute = new OCTETSTRING(*other_value.field_other__attribute);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
}
union_selection = other_value.union_selection;
}

SubjectAttributeContainer::SubjectAttributeContainer()
{
union_selection = UNBOUND_VALUE;
}

SubjectAttributeContainer::SubjectAttributeContainer(const SubjectAttributeContainer& other_value)
: Base_Type(){
copy_value(other_value);
}

SubjectAttributeContainer::~SubjectAttributeContainer()
{
clean_up();
}

SubjectAttributeContainer& SubjectAttributeContainer::operator=(const SubjectAttributeContainer& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean SubjectAttributeContainer::operator==(const SubjectAttributeContainer& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_key:
return *field_key == *other_value.field_key;
case ALT_rv:
return *field_rv == *other_value.field_rv;
case ALT_assurance__level:
return *field_assurance__level == *other_value.field_assurance__level;
case ALT_its__aid__list:
return *field_its__aid__list == *other_value.field_its__aid__list;
case ALT_its__aid__ssp__list:
return *field_its__aid__ssp__list == *other_value.field_its__aid__ssp__list;
case ALT_other__attribute:
return *field_other__attribute == *other_value.field_other__attribute;
default:
return FALSE;
}
}

PublicKey& SubjectAttributeContainer::key()
{
if (union_selection != ALT_key) {
clean_up();
field_key = new PublicKey;
union_selection = ALT_key;
}
return *field_key;
}

const PublicKey& SubjectAttributeContainer::key() const
{
if (union_selection != ALT_key) TTCN_error("Using non-selected field key in a value of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
return *field_key;
}

EccPoint& SubjectAttributeContainer::rv()
{
if (union_selection != ALT_rv) {
clean_up();
field_rv = new EccPoint;
union_selection = ALT_rv;
}
return *field_rv;
}

const EccPoint& SubjectAttributeContainer::rv() const
{
if (union_selection != ALT_rv) TTCN_error("Using non-selected field rv in a value of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
return *field_rv;
}

SubjectAssurance& SubjectAttributeContainer::assurance__level()
{
if (union_selection != ALT_assurance__level) {
clean_up();
field_assurance__level = new SubjectAssurance;
union_selection = ALT_assurance__level;
}
return *field_assurance__level;
}

const SubjectAssurance& SubjectAttributeContainer::assurance__level() const
{
if (union_selection != ALT_assurance__level) TTCN_error("Using non-selected field assurance_level in a value of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
return *field_assurance__level;
}

IntXs& SubjectAttributeContainer::its__aid__list()
{
if (union_selection != ALT_its__aid__list) {
clean_up();
field_its__aid__list = new IntXs;
union_selection = ALT_its__aid__list;
}
return *field_its__aid__list;
}

const IntXs& SubjectAttributeContainer::its__aid__list() const
{
if (union_selection != ALT_its__aid__list) TTCN_error("Using non-selected field its_aid_list in a value of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
return *field_its__aid__list;
}

ItsAidSsps& SubjectAttributeContainer::its__aid__ssp__list()
{
if (union_selection != ALT_its__aid__ssp__list) {
clean_up();
field_its__aid__ssp__list = new ItsAidSsps;
union_selection = ALT_its__aid__ssp__list;
}
return *field_its__aid__ssp__list;
}

const ItsAidSsps& SubjectAttributeContainer::its__aid__ssp__list() const
{
if (union_selection != ALT_its__aid__ssp__list) TTCN_error("Using non-selected field its_aid_ssp_list in a value of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
return *field_its__aid__ssp__list;
}

OCTETSTRING& SubjectAttributeContainer::other__attribute()
{
if (union_selection != ALT_other__attribute) {
clean_up();
field_other__attribute = new OCTETSTRING;
union_selection = ALT_other__attribute;
}
return *field_other__attribute;
}

const OCTETSTRING& SubjectAttributeContainer::other__attribute() const
{
if (union_selection != ALT_other__attribute) TTCN_error("Using non-selected field other_attribute in a value of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
return *field_other__attribute;
}

boolean SubjectAttributeContainer::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
return union_selection == checked_selection;
}

boolean SubjectAttributeContainer::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean SubjectAttributeContainer::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_key: return field_key->is_value();
case ALT_rv: return field_rv->is_value();
case ALT_assurance__level: return field_assurance__level->is_value();
case ALT_its__aid__list: return field_its__aid__list->is_value();
case ALT_its__aid__ssp__list: return field_its__aid__ssp__list->is_value();
case ALT_other__attribute: return field_other__attribute->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void SubjectAttributeContainer::clean_up()
{
switch (union_selection) {
case ALT_key:
  delete field_key;
  break;
case ALT_rv:
  delete field_rv;
  break;
case ALT_assurance__level:
  delete field_assurance__level;
  break;
case ALT_its__aid__list:
  delete field_its__aid__list;
  break;
case ALT_its__aid__ssp__list:
  delete field_its__aid__ssp__list;
  break;
case ALT_other__attribute:
  delete field_other__attribute;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void SubjectAttributeContainer::log() const
{
switch (union_selection) {
case ALT_key:
TTCN_Logger::log_event_str("{ key := ");
field_key->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_rv:
TTCN_Logger::log_event_str("{ rv := ");
field_rv->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_assurance__level:
TTCN_Logger::log_event_str("{ assurance_level := ");
field_assurance__level->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_its__aid__list:
TTCN_Logger::log_event_str("{ its_aid_list := ");
field_its__aid__list->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_its__aid__ssp__list:
TTCN_Logger::log_event_str("{ its_aid_ssp_list := ");
field_its__aid__ssp__list->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_other__attribute:
TTCN_Logger::log_event_str("{ other_attribute := ");
field_other__attribute->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void SubjectAttributeContainer::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsSecurity_TypesAndValues.SubjectAttributeContainer'");
    }
    if (strcmp("key", param_field) == 0) {
      key().set_param(param);
      return;
    } else if (strcmp("rv", param_field) == 0) {
      rv().set_param(param);
      return;
    } else if (strcmp("assurance_level", param_field) == 0) {
      assurance__level().set_param(param);
      return;
    } else if (strcmp("its_aid_list", param_field) == 0) {
      its__aid__list().set_param(param);
      return;
    } else if (strcmp("its_aid_ssp_list", param_field) == 0) {
      its__aid__ssp__list().set_param(param);
      return;
    } else if (strcmp("other_attribute", param_field) == 0) {
      other__attribute().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsSecurity_TypesAndValues.SubjectAttributeContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "key")) {
    key().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "rv")) {
    rv().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "assurance_level")) {
    assurance__level().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "its_aid_list")) {
    its__aid__list().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "its_aid_ssp_list")) {
    its__aid__ssp__list().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "other_attribute")) {
    other__attribute().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.", mp_last->get_id()->get_name());
}

Module_Param* SubjectAttributeContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsSecurity_TypesAndValues.SubjectAttributeContainer'");
    }
    if (strcmp("key", param_field) == 0) {
      return key().get_param(param_name);
    } else if (strcmp("rv", param_field) == 0) {
      return rv().get_param(param_name);
    } else if (strcmp("assurance_level", param_field) == 0) {
      return assurance__level().get_param(param_name);
    } else if (strcmp("its_aid_list", param_field) == 0) {
      return its__aid__list().get_param(param_name);
    } else if (strcmp("its_aid_ssp_list", param_field) == 0) {
      return its__aid__ssp__list().get_param(param_name);
    } else if (strcmp("other_attribute", param_field) == 0) {
      return other__attribute().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `SubjectAttributeContainer'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_key:
    mp_field = field_key->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("key")));
    break;
  case ALT_rv:
    mp_field = field_rv->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("rv")));
    break;
  case ALT_assurance__level:
    mp_field = field_assurance__level->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("assurance_level")));
    break;
  case ALT_its__aid__list:
    mp_field = field_its__aid__list->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("its_aid_list")));
    break;
  case ALT_its__aid__ssp__list:
    mp_field = field_its__aid__ssp__list->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("its_aid_ssp_list")));
    break;
  case ALT_other__attribute:
    mp_field = field_other__attribute->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("other_attribute")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void SubjectAttributeContainer::set_implicit_omit()
{
switch (union_selection) {
case ALT_key:
field_key->set_implicit_omit(); break;
case ALT_rv:
field_rv->set_implicit_omit(); break;
case ALT_assurance__level:
field_assurance__level->set_implicit_omit(); break;
case ALT_its__aid__list:
field_its__aid__list->set_implicit_omit(); break;
case ALT_its__aid__ssp__list:
field_its__aid__ssp__list->set_implicit_omit(); break;
case ALT_other__attribute:
field_other__attribute->set_implicit_omit(); break;
default: break;
}
}

void SubjectAttributeContainer::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_key:
field_key->encode_text(text_buf);
break;
case ALT_rv:
field_rv->encode_text(text_buf);
break;
case ALT_assurance__level:
field_assurance__level->encode_text(text_buf);
break;
case ALT_its__aid__list:
field_its__aid__list->encode_text(text_buf);
break;
case ALT_its__aid__ssp__list:
field_its__aid__ssp__list->encode_text(text_buf);
break;
case ALT_other__attribute:
field_other__attribute->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
}
}

void SubjectAttributeContainer::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_key:
key().decode_text(text_buf);
break;
case ALT_rv:
rv().decode_text(text_buf);
break;
case ALT_assurance__level:
assurance__level().decode_text(text_buf);
break;
case ALT_its__aid__list:
its__aid__list().decode_text(text_buf);
break;
case ALT_its__aid__ssp__list:
its__aid__ssp__list().decode_text(text_buf);
break;
case ALT_other__attribute:
other__attribute().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
}
}

void SubjectAttributeContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SubjectAttributeContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SubjectAttributeContainer::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = key().RAW_decode(PublicKey_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = rv().RAW_decode(EccPoint_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 2:
      decoded_length = assurance__level().RAW_decode(SubjectAssurance_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 3:
      decoded_length = its__aid__list().RAW_decode(IntXs_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 4:
      decoded_length = its__aid__ssp__list().RAW_decode(ItsAidSsps_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 5:
      decoded_length = other__attribute().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = key().RAW_decode(PublicKey_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = rv().RAW_decode(EccPoint_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = assurance__level().RAW_decode(SubjectAssurance_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = its__aid__list().RAW_decode(IntXs_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = its__aid__ssp__list().RAW_decode(ItsAidSsps_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = other__attribute().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int SubjectAttributeContainer::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 6;  myleaf.body.node.nodes = init_nodes_of_enc_tree(6);
  memset(myleaf.body.node.nodes, 0, 6 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_key:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, PublicKey_descr_.raw);
    encoded_length = field_key->RAW_encode(PublicKey_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &PublicKey_descr_;
    break;
  case ALT_rv:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, EccPoint_descr_.raw);
    encoded_length = field_rv->RAW_encode(EccPoint_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &EccPoint_descr_;
    break;
  case ALT_assurance__level:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, SubjectAssurance_descr_.raw);
    encoded_length = field_assurance__level->RAW_encode(SubjectAssurance_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &SubjectAssurance_descr_;
    break;
  case ALT_its__aid__list:
    myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 3, IntXs_descr_.raw);
    encoded_length = field_its__aid__list->RAW_encode(IntXs_descr_, *myleaf.body.node.nodes[3]);
    myleaf.body.node.nodes[3]->coding_descr = &IntXs_descr_;
    break;
  case ALT_its__aid__ssp__list:
    myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 4, ItsAidSsps_descr_.raw);
    encoded_length = field_its__aid__ssp__list->RAW_encode(ItsAidSsps_descr_, *myleaf.body.node.nodes[4]);
    myleaf.body.node.nodes[4]->coding_descr = &ItsAidSsps_descr_;
    break;
  case ALT_other__attribute:
    myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 5, OCTETSTRING_descr_.raw);
    encoded_length = field_other__attribute->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[5]);
    myleaf.body.node.nodes[5]->coding_descr = &OCTETSTRING_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int SubjectAttributeContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_key:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "key");
    enc_len += field_key->JSON_encode(PublicKey_descr_, p_tok);
    break;
  case ALT_rv:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "rv");
    enc_len += field_rv->JSON_encode(EccPoint_descr_, p_tok);
    break;
  case ALT_assurance__level:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "assurance_level");
    enc_len += field_assurance__level->JSON_encode(SubjectAssurance_descr_, p_tok);
    break;
  case ALT_its__aid__list:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "its_aid_list");
    enc_len += field_its__aid__list->JSON_encode(IntXs_descr_, p_tok);
    break;
  case ALT_its__aid__ssp__list:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "its_aid_ssp_list");
    enc_len += field_its__aid__ssp__list->JSON_encode(ItsAidSsps_descr_, p_tok);
    break;
  case ALT_other__attribute:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "other_attribute");
    enc_len += field_other__attribute->JSON_encode(OCTETSTRING_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SubjectAttributeContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "key", name_len)) {
      int ret_val = key().JSON_decode(PublicKey_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "key");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "rv", name_len)) {
      int ret_val = rv().JSON_decode(EccPoint_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "rv");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "assurance_level", name_len)) {
      int ret_val = assurance__level().JSON_decode(SubjectAssurance_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "assurance_level");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "its_aid_list", name_len)) {
      int ret_val = its__aid__list().JSON_decode(IntXs_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "its_aid_list");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "its_aid_ssp_list", name_len)) {
      int ret_val = its__aid__ssp__list().JSON_decode(ItsAidSsps_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "its_aid_ssp_list");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "other_attribute", name_len)) {
      int ret_val = other__attribute().JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "other_attribute");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void SubjectAttributeContainer_template::copy_value(const SubjectAttributeContainer& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case SubjectAttributeContainer::ALT_key:
single_value.field_key = new PublicKey_template(other_value.key());
break;
case SubjectAttributeContainer::ALT_rv:
single_value.field_rv = new EccPoint_template(other_value.rv());
break;
case SubjectAttributeContainer::ALT_assurance__level:
single_value.field_assurance__level = new SubjectAssurance_template(other_value.assurance__level());
break;
case SubjectAttributeContainer::ALT_its__aid__list:
single_value.field_its__aid__list = new IntXs_template(other_value.its__aid__list());
break;
case SubjectAttributeContainer::ALT_its__aid__ssp__list:
single_value.field_its__aid__ssp__list = new ItsAidSsps_template(other_value.its__aid__ssp__list());
break;
case SubjectAttributeContainer::ALT_other__attribute:
single_value.field_other__attribute = new OCTETSTRING_template(other_value.other__attribute());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
}
set_selection(SPECIFIC_VALUE);
}

void SubjectAttributeContainer_template::copy_template(const SubjectAttributeContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case SubjectAttributeContainer::ALT_key:
single_value.field_key = new PublicKey_template(*other_value.single_value.field_key);
break;
case SubjectAttributeContainer::ALT_rv:
single_value.field_rv = new EccPoint_template(*other_value.single_value.field_rv);
break;
case SubjectAttributeContainer::ALT_assurance__level:
single_value.field_assurance__level = new SubjectAssurance_template(*other_value.single_value.field_assurance__level);
break;
case SubjectAttributeContainer::ALT_its__aid__list:
single_value.field_its__aid__list = new IntXs_template(*other_value.single_value.field_its__aid__list);
break;
case SubjectAttributeContainer::ALT_its__aid__ssp__list:
single_value.field_its__aid__ssp__list = new ItsAidSsps_template(*other_value.single_value.field_its__aid__ssp__list);
break;
case SubjectAttributeContainer::ALT_other__attribute:
single_value.field_other__attribute = new OCTETSTRING_template(*other_value.single_value.field_other__attribute);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SubjectAttributeContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
}
set_selection(other_value);
}

SubjectAttributeContainer_template::SubjectAttributeContainer_template()
{
}

SubjectAttributeContainer_template::SubjectAttributeContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SubjectAttributeContainer_template::SubjectAttributeContainer_template(const SubjectAttributeContainer& other_value)
{
copy_value(other_value);
}

SubjectAttributeContainer_template::SubjectAttributeContainer_template(const OPTIONAL<SubjectAttributeContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SubjectAttributeContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer from an unbound optional field.");
}
}

SubjectAttributeContainer_template::SubjectAttributeContainer_template(const SubjectAttributeContainer_template& other_value)
: Base_Template(){
copy_template(other_value);
}

SubjectAttributeContainer_template::~SubjectAttributeContainer_template()
{
clean_up();
}

void SubjectAttributeContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case SubjectAttributeContainer::ALT_key:
delete single_value.field_key;
break;
case SubjectAttributeContainer::ALT_rv:
delete single_value.field_rv;
break;
case SubjectAttributeContainer::ALT_assurance__level:
delete single_value.field_assurance__level;
break;
case SubjectAttributeContainer::ALT_its__aid__list:
delete single_value.field_its__aid__list;
break;
case SubjectAttributeContainer::ALT_its__aid__ssp__list:
delete single_value.field_its__aid__ssp__list;
break;
case SubjectAttributeContainer::ALT_other__attribute:
delete single_value.field_other__attribute;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SubjectAttributeContainer_template& SubjectAttributeContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SubjectAttributeContainer_template& SubjectAttributeContainer_template::operator=(const SubjectAttributeContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SubjectAttributeContainer_template& SubjectAttributeContainer_template::operator=(const OPTIONAL<SubjectAttributeContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SubjectAttributeContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
}
return *this;
}

SubjectAttributeContainer_template& SubjectAttributeContainer_template::operator=(const SubjectAttributeContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SubjectAttributeContainer_template::match(const SubjectAttributeContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
SubjectAttributeContainer::union_selection_type value_selection = other_value.get_selection();
if (value_selection == SubjectAttributeContainer::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case SubjectAttributeContainer::ALT_key:
return single_value.field_key->match(other_value.key(), legacy);
case SubjectAttributeContainer::ALT_rv:
return single_value.field_rv->match(other_value.rv(), legacy);
case SubjectAttributeContainer::ALT_assurance__level:
return single_value.field_assurance__level->match(other_value.assurance__level(), legacy);
case SubjectAttributeContainer::ALT_its__aid__list:
return single_value.field_its__aid__list->match(other_value.its__aid__list(), legacy);
case SubjectAttributeContainer::ALT_its__aid__ssp__list:
return single_value.field_its__aid__ssp__list->match(other_value.its__aid__ssp__list(), legacy);
case SubjectAttributeContainer::ALT_other__attribute:
return single_value.field_other__attribute->match(other_value.other__attribute(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
}
return FALSE;
}

boolean SubjectAttributeContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case SubjectAttributeContainer::ALT_key:
return single_value.field_key->is_value();
case SubjectAttributeContainer::ALT_rv:
return single_value.field_rv->is_value();
case SubjectAttributeContainer::ALT_assurance__level:
return single_value.field_assurance__level->is_value();
case SubjectAttributeContainer::ALT_its__aid__list:
return single_value.field_its__aid__list->is_value();
case SubjectAttributeContainer::ALT_its__aid__ssp__list:
return single_value.field_its__aid__ssp__list->is_value();
case SubjectAttributeContainer::ALT_other__attribute:
return single_value.field_other__attribute->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
}
}

SubjectAttributeContainer SubjectAttributeContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
SubjectAttributeContainer ret_val;
switch (single_value.union_selection) {
case SubjectAttributeContainer::ALT_key:
ret_val.key() = single_value.field_key->valueof();
break;
case SubjectAttributeContainer::ALT_rv:
ret_val.rv() = single_value.field_rv->valueof();
break;
case SubjectAttributeContainer::ALT_assurance__level:
ret_val.assurance__level() = single_value.field_assurance__level->valueof();
break;
case SubjectAttributeContainer::ALT_its__aid__list:
ret_val.its__aid__list() = single_value.field_its__aid__list->valueof();
break;
case SubjectAttributeContainer::ALT_its__aid__ssp__list:
ret_val.its__aid__ssp__list() = single_value.field_its__aid__ssp__list->valueof();
break;
case SubjectAttributeContainer::ALT_other__attribute:
ret_val.other__attribute() = single_value.field_other__attribute->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
}
return ret_val;
}

SubjectAttributeContainer_template& SubjectAttributeContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
return value_list.list_value[list_index];
}
void SubjectAttributeContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SubjectAttributeContainer_template[list_length];
}

PublicKey_template& SubjectAttributeContainer_template::key()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SubjectAttributeContainer::ALT_key) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_key = new PublicKey_template(ANY_VALUE);
else single_value.field_key = new PublicKey_template;
single_value.union_selection = SubjectAttributeContainer::ALT_key;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_key;
}

const PublicKey_template& SubjectAttributeContainer_template::key() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field key in a non-specific template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
if (single_value.union_selection != SubjectAttributeContainer::ALT_key) TTCN_error("Accessing non-selected field key in a template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
return *single_value.field_key;
}

EccPoint_template& SubjectAttributeContainer_template::rv()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SubjectAttributeContainer::ALT_rv) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_rv = new EccPoint_template(ANY_VALUE);
else single_value.field_rv = new EccPoint_template;
single_value.union_selection = SubjectAttributeContainer::ALT_rv;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_rv;
}

const EccPoint_template& SubjectAttributeContainer_template::rv() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field rv in a non-specific template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
if (single_value.union_selection != SubjectAttributeContainer::ALT_rv) TTCN_error("Accessing non-selected field rv in a template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
return *single_value.field_rv;
}

SubjectAssurance_template& SubjectAttributeContainer_template::assurance__level()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SubjectAttributeContainer::ALT_assurance__level) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_assurance__level = new SubjectAssurance_template(ANY_VALUE);
else single_value.field_assurance__level = new SubjectAssurance_template;
single_value.union_selection = SubjectAttributeContainer::ALT_assurance__level;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_assurance__level;
}

const SubjectAssurance_template& SubjectAttributeContainer_template::assurance__level() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field assurance_level in a non-specific template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
if (single_value.union_selection != SubjectAttributeContainer::ALT_assurance__level) TTCN_error("Accessing non-selected field assurance_level in a template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
return *single_value.field_assurance__level;
}

IntXs_template& SubjectAttributeContainer_template::its__aid__list()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SubjectAttributeContainer::ALT_its__aid__list) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_its__aid__list = new IntXs_template(ANY_VALUE);
else single_value.field_its__aid__list = new IntXs_template;
single_value.union_selection = SubjectAttributeContainer::ALT_its__aid__list;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_its__aid__list;
}

const IntXs_template& SubjectAttributeContainer_template::its__aid__list() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field its_aid_list in a non-specific template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
if (single_value.union_selection != SubjectAttributeContainer::ALT_its__aid__list) TTCN_error("Accessing non-selected field its_aid_list in a template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
return *single_value.field_its__aid__list;
}

ItsAidSsps_template& SubjectAttributeContainer_template::its__aid__ssp__list()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SubjectAttributeContainer::ALT_its__aid__ssp__list) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_its__aid__ssp__list = new ItsAidSsps_template(ANY_VALUE);
else single_value.field_its__aid__ssp__list = new ItsAidSsps_template;
single_value.union_selection = SubjectAttributeContainer::ALT_its__aid__ssp__list;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_its__aid__ssp__list;
}

const ItsAidSsps_template& SubjectAttributeContainer_template::its__aid__ssp__list() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field its_aid_ssp_list in a non-specific template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
if (single_value.union_selection != SubjectAttributeContainer::ALT_its__aid__ssp__list) TTCN_error("Accessing non-selected field its_aid_ssp_list in a template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
return *single_value.field_its__aid__ssp__list;
}

OCTETSTRING_template& SubjectAttributeContainer_template::other__attribute()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != SubjectAttributeContainer::ALT_other__attribute) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_other__attribute = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_other__attribute = new OCTETSTRING_template;
single_value.union_selection = SubjectAttributeContainer::ALT_other__attribute;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_other__attribute;
}

const OCTETSTRING_template& SubjectAttributeContainer_template::other__attribute() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field other_attribute in a non-specific template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
if (single_value.union_selection != SubjectAttributeContainer::ALT_other__attribute) TTCN_error("Accessing non-selected field other_attribute in a template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
return *single_value.field_other__attribute;
}

boolean SubjectAttributeContainer_template::ischosen(SubjectAttributeContainer::union_selection_type checked_selection) const
{
if (checked_selection == SubjectAttributeContainer::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == SubjectAttributeContainer::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer");
}
return FALSE;
}

void SubjectAttributeContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case SubjectAttributeContainer::ALT_key:
TTCN_Logger::log_event_str("{ key := ");
single_value.field_key->log();
TTCN_Logger::log_event_str(" }");
break;
case SubjectAttributeContainer::ALT_rv:
TTCN_Logger::log_event_str("{ rv := ");
single_value.field_rv->log();
TTCN_Logger::log_event_str(" }");
break;
case SubjectAttributeContainer::ALT_assurance__level:
TTCN_Logger::log_event_str("{ assurance_level := ");
single_value.field_assurance__level->log();
TTCN_Logger::log_event_str(" }");
break;
case SubjectAttributeContainer::ALT_its__aid__list:
TTCN_Logger::log_event_str("{ its_aid_list := ");
single_value.field_its__aid__list->log();
TTCN_Logger::log_event_str(" }");
break;
case SubjectAttributeContainer::ALT_its__aid__ssp__list:
TTCN_Logger::log_event_str("{ its_aid_ssp_list := ");
single_value.field_its__aid__ssp__list->log();
TTCN_Logger::log_event_str(" }");
break;
case SubjectAttributeContainer::ALT_other__attribute:
TTCN_Logger::log_event_str("{ other_attribute := ");
single_value.field_other__attribute->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SubjectAttributeContainer_template::log_match(const SubjectAttributeContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case SubjectAttributeContainer::ALT_key:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".key");
single_value.field_key->log_match(match_value.key(), legacy);
} else {
TTCN_Logger::log_event_str("{ key := ");
single_value.field_key->log_match(match_value.key(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SubjectAttributeContainer::ALT_rv:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".rv");
single_value.field_rv->log_match(match_value.rv(), legacy);
} else {
TTCN_Logger::log_event_str("{ rv := ");
single_value.field_rv->log_match(match_value.rv(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SubjectAttributeContainer::ALT_assurance__level:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".assurance_level");
single_value.field_assurance__level->log_match(match_value.assurance__level(), legacy);
} else {
TTCN_Logger::log_event_str("{ assurance_level := ");
single_value.field_assurance__level->log_match(match_value.assurance__level(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SubjectAttributeContainer::ALT_its__aid__list:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".its_aid_list");
single_value.field_its__aid__list->log_match(match_value.its__aid__list(), legacy);
} else {
TTCN_Logger::log_event_str("{ its_aid_list := ");
single_value.field_its__aid__list->log_match(match_value.its__aid__list(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SubjectAttributeContainer::ALT_its__aid__ssp__list:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".its_aid_ssp_list");
single_value.field_its__aid__ssp__list->log_match(match_value.its__aid__ssp__list(), legacy);
} else {
TTCN_Logger::log_event_str("{ its_aid_ssp_list := ");
single_value.field_its__aid__ssp__list->log_match(match_value.its__aid__ssp__list(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case SubjectAttributeContainer::ALT_other__attribute:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".other_attribute");
single_value.field_other__attribute->log_match(match_value.other__attribute(), legacy);
} else {
TTCN_Logger::log_event_str("{ other_attribute := ");
single_value.field_other__attribute->log_match(match_value.other__attribute(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SubjectAttributeContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case SubjectAttributeContainer::ALT_key:
single_value.field_key->encode_text(text_buf);
break;
case SubjectAttributeContainer::ALT_rv:
single_value.field_rv->encode_text(text_buf);
break;
case SubjectAttributeContainer::ALT_assurance__level:
single_value.field_assurance__level->encode_text(text_buf);
break;
case SubjectAttributeContainer::ALT_its__aid__list:
single_value.field_its__aid__list->encode_text(text_buf);
break;
case SubjectAttributeContainer::ALT_its__aid__ssp__list:
single_value.field_its__aid__ssp__list->encode_text(text_buf);
break;
case SubjectAttributeContainer::ALT_other__attribute:
single_value.field_other__attribute->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
}
}

void SubjectAttributeContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = SubjectAttributeContainer::UNBOUND_VALUE;
SubjectAttributeContainer::union_selection_type new_selection = (SubjectAttributeContainer::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case SubjectAttributeContainer::ALT_key:
single_value.field_key = new PublicKey_template;
single_value.field_key->decode_text(text_buf);
break;
case SubjectAttributeContainer::ALT_rv:
single_value.field_rv = new EccPoint_template;
single_value.field_rv->decode_text(text_buf);
break;
case SubjectAttributeContainer::ALT_assurance__level:
single_value.field_assurance__level = new SubjectAssurance_template;
single_value.field_assurance__level->decode_text(text_buf);
break;
case SubjectAttributeContainer::ALT_its__aid__list:
single_value.field_its__aid__list = new IntXs_template;
single_value.field_its__aid__list->decode_text(text_buf);
break;
case SubjectAttributeContainer::ALT_its__aid__ssp__list:
single_value.field_its__aid__ssp__list = new ItsAidSsps_template;
single_value.field_its__aid__ssp__list->decode_text(text_buf);
break;
case SubjectAttributeContainer::ALT_other__attribute:
single_value.field_other__attribute = new OCTETSTRING_template;
single_value.field_other__attribute->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SubjectAttributeContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
}
}

boolean SubjectAttributeContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SubjectAttributeContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SubjectAttributeContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsSecurity_TypesAndValues.SubjectAttributeContainer'");
    }
    if (strcmp("key", param_field) == 0) {
      key().set_param(param);
      return;
    } else if (strcmp("rv", param_field) == 0) {
      rv().set_param(param);
      return;
    } else if (strcmp("assurance_level", param_field) == 0) {
      assurance__level().set_param(param);
      return;
    } else if (strcmp("its_aid_list", param_field) == 0) {
      its__aid__list().set_param(param);
      return;
    } else if (strcmp("its_aid_ssp_list", param_field) == 0) {
      its__aid__ssp__list().set_param(param);
      return;
    } else if (strcmp("other_attribute", param_field) == 0) {
      other__attribute().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsSecurity_TypesAndValues.SubjectAttributeContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SubjectAttributeContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.SubjectAttributeContainer");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "key")) {
      key().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "rv")) {
      rv().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "assurance_level")) {
      assurance__level().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "its_aid_list")) {
      its__aid__list().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "its_aid_ssp_list")) {
      its__aid__ssp__list().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "other_attribute")) {
      other__attribute().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.SubjectAttributeContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SubjectAttributeContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsSecurity_TypesAndValues.SubjectAttributeContainer'");
    }
    if (strcmp("key", param_field) == 0) {
      return key().get_param(param_name);
    } else if (strcmp("rv", param_field) == 0) {
      return rv().get_param(param_name);
    } else if (strcmp("assurance_level", param_field) == 0) {
      return assurance__level().get_param(param_name);
    } else if (strcmp("its_aid_list", param_field) == 0) {
      return its__aid__list().get_param(param_name);
    } else if (strcmp("its_aid_ssp_list", param_field) == 0) {
      return its__aid__ssp__list().get_param(param_name);
    } else if (strcmp("other_attribute", param_field) == 0) {
      return other__attribute().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `SubjectAttributeContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case SubjectAttributeContainer::ALT_key:
      mp_field = single_value.field_key->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("key")));
      break;
    case SubjectAttributeContainer::ALT_rv:
      mp_field = single_value.field_rv->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("rv")));
      break;
    case SubjectAttributeContainer::ALT_assurance__level:
      mp_field = single_value.field_assurance__level->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("assurance_level")));
      break;
    case SubjectAttributeContainer::ALT_its__aid__list:
      mp_field = single_value.field_its__aid__list->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("its_aid_list")));
      break;
    case SubjectAttributeContainer::ALT_its__aid__ssp__list:
      mp_field = single_value.field_its__aid__ssp__list->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("its_aid_ssp_list")));
      break;
    case SubjectAttributeContainer::ALT_other__attribute:
      mp_field = single_value.field_other__attribute->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("other_attribute")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SubjectAttributeContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case SubjectAttributeContainer::ALT_key:
single_value.field_key->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectAttributeContainer");
return;
case SubjectAttributeContainer::ALT_rv:
single_value.field_rv->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectAttributeContainer");
return;
case SubjectAttributeContainer::ALT_assurance__level:
single_value.field_assurance__level->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectAttributeContainer");
return;
case SubjectAttributeContainer::ALT_its__aid__list:
single_value.field_its__aid__list->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectAttributeContainer");
return;
case SubjectAttributeContainer::ALT_its__aid__ssp__list:
single_value.field_its__aid__ssp__list->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectAttributeContainer");
return;
case SubjectAttributeContainer::ALT_other__attribute:
single_value.field_other__attribute->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectAttributeContainer");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsSecurity_TypesAndValues.SubjectAttributeContainer.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectAttributeContainer");
}

SubjectAssurance::SubjectAssurance()
{
  bound_flag = FALSE;
}

SubjectAssurance::SubjectAssurance(const BITSTRING& par_levels,
    const BITSTRING& par_reserved,
    const BITSTRING& par_confidence)
  :   field_levels(par_levels),
  field_reserved(par_reserved),
  field_confidence(par_confidence)
{
  bound_flag = TRUE;
}

SubjectAssurance::SubjectAssurance(const SubjectAssurance& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAssurance.");
bound_flag = TRUE;
if (other_value.levels().is_bound()) field_levels = other_value.levels();
else field_levels.clean_up();
if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
else field_reserved.clean_up();
if (other_value.confidence().is_bound()) field_confidence = other_value.confidence();
else field_confidence.clean_up();
}

void SubjectAssurance::clean_up()
{
field_levels.clean_up();
field_reserved.clean_up();
field_confidence.clean_up();
bound_flag = FALSE;
}

SubjectAssurance& SubjectAssurance::operator=(const SubjectAssurance& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAssurance.");
  bound_flag = TRUE;
  if (other_value.levels().is_bound()) field_levels = other_value.levels();
  else field_levels.clean_up();
  if (other_value.reserved().is_bound()) field_reserved = other_value.reserved();
  else field_reserved.clean_up();
  if (other_value.confidence().is_bound()) field_confidence = other_value.confidence();
  else field_confidence.clean_up();
}
return *this;
}

boolean SubjectAssurance::operator==(const SubjectAssurance& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_levels==other_value.field_levels
  && field_reserved==other_value.field_reserved
  && field_confidence==other_value.field_confidence;
}

boolean SubjectAssurance::is_bound() const
{
if (bound_flag) return TRUE;
if(field_levels.is_bound()) return TRUE;
if(field_reserved.is_bound()) return TRUE;
if(field_confidence.is_bound()) return TRUE;
return FALSE;
}
boolean SubjectAssurance::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_levels.is_value()) return FALSE;
if(!field_reserved.is_value()) return FALSE;
if(!field_confidence.is_value()) return FALSE;
return TRUE;
}
int SubjectAssurance::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.SubjectAssurance");
  return 3;
}

void SubjectAssurance::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ levels := ");
field_levels.log();
TTCN_Logger::log_event_str(", reserved := ");
field_reserved.log();
TTCN_Logger::log_event_str(", confidence := ");
field_confidence.log();
TTCN_Logger::log_event_str(" }");
}

void SubjectAssurance::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.SubjectAssurance'");
    }
    if (strcmp("levels", param_field) == 0) {
      levels().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("confidence", param_field) == 0) {
      confidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SubjectAssurance'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.SubjectAssurance has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) levels().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) confidence().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "levels")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          levels().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "confidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          confidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.SubjectAssurance: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.SubjectAssurance");
  }
}

Module_Param* SubjectAssurance::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.SubjectAssurance'");
    }
    if (strcmp("levels", param_field) == 0) {
      return levels().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("confidence", param_field) == 0) {
      return confidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SubjectAssurance'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_levels = field_levels.get_param(param_name);
  mp_field_levels->set_id(new Module_Param_FieldName(mcopystr("levels")));
  mp->add_elem(mp_field_levels);
  Module_Param* mp_field_reserved = field_reserved.get_param(param_name);
  mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
  mp->add_elem(mp_field_reserved);
  Module_Param* mp_field_confidence = field_confidence.get_param(param_name);
  mp_field_confidence->set_id(new Module_Param_FieldName(mcopystr("confidence")));
  mp->add_elem(mp_field_confidence);
  return mp;
  }

void SubjectAssurance::set_implicit_omit()
{
if (levels().is_bound()) levels().set_implicit_omit();
if (reserved().is_bound()) reserved().set_implicit_omit();
if (confidence().is_bound()) confidence().set_implicit_omit();
}

void SubjectAssurance::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.SubjectAssurance.");
field_levels.encode_text(text_buf);
field_reserved.encode_text(text_buf);
field_confidence.encode_text(text_buf);
}

void SubjectAssurance::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_levels.decode_text(text_buf);
field_reserved.decode_text(text_buf);
field_confidence.decode_text(text_buf);
}

void SubjectAssurance::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SubjectAssurance::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SubjectAssurance::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_levels.RAW_decode(LibCommon__DataStrings::Bit3_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved.RAW_decode(LibCommon__DataStrings::Bit3_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_confidence.RAW_decode(LibCommon__DataStrings::Bit2_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int SubjectAssurance::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__DataStrings::Bit3_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__DataStrings::Bit3_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__DataStrings::Bit2_descr_.raw);
  encoded_length += field_levels.RAW_encode(LibCommon__DataStrings::Bit3_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_reserved.RAW_encode(LibCommon__DataStrings::Bit3_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_confidence.RAW_encode(LibCommon__DataStrings::Bit2_descr_, *myleaf.body.node.nodes[2]);
  return myleaf.length = encoded_length;
}

int SubjectAssurance::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAssurance.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "levels");
    enc_len += field_levels.JSON_encode(LibCommon__DataStrings::Bit3_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved");
    enc_len += field_reserved.JSON_encode(LibCommon__DataStrings::Bit3_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "confidence");
    enc_len += field_confidence.JSON_encode(LibCommon__DataStrings::Bit2_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SubjectAssurance::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (6 == name_len && 0 == strncmp(fld_name, "levels", name_len)) {
         int ret_val = field_levels.JSON_decode(LibCommon__DataStrings::Bit3_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "levels");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "reserved", name_len)) {
         int ret_val = field_reserved.JSON_decode(LibCommon__DataStrings::Bit3_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "confidence", name_len)) {
         int ret_val = field_confidence.JSON_decode(LibCommon__DataStrings::Bit2_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "confidence");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_levels.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "levels");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved");
    return JSON_ERROR_FATAL;
  }
if (!field_confidence.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "confidence");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct SubjectAssurance_template::single_value_struct {
BITSTRING_template field_levels;
BITSTRING_template field_reserved;
BITSTRING_template field_confidence;
};

void SubjectAssurance_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_levels = ANY_VALUE;
single_value->field_reserved = ANY_VALUE;
single_value->field_confidence = ANY_VALUE;
}
}
}

void SubjectAssurance_template::copy_value(const SubjectAssurance& other_value)
{
single_value = new single_value_struct;
if (other_value.levels().is_bound()) {
  single_value->field_levels = other_value.levels();
} else {
  single_value->field_levels.clean_up();
}
if (other_value.reserved().is_bound()) {
  single_value->field_reserved = other_value.reserved();
} else {
  single_value->field_reserved.clean_up();
}
if (other_value.confidence().is_bound()) {
  single_value->field_confidence = other_value.confidence();
} else {
  single_value->field_confidence.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SubjectAssurance_template::copy_template(const SubjectAssurance_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.levels().get_selection()) {
single_value->field_levels = other_value.levels();
} else {
single_value->field_levels.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved().get_selection()) {
single_value->field_reserved = other_value.reserved();
} else {
single_value->field_reserved.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.confidence().get_selection()) {
single_value->field_confidence = other_value.confidence();
} else {
single_value->field_confidence.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SubjectAssurance_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SubjectAssurance.");
break;
}
set_selection(other_value);
}

SubjectAssurance_template::SubjectAssurance_template()
{
}

SubjectAssurance_template::SubjectAssurance_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SubjectAssurance_template::SubjectAssurance_template(const SubjectAssurance& other_value)
{
copy_value(other_value);
}

SubjectAssurance_template::SubjectAssurance_template(const OPTIONAL<SubjectAssurance>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SubjectAssurance&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.SubjectAssurance from an unbound optional field.");
}
}

SubjectAssurance_template::SubjectAssurance_template(const SubjectAssurance_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SubjectAssurance_template::~SubjectAssurance_template()
{
clean_up();
}

SubjectAssurance_template& SubjectAssurance_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SubjectAssurance_template& SubjectAssurance_template::operator=(const SubjectAssurance& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SubjectAssurance_template& SubjectAssurance_template::operator=(const OPTIONAL<SubjectAssurance>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SubjectAssurance&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.SubjectAssurance.");
}
return *this;
}

SubjectAssurance_template& SubjectAssurance_template::operator=(const SubjectAssurance_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SubjectAssurance_template::match(const SubjectAssurance& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.levels().is_bound()) return FALSE;
if(!single_value->field_levels.match(other_value.levels(), legacy))return FALSE;
if(!other_value.reserved().is_bound()) return FALSE;
if(!single_value->field_reserved.match(other_value.reserved(), legacy))return FALSE;
if(!other_value.confidence().is_bound()) return FALSE;
if(!single_value->field_confidence.match(other_value.confidence(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SubjectAssurance.");
}
return FALSE;
}

boolean SubjectAssurance_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_levels.is_bound()) return TRUE;
if (single_value->field_reserved.is_bound()) return TRUE;
if (single_value->field_confidence.is_bound()) return TRUE;
return FALSE;
}

boolean SubjectAssurance_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_levels.is_value()) return FALSE;
if (!single_value->field_reserved.is_value()) return FALSE;
if (!single_value->field_confidence.is_value()) return FALSE;
return TRUE;
}

void SubjectAssurance_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SubjectAssurance SubjectAssurance_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.SubjectAssurance.");
SubjectAssurance ret_val;
if (single_value->field_levels.is_bound()) {
ret_val.levels() = single_value->field_levels.valueof();
}
if (single_value->field_reserved.is_bound()) {
ret_val.reserved() = single_value->field_reserved.valueof();
}
if (single_value->field_confidence.is_bound()) {
ret_val.confidence() = single_value->field_confidence.valueof();
}
return ret_val;
}

void SubjectAssurance_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.SubjectAssurance.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SubjectAssurance_template[list_length];
}

SubjectAssurance_template& SubjectAssurance_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.SubjectAssurance.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.SubjectAssurance.");
return value_list.list_value[list_index];
}

BITSTRING_template& SubjectAssurance_template::levels()
{
set_specific();
return single_value->field_levels;
}

const BITSTRING_template& SubjectAssurance_template::levels() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field levels of a non-specific template of type @LibItsSecurity_TypesAndValues.SubjectAssurance.");
return single_value->field_levels;
}

BITSTRING_template& SubjectAssurance_template::reserved()
{
set_specific();
return single_value->field_reserved;
}

const BITSTRING_template& SubjectAssurance_template::reserved() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved of a non-specific template of type @LibItsSecurity_TypesAndValues.SubjectAssurance.");
return single_value->field_reserved;
}

BITSTRING_template& SubjectAssurance_template::confidence()
{
set_specific();
return single_value->field_confidence;
}

const BITSTRING_template& SubjectAssurance_template::confidence() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field confidence of a non-specific template of type @LibItsSecurity_TypesAndValues.SubjectAssurance.");
return single_value->field_confidence;
}

int SubjectAssurance_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAssurance which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAssurance containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAssurance containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAssurance containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAssurance containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAssurance containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SubjectAssurance.");
  }
  return 0;
}

void SubjectAssurance_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ levels := ");
single_value->field_levels.log();
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log();
TTCN_Logger::log_event_str(", confidence := ");
single_value->field_confidence.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SubjectAssurance_template::log_match(const SubjectAssurance& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_levels.match(match_value.levels(), legacy)){
TTCN_Logger::log_logmatch_info(".levels");
single_value->field_levels.log_match(match_value.levels(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved.match(match_value.reserved(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_confidence.match(match_value.confidence(), legacy)){
TTCN_Logger::log_logmatch_info(".confidence");
single_value->field_confidence.log_match(match_value.confidence(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ levels := ");
single_value->field_levels.log_match(match_value.levels(), legacy);
TTCN_Logger::log_event_str(", reserved := ");
single_value->field_reserved.log_match(match_value.reserved(), legacy);
TTCN_Logger::log_event_str(", confidence := ");
single_value->field_confidence.log_match(match_value.confidence(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SubjectAssurance_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_levels.encode_text(text_buf);
single_value->field_reserved.encode_text(text_buf);
single_value->field_confidence.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SubjectAssurance.");
}
}

void SubjectAssurance_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_levels.decode_text(text_buf);
single_value->field_reserved.decode_text(text_buf);
single_value->field_confidence.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SubjectAssurance_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.SubjectAssurance.");
}
}

void SubjectAssurance_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.SubjectAssurance'");
    }
    if (strcmp("levels", param_field) == 0) {
      levels().set_param(param);
      return;
    } else if (strcmp("reserved", param_field) == 0) {
      reserved().set_param(param);
      return;
    } else if (strcmp("confidence", param_field) == 0) {
      confidence().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.SubjectAssurance'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SubjectAssurance_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.SubjectAssurance has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) levels().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) reserved().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) confidence().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "levels")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          levels().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "confidence")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          confidence().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.SubjectAssurance: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.SubjectAssurance");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SubjectAssurance_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.SubjectAssurance'");
    }
    if (strcmp("levels", param_field) == 0) {
      return levels().get_param(param_name);
    } else if (strcmp("reserved", param_field) == 0) {
      return reserved().get_param(param_name);
    } else if (strcmp("confidence", param_field) == 0) {
      return confidence().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SubjectAssurance'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_levels = single_value->field_levels.get_param(param_name);
    mp_field_levels->set_id(new Module_Param_FieldName(mcopystr("levels")));
    mp->add_elem(mp_field_levels);
    Module_Param* mp_field_reserved = single_value->field_reserved.get_param(param_name);
    mp_field_reserved->set_id(new Module_Param_FieldName(mcopystr("reserved")));
    mp->add_elem(mp_field_reserved);
    Module_Param* mp_field_confidence = single_value->field_confidence.get_param(param_name);
    mp_field_confidence->set_id(new Module_Param_FieldName(mcopystr("confidence")));
    mp->add_elem(mp_field_confidence);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SubjectAssurance_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_levels.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectAssurance");
single_value->field_reserved.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectAssurance");
single_value->field_confidence.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectAssurance");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectAssurance");
}

boolean SubjectAssurance_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SubjectAssurance_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const ItsAidSsp ItsAidSsps::UNBOUND_ELEM;
boolean ItsAidSsps::compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index)
{
if (((const ItsAidSsps*)left_ptr)->val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
if (((const ItsAidSsps*)right_ptr)->val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
if (((const ItsAidSsps*)left_ptr)->val_ptr->value_elements[left_index] != NULL){
if (((const ItsAidSsps*)right_ptr)->val_ptr->value_elements[right_index] != NULL){
return *((const ItsAidSsps*)left_ptr)->val_ptr->value_elements[left_index] == *((const ItsAidSsps*)right_ptr)->val_ptr->value_elements[right_index];
} else return FALSE;
} else {
return ((const ItsAidSsps*)right_ptr)->val_ptr->value_elements[right_index] == NULL;
}
}

ItsAidSsps::ItsAidSsps()
{
val_ptr = NULL;
}

ItsAidSsps::ItsAidSsps(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

ItsAidSsps::ItsAidSsps(const ItsAidSsps& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

ItsAidSsps::~ItsAidSsps()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void ItsAidSsps::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

ItsAidSsps& ItsAidSsps::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

ItsAidSsps& ItsAidSsps::operator=(const ItsAidSsps& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean ItsAidSsps::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
return val_ptr->n_elements == 0 ;
}

boolean ItsAidSsps::operator==(const ItsAidSsps& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
if (val_ptr == other_value.val_ptr) return TRUE;
return compare_set_of(this, val_ptr->n_elements, &other_value, (other_value.val_ptr)->n_elements, compare_function);
}

ItsAidSsp& ItsAidSsps::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.ItsAidSsps using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (ItsAidSsp**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new ItsAidSsp(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new ItsAidSsp;
}
return *val_ptr->value_elements[index_value];
}

ItsAidSsp& ItsAidSsps::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
return (*this)[(int)index_value];
}

const ItsAidSsp& ItsAidSsps::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.ItsAidSsps using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsSecurity_TypesAndValues.ItsAidSsps: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const ItsAidSsp& ItsAidSsps::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
return (*this)[(int)index_value];
}

ItsAidSsps ItsAidSsps::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

ItsAidSsps ItsAidSsps::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

ItsAidSsps ItsAidSsps::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

ItsAidSsps ItsAidSsps::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
ItsAidSsps ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new ItsAidSsp(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

ItsAidSsps ItsAidSsps::operator+(const ItsAidSsps& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsSecurity_TypesAndValues.ItsAidSsps concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
ItsAidSsps ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new ItsAidSsp(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new ItsAidSsp(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

ItsAidSsps ItsAidSsps::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsSecurity_TypesAndValues.ItsAidSsps","element");
ItsAidSsps ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new ItsAidSsp(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

ItsAidSsps ItsAidSsps::replace(int index, int len, const ItsAidSsps& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsSecurity_TypesAndValues.ItsAidSsps","element");
ItsAidSsps ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new ItsAidSsp(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new ItsAidSsp(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new ItsAidSsp(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

ItsAidSsps ItsAidSsps::replace(int index, int len, const ItsAidSsps_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void ItsAidSsps::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (ItsAidSsp**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new ItsAidSsp(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (ItsAidSsp**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsSecurity_TypesAndValues.ItsAidSsps: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (ItsAidSsp**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean ItsAidSsps::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int ItsAidSsps::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
return val_ptr->n_elements;
}

int ItsAidSsps::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void ItsAidSsps::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void ItsAidSsps::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set of type `@LibItsSecurity_TypesAndValues.ItsAidSsps'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "set of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.ItsAidSsps");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.ItsAidSsps");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* ItsAidSsps::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of type `@LibItsSecurity_TypesAndValues.ItsAidSsps'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void ItsAidSsps::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void ItsAidSsps::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void ItsAidSsps::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
val_ptr->value_elements = (ItsAidSsp**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new ItsAidSsp;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void ItsAidSsps::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ItsAidSsps::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ItsAidSsps::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int ItsAidSsps::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

int ItsAidSsps::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int ItsAidSsps::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    ItsAidSsp* val = new ItsAidSsp;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (ItsAidSsp**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void ItsAidSsps_template::copy_value(const ItsAidSsps& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (ItsAidSsp_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new ItsAidSsp_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new ItsAidSsp_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void ItsAidSsps_template::copy_template(const ItsAidSsps_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (ItsAidSsp_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new ItsAidSsp_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new ItsAidSsp_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ItsAidSsps_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = other_value.value_set.n_items;
value_set.set_items = new ItsAidSsp_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count] = other_value.value_set.set_items[set_count];
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
break;
}
set_selection(other_value);
}

boolean ItsAidSsps_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const ItsAidSsps_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const ItsAidSsps*)value_ptr)[value_index], legacy);
else return ((const ItsAidSsps_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

boolean ItsAidSsps_template::match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const ItsAidSsps_template*)template_ptr)->value_set.set_items[template_index].match((*(const ItsAidSsps*)value_ptr)[value_index], legacy);
else return ((const ItsAidSsps_template*)template_ptr)->value_set.set_items[template_index].is_any_or_omit();
}

void ItsAidSsps_template::log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy)
{
if (value_ptr != NULL && template_ptr != NULL)((const ItsAidSsps_template*)template_ptr)->single_value.value_elements[index_template]->log_match((*(const ItsAidSsps*)value_ptr)[index_value], legacy);
else if (value_ptr != NULL) (*(const ItsAidSsps*)value_ptr)[index_value].log();
else if (template_ptr != NULL) ((const ItsAidSsps_template*)template_ptr)->single_value.value_elements[index_template]->log();
}

ItsAidSsps_template::ItsAidSsps_template()
{
}

ItsAidSsps_template::ItsAidSsps_template(template_sel other_value)
 : Restricted_Length_Template(other_value)
{
check_single_selection(other_value);
}

ItsAidSsps_template::ItsAidSsps_template(null_type)
 : Restricted_Length_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

ItsAidSsps_template::ItsAidSsps_template(const ItsAidSsps& other_value)
{
copy_value(other_value);
}

ItsAidSsps_template::ItsAidSsps_template(const OPTIONAL<ItsAidSsps>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ItsAidSsps&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps from an unbound optional field.");
}
}

ItsAidSsps_template::ItsAidSsps_template(const ItsAidSsps_template& other_value)
 : Restricted_Length_Template()
{
copy_template(other_value);
}

ItsAidSsps_template::~ItsAidSsps_template()
{
clean_up();
}

void ItsAidSsps_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
delete [] value_set.set_items;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ItsAidSsps_template& ItsAidSsps_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ItsAidSsps_template& ItsAidSsps_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

ItsAidSsps_template& ItsAidSsps_template::operator=(const ItsAidSsps& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ItsAidSsps_template& ItsAidSsps_template::operator=(const OPTIONAL<ItsAidSsps>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ItsAidSsps&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
}
return *this;
}

ItsAidSsps_template& ItsAidSsps_template::operator=(const ItsAidSsps_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

ItsAidSsp_template& ItsAidSsps_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.ItsAidSsps using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
    break;
}
return *single_value.value_elements[index_value];
}

ItsAidSsp_template& ItsAidSsps_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
return (*this)[(int)index_value];
}

const ItsAidSsp_template& ItsAidSsps_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.ItsAidSsps using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const ItsAidSsp_template& ItsAidSsps_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
return (*this)[(int)index_value];
}

void ItsAidSsps_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (ItsAidSsp_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new ItsAidSsp_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new ItsAidSsp_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (ItsAidSsp_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int ItsAidSsps_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int ItsAidSsps_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case SUPERSET_MATCH:
case SUBSET_MATCH: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = value_set.n_items;
  if (!is_size) { while (elem_count>0 && !value_set.set_items[elem_count-1].is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (value_set.set_items[i].get_selection())
    {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
  if (template_selection==SUPERSET_MATCH) {
    has_any_or_none = TRUE;
   } else {
    int max_size = min_size;
    min_size = 0;
    if (!has_any_or_none) { // [0,max_size]
      switch (length_restriction_type) {
      case NO_LENGTH_RESTRICTION:
        if (max_size==0) return 0;
        TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps with no exact size.", op_name);
      case SINGLE_LENGTH_RESTRICTION:
        if (length_restriction.single_length<=max_size)
          return length_restriction.single_length;
        TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.ItsAidSsps. The maximum size (%d) contradicts the length restriction (%d).", op_name, max_size, length_restriction.single_length);
      case RANGE_LENGTH_RESTRICTION:
        if (max_size==length_restriction.range_length.min_length) {
          return max_size;
        } else if (max_size>length_restriction.range_length.min_length){
          TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps with no exact size.", op_name);
        } else
          TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.ItsAidSsps. Maximum size (%d) contradicts the length restriction (%d..%d).", op_name, max_size, length_restriction.range_length.min_length, length_restriction.range_length.max_length);
      default:
        TTCN_error("Internal error: Template has invalid length restriction type.");
      }
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ItsAidSsps.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsSecurity_TypesAndValues.ItsAidSsps");
}

boolean ItsAidSsps_template::match(const ItsAidSsps& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_set_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case SUPERSET_MATCH:
case SUBSET_MATCH:
return match_set_of(&other_value, value_length, this, value_set.n_items, match_function_set, legacy);
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
}
return FALSE;
}

boolean ItsAidSsps_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

ItsAidSsps ItsAidSsps_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
ItsAidSsps ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

ItsAidSsps ItsAidSsps_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

ItsAidSsps ItsAidSsps_template::replace(int index, int len, const ItsAidSsps_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

ItsAidSsps ItsAidSsps_template::replace(int index, int len, const ItsAidSsps& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void ItsAidSsps_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new ItsAidSsps_template[list_length];
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = list_length;
value_set.set_items = new ItsAidSsp_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
}
set_selection(template_type);
}

ItsAidSsps_template& ItsAidSsps_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
return value_list.list_value[list_index];
}

ItsAidSsp_template& ItsAidSsps_template::set_item(unsigned int set_index)
{
if (template_selection != SUPERSET_MATCH && template_selection != SUBSET_MATCH) TTCN_error("Internal error: Accessing a set element of a non-set template of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
if (set_index >= value_set.n_items) TTCN_error("Internal error: Index overflow in a set template of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
return value_set.set_items[set_index];
}

void ItsAidSsps_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log();
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
TTCN_Logger::log_event("%s(", template_selection == SUPERSET_MATCH ? "superset" : "subset");
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++) {
if (set_count > 0) TTCN_Logger::log_event_str(", ");
value_set.set_items[set_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void ItsAidSsps_template::log_match(const ItsAidSsps& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (template_selection == SPECIFIC_VALUE)
  log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
else{
if(previous_size != 0){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::set_logmatch_buffer_len(previous_size);
TTCN_Logger::log_event_str(":=");
}
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
return;
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else {
TTCN_Logger::log_event_str(" unmatched");
if (template_selection == SPECIFIC_VALUE) log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
}
}

void ItsAidSsps_template::encode_text(Text_Buf& text_buf) const
{
encode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
text_buf.push_int(value_set.n_items);
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
}
}

void ItsAidSsps_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
single_value.value_elements = (ItsAidSsp_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new ItsAidSsp_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ItsAidSsps_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = text_buf.pull_int().get_val();
value_set.set_items = new ItsAidSsp_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
}
}

boolean ItsAidSsps_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ItsAidSsps_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ItsAidSsps_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set template type `@LibItsSecurity_TypesAndValues.ItsAidSsps'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "set of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ItsAidSsps_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    set_size(mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      if (mp->get_elem(p_i)->get_type()!=Module_Param::MP_NotUsed) {
        (*this)[p_i].set_param(*mp->get_elem(p_i));
      }
    }
    break;
  case Module_Param::MP_Superset_Template:
  case Module_Param::MP_Subset_Template:
    set_type(mp->get_type()==Module_Param::MP_Superset_Template ? SUPERSET_MATCH : SUBSET_MATCH, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      set_item(p_i).set_param(*mp->get_elem(p_i));
    }
    break;
  default:
    param.type_error("set of template", "@LibItsSecurity_TypesAndValues.ItsAidSsps");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* ItsAidSsps_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of template type `@LibItsSecurity_TypesAndValues.ItsAidSsps'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void ItsAidSsps_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ItsAidSsps");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.ItsAidSsps");
}

ServiceSpecificPermissions::ServiceSpecificPermissions()
{
  bound_flag = FALSE;
}

ServiceSpecificPermissions::ServiceSpecificPermissions(const OCTETSTRING& par_version,
    const OPTIONAL<ServiceSpecificPermissionsContainer>& par_sspContainer)
  :   field_version(par_version),
  field_sspContainer(par_sspContainer)
{
  bound_flag = TRUE;
}

ServiceSpecificPermissions::ServiceSpecificPermissions(const ServiceSpecificPermissions& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions.");
bound_flag = TRUE;
if (other_value.version().is_bound()) field_version = other_value.version();
else field_version.clean_up();
if (other_value.sspContainer().is_bound()) field_sspContainer = other_value.sspContainer();
else field_sspContainer.clean_up();
}

void ServiceSpecificPermissions::clean_up()
{
field_version.clean_up();
field_sspContainer.clean_up();
bound_flag = FALSE;
}

ServiceSpecificPermissions& ServiceSpecificPermissions::operator=(const ServiceSpecificPermissions& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions.");
  bound_flag = TRUE;
  if (other_value.version().is_bound()) field_version = other_value.version();
  else field_version.clean_up();
  if (other_value.sspContainer().is_bound()) field_sspContainer = other_value.sspContainer();
  else field_sspContainer.clean_up();
}
return *this;
}

boolean ServiceSpecificPermissions::operator==(const ServiceSpecificPermissions& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_version==other_value.field_version
  && field_sspContainer==other_value.field_sspContainer;
}

boolean ServiceSpecificPermissions::is_bound() const
{
if (bound_flag) return TRUE;
if(field_version.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_sspContainer.get_selection() || field_sspContainer.is_bound()) return TRUE;
return FALSE;
}
boolean ServiceSpecificPermissions::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_version.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_sspContainer.get_selection() && !field_sspContainer.is_value()) return FALSE;
return TRUE;
}
int ServiceSpecificPermissions::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions");
  int ret_val = 1;
  if (field_sspContainer.ispresent()) ret_val++;
  return ret_val;
}

void ServiceSpecificPermissions::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ version := ");
field_version.log();
TTCN_Logger::log_event_str(", sspContainer := ");
field_sspContainer.log();
TTCN_Logger::log_event_str(" }");
}

void ServiceSpecificPermissions::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.ServiceSpecificPermissions'");
    }
    if (strcmp("version", param_field) == 0) {
      version().set_param(param);
      return;
    } else if (strcmp("sspContainer", param_field) == 0) {
      sspContainer().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ServiceSpecificPermissions'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sspContainer().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sspContainer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sspContainer().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.ServiceSpecificPermissions");
  }
}

Module_Param* ServiceSpecificPermissions::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.ServiceSpecificPermissions'");
    }
    if (strcmp("version", param_field) == 0) {
      return version().get_param(param_name);
    } else if (strcmp("sspContainer", param_field) == 0) {
      return sspContainer().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ServiceSpecificPermissions'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_version = field_version.get_param(param_name);
  mp_field_version->set_id(new Module_Param_FieldName(mcopystr("version")));
  mp->add_elem(mp_field_version);
  Module_Param* mp_field_sspContainer = field_sspContainer.get_param(param_name);
  mp_field_sspContainer->set_id(new Module_Param_FieldName(mcopystr("sspContainer")));
  mp->add_elem(mp_field_sspContainer);
  return mp;
  }

void ServiceSpecificPermissions::set_implicit_omit()
{
if (version().is_bound()) version().set_implicit_omit();
if (!sspContainer().is_bound()) sspContainer() = OMIT_VALUE;
else sspContainer().set_implicit_omit();
}

void ServiceSpecificPermissions::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions.");
field_version.encode_text(text_buf);
field_sspContainer.encode_text(text_buf);
}

void ServiceSpecificPermissions::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_version.decode_text(text_buf);
field_sspContainer.decode_text(text_buf);
}

void ServiceSpecificPermissions::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ServiceSpecificPermissions::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ServiceSpecificPermissions::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_version.RAW_decode(LibCommon__DataStrings::Oct1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_sspContainer().RAW_decode(ServiceSpecificPermissionsContainer_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_sspContainer = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_sspContainer=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ServiceSpecificPermissions::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__DataStrings::Oct1_descr_.raw);
  if (field_sspContainer.ispresent()) {
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, ServiceSpecificPermissionsContainer_descr_.raw);
  }
  else myleaf.body.node.nodes[1] = NULL;
  encoded_length += field_version.RAW_encode(LibCommon__DataStrings::Oct1_descr_, *myleaf.body.node.nodes[0]);
  if (field_sspContainer.ispresent()) {
  encoded_length += field_sspContainer().RAW_encode(ServiceSpecificPermissionsContainer_descr_, *myleaf.body.node.nodes[1]);
  }
  return myleaf.length = encoded_length;
}

int ServiceSpecificPermissions::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "version");
    enc_len += field_version.JSON_encode(LibCommon__DataStrings::Oct1_descr_, p_tok);
  }

  if (field_sspContainer.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "sspContainer");
    enc_len += field_sspContainer.JSON_encode(ServiceSpecificPermissionsContainer_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ServiceSpecificPermissions::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (7 == name_len && 0 == strncmp(fld_name, "version", name_len)) {
         int ret_val = field_version.JSON_decode(LibCommon__DataStrings::Oct1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "version");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "sspContainer", name_len)) {
         int ret_val = field_sspContainer.JSON_decode(ServiceSpecificPermissionsContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "sspContainer");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_version.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "version");
    return JSON_ERROR_FATAL;
  }
if (!field_sspContainer.is_bound()) {
    field_sspContainer = OMIT_VALUE;
  }

  return dec_len;
}

struct ServiceSpecificPermissions_template::single_value_struct {
OCTETSTRING_template field_version;
ServiceSpecificPermissionsContainer_template field_sspContainer;
};

void ServiceSpecificPermissions_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_version = ANY_VALUE;
single_value->field_sspContainer = ANY_OR_OMIT;
}
}
}

void ServiceSpecificPermissions_template::copy_value(const ServiceSpecificPermissions& other_value)
{
single_value = new single_value_struct;
if (other_value.version().is_bound()) {
  single_value->field_version = other_value.version();
} else {
  single_value->field_version.clean_up();
}
if (other_value.sspContainer().is_bound()) {
  if (other_value.sspContainer().ispresent()) single_value->field_sspContainer = other_value.sspContainer()();
  else single_value->field_sspContainer = OMIT_VALUE;
} else {
  single_value->field_sspContainer.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ServiceSpecificPermissions_template::copy_template(const ServiceSpecificPermissions_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.version().get_selection()) {
single_value->field_version = other_value.version();
} else {
single_value->field_version.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.sspContainer().get_selection()) {
single_value->field_sspContainer = other_value.sspContainer();
} else {
single_value->field_sspContainer.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ServiceSpecificPermissions_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions.");
break;
}
set_selection(other_value);
}

ServiceSpecificPermissions_template::ServiceSpecificPermissions_template()
{
}

ServiceSpecificPermissions_template::ServiceSpecificPermissions_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ServiceSpecificPermissions_template::ServiceSpecificPermissions_template(const ServiceSpecificPermissions& other_value)
{
copy_value(other_value);
}

ServiceSpecificPermissions_template::ServiceSpecificPermissions_template(const OPTIONAL<ServiceSpecificPermissions>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ServiceSpecificPermissions&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions from an unbound optional field.");
}
}

ServiceSpecificPermissions_template::ServiceSpecificPermissions_template(const ServiceSpecificPermissions_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ServiceSpecificPermissions_template::~ServiceSpecificPermissions_template()
{
clean_up();
}

ServiceSpecificPermissions_template& ServiceSpecificPermissions_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ServiceSpecificPermissions_template& ServiceSpecificPermissions_template::operator=(const ServiceSpecificPermissions& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ServiceSpecificPermissions_template& ServiceSpecificPermissions_template::operator=(const OPTIONAL<ServiceSpecificPermissions>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ServiceSpecificPermissions&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions.");
}
return *this;
}

ServiceSpecificPermissions_template& ServiceSpecificPermissions_template::operator=(const ServiceSpecificPermissions_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ServiceSpecificPermissions_template::match(const ServiceSpecificPermissions& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.version().is_bound()) return FALSE;
if(!single_value->field_version.match(other_value.version(), legacy))return FALSE;
if(!other_value.sspContainer().is_bound()) return FALSE;
if((other_value.sspContainer().ispresent() ? !single_value->field_sspContainer.match((const ServiceSpecificPermissionsContainer&)other_value.sspContainer(), legacy) : !single_value->field_sspContainer.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions.");
}
return FALSE;
}

boolean ServiceSpecificPermissions_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_version.is_bound()) return TRUE;
if (single_value->field_sspContainer.is_omit() || single_value->field_sspContainer.is_bound()) return TRUE;
return FALSE;
}

boolean ServiceSpecificPermissions_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_version.is_value()) return FALSE;
if (!single_value->field_sspContainer.is_omit() && !single_value->field_sspContainer.is_value()) return FALSE;
return TRUE;
}

void ServiceSpecificPermissions_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ServiceSpecificPermissions ServiceSpecificPermissions_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions.");
ServiceSpecificPermissions ret_val;
if (single_value->field_version.is_bound()) {
ret_val.version() = single_value->field_version.valueof();
}
if (single_value->field_sspContainer.is_omit()) ret_val.sspContainer() = OMIT_VALUE;
else if (single_value->field_sspContainer.is_bound()) {
ret_val.sspContainer() = single_value->field_sspContainer.valueof();
}
return ret_val;
}

void ServiceSpecificPermissions_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ServiceSpecificPermissions_template[list_length];
}

ServiceSpecificPermissions_template& ServiceSpecificPermissions_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions.");
return value_list.list_value[list_index];
}

OCTETSTRING_template& ServiceSpecificPermissions_template::version()
{
set_specific();
return single_value->field_version;
}

const OCTETSTRING_template& ServiceSpecificPermissions_template::version() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field version of a non-specific template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions.");
return single_value->field_version;
}

ServiceSpecificPermissionsContainer_template& ServiceSpecificPermissions_template::sspContainer()
{
set_specific();
return single_value->field_sspContainer;
}

const ServiceSpecificPermissionsContainer_template& ServiceSpecificPermissions_template::sspContainer() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field sspContainer of a non-specific template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions.");
return single_value->field_sspContainer;
}

int ServiceSpecificPermissions_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_sspContainer.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions.");
  }
  return 0;
}

void ServiceSpecificPermissions_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log();
TTCN_Logger::log_event_str(", sspContainer := ");
single_value->field_sspContainer.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ServiceSpecificPermissions_template::log_match(const ServiceSpecificPermissions& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_version.match(match_value.version(), legacy)){
TTCN_Logger::log_logmatch_info(".version");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.sspContainer().ispresent()){
if(!single_value->field_sspContainer.match(match_value.sspContainer(), legacy)){
TTCN_Logger::log_logmatch_info(".sspContainer");
single_value->field_sspContainer.log_match(match_value.sspContainer(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_sspContainer.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".sspContainer := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_sspContainer.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::log_event_str(", sspContainer := ");
if (match_value.sspContainer().ispresent()) single_value->field_sspContainer.log_match(match_value.sspContainer(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_sspContainer.log();
if (single_value->field_sspContainer.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ServiceSpecificPermissions_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_version.encode_text(text_buf);
single_value->field_sspContainer.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions.");
}
}

void ServiceSpecificPermissions_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_version.decode_text(text_buf);
single_value->field_sspContainer.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ServiceSpecificPermissions_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions.");
}
}

void ServiceSpecificPermissions_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.ServiceSpecificPermissions'");
    }
    if (strcmp("version", param_field) == 0) {
      version().set_param(param);
      return;
    } else if (strcmp("sspContainer", param_field) == 0) {
      sspContainer().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.ServiceSpecificPermissions'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ServiceSpecificPermissions_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) sspContainer().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "sspContainer")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          sspContainer().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissions: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.ServiceSpecificPermissions");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ServiceSpecificPermissions_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.ServiceSpecificPermissions'");
    }
    if (strcmp("version", param_field) == 0) {
      return version().get_param(param_name);
    } else if (strcmp("sspContainer", param_field) == 0) {
      return sspContainer().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ServiceSpecificPermissions'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_version = single_value->field_version.get_param(param_name);
    mp_field_version->set_id(new Module_Param_FieldName(mcopystr("version")));
    mp->add_elem(mp_field_version);
    Module_Param* mp_field_sspContainer = single_value->field_sspContainer.get_param(param_name);
    mp_field_sspContainer->set_id(new Module_Param_FieldName(mcopystr("sspContainer")));
    mp->add_elem(mp_field_sspContainer);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ServiceSpecificPermissions_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_version.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ServiceSpecificPermissions");
single_value->field_sspContainer.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ServiceSpecificPermissions");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.ServiceSpecificPermissions");
}

boolean ServiceSpecificPermissions_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ServiceSpecificPermissions_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ServiceSpecificPermissionsContainer::copy_value(const ServiceSpecificPermissionsContainer& other_value)
{
switch (other_value.union_selection) {
case ALT_sspCAM:
field_sspCAM = new SspCAM(*other_value.field_sspCAM);
break;
case ALT_sspDENM:
field_sspDENM = new SspDENM(*other_value.field_sspDENM);
break;
case ALT_opaque:
field_opaque = new OCTETSTRING(*other_value.field_opaque);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
}
union_selection = other_value.union_selection;
}

ServiceSpecificPermissionsContainer::ServiceSpecificPermissionsContainer()
{
union_selection = UNBOUND_VALUE;
}

ServiceSpecificPermissionsContainer::ServiceSpecificPermissionsContainer(const ServiceSpecificPermissionsContainer& other_value)
: Base_Type(){
copy_value(other_value);
}

ServiceSpecificPermissionsContainer::~ServiceSpecificPermissionsContainer()
{
clean_up();
}

ServiceSpecificPermissionsContainer& ServiceSpecificPermissionsContainer::operator=(const ServiceSpecificPermissionsContainer& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean ServiceSpecificPermissionsContainer::operator==(const ServiceSpecificPermissionsContainer& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_sspCAM:
return *field_sspCAM == *other_value.field_sspCAM;
case ALT_sspDENM:
return *field_sspDENM == *other_value.field_sspDENM;
case ALT_opaque:
return *field_opaque == *other_value.field_opaque;
default:
return FALSE;
}
}

SspCAM& ServiceSpecificPermissionsContainer::sspCAM()
{
if (union_selection != ALT_sspCAM) {
clean_up();
field_sspCAM = new SspCAM;
union_selection = ALT_sspCAM;
}
return *field_sspCAM;
}

const SspCAM& ServiceSpecificPermissionsContainer::sspCAM() const
{
if (union_selection != ALT_sspCAM) TTCN_error("Using non-selected field sspCAM in a value of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
return *field_sspCAM;
}

SspDENM& ServiceSpecificPermissionsContainer::sspDENM()
{
if (union_selection != ALT_sspDENM) {
clean_up();
field_sspDENM = new SspDENM;
union_selection = ALT_sspDENM;
}
return *field_sspDENM;
}

const SspDENM& ServiceSpecificPermissionsContainer::sspDENM() const
{
if (union_selection != ALT_sspDENM) TTCN_error("Using non-selected field sspDENM in a value of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
return *field_sspDENM;
}

OCTETSTRING& ServiceSpecificPermissionsContainer::opaque()
{
if (union_selection != ALT_opaque) {
clean_up();
field_opaque = new OCTETSTRING;
union_selection = ALT_opaque;
}
return *field_opaque;
}

const OCTETSTRING& ServiceSpecificPermissionsContainer::opaque() const
{
if (union_selection != ALT_opaque) TTCN_error("Using non-selected field opaque in a value of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
return *field_opaque;
}

boolean ServiceSpecificPermissionsContainer::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
return union_selection == checked_selection;
}

boolean ServiceSpecificPermissionsContainer::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean ServiceSpecificPermissionsContainer::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_sspCAM: return field_sspCAM->is_value();
case ALT_sspDENM: return field_sspDENM->is_value();
case ALT_opaque: return field_opaque->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void ServiceSpecificPermissionsContainer::clean_up()
{
switch (union_selection) {
case ALT_sspCAM:
  delete field_sspCAM;
  break;
case ALT_sspDENM:
  delete field_sspDENM;
  break;
case ALT_opaque:
  delete field_opaque;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void ServiceSpecificPermissionsContainer::log() const
{
switch (union_selection) {
case ALT_sspCAM:
TTCN_Logger::log_event_str("{ sspCAM := ");
field_sspCAM->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_sspDENM:
TTCN_Logger::log_event_str("{ sspDENM := ");
field_sspDENM->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_opaque:
TTCN_Logger::log_event_str("{ opaque := ");
field_opaque->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void ServiceSpecificPermissionsContainer::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer'");
    }
    if (strcmp("sspCAM", param_field) == 0) {
      sspCAM().set_param(param);
      return;
    } else if (strcmp("sspDENM", param_field) == 0) {
      sspDENM().set_param(param);
      return;
    } else if (strcmp("opaque", param_field) == 0) {
      opaque().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "sspCAM")) {
    sspCAM().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "sspDENM")) {
    sspDENM().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "opaque")) {
    opaque().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.", mp_last->get_id()->get_name());
}

Module_Param* ServiceSpecificPermissionsContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer'");
    }
    if (strcmp("sspCAM", param_field) == 0) {
      return sspCAM().get_param(param_name);
    } else if (strcmp("sspDENM", param_field) == 0) {
      return sspDENM().get_param(param_name);
    } else if (strcmp("opaque", param_field) == 0) {
      return opaque().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `ServiceSpecificPermissionsContainer'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_sspCAM:
    mp_field = field_sspCAM->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("sspCAM")));
    break;
  case ALT_sspDENM:
    mp_field = field_sspDENM->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("sspDENM")));
    break;
  case ALT_opaque:
    mp_field = field_opaque->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("opaque")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void ServiceSpecificPermissionsContainer::set_implicit_omit()
{
switch (union_selection) {
case ALT_sspCAM:
field_sspCAM->set_implicit_omit(); break;
case ALT_sspDENM:
field_sspDENM->set_implicit_omit(); break;
case ALT_opaque:
field_opaque->set_implicit_omit(); break;
default: break;
}
}

void ServiceSpecificPermissionsContainer::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_sspCAM:
field_sspCAM->encode_text(text_buf);
break;
case ALT_sspDENM:
field_sspDENM->encode_text(text_buf);
break;
case ALT_opaque:
field_opaque->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
}
}

void ServiceSpecificPermissionsContainer::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_sspCAM:
sspCAM().decode_text(text_buf);
break;
case ALT_sspDENM:
sspDENM().decode_text(text_buf);
break;
case ALT_opaque:
opaque().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
}
}

void ServiceSpecificPermissionsContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ServiceSpecificPermissionsContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ServiceSpecificPermissionsContainer::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = sspCAM().RAW_decode(SspCAM_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = sspDENM().RAW_decode(SspDENM_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 2:
      decoded_length = opaque().RAW_decode(LibCommon__DataStrings::Oct0to30_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = sspCAM().RAW_decode(SspCAM_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = sspDENM().RAW_decode(SspDENM_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = opaque().RAW_decode(LibCommon__DataStrings::Oct0to30_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int ServiceSpecificPermissionsContainer::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 3;  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  memset(myleaf.body.node.nodes, 0, 3 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_sspCAM:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, SspCAM_descr_.raw);
    encoded_length = field_sspCAM->RAW_encode(SspCAM_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &SspCAM_descr_;
    break;
  case ALT_sspDENM:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, SspDENM_descr_.raw);
    encoded_length = field_sspDENM->RAW_encode(SspDENM_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &SspDENM_descr_;
    break;
  case ALT_opaque:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, LibCommon__DataStrings::Oct0to30_descr_.raw);
    encoded_length = field_opaque->RAW_encode(LibCommon__DataStrings::Oct0to30_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &LibCommon__DataStrings::Oct0to30_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int ServiceSpecificPermissionsContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_sspCAM:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "sspCAM");
    enc_len += field_sspCAM->JSON_encode(SspCAM_descr_, p_tok);
    break;
  case ALT_sspDENM:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "sspDENM");
    enc_len += field_sspDENM->JSON_encode(SspDENM_descr_, p_tok);
    break;
  case ALT_opaque:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "opaque");
    enc_len += field_opaque->JSON_encode(LibCommon__DataStrings::Oct0to30_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ServiceSpecificPermissionsContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "sspCAM", name_len)) {
      int ret_val = sspCAM().JSON_decode(SspCAM_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "sspCAM");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "sspDENM", name_len)) {
      int ret_val = sspDENM().JSON_decode(SspDENM_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "sspDENM");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "opaque", name_len)) {
      int ret_val = opaque().JSON_decode(LibCommon__DataStrings::Oct0to30_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "opaque");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void ServiceSpecificPermissionsContainer_template::copy_value(const ServiceSpecificPermissionsContainer& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case ServiceSpecificPermissionsContainer::ALT_sspCAM:
single_value.field_sspCAM = new SspCAM_template(other_value.sspCAM());
break;
case ServiceSpecificPermissionsContainer::ALT_sspDENM:
single_value.field_sspDENM = new SspDENM_template(other_value.sspDENM());
break;
case ServiceSpecificPermissionsContainer::ALT_opaque:
single_value.field_opaque = new OCTETSTRING_template(other_value.opaque());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
}
set_selection(SPECIFIC_VALUE);
}

void ServiceSpecificPermissionsContainer_template::copy_template(const ServiceSpecificPermissionsContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case ServiceSpecificPermissionsContainer::ALT_sspCAM:
single_value.field_sspCAM = new SspCAM_template(*other_value.single_value.field_sspCAM);
break;
case ServiceSpecificPermissionsContainer::ALT_sspDENM:
single_value.field_sspDENM = new SspDENM_template(*other_value.single_value.field_sspDENM);
break;
case ServiceSpecificPermissionsContainer::ALT_opaque:
single_value.field_opaque = new OCTETSTRING_template(*other_value.single_value.field_opaque);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ServiceSpecificPermissionsContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
}
set_selection(other_value);
}

ServiceSpecificPermissionsContainer_template::ServiceSpecificPermissionsContainer_template()
{
}

ServiceSpecificPermissionsContainer_template::ServiceSpecificPermissionsContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ServiceSpecificPermissionsContainer_template::ServiceSpecificPermissionsContainer_template(const ServiceSpecificPermissionsContainer& other_value)
{
copy_value(other_value);
}

ServiceSpecificPermissionsContainer_template::ServiceSpecificPermissionsContainer_template(const OPTIONAL<ServiceSpecificPermissionsContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ServiceSpecificPermissionsContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer from an unbound optional field.");
}
}

ServiceSpecificPermissionsContainer_template::ServiceSpecificPermissionsContainer_template(const ServiceSpecificPermissionsContainer_template& other_value)
: Base_Template(){
copy_template(other_value);
}

ServiceSpecificPermissionsContainer_template::~ServiceSpecificPermissionsContainer_template()
{
clean_up();
}

void ServiceSpecificPermissionsContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ServiceSpecificPermissionsContainer::ALT_sspCAM:
delete single_value.field_sspCAM;
break;
case ServiceSpecificPermissionsContainer::ALT_sspDENM:
delete single_value.field_sspDENM;
break;
case ServiceSpecificPermissionsContainer::ALT_opaque:
delete single_value.field_opaque;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ServiceSpecificPermissionsContainer_template& ServiceSpecificPermissionsContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ServiceSpecificPermissionsContainer_template& ServiceSpecificPermissionsContainer_template::operator=(const ServiceSpecificPermissionsContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ServiceSpecificPermissionsContainer_template& ServiceSpecificPermissionsContainer_template::operator=(const OPTIONAL<ServiceSpecificPermissionsContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ServiceSpecificPermissionsContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
}
return *this;
}

ServiceSpecificPermissionsContainer_template& ServiceSpecificPermissionsContainer_template::operator=(const ServiceSpecificPermissionsContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ServiceSpecificPermissionsContainer_template::match(const ServiceSpecificPermissionsContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
ServiceSpecificPermissionsContainer::union_selection_type value_selection = other_value.get_selection();
if (value_selection == ServiceSpecificPermissionsContainer::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case ServiceSpecificPermissionsContainer::ALT_sspCAM:
return single_value.field_sspCAM->match(other_value.sspCAM(), legacy);
case ServiceSpecificPermissionsContainer::ALT_sspDENM:
return single_value.field_sspDENM->match(other_value.sspDENM(), legacy);
case ServiceSpecificPermissionsContainer::ALT_opaque:
return single_value.field_opaque->match(other_value.opaque(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
}
return FALSE;
}

boolean ServiceSpecificPermissionsContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case ServiceSpecificPermissionsContainer::ALT_sspCAM:
return single_value.field_sspCAM->is_value();
case ServiceSpecificPermissionsContainer::ALT_sspDENM:
return single_value.field_sspDENM->is_value();
case ServiceSpecificPermissionsContainer::ALT_opaque:
return single_value.field_opaque->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
}
}

ServiceSpecificPermissionsContainer ServiceSpecificPermissionsContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
ServiceSpecificPermissionsContainer ret_val;
switch (single_value.union_selection) {
case ServiceSpecificPermissionsContainer::ALT_sspCAM:
ret_val.sspCAM() = single_value.field_sspCAM->valueof();
break;
case ServiceSpecificPermissionsContainer::ALT_sspDENM:
ret_val.sspDENM() = single_value.field_sspDENM->valueof();
break;
case ServiceSpecificPermissionsContainer::ALT_opaque:
ret_val.opaque() = single_value.field_opaque->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
}
return ret_val;
}

ServiceSpecificPermissionsContainer_template& ServiceSpecificPermissionsContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
return value_list.list_value[list_index];
}
void ServiceSpecificPermissionsContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ServiceSpecificPermissionsContainer_template[list_length];
}

SspCAM_template& ServiceSpecificPermissionsContainer_template::sspCAM()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ServiceSpecificPermissionsContainer::ALT_sspCAM) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sspCAM = new SspCAM_template(ANY_VALUE);
else single_value.field_sspCAM = new SspCAM_template;
single_value.union_selection = ServiceSpecificPermissionsContainer::ALT_sspCAM;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sspCAM;
}

const SspCAM_template& ServiceSpecificPermissionsContainer_template::sspCAM() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sspCAM in a non-specific template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
if (single_value.union_selection != ServiceSpecificPermissionsContainer::ALT_sspCAM) TTCN_error("Accessing non-selected field sspCAM in a template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
return *single_value.field_sspCAM;
}

SspDENM_template& ServiceSpecificPermissionsContainer_template::sspDENM()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ServiceSpecificPermissionsContainer::ALT_sspDENM) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_sspDENM = new SspDENM_template(ANY_VALUE);
else single_value.field_sspDENM = new SspDENM_template;
single_value.union_selection = ServiceSpecificPermissionsContainer::ALT_sspDENM;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_sspDENM;
}

const SspDENM_template& ServiceSpecificPermissionsContainer_template::sspDENM() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field sspDENM in a non-specific template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
if (single_value.union_selection != ServiceSpecificPermissionsContainer::ALT_sspDENM) TTCN_error("Accessing non-selected field sspDENM in a template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
return *single_value.field_sspDENM;
}

OCTETSTRING_template& ServiceSpecificPermissionsContainer_template::opaque()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ServiceSpecificPermissionsContainer::ALT_opaque) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_opaque = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_opaque = new OCTETSTRING_template;
single_value.union_selection = ServiceSpecificPermissionsContainer::ALT_opaque;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_opaque;
}

const OCTETSTRING_template& ServiceSpecificPermissionsContainer_template::opaque() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field opaque in a non-specific template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
if (single_value.union_selection != ServiceSpecificPermissionsContainer::ALT_opaque) TTCN_error("Accessing non-selected field opaque in a template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
return *single_value.field_opaque;
}

boolean ServiceSpecificPermissionsContainer_template::ischosen(ServiceSpecificPermissionsContainer::union_selection_type checked_selection) const
{
if (checked_selection == ServiceSpecificPermissionsContainer::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == ServiceSpecificPermissionsContainer::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer");
}
return FALSE;
}

void ServiceSpecificPermissionsContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ServiceSpecificPermissionsContainer::ALT_sspCAM:
TTCN_Logger::log_event_str("{ sspCAM := ");
single_value.field_sspCAM->log();
TTCN_Logger::log_event_str(" }");
break;
case ServiceSpecificPermissionsContainer::ALT_sspDENM:
TTCN_Logger::log_event_str("{ sspDENM := ");
single_value.field_sspDENM->log();
TTCN_Logger::log_event_str(" }");
break;
case ServiceSpecificPermissionsContainer::ALT_opaque:
TTCN_Logger::log_event_str("{ opaque := ");
single_value.field_opaque->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ServiceSpecificPermissionsContainer_template::log_match(const ServiceSpecificPermissionsContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case ServiceSpecificPermissionsContainer::ALT_sspCAM:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sspCAM");
single_value.field_sspCAM->log_match(match_value.sspCAM(), legacy);
} else {
TTCN_Logger::log_event_str("{ sspCAM := ");
single_value.field_sspCAM->log_match(match_value.sspCAM(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ServiceSpecificPermissionsContainer::ALT_sspDENM:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".sspDENM");
single_value.field_sspDENM->log_match(match_value.sspDENM(), legacy);
} else {
TTCN_Logger::log_event_str("{ sspDENM := ");
single_value.field_sspDENM->log_match(match_value.sspDENM(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ServiceSpecificPermissionsContainer::ALT_opaque:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".opaque");
single_value.field_opaque->log_match(match_value.opaque(), legacy);
} else {
TTCN_Logger::log_event_str("{ opaque := ");
single_value.field_opaque->log_match(match_value.opaque(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ServiceSpecificPermissionsContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case ServiceSpecificPermissionsContainer::ALT_sspCAM:
single_value.field_sspCAM->encode_text(text_buf);
break;
case ServiceSpecificPermissionsContainer::ALT_sspDENM:
single_value.field_sspDENM->encode_text(text_buf);
break;
case ServiceSpecificPermissionsContainer::ALT_opaque:
single_value.field_opaque->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
}
}

void ServiceSpecificPermissionsContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = ServiceSpecificPermissionsContainer::UNBOUND_VALUE;
ServiceSpecificPermissionsContainer::union_selection_type new_selection = (ServiceSpecificPermissionsContainer::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case ServiceSpecificPermissionsContainer::ALT_sspCAM:
single_value.field_sspCAM = new SspCAM_template;
single_value.field_sspCAM->decode_text(text_buf);
break;
case ServiceSpecificPermissionsContainer::ALT_sspDENM:
single_value.field_sspDENM = new SspDENM_template;
single_value.field_sspDENM->decode_text(text_buf);
break;
case ServiceSpecificPermissionsContainer::ALT_opaque:
single_value.field_opaque = new OCTETSTRING_template;
single_value.field_opaque->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ServiceSpecificPermissionsContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
}
}

boolean ServiceSpecificPermissionsContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ServiceSpecificPermissionsContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ServiceSpecificPermissionsContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer'");
    }
    if (strcmp("sspCAM", param_field) == 0) {
      sspCAM().set_param(param);
      return;
    } else if (strcmp("sspDENM", param_field) == 0) {
      sspDENM().set_param(param);
      return;
    } else if (strcmp("opaque", param_field) == 0) {
      opaque().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ServiceSpecificPermissionsContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "sspCAM")) {
      sspCAM().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "sspDENM")) {
      sspDENM().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "opaque")) {
      opaque().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ServiceSpecificPermissionsContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer'");
    }
    if (strcmp("sspCAM", param_field) == 0) {
      return sspCAM().get_param(param_name);
    } else if (strcmp("sspDENM", param_field) == 0) {
      return sspDENM().get_param(param_name);
    } else if (strcmp("opaque", param_field) == 0) {
      return opaque().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `ServiceSpecificPermissionsContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case ServiceSpecificPermissionsContainer::ALT_sspCAM:
      mp_field = single_value.field_sspCAM->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("sspCAM")));
      break;
    case ServiceSpecificPermissionsContainer::ALT_sspDENM:
      mp_field = single_value.field_sspDENM->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("sspDENM")));
      break;
    case ServiceSpecificPermissionsContainer::ALT_opaque:
      mp_field = single_value.field_opaque->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("opaque")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ServiceSpecificPermissionsContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case ServiceSpecificPermissionsContainer::ALT_sspCAM:
single_value.field_sspCAM->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer");
return;
case ServiceSpecificPermissionsContainer::ALT_sspDENM:
single_value.field_sspDENM->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer");
return;
case ServiceSpecificPermissionsContainer::ALT_opaque:
single_value.field_opaque->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.ServiceSpecificPermissionsContainer");
}

SspCAM::SspCAM()
{
  bound_flag = FALSE;
}

SspCAM::SspCAM(const BITSTRING& par_cenDsrcTollingZone,
    const BITSTRING& par_publicTransport,
    const BITSTRING& par_specialTransport,
    const BITSTRING& par_dangerousGoods,
    const BITSTRING& par_roadwork,
    const BITSTRING& par_rescue,
    const BITSTRING& par_emergency,
    const BITSTRING& par_safetyCar,
    const BITSTRING& par_closedLanes,
    const BITSTRING& par_requestForRightOfWay,
    const BITSTRING& par_requestForFreeCrossingAtATrafficLight,
    const BITSTRING& par_noPassing,
    const BITSTRING& par_noPassingForTrucks,
    const BITSTRING& par_speedLimit,
    const BITSTRING& par_reserved1,
    const BITSTRING& par_reserved2)
  :   field_cenDsrcTollingZone(par_cenDsrcTollingZone),
  field_publicTransport(par_publicTransport),
  field_specialTransport(par_specialTransport),
  field_dangerousGoods(par_dangerousGoods),
  field_roadwork(par_roadwork),
  field_rescue(par_rescue),
  field_emergency(par_emergency),
  field_safetyCar(par_safetyCar),
  field_closedLanes(par_closedLanes),
  field_requestForRightOfWay(par_requestForRightOfWay),
  field_requestForFreeCrossingAtATrafficLight(par_requestForFreeCrossingAtATrafficLight),
  field_noPassing(par_noPassing),
  field_noPassingForTrucks(par_noPassingForTrucks),
  field_speedLimit(par_speedLimit),
  field_reserved1(par_reserved1),
  field_reserved2(par_reserved2)
{
  bound_flag = TRUE;
}

SspCAM::SspCAM(const SspCAM& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.SspCAM.");
bound_flag = TRUE;
if (other_value.cenDsrcTollingZone().is_bound()) field_cenDsrcTollingZone = other_value.cenDsrcTollingZone();
else field_cenDsrcTollingZone.clean_up();
if (other_value.publicTransport().is_bound()) field_publicTransport = other_value.publicTransport();
else field_publicTransport.clean_up();
if (other_value.specialTransport().is_bound()) field_specialTransport = other_value.specialTransport();
else field_specialTransport.clean_up();
if (other_value.dangerousGoods().is_bound()) field_dangerousGoods = other_value.dangerousGoods();
else field_dangerousGoods.clean_up();
if (other_value.roadwork().is_bound()) field_roadwork = other_value.roadwork();
else field_roadwork.clean_up();
if (other_value.rescue().is_bound()) field_rescue = other_value.rescue();
else field_rescue.clean_up();
if (other_value.emergency().is_bound()) field_emergency = other_value.emergency();
else field_emergency.clean_up();
if (other_value.safetyCar().is_bound()) field_safetyCar = other_value.safetyCar();
else field_safetyCar.clean_up();
if (other_value.closedLanes().is_bound()) field_closedLanes = other_value.closedLanes();
else field_closedLanes.clean_up();
if (other_value.requestForRightOfWay().is_bound()) field_requestForRightOfWay = other_value.requestForRightOfWay();
else field_requestForRightOfWay.clean_up();
if (other_value.requestForFreeCrossingAtATrafficLight().is_bound()) field_requestForFreeCrossingAtATrafficLight = other_value.requestForFreeCrossingAtATrafficLight();
else field_requestForFreeCrossingAtATrafficLight.clean_up();
if (other_value.noPassing().is_bound()) field_noPassing = other_value.noPassing();
else field_noPassing.clean_up();
if (other_value.noPassingForTrucks().is_bound()) field_noPassingForTrucks = other_value.noPassingForTrucks();
else field_noPassingForTrucks.clean_up();
if (other_value.speedLimit().is_bound()) field_speedLimit = other_value.speedLimit();
else field_speedLimit.clean_up();
if (other_value.reserved1().is_bound()) field_reserved1 = other_value.reserved1();
else field_reserved1.clean_up();
if (other_value.reserved2().is_bound()) field_reserved2 = other_value.reserved2();
else field_reserved2.clean_up();
}

void SspCAM::clean_up()
{
field_cenDsrcTollingZone.clean_up();
field_publicTransport.clean_up();
field_specialTransport.clean_up();
field_dangerousGoods.clean_up();
field_roadwork.clean_up();
field_rescue.clean_up();
field_emergency.clean_up();
field_safetyCar.clean_up();
field_closedLanes.clean_up();
field_requestForRightOfWay.clean_up();
field_requestForFreeCrossingAtATrafficLight.clean_up();
field_noPassing.clean_up();
field_noPassingForTrucks.clean_up();
field_speedLimit.clean_up();
field_reserved1.clean_up();
field_reserved2.clean_up();
bound_flag = FALSE;
}

SspCAM& SspCAM::operator=(const SspCAM& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.SspCAM.");
  bound_flag = TRUE;
  if (other_value.cenDsrcTollingZone().is_bound()) field_cenDsrcTollingZone = other_value.cenDsrcTollingZone();
  else field_cenDsrcTollingZone.clean_up();
  if (other_value.publicTransport().is_bound()) field_publicTransport = other_value.publicTransport();
  else field_publicTransport.clean_up();
  if (other_value.specialTransport().is_bound()) field_specialTransport = other_value.specialTransport();
  else field_specialTransport.clean_up();
  if (other_value.dangerousGoods().is_bound()) field_dangerousGoods = other_value.dangerousGoods();
  else field_dangerousGoods.clean_up();
  if (other_value.roadwork().is_bound()) field_roadwork = other_value.roadwork();
  else field_roadwork.clean_up();
  if (other_value.rescue().is_bound()) field_rescue = other_value.rescue();
  else field_rescue.clean_up();
  if (other_value.emergency().is_bound()) field_emergency = other_value.emergency();
  else field_emergency.clean_up();
  if (other_value.safetyCar().is_bound()) field_safetyCar = other_value.safetyCar();
  else field_safetyCar.clean_up();
  if (other_value.closedLanes().is_bound()) field_closedLanes = other_value.closedLanes();
  else field_closedLanes.clean_up();
  if (other_value.requestForRightOfWay().is_bound()) field_requestForRightOfWay = other_value.requestForRightOfWay();
  else field_requestForRightOfWay.clean_up();
  if (other_value.requestForFreeCrossingAtATrafficLight().is_bound()) field_requestForFreeCrossingAtATrafficLight = other_value.requestForFreeCrossingAtATrafficLight();
  else field_requestForFreeCrossingAtATrafficLight.clean_up();
  if (other_value.noPassing().is_bound()) field_noPassing = other_value.noPassing();
  else field_noPassing.clean_up();
  if (other_value.noPassingForTrucks().is_bound()) field_noPassingForTrucks = other_value.noPassingForTrucks();
  else field_noPassingForTrucks.clean_up();
  if (other_value.speedLimit().is_bound()) field_speedLimit = other_value.speedLimit();
  else field_speedLimit.clean_up();
  if (other_value.reserved1().is_bound()) field_reserved1 = other_value.reserved1();
  else field_reserved1.clean_up();
  if (other_value.reserved2().is_bound()) field_reserved2 = other_value.reserved2();
  else field_reserved2.clean_up();
}
return *this;
}

boolean SspCAM::operator==(const SspCAM& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_cenDsrcTollingZone==other_value.field_cenDsrcTollingZone
  && field_publicTransport==other_value.field_publicTransport
  && field_specialTransport==other_value.field_specialTransport
  && field_dangerousGoods==other_value.field_dangerousGoods
  && field_roadwork==other_value.field_roadwork
  && field_rescue==other_value.field_rescue
  && field_emergency==other_value.field_emergency
  && field_safetyCar==other_value.field_safetyCar
  && field_closedLanes==other_value.field_closedLanes
  && field_requestForRightOfWay==other_value.field_requestForRightOfWay
  && field_requestForFreeCrossingAtATrafficLight==other_value.field_requestForFreeCrossingAtATrafficLight
  && field_noPassing==other_value.field_noPassing
  && field_noPassingForTrucks==other_value.field_noPassingForTrucks
  && field_speedLimit==other_value.field_speedLimit
  && field_reserved1==other_value.field_reserved1
  && field_reserved2==other_value.field_reserved2;
}

boolean SspCAM::is_bound() const
{
if (bound_flag) return TRUE;
if(field_cenDsrcTollingZone.is_bound()) return TRUE;
if(field_publicTransport.is_bound()) return TRUE;
if(field_specialTransport.is_bound()) return TRUE;
if(field_dangerousGoods.is_bound()) return TRUE;
if(field_roadwork.is_bound()) return TRUE;
if(field_rescue.is_bound()) return TRUE;
if(field_emergency.is_bound()) return TRUE;
if(field_safetyCar.is_bound()) return TRUE;
if(field_closedLanes.is_bound()) return TRUE;
if(field_requestForRightOfWay.is_bound()) return TRUE;
if(field_requestForFreeCrossingAtATrafficLight.is_bound()) return TRUE;
if(field_noPassing.is_bound()) return TRUE;
if(field_noPassingForTrucks.is_bound()) return TRUE;
if(field_speedLimit.is_bound()) return TRUE;
if(field_reserved1.is_bound()) return TRUE;
if(field_reserved2.is_bound()) return TRUE;
return FALSE;
}
boolean SspCAM::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_cenDsrcTollingZone.is_value()) return FALSE;
if(!field_publicTransport.is_value()) return FALSE;
if(!field_specialTransport.is_value()) return FALSE;
if(!field_dangerousGoods.is_value()) return FALSE;
if(!field_roadwork.is_value()) return FALSE;
if(!field_rescue.is_value()) return FALSE;
if(!field_emergency.is_value()) return FALSE;
if(!field_safetyCar.is_value()) return FALSE;
if(!field_closedLanes.is_value()) return FALSE;
if(!field_requestForRightOfWay.is_value()) return FALSE;
if(!field_requestForFreeCrossingAtATrafficLight.is_value()) return FALSE;
if(!field_noPassing.is_value()) return FALSE;
if(!field_noPassingForTrucks.is_value()) return FALSE;
if(!field_speedLimit.is_value()) return FALSE;
if(!field_reserved1.is_value()) return FALSE;
if(!field_reserved2.is_value()) return FALSE;
return TRUE;
}
int SspCAM::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.SspCAM");
  return 16;
}

void SspCAM::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ cenDsrcTollingZone := ");
field_cenDsrcTollingZone.log();
TTCN_Logger::log_event_str(", publicTransport := ");
field_publicTransport.log();
TTCN_Logger::log_event_str(", specialTransport := ");
field_specialTransport.log();
TTCN_Logger::log_event_str(", dangerousGoods := ");
field_dangerousGoods.log();
TTCN_Logger::log_event_str(", roadwork := ");
field_roadwork.log();
TTCN_Logger::log_event_str(", rescue := ");
field_rescue.log();
TTCN_Logger::log_event_str(", emergency := ");
field_emergency.log();
TTCN_Logger::log_event_str(", safetyCar := ");
field_safetyCar.log();
TTCN_Logger::log_event_str(", closedLanes := ");
field_closedLanes.log();
TTCN_Logger::log_event_str(", requestForRightOfWay := ");
field_requestForRightOfWay.log();
TTCN_Logger::log_event_str(", requestForFreeCrossingAtATrafficLight := ");
field_requestForFreeCrossingAtATrafficLight.log();
TTCN_Logger::log_event_str(", noPassing := ");
field_noPassing.log();
TTCN_Logger::log_event_str(", noPassingForTrucks := ");
field_noPassingForTrucks.log();
TTCN_Logger::log_event_str(", speedLimit := ");
field_speedLimit.log();
TTCN_Logger::log_event_str(", reserved1 := ");
field_reserved1.log();
TTCN_Logger::log_event_str(", reserved2 := ");
field_reserved2.log();
TTCN_Logger::log_event_str(" }");
}

void SspCAM::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.SspCAM'");
    }
    if (strcmp("cenDsrcTollingZone", param_field) == 0) {
      cenDsrcTollingZone().set_param(param);
      return;
    } else if (strcmp("publicTransport", param_field) == 0) {
      publicTransport().set_param(param);
      return;
    } else if (strcmp("specialTransport", param_field) == 0) {
      specialTransport().set_param(param);
      return;
    } else if (strcmp("dangerousGoods", param_field) == 0) {
      dangerousGoods().set_param(param);
      return;
    } else if (strcmp("roadwork", param_field) == 0) {
      roadwork().set_param(param);
      return;
    } else if (strcmp("rescue", param_field) == 0) {
      rescue().set_param(param);
      return;
    } else if (strcmp("emergency", param_field) == 0) {
      emergency().set_param(param);
      return;
    } else if (strcmp("safetyCar", param_field) == 0) {
      safetyCar().set_param(param);
      return;
    } else if (strcmp("closedLanes", param_field) == 0) {
      closedLanes().set_param(param);
      return;
    } else if (strcmp("requestForRightOfWay", param_field) == 0) {
      requestForRightOfWay().set_param(param);
      return;
    } else if (strcmp("requestForFreeCrossingAtATrafficLight", param_field) == 0) {
      requestForFreeCrossingAtATrafficLight().set_param(param);
      return;
    } else if (strcmp("noPassing", param_field) == 0) {
      noPassing().set_param(param);
      return;
    } else if (strcmp("noPassingForTrucks", param_field) == 0) {
      noPassingForTrucks().set_param(param);
      return;
    } else if (strcmp("speedLimit", param_field) == 0) {
      speedLimit().set_param(param);
      return;
    } else if (strcmp("reserved1", param_field) == 0) {
      reserved1().set_param(param);
      return;
    } else if (strcmp("reserved2", param_field) == 0) {
      reserved2().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SspCAM'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (16<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.SspCAM has 16 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) cenDsrcTollingZone().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) publicTransport().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) specialTransport().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) dangerousGoods().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) roadwork().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) rescue().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) emergency().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) safetyCar().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) closedLanes().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) requestForRightOfWay().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) requestForFreeCrossingAtATrafficLight().set_param(*mp->get_elem(10));
    if (mp->get_size()>11 && mp->get_elem(11)->get_type()!=Module_Param::MP_NotUsed) noPassing().set_param(*mp->get_elem(11));
    if (mp->get_size()>12 && mp->get_elem(12)->get_type()!=Module_Param::MP_NotUsed) noPassingForTrucks().set_param(*mp->get_elem(12));
    if (mp->get_size()>13 && mp->get_elem(13)->get_type()!=Module_Param::MP_NotUsed) speedLimit().set_param(*mp->get_elem(13));
    if (mp->get_size()>14 && mp->get_elem(14)->get_type()!=Module_Param::MP_NotUsed) reserved1().set_param(*mp->get_elem(14));
    if (mp->get_size()>15 && mp->get_elem(15)->get_type()!=Module_Param::MP_NotUsed) reserved2().set_param(*mp->get_elem(15));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cenDsrcTollingZone")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cenDsrcTollingZone().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "publicTransport")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          publicTransport().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "specialTransport")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          specialTransport().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dangerousGoods")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dangerousGoods().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "roadwork")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          roadwork().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rescue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rescue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "emergency")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          emergency().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "safetyCar")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          safetyCar().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "closedLanes")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          closedLanes().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "requestForRightOfWay")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          requestForRightOfWay().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "requestForFreeCrossingAtATrafficLight")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          requestForFreeCrossingAtATrafficLight().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "noPassing")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          noPassing().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "noPassingForTrucks")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          noPassingForTrucks().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speedLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speedLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved1")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved1().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved2().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.SspCAM: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.SspCAM");
  }
}

Module_Param* SspCAM::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.SspCAM'");
    }
    if (strcmp("cenDsrcTollingZone", param_field) == 0) {
      return cenDsrcTollingZone().get_param(param_name);
    } else if (strcmp("publicTransport", param_field) == 0) {
      return publicTransport().get_param(param_name);
    } else if (strcmp("specialTransport", param_field) == 0) {
      return specialTransport().get_param(param_name);
    } else if (strcmp("dangerousGoods", param_field) == 0) {
      return dangerousGoods().get_param(param_name);
    } else if (strcmp("roadwork", param_field) == 0) {
      return roadwork().get_param(param_name);
    } else if (strcmp("rescue", param_field) == 0) {
      return rescue().get_param(param_name);
    } else if (strcmp("emergency", param_field) == 0) {
      return emergency().get_param(param_name);
    } else if (strcmp("safetyCar", param_field) == 0) {
      return safetyCar().get_param(param_name);
    } else if (strcmp("closedLanes", param_field) == 0) {
      return closedLanes().get_param(param_name);
    } else if (strcmp("requestForRightOfWay", param_field) == 0) {
      return requestForRightOfWay().get_param(param_name);
    } else if (strcmp("requestForFreeCrossingAtATrafficLight", param_field) == 0) {
      return requestForFreeCrossingAtATrafficLight().get_param(param_name);
    } else if (strcmp("noPassing", param_field) == 0) {
      return noPassing().get_param(param_name);
    } else if (strcmp("noPassingForTrucks", param_field) == 0) {
      return noPassingForTrucks().get_param(param_name);
    } else if (strcmp("speedLimit", param_field) == 0) {
      return speedLimit().get_param(param_name);
    } else if (strcmp("reserved1", param_field) == 0) {
      return reserved1().get_param(param_name);
    } else if (strcmp("reserved2", param_field) == 0) {
      return reserved2().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SspCAM'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_cenDsrcTollingZone = field_cenDsrcTollingZone.get_param(param_name);
  mp_field_cenDsrcTollingZone->set_id(new Module_Param_FieldName(mcopystr("cenDsrcTollingZone")));
  mp->add_elem(mp_field_cenDsrcTollingZone);
  Module_Param* mp_field_publicTransport = field_publicTransport.get_param(param_name);
  mp_field_publicTransport->set_id(new Module_Param_FieldName(mcopystr("publicTransport")));
  mp->add_elem(mp_field_publicTransport);
  Module_Param* mp_field_specialTransport = field_specialTransport.get_param(param_name);
  mp_field_specialTransport->set_id(new Module_Param_FieldName(mcopystr("specialTransport")));
  mp->add_elem(mp_field_specialTransport);
  Module_Param* mp_field_dangerousGoods = field_dangerousGoods.get_param(param_name);
  mp_field_dangerousGoods->set_id(new Module_Param_FieldName(mcopystr("dangerousGoods")));
  mp->add_elem(mp_field_dangerousGoods);
  Module_Param* mp_field_roadwork = field_roadwork.get_param(param_name);
  mp_field_roadwork->set_id(new Module_Param_FieldName(mcopystr("roadwork")));
  mp->add_elem(mp_field_roadwork);
  Module_Param* mp_field_rescue = field_rescue.get_param(param_name);
  mp_field_rescue->set_id(new Module_Param_FieldName(mcopystr("rescue")));
  mp->add_elem(mp_field_rescue);
  Module_Param* mp_field_emergency = field_emergency.get_param(param_name);
  mp_field_emergency->set_id(new Module_Param_FieldName(mcopystr("emergency")));
  mp->add_elem(mp_field_emergency);
  Module_Param* mp_field_safetyCar = field_safetyCar.get_param(param_name);
  mp_field_safetyCar->set_id(new Module_Param_FieldName(mcopystr("safetyCar")));
  mp->add_elem(mp_field_safetyCar);
  Module_Param* mp_field_closedLanes = field_closedLanes.get_param(param_name);
  mp_field_closedLanes->set_id(new Module_Param_FieldName(mcopystr("closedLanes")));
  mp->add_elem(mp_field_closedLanes);
  Module_Param* mp_field_requestForRightOfWay = field_requestForRightOfWay.get_param(param_name);
  mp_field_requestForRightOfWay->set_id(new Module_Param_FieldName(mcopystr("requestForRightOfWay")));
  mp->add_elem(mp_field_requestForRightOfWay);
  Module_Param* mp_field_requestForFreeCrossingAtATrafficLight = field_requestForFreeCrossingAtATrafficLight.get_param(param_name);
  mp_field_requestForFreeCrossingAtATrafficLight->set_id(new Module_Param_FieldName(mcopystr("requestForFreeCrossingAtATrafficLight")));
  mp->add_elem(mp_field_requestForFreeCrossingAtATrafficLight);
  Module_Param* mp_field_noPassing = field_noPassing.get_param(param_name);
  mp_field_noPassing->set_id(new Module_Param_FieldName(mcopystr("noPassing")));
  mp->add_elem(mp_field_noPassing);
  Module_Param* mp_field_noPassingForTrucks = field_noPassingForTrucks.get_param(param_name);
  mp_field_noPassingForTrucks->set_id(new Module_Param_FieldName(mcopystr("noPassingForTrucks")));
  mp->add_elem(mp_field_noPassingForTrucks);
  Module_Param* mp_field_speedLimit = field_speedLimit.get_param(param_name);
  mp_field_speedLimit->set_id(new Module_Param_FieldName(mcopystr("speedLimit")));
  mp->add_elem(mp_field_speedLimit);
  Module_Param* mp_field_reserved1 = field_reserved1.get_param(param_name);
  mp_field_reserved1->set_id(new Module_Param_FieldName(mcopystr("reserved1")));
  mp->add_elem(mp_field_reserved1);
  Module_Param* mp_field_reserved2 = field_reserved2.get_param(param_name);
  mp_field_reserved2->set_id(new Module_Param_FieldName(mcopystr("reserved2")));
  mp->add_elem(mp_field_reserved2);
  return mp;
  }

void SspCAM::set_implicit_omit()
{
if (cenDsrcTollingZone().is_bound()) cenDsrcTollingZone().set_implicit_omit();
if (publicTransport().is_bound()) publicTransport().set_implicit_omit();
if (specialTransport().is_bound()) specialTransport().set_implicit_omit();
if (dangerousGoods().is_bound()) dangerousGoods().set_implicit_omit();
if (roadwork().is_bound()) roadwork().set_implicit_omit();
if (rescue().is_bound()) rescue().set_implicit_omit();
if (emergency().is_bound()) emergency().set_implicit_omit();
if (safetyCar().is_bound()) safetyCar().set_implicit_omit();
if (closedLanes().is_bound()) closedLanes().set_implicit_omit();
if (requestForRightOfWay().is_bound()) requestForRightOfWay().set_implicit_omit();
if (requestForFreeCrossingAtATrafficLight().is_bound()) requestForFreeCrossingAtATrafficLight().set_implicit_omit();
if (noPassing().is_bound()) noPassing().set_implicit_omit();
if (noPassingForTrucks().is_bound()) noPassingForTrucks().set_implicit_omit();
if (speedLimit().is_bound()) speedLimit().set_implicit_omit();
if (reserved1().is_bound()) reserved1().set_implicit_omit();
if (reserved2().is_bound()) reserved2().set_implicit_omit();
}

void SspCAM::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.SspCAM.");
field_cenDsrcTollingZone.encode_text(text_buf);
field_publicTransport.encode_text(text_buf);
field_specialTransport.encode_text(text_buf);
field_dangerousGoods.encode_text(text_buf);
field_roadwork.encode_text(text_buf);
field_rescue.encode_text(text_buf);
field_emergency.encode_text(text_buf);
field_safetyCar.encode_text(text_buf);
field_closedLanes.encode_text(text_buf);
field_requestForRightOfWay.encode_text(text_buf);
field_requestForFreeCrossingAtATrafficLight.encode_text(text_buf);
field_noPassing.encode_text(text_buf);
field_noPassingForTrucks.encode_text(text_buf);
field_speedLimit.encode_text(text_buf);
field_reserved1.encode_text(text_buf);
field_reserved2.encode_text(text_buf);
}

void SspCAM::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_cenDsrcTollingZone.decode_text(text_buf);
field_publicTransport.decode_text(text_buf);
field_specialTransport.decode_text(text_buf);
field_dangerousGoods.decode_text(text_buf);
field_roadwork.decode_text(text_buf);
field_rescue.decode_text(text_buf);
field_emergency.decode_text(text_buf);
field_safetyCar.decode_text(text_buf);
field_closedLanes.decode_text(text_buf);
field_requestForRightOfWay.decode_text(text_buf);
field_requestForFreeCrossingAtATrafficLight.decode_text(text_buf);
field_noPassing.decode_text(text_buf);
field_noPassingForTrucks.decode_text(text_buf);
field_speedLimit.decode_text(text_buf);
field_reserved1.decode_text(text_buf);
field_reserved2.decode_text(text_buf);
}

void SspCAM::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SspCAM::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SspCAM::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_cenDsrcTollingZone.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_publicTransport.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_specialTransport.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_dangerousGoods.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_roadwork.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_rescue.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_emergency.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_safetyCar.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_closedLanes.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_requestForRightOfWay.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_requestForFreeCrossingAtATrafficLight.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_noPassing.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_noPassingForTrucks.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_speedLimit.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved1.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_reserved2.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int SspCAM::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 16;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(16);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[7] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 7, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[8] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 8, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[9] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 9, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[10] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 10, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[11] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 11, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[12] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 12, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[13] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 13, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[14] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 14, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[15] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 15, LibCommon__DataStrings::Bit1_descr_.raw);
  encoded_length += field_cenDsrcTollingZone.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_publicTransport.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_specialTransport.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_dangerousGoods.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_roadwork.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_rescue.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_emergency.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[6]);
  encoded_length += field_safetyCar.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[7]);
  encoded_length += field_closedLanes.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[8]);
  encoded_length += field_requestForRightOfWay.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[9]);
  encoded_length += field_requestForFreeCrossingAtATrafficLight.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[10]);
  encoded_length += field_noPassing.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[11]);
  encoded_length += field_noPassingForTrucks.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[12]);
  encoded_length += field_speedLimit.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[13]);
  encoded_length += field_reserved1.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[14]);
  encoded_length += field_reserved2.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[15]);
  return myleaf.length = encoded_length;
}

int SspCAM::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.SspCAM.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "cenDsrcTollingZone");
    enc_len += field_cenDsrcTollingZone.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "publicTransport");
    enc_len += field_publicTransport.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "specialTransport");
    enc_len += field_specialTransport.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "dangerousGoods");
    enc_len += field_dangerousGoods.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "roadwork");
    enc_len += field_roadwork.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "rescue");
    enc_len += field_rescue.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "emergency");
    enc_len += field_emergency.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "safetyCar");
    enc_len += field_safetyCar.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "closedLanes");
    enc_len += field_closedLanes.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "requestForRightOfWay");
    enc_len += field_requestForRightOfWay.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "requestForFreeCrossingAtATrafficLight");
    enc_len += field_requestForFreeCrossingAtATrafficLight.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "noPassing");
    enc_len += field_noPassing.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "noPassingForTrucks");
    enc_len += field_noPassingForTrucks.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "speedLimit");
    enc_len += field_speedLimit.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved1");
    enc_len += field_reserved1.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "reserved2");
    enc_len += field_reserved2.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SspCAM::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (18 == name_len && 0 == strncmp(fld_name, "cenDsrcTollingZone", name_len)) {
         int ret_val = field_cenDsrcTollingZone.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "cenDsrcTollingZone");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "publicTransport", name_len)) {
         int ret_val = field_publicTransport.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "publicTransport");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (16 == name_len && 0 == strncmp(fld_name, "specialTransport", name_len)) {
         int ret_val = field_specialTransport.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "specialTransport");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "dangerousGoods", name_len)) {
         int ret_val = field_dangerousGoods.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "dangerousGoods");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "roadwork", name_len)) {
         int ret_val = field_roadwork.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "roadwork");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "rescue", name_len)) {
         int ret_val = field_rescue.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "rescue");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "emergency", name_len)) {
         int ret_val = field_emergency.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "emergency");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "safetyCar", name_len)) {
         int ret_val = field_safetyCar.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "safetyCar");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "closedLanes", name_len)) {
         int ret_val = field_closedLanes.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "closedLanes");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (20 == name_len && 0 == strncmp(fld_name, "requestForRightOfWay", name_len)) {
         int ret_val = field_requestForRightOfWay.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "requestForRightOfWay");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (37 == name_len && 0 == strncmp(fld_name, "requestForFreeCrossingAtATrafficLight", name_len)) {
         int ret_val = field_requestForFreeCrossingAtATrafficLight.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "requestForFreeCrossingAtATrafficLight");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "noPassing", name_len)) {
         int ret_val = field_noPassing.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "noPassing");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "noPassingForTrucks", name_len)) {
         int ret_val = field_noPassingForTrucks.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "noPassingForTrucks");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "speedLimit", name_len)) {
         int ret_val = field_speedLimit.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "speedLimit");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "reserved1", name_len)) {
         int ret_val = field_reserved1.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved1");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "reserved2", name_len)) {
         int ret_val = field_reserved2.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "reserved2");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_cenDsrcTollingZone.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "cenDsrcTollingZone");
    return JSON_ERROR_FATAL;
  }
if (!field_publicTransport.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "publicTransport");
    return JSON_ERROR_FATAL;
  }
if (!field_specialTransport.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "specialTransport");
    return JSON_ERROR_FATAL;
  }
if (!field_dangerousGoods.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "dangerousGoods");
    return JSON_ERROR_FATAL;
  }
if (!field_roadwork.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "roadwork");
    return JSON_ERROR_FATAL;
  }
if (!field_rescue.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "rescue");
    return JSON_ERROR_FATAL;
  }
if (!field_emergency.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "emergency");
    return JSON_ERROR_FATAL;
  }
if (!field_safetyCar.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "safetyCar");
    return JSON_ERROR_FATAL;
  }
if (!field_closedLanes.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "closedLanes");
    return JSON_ERROR_FATAL;
  }
if (!field_requestForRightOfWay.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "requestForRightOfWay");
    return JSON_ERROR_FATAL;
  }
if (!field_requestForFreeCrossingAtATrafficLight.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "requestForFreeCrossingAtATrafficLight");
    return JSON_ERROR_FATAL;
  }
if (!field_noPassing.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "noPassing");
    return JSON_ERROR_FATAL;
  }
if (!field_noPassingForTrucks.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "noPassingForTrucks");
    return JSON_ERROR_FATAL;
  }
if (!field_speedLimit.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "speedLimit");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved1.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved1");
    return JSON_ERROR_FATAL;
  }
if (!field_reserved2.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "reserved2");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct SspCAM_template::single_value_struct {
BITSTRING_template field_cenDsrcTollingZone;
BITSTRING_template field_publicTransport;
BITSTRING_template field_specialTransport;
BITSTRING_template field_dangerousGoods;
BITSTRING_template field_roadwork;
BITSTRING_template field_rescue;
BITSTRING_template field_emergency;
BITSTRING_template field_safetyCar;
BITSTRING_template field_closedLanes;
BITSTRING_template field_requestForRightOfWay;
BITSTRING_template field_requestForFreeCrossingAtATrafficLight;
BITSTRING_template field_noPassing;
BITSTRING_template field_noPassingForTrucks;
BITSTRING_template field_speedLimit;
BITSTRING_template field_reserved1;
BITSTRING_template field_reserved2;
};

void SspCAM_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_cenDsrcTollingZone = ANY_VALUE;
single_value->field_publicTransport = ANY_VALUE;
single_value->field_specialTransport = ANY_VALUE;
single_value->field_dangerousGoods = ANY_VALUE;
single_value->field_roadwork = ANY_VALUE;
single_value->field_rescue = ANY_VALUE;
single_value->field_emergency = ANY_VALUE;
single_value->field_safetyCar = ANY_VALUE;
single_value->field_closedLanes = ANY_VALUE;
single_value->field_requestForRightOfWay = ANY_VALUE;
single_value->field_requestForFreeCrossingAtATrafficLight = ANY_VALUE;
single_value->field_noPassing = ANY_VALUE;
single_value->field_noPassingForTrucks = ANY_VALUE;
single_value->field_speedLimit = ANY_VALUE;
single_value->field_reserved1 = ANY_VALUE;
single_value->field_reserved2 = ANY_VALUE;
}
}
}

void SspCAM_template::copy_value(const SspCAM& other_value)
{
single_value = new single_value_struct;
if (other_value.cenDsrcTollingZone().is_bound()) {
  single_value->field_cenDsrcTollingZone = other_value.cenDsrcTollingZone();
} else {
  single_value->field_cenDsrcTollingZone.clean_up();
}
if (other_value.publicTransport().is_bound()) {
  single_value->field_publicTransport = other_value.publicTransport();
} else {
  single_value->field_publicTransport.clean_up();
}
if (other_value.specialTransport().is_bound()) {
  single_value->field_specialTransport = other_value.specialTransport();
} else {
  single_value->field_specialTransport.clean_up();
}
if (other_value.dangerousGoods().is_bound()) {
  single_value->field_dangerousGoods = other_value.dangerousGoods();
} else {
  single_value->field_dangerousGoods.clean_up();
}
if (other_value.roadwork().is_bound()) {
  single_value->field_roadwork = other_value.roadwork();
} else {
  single_value->field_roadwork.clean_up();
}
if (other_value.rescue().is_bound()) {
  single_value->field_rescue = other_value.rescue();
} else {
  single_value->field_rescue.clean_up();
}
if (other_value.emergency().is_bound()) {
  single_value->field_emergency = other_value.emergency();
} else {
  single_value->field_emergency.clean_up();
}
if (other_value.safetyCar().is_bound()) {
  single_value->field_safetyCar = other_value.safetyCar();
} else {
  single_value->field_safetyCar.clean_up();
}
if (other_value.closedLanes().is_bound()) {
  single_value->field_closedLanes = other_value.closedLanes();
} else {
  single_value->field_closedLanes.clean_up();
}
if (other_value.requestForRightOfWay().is_bound()) {
  single_value->field_requestForRightOfWay = other_value.requestForRightOfWay();
} else {
  single_value->field_requestForRightOfWay.clean_up();
}
if (other_value.requestForFreeCrossingAtATrafficLight().is_bound()) {
  single_value->field_requestForFreeCrossingAtATrafficLight = other_value.requestForFreeCrossingAtATrafficLight();
} else {
  single_value->field_requestForFreeCrossingAtATrafficLight.clean_up();
}
if (other_value.noPassing().is_bound()) {
  single_value->field_noPassing = other_value.noPassing();
} else {
  single_value->field_noPassing.clean_up();
}
if (other_value.noPassingForTrucks().is_bound()) {
  single_value->field_noPassingForTrucks = other_value.noPassingForTrucks();
} else {
  single_value->field_noPassingForTrucks.clean_up();
}
if (other_value.speedLimit().is_bound()) {
  single_value->field_speedLimit = other_value.speedLimit();
} else {
  single_value->field_speedLimit.clean_up();
}
if (other_value.reserved1().is_bound()) {
  single_value->field_reserved1 = other_value.reserved1();
} else {
  single_value->field_reserved1.clean_up();
}
if (other_value.reserved2().is_bound()) {
  single_value->field_reserved2 = other_value.reserved2();
} else {
  single_value->field_reserved2.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SspCAM_template::copy_template(const SspCAM_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.cenDsrcTollingZone().get_selection()) {
single_value->field_cenDsrcTollingZone = other_value.cenDsrcTollingZone();
} else {
single_value->field_cenDsrcTollingZone.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.publicTransport().get_selection()) {
single_value->field_publicTransport = other_value.publicTransport();
} else {
single_value->field_publicTransport.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.specialTransport().get_selection()) {
single_value->field_specialTransport = other_value.specialTransport();
} else {
single_value->field_specialTransport.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.dangerousGoods().get_selection()) {
single_value->field_dangerousGoods = other_value.dangerousGoods();
} else {
single_value->field_dangerousGoods.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.roadwork().get_selection()) {
single_value->field_roadwork = other_value.roadwork();
} else {
single_value->field_roadwork.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rescue().get_selection()) {
single_value->field_rescue = other_value.rescue();
} else {
single_value->field_rescue.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.emergency().get_selection()) {
single_value->field_emergency = other_value.emergency();
} else {
single_value->field_emergency.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.safetyCar().get_selection()) {
single_value->field_safetyCar = other_value.safetyCar();
} else {
single_value->field_safetyCar.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.closedLanes().get_selection()) {
single_value->field_closedLanes = other_value.closedLanes();
} else {
single_value->field_closedLanes.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.requestForRightOfWay().get_selection()) {
single_value->field_requestForRightOfWay = other_value.requestForRightOfWay();
} else {
single_value->field_requestForRightOfWay.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.requestForFreeCrossingAtATrafficLight().get_selection()) {
single_value->field_requestForFreeCrossingAtATrafficLight = other_value.requestForFreeCrossingAtATrafficLight();
} else {
single_value->field_requestForFreeCrossingAtATrafficLight.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.noPassing().get_selection()) {
single_value->field_noPassing = other_value.noPassing();
} else {
single_value->field_noPassing.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.noPassingForTrucks().get_selection()) {
single_value->field_noPassingForTrucks = other_value.noPassingForTrucks();
} else {
single_value->field_noPassingForTrucks.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.speedLimit().get_selection()) {
single_value->field_speedLimit = other_value.speedLimit();
} else {
single_value->field_speedLimit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved1().get_selection()) {
single_value->field_reserved1 = other_value.reserved1();
} else {
single_value->field_reserved1.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.reserved2().get_selection()) {
single_value->field_reserved2 = other_value.reserved2();
} else {
single_value->field_reserved2.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SspCAM_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SspCAM.");
break;
}
set_selection(other_value);
}

SspCAM_template::SspCAM_template()
{
}

SspCAM_template::SspCAM_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SspCAM_template::SspCAM_template(const SspCAM& other_value)
{
copy_value(other_value);
}

SspCAM_template::SspCAM_template(const OPTIONAL<SspCAM>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SspCAM&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.SspCAM from an unbound optional field.");
}
}

SspCAM_template::SspCAM_template(const SspCAM_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SspCAM_template::~SspCAM_template()
{
clean_up();
}

SspCAM_template& SspCAM_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SspCAM_template& SspCAM_template::operator=(const SspCAM& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SspCAM_template& SspCAM_template::operator=(const OPTIONAL<SspCAM>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SspCAM&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.SspCAM.");
}
return *this;
}

SspCAM_template& SspCAM_template::operator=(const SspCAM_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SspCAM_template::match(const SspCAM& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.cenDsrcTollingZone().is_bound()) return FALSE;
if(!single_value->field_cenDsrcTollingZone.match(other_value.cenDsrcTollingZone(), legacy))return FALSE;
if(!other_value.publicTransport().is_bound()) return FALSE;
if(!single_value->field_publicTransport.match(other_value.publicTransport(), legacy))return FALSE;
if(!other_value.specialTransport().is_bound()) return FALSE;
if(!single_value->field_specialTransport.match(other_value.specialTransport(), legacy))return FALSE;
if(!other_value.dangerousGoods().is_bound()) return FALSE;
if(!single_value->field_dangerousGoods.match(other_value.dangerousGoods(), legacy))return FALSE;
if(!other_value.roadwork().is_bound()) return FALSE;
if(!single_value->field_roadwork.match(other_value.roadwork(), legacy))return FALSE;
if(!other_value.rescue().is_bound()) return FALSE;
if(!single_value->field_rescue.match(other_value.rescue(), legacy))return FALSE;
if(!other_value.emergency().is_bound()) return FALSE;
if(!single_value->field_emergency.match(other_value.emergency(), legacy))return FALSE;
if(!other_value.safetyCar().is_bound()) return FALSE;
if(!single_value->field_safetyCar.match(other_value.safetyCar(), legacy))return FALSE;
if(!other_value.closedLanes().is_bound()) return FALSE;
if(!single_value->field_closedLanes.match(other_value.closedLanes(), legacy))return FALSE;
if(!other_value.requestForRightOfWay().is_bound()) return FALSE;
if(!single_value->field_requestForRightOfWay.match(other_value.requestForRightOfWay(), legacy))return FALSE;
if(!other_value.requestForFreeCrossingAtATrafficLight().is_bound()) return FALSE;
if(!single_value->field_requestForFreeCrossingAtATrafficLight.match(other_value.requestForFreeCrossingAtATrafficLight(), legacy))return FALSE;
if(!other_value.noPassing().is_bound()) return FALSE;
if(!single_value->field_noPassing.match(other_value.noPassing(), legacy))return FALSE;
if(!other_value.noPassingForTrucks().is_bound()) return FALSE;
if(!single_value->field_noPassingForTrucks.match(other_value.noPassingForTrucks(), legacy))return FALSE;
if(!other_value.speedLimit().is_bound()) return FALSE;
if(!single_value->field_speedLimit.match(other_value.speedLimit(), legacy))return FALSE;
if(!other_value.reserved1().is_bound()) return FALSE;
if(!single_value->field_reserved1.match(other_value.reserved1(), legacy))return FALSE;
if(!other_value.reserved2().is_bound()) return FALSE;
if(!single_value->field_reserved2.match(other_value.reserved2(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SspCAM.");
}
return FALSE;
}

boolean SspCAM_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_cenDsrcTollingZone.is_bound()) return TRUE;
if (single_value->field_publicTransport.is_bound()) return TRUE;
if (single_value->field_specialTransport.is_bound()) return TRUE;
if (single_value->field_dangerousGoods.is_bound()) return TRUE;
if (single_value->field_roadwork.is_bound()) return TRUE;
if (single_value->field_rescue.is_bound()) return TRUE;
if (single_value->field_emergency.is_bound()) return TRUE;
if (single_value->field_safetyCar.is_bound()) return TRUE;
if (single_value->field_closedLanes.is_bound()) return TRUE;
if (single_value->field_requestForRightOfWay.is_bound()) return TRUE;
if (single_value->field_requestForFreeCrossingAtATrafficLight.is_bound()) return TRUE;
if (single_value->field_noPassing.is_bound()) return TRUE;
if (single_value->field_noPassingForTrucks.is_bound()) return TRUE;
if (single_value->field_speedLimit.is_bound()) return TRUE;
if (single_value->field_reserved1.is_bound()) return TRUE;
if (single_value->field_reserved2.is_bound()) return TRUE;
return FALSE;
}

boolean SspCAM_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_cenDsrcTollingZone.is_value()) return FALSE;
if (!single_value->field_publicTransport.is_value()) return FALSE;
if (!single_value->field_specialTransport.is_value()) return FALSE;
if (!single_value->field_dangerousGoods.is_value()) return FALSE;
if (!single_value->field_roadwork.is_value()) return FALSE;
if (!single_value->field_rescue.is_value()) return FALSE;
if (!single_value->field_emergency.is_value()) return FALSE;
if (!single_value->field_safetyCar.is_value()) return FALSE;
if (!single_value->field_closedLanes.is_value()) return FALSE;
if (!single_value->field_requestForRightOfWay.is_value()) return FALSE;
if (!single_value->field_requestForFreeCrossingAtATrafficLight.is_value()) return FALSE;
if (!single_value->field_noPassing.is_value()) return FALSE;
if (!single_value->field_noPassingForTrucks.is_value()) return FALSE;
if (!single_value->field_speedLimit.is_value()) return FALSE;
if (!single_value->field_reserved1.is_value()) return FALSE;
if (!single_value->field_reserved2.is_value()) return FALSE;
return TRUE;
}

void SspCAM_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SspCAM SspCAM_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.SspCAM.");
SspCAM ret_val;
if (single_value->field_cenDsrcTollingZone.is_bound()) {
ret_val.cenDsrcTollingZone() = single_value->field_cenDsrcTollingZone.valueof();
}
if (single_value->field_publicTransport.is_bound()) {
ret_val.publicTransport() = single_value->field_publicTransport.valueof();
}
if (single_value->field_specialTransport.is_bound()) {
ret_val.specialTransport() = single_value->field_specialTransport.valueof();
}
if (single_value->field_dangerousGoods.is_bound()) {
ret_val.dangerousGoods() = single_value->field_dangerousGoods.valueof();
}
if (single_value->field_roadwork.is_bound()) {
ret_val.roadwork() = single_value->field_roadwork.valueof();
}
if (single_value->field_rescue.is_bound()) {
ret_val.rescue() = single_value->field_rescue.valueof();
}
if (single_value->field_emergency.is_bound()) {
ret_val.emergency() = single_value->field_emergency.valueof();
}
if (single_value->field_safetyCar.is_bound()) {
ret_val.safetyCar() = single_value->field_safetyCar.valueof();
}
if (single_value->field_closedLanes.is_bound()) {
ret_val.closedLanes() = single_value->field_closedLanes.valueof();
}
if (single_value->field_requestForRightOfWay.is_bound()) {
ret_val.requestForRightOfWay() = single_value->field_requestForRightOfWay.valueof();
}
if (single_value->field_requestForFreeCrossingAtATrafficLight.is_bound()) {
ret_val.requestForFreeCrossingAtATrafficLight() = single_value->field_requestForFreeCrossingAtATrafficLight.valueof();
}
if (single_value->field_noPassing.is_bound()) {
ret_val.noPassing() = single_value->field_noPassing.valueof();
}
if (single_value->field_noPassingForTrucks.is_bound()) {
ret_val.noPassingForTrucks() = single_value->field_noPassingForTrucks.valueof();
}
if (single_value->field_speedLimit.is_bound()) {
ret_val.speedLimit() = single_value->field_speedLimit.valueof();
}
if (single_value->field_reserved1.is_bound()) {
ret_val.reserved1() = single_value->field_reserved1.valueof();
}
if (single_value->field_reserved2.is_bound()) {
ret_val.reserved2() = single_value->field_reserved2.valueof();
}
return ret_val;
}

void SspCAM_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.SspCAM.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SspCAM_template[list_length];
}

SspCAM_template& SspCAM_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.SspCAM.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.SspCAM.");
return value_list.list_value[list_index];
}

BITSTRING_template& SspCAM_template::cenDsrcTollingZone()
{
set_specific();
return single_value->field_cenDsrcTollingZone;
}

const BITSTRING_template& SspCAM_template::cenDsrcTollingZone() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cenDsrcTollingZone of a non-specific template of type @LibItsSecurity_TypesAndValues.SspCAM.");
return single_value->field_cenDsrcTollingZone;
}

BITSTRING_template& SspCAM_template::publicTransport()
{
set_specific();
return single_value->field_publicTransport;
}

const BITSTRING_template& SspCAM_template::publicTransport() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field publicTransport of a non-specific template of type @LibItsSecurity_TypesAndValues.SspCAM.");
return single_value->field_publicTransport;
}

BITSTRING_template& SspCAM_template::specialTransport()
{
set_specific();
return single_value->field_specialTransport;
}

const BITSTRING_template& SspCAM_template::specialTransport() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field specialTransport of a non-specific template of type @LibItsSecurity_TypesAndValues.SspCAM.");
return single_value->field_specialTransport;
}

BITSTRING_template& SspCAM_template::dangerousGoods()
{
set_specific();
return single_value->field_dangerousGoods;
}

const BITSTRING_template& SspCAM_template::dangerousGoods() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field dangerousGoods of a non-specific template of type @LibItsSecurity_TypesAndValues.SspCAM.");
return single_value->field_dangerousGoods;
}

BITSTRING_template& SspCAM_template::roadwork()
{
set_specific();
return single_value->field_roadwork;
}

const BITSTRING_template& SspCAM_template::roadwork() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field roadwork of a non-specific template of type @LibItsSecurity_TypesAndValues.SspCAM.");
return single_value->field_roadwork;
}

BITSTRING_template& SspCAM_template::rescue()
{
set_specific();
return single_value->field_rescue;
}

const BITSTRING_template& SspCAM_template::rescue() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rescue of a non-specific template of type @LibItsSecurity_TypesAndValues.SspCAM.");
return single_value->field_rescue;
}

BITSTRING_template& SspCAM_template::emergency()
{
set_specific();
return single_value->field_emergency;
}

const BITSTRING_template& SspCAM_template::emergency() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field emergency of a non-specific template of type @LibItsSecurity_TypesAndValues.SspCAM.");
return single_value->field_emergency;
}

BITSTRING_template& SspCAM_template::safetyCar()
{
set_specific();
return single_value->field_safetyCar;
}

const BITSTRING_template& SspCAM_template::safetyCar() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field safetyCar of a non-specific template of type @LibItsSecurity_TypesAndValues.SspCAM.");
return single_value->field_safetyCar;
}

BITSTRING_template& SspCAM_template::closedLanes()
{
set_specific();
return single_value->field_closedLanes;
}

const BITSTRING_template& SspCAM_template::closedLanes() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field closedLanes of a non-specific template of type @LibItsSecurity_TypesAndValues.SspCAM.");
return single_value->field_closedLanes;
}

BITSTRING_template& SspCAM_template::requestForRightOfWay()
{
set_specific();
return single_value->field_requestForRightOfWay;
}

const BITSTRING_template& SspCAM_template::requestForRightOfWay() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field requestForRightOfWay of a non-specific template of type @LibItsSecurity_TypesAndValues.SspCAM.");
return single_value->field_requestForRightOfWay;
}

BITSTRING_template& SspCAM_template::requestForFreeCrossingAtATrafficLight()
{
set_specific();
return single_value->field_requestForFreeCrossingAtATrafficLight;
}

const BITSTRING_template& SspCAM_template::requestForFreeCrossingAtATrafficLight() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field requestForFreeCrossingAtATrafficLight of a non-specific template of type @LibItsSecurity_TypesAndValues.SspCAM.");
return single_value->field_requestForFreeCrossingAtATrafficLight;
}

BITSTRING_template& SspCAM_template::noPassing()
{
set_specific();
return single_value->field_noPassing;
}

const BITSTRING_template& SspCAM_template::noPassing() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field noPassing of a non-specific template of type @LibItsSecurity_TypesAndValues.SspCAM.");
return single_value->field_noPassing;
}

BITSTRING_template& SspCAM_template::noPassingForTrucks()
{
set_specific();
return single_value->field_noPassingForTrucks;
}

const BITSTRING_template& SspCAM_template::noPassingForTrucks() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field noPassingForTrucks of a non-specific template of type @LibItsSecurity_TypesAndValues.SspCAM.");
return single_value->field_noPassingForTrucks;
}

BITSTRING_template& SspCAM_template::speedLimit()
{
set_specific();
return single_value->field_speedLimit;
}

const BITSTRING_template& SspCAM_template::speedLimit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field speedLimit of a non-specific template of type @LibItsSecurity_TypesAndValues.SspCAM.");
return single_value->field_speedLimit;
}

BITSTRING_template& SspCAM_template::reserved1()
{
set_specific();
return single_value->field_reserved1;
}

const BITSTRING_template& SspCAM_template::reserved1() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved1 of a non-specific template of type @LibItsSecurity_TypesAndValues.SspCAM.");
return single_value->field_reserved1;
}

BITSTRING_template& SspCAM_template::reserved2()
{
set_specific();
return single_value->field_reserved2;
}

const BITSTRING_template& SspCAM_template::reserved2() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field reserved2 of a non-specific template of type @LibItsSecurity_TypesAndValues.SspCAM.");
return single_value->field_reserved2;
}

int SspCAM_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SspCAM which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 16;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SspCAM containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SspCAM containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SspCAM containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SspCAM containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SspCAM containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SspCAM.");
  }
  return 0;
}

void SspCAM_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ cenDsrcTollingZone := ");
single_value->field_cenDsrcTollingZone.log();
TTCN_Logger::log_event_str(", publicTransport := ");
single_value->field_publicTransport.log();
TTCN_Logger::log_event_str(", specialTransport := ");
single_value->field_specialTransport.log();
TTCN_Logger::log_event_str(", dangerousGoods := ");
single_value->field_dangerousGoods.log();
TTCN_Logger::log_event_str(", roadwork := ");
single_value->field_roadwork.log();
TTCN_Logger::log_event_str(", rescue := ");
single_value->field_rescue.log();
TTCN_Logger::log_event_str(", emergency := ");
single_value->field_emergency.log();
TTCN_Logger::log_event_str(", safetyCar := ");
single_value->field_safetyCar.log();
TTCN_Logger::log_event_str(", closedLanes := ");
single_value->field_closedLanes.log();
TTCN_Logger::log_event_str(", requestForRightOfWay := ");
single_value->field_requestForRightOfWay.log();
TTCN_Logger::log_event_str(", requestForFreeCrossingAtATrafficLight := ");
single_value->field_requestForFreeCrossingAtATrafficLight.log();
TTCN_Logger::log_event_str(", noPassing := ");
single_value->field_noPassing.log();
TTCN_Logger::log_event_str(", noPassingForTrucks := ");
single_value->field_noPassingForTrucks.log();
TTCN_Logger::log_event_str(", speedLimit := ");
single_value->field_speedLimit.log();
TTCN_Logger::log_event_str(", reserved1 := ");
single_value->field_reserved1.log();
TTCN_Logger::log_event_str(", reserved2 := ");
single_value->field_reserved2.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SspCAM_template::log_match(const SspCAM& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_cenDsrcTollingZone.match(match_value.cenDsrcTollingZone(), legacy)){
TTCN_Logger::log_logmatch_info(".cenDsrcTollingZone");
single_value->field_cenDsrcTollingZone.log_match(match_value.cenDsrcTollingZone(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_publicTransport.match(match_value.publicTransport(), legacy)){
TTCN_Logger::log_logmatch_info(".publicTransport");
single_value->field_publicTransport.log_match(match_value.publicTransport(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_specialTransport.match(match_value.specialTransport(), legacy)){
TTCN_Logger::log_logmatch_info(".specialTransport");
single_value->field_specialTransport.log_match(match_value.specialTransport(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_dangerousGoods.match(match_value.dangerousGoods(), legacy)){
TTCN_Logger::log_logmatch_info(".dangerousGoods");
single_value->field_dangerousGoods.log_match(match_value.dangerousGoods(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_roadwork.match(match_value.roadwork(), legacy)){
TTCN_Logger::log_logmatch_info(".roadwork");
single_value->field_roadwork.log_match(match_value.roadwork(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_rescue.match(match_value.rescue(), legacy)){
TTCN_Logger::log_logmatch_info(".rescue");
single_value->field_rescue.log_match(match_value.rescue(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_emergency.match(match_value.emergency(), legacy)){
TTCN_Logger::log_logmatch_info(".emergency");
single_value->field_emergency.log_match(match_value.emergency(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_safetyCar.match(match_value.safetyCar(), legacy)){
TTCN_Logger::log_logmatch_info(".safetyCar");
single_value->field_safetyCar.log_match(match_value.safetyCar(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_closedLanes.match(match_value.closedLanes(), legacy)){
TTCN_Logger::log_logmatch_info(".closedLanes");
single_value->field_closedLanes.log_match(match_value.closedLanes(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_requestForRightOfWay.match(match_value.requestForRightOfWay(), legacy)){
TTCN_Logger::log_logmatch_info(".requestForRightOfWay");
single_value->field_requestForRightOfWay.log_match(match_value.requestForRightOfWay(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_requestForFreeCrossingAtATrafficLight.match(match_value.requestForFreeCrossingAtATrafficLight(), legacy)){
TTCN_Logger::log_logmatch_info(".requestForFreeCrossingAtATrafficLight");
single_value->field_requestForFreeCrossingAtATrafficLight.log_match(match_value.requestForFreeCrossingAtATrafficLight(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_noPassing.match(match_value.noPassing(), legacy)){
TTCN_Logger::log_logmatch_info(".noPassing");
single_value->field_noPassing.log_match(match_value.noPassing(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_noPassingForTrucks.match(match_value.noPassingForTrucks(), legacy)){
TTCN_Logger::log_logmatch_info(".noPassingForTrucks");
single_value->field_noPassingForTrucks.log_match(match_value.noPassingForTrucks(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_speedLimit.match(match_value.speedLimit(), legacy)){
TTCN_Logger::log_logmatch_info(".speedLimit");
single_value->field_speedLimit.log_match(match_value.speedLimit(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved1.match(match_value.reserved1(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved1");
single_value->field_reserved1.log_match(match_value.reserved1(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_reserved2.match(match_value.reserved2(), legacy)){
TTCN_Logger::log_logmatch_info(".reserved2");
single_value->field_reserved2.log_match(match_value.reserved2(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ cenDsrcTollingZone := ");
single_value->field_cenDsrcTollingZone.log_match(match_value.cenDsrcTollingZone(), legacy);
TTCN_Logger::log_event_str(", publicTransport := ");
single_value->field_publicTransport.log_match(match_value.publicTransport(), legacy);
TTCN_Logger::log_event_str(", specialTransport := ");
single_value->field_specialTransport.log_match(match_value.specialTransport(), legacy);
TTCN_Logger::log_event_str(", dangerousGoods := ");
single_value->field_dangerousGoods.log_match(match_value.dangerousGoods(), legacy);
TTCN_Logger::log_event_str(", roadwork := ");
single_value->field_roadwork.log_match(match_value.roadwork(), legacy);
TTCN_Logger::log_event_str(", rescue := ");
single_value->field_rescue.log_match(match_value.rescue(), legacy);
TTCN_Logger::log_event_str(", emergency := ");
single_value->field_emergency.log_match(match_value.emergency(), legacy);
TTCN_Logger::log_event_str(", safetyCar := ");
single_value->field_safetyCar.log_match(match_value.safetyCar(), legacy);
TTCN_Logger::log_event_str(", closedLanes := ");
single_value->field_closedLanes.log_match(match_value.closedLanes(), legacy);
TTCN_Logger::log_event_str(", requestForRightOfWay := ");
single_value->field_requestForRightOfWay.log_match(match_value.requestForRightOfWay(), legacy);
TTCN_Logger::log_event_str(", requestForFreeCrossingAtATrafficLight := ");
single_value->field_requestForFreeCrossingAtATrafficLight.log_match(match_value.requestForFreeCrossingAtATrafficLight(), legacy);
TTCN_Logger::log_event_str(", noPassing := ");
single_value->field_noPassing.log_match(match_value.noPassing(), legacy);
TTCN_Logger::log_event_str(", noPassingForTrucks := ");
single_value->field_noPassingForTrucks.log_match(match_value.noPassingForTrucks(), legacy);
TTCN_Logger::log_event_str(", speedLimit := ");
single_value->field_speedLimit.log_match(match_value.speedLimit(), legacy);
TTCN_Logger::log_event_str(", reserved1 := ");
single_value->field_reserved1.log_match(match_value.reserved1(), legacy);
TTCN_Logger::log_event_str(", reserved2 := ");
single_value->field_reserved2.log_match(match_value.reserved2(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SspCAM_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_cenDsrcTollingZone.encode_text(text_buf);
single_value->field_publicTransport.encode_text(text_buf);
single_value->field_specialTransport.encode_text(text_buf);
single_value->field_dangerousGoods.encode_text(text_buf);
single_value->field_roadwork.encode_text(text_buf);
single_value->field_rescue.encode_text(text_buf);
single_value->field_emergency.encode_text(text_buf);
single_value->field_safetyCar.encode_text(text_buf);
single_value->field_closedLanes.encode_text(text_buf);
single_value->field_requestForRightOfWay.encode_text(text_buf);
single_value->field_requestForFreeCrossingAtATrafficLight.encode_text(text_buf);
single_value->field_noPassing.encode_text(text_buf);
single_value->field_noPassingForTrucks.encode_text(text_buf);
single_value->field_speedLimit.encode_text(text_buf);
single_value->field_reserved1.encode_text(text_buf);
single_value->field_reserved2.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SspCAM.");
}
}

void SspCAM_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_cenDsrcTollingZone.decode_text(text_buf);
single_value->field_publicTransport.decode_text(text_buf);
single_value->field_specialTransport.decode_text(text_buf);
single_value->field_dangerousGoods.decode_text(text_buf);
single_value->field_roadwork.decode_text(text_buf);
single_value->field_rescue.decode_text(text_buf);
single_value->field_emergency.decode_text(text_buf);
single_value->field_safetyCar.decode_text(text_buf);
single_value->field_closedLanes.decode_text(text_buf);
single_value->field_requestForRightOfWay.decode_text(text_buf);
single_value->field_requestForFreeCrossingAtATrafficLight.decode_text(text_buf);
single_value->field_noPassing.decode_text(text_buf);
single_value->field_noPassingForTrucks.decode_text(text_buf);
single_value->field_speedLimit.decode_text(text_buf);
single_value->field_reserved1.decode_text(text_buf);
single_value->field_reserved2.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SspCAM_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.SspCAM.");
}
}

void SspCAM_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.SspCAM'");
    }
    if (strcmp("cenDsrcTollingZone", param_field) == 0) {
      cenDsrcTollingZone().set_param(param);
      return;
    } else if (strcmp("publicTransport", param_field) == 0) {
      publicTransport().set_param(param);
      return;
    } else if (strcmp("specialTransport", param_field) == 0) {
      specialTransport().set_param(param);
      return;
    } else if (strcmp("dangerousGoods", param_field) == 0) {
      dangerousGoods().set_param(param);
      return;
    } else if (strcmp("roadwork", param_field) == 0) {
      roadwork().set_param(param);
      return;
    } else if (strcmp("rescue", param_field) == 0) {
      rescue().set_param(param);
      return;
    } else if (strcmp("emergency", param_field) == 0) {
      emergency().set_param(param);
      return;
    } else if (strcmp("safetyCar", param_field) == 0) {
      safetyCar().set_param(param);
      return;
    } else if (strcmp("closedLanes", param_field) == 0) {
      closedLanes().set_param(param);
      return;
    } else if (strcmp("requestForRightOfWay", param_field) == 0) {
      requestForRightOfWay().set_param(param);
      return;
    } else if (strcmp("requestForFreeCrossingAtATrafficLight", param_field) == 0) {
      requestForFreeCrossingAtATrafficLight().set_param(param);
      return;
    } else if (strcmp("noPassing", param_field) == 0) {
      noPassing().set_param(param);
      return;
    } else if (strcmp("noPassingForTrucks", param_field) == 0) {
      noPassingForTrucks().set_param(param);
      return;
    } else if (strcmp("speedLimit", param_field) == 0) {
      speedLimit().set_param(param);
      return;
    } else if (strcmp("reserved1", param_field) == 0) {
      reserved1().set_param(param);
      return;
    } else if (strcmp("reserved2", param_field) == 0) {
      reserved2().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.SspCAM'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SspCAM_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (16<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.SspCAM has 16 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) cenDsrcTollingZone().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) publicTransport().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) specialTransport().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) dangerousGoods().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) roadwork().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) rescue().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) emergency().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) safetyCar().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) closedLanes().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) requestForRightOfWay().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) requestForFreeCrossingAtATrafficLight().set_param(*mp->get_elem(10));
    if (mp->get_size()>11 && mp->get_elem(11)->get_type()!=Module_Param::MP_NotUsed) noPassing().set_param(*mp->get_elem(11));
    if (mp->get_size()>12 && mp->get_elem(12)->get_type()!=Module_Param::MP_NotUsed) noPassingForTrucks().set_param(*mp->get_elem(12));
    if (mp->get_size()>13 && mp->get_elem(13)->get_type()!=Module_Param::MP_NotUsed) speedLimit().set_param(*mp->get_elem(13));
    if (mp->get_size()>14 && mp->get_elem(14)->get_type()!=Module_Param::MP_NotUsed) reserved1().set_param(*mp->get_elem(14));
    if (mp->get_size()>15 && mp->get_elem(15)->get_type()!=Module_Param::MP_NotUsed) reserved2().set_param(*mp->get_elem(15));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cenDsrcTollingZone")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cenDsrcTollingZone().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "publicTransport")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          publicTransport().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "specialTransport")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          specialTransport().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dangerousGoods")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dangerousGoods().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "roadwork")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          roadwork().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rescue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rescue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "emergency")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          emergency().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "safetyCar")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          safetyCar().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "closedLanes")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          closedLanes().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "requestForRightOfWay")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          requestForRightOfWay().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "requestForFreeCrossingAtATrafficLight")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          requestForFreeCrossingAtATrafficLight().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "noPassing")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          noPassing().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "noPassingForTrucks")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          noPassingForTrucks().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "speedLimit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          speedLimit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved1")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved1().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "reserved2")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          reserved2().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.SspCAM: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.SspCAM");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SspCAM_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.SspCAM'");
    }
    if (strcmp("cenDsrcTollingZone", param_field) == 0) {
      return cenDsrcTollingZone().get_param(param_name);
    } else if (strcmp("publicTransport", param_field) == 0) {
      return publicTransport().get_param(param_name);
    } else if (strcmp("specialTransport", param_field) == 0) {
      return specialTransport().get_param(param_name);
    } else if (strcmp("dangerousGoods", param_field) == 0) {
      return dangerousGoods().get_param(param_name);
    } else if (strcmp("roadwork", param_field) == 0) {
      return roadwork().get_param(param_name);
    } else if (strcmp("rescue", param_field) == 0) {
      return rescue().get_param(param_name);
    } else if (strcmp("emergency", param_field) == 0) {
      return emergency().get_param(param_name);
    } else if (strcmp("safetyCar", param_field) == 0) {
      return safetyCar().get_param(param_name);
    } else if (strcmp("closedLanes", param_field) == 0) {
      return closedLanes().get_param(param_name);
    } else if (strcmp("requestForRightOfWay", param_field) == 0) {
      return requestForRightOfWay().get_param(param_name);
    } else if (strcmp("requestForFreeCrossingAtATrafficLight", param_field) == 0) {
      return requestForFreeCrossingAtATrafficLight().get_param(param_name);
    } else if (strcmp("noPassing", param_field) == 0) {
      return noPassing().get_param(param_name);
    } else if (strcmp("noPassingForTrucks", param_field) == 0) {
      return noPassingForTrucks().get_param(param_name);
    } else if (strcmp("speedLimit", param_field) == 0) {
      return speedLimit().get_param(param_name);
    } else if (strcmp("reserved1", param_field) == 0) {
      return reserved1().get_param(param_name);
    } else if (strcmp("reserved2", param_field) == 0) {
      return reserved2().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SspCAM'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_cenDsrcTollingZone = single_value->field_cenDsrcTollingZone.get_param(param_name);
    mp_field_cenDsrcTollingZone->set_id(new Module_Param_FieldName(mcopystr("cenDsrcTollingZone")));
    mp->add_elem(mp_field_cenDsrcTollingZone);
    Module_Param* mp_field_publicTransport = single_value->field_publicTransport.get_param(param_name);
    mp_field_publicTransport->set_id(new Module_Param_FieldName(mcopystr("publicTransport")));
    mp->add_elem(mp_field_publicTransport);
    Module_Param* mp_field_specialTransport = single_value->field_specialTransport.get_param(param_name);
    mp_field_specialTransport->set_id(new Module_Param_FieldName(mcopystr("specialTransport")));
    mp->add_elem(mp_field_specialTransport);
    Module_Param* mp_field_dangerousGoods = single_value->field_dangerousGoods.get_param(param_name);
    mp_field_dangerousGoods->set_id(new Module_Param_FieldName(mcopystr("dangerousGoods")));
    mp->add_elem(mp_field_dangerousGoods);
    Module_Param* mp_field_roadwork = single_value->field_roadwork.get_param(param_name);
    mp_field_roadwork->set_id(new Module_Param_FieldName(mcopystr("roadwork")));
    mp->add_elem(mp_field_roadwork);
    Module_Param* mp_field_rescue = single_value->field_rescue.get_param(param_name);
    mp_field_rescue->set_id(new Module_Param_FieldName(mcopystr("rescue")));
    mp->add_elem(mp_field_rescue);
    Module_Param* mp_field_emergency = single_value->field_emergency.get_param(param_name);
    mp_field_emergency->set_id(new Module_Param_FieldName(mcopystr("emergency")));
    mp->add_elem(mp_field_emergency);
    Module_Param* mp_field_safetyCar = single_value->field_safetyCar.get_param(param_name);
    mp_field_safetyCar->set_id(new Module_Param_FieldName(mcopystr("safetyCar")));
    mp->add_elem(mp_field_safetyCar);
    Module_Param* mp_field_closedLanes = single_value->field_closedLanes.get_param(param_name);
    mp_field_closedLanes->set_id(new Module_Param_FieldName(mcopystr("closedLanes")));
    mp->add_elem(mp_field_closedLanes);
    Module_Param* mp_field_requestForRightOfWay = single_value->field_requestForRightOfWay.get_param(param_name);
    mp_field_requestForRightOfWay->set_id(new Module_Param_FieldName(mcopystr("requestForRightOfWay")));
    mp->add_elem(mp_field_requestForRightOfWay);
    Module_Param* mp_field_requestForFreeCrossingAtATrafficLight = single_value->field_requestForFreeCrossingAtATrafficLight.get_param(param_name);
    mp_field_requestForFreeCrossingAtATrafficLight->set_id(new Module_Param_FieldName(mcopystr("requestForFreeCrossingAtATrafficLight")));
    mp->add_elem(mp_field_requestForFreeCrossingAtATrafficLight);
    Module_Param* mp_field_noPassing = single_value->field_noPassing.get_param(param_name);
    mp_field_noPassing->set_id(new Module_Param_FieldName(mcopystr("noPassing")));
    mp->add_elem(mp_field_noPassing);
    Module_Param* mp_field_noPassingForTrucks = single_value->field_noPassingForTrucks.get_param(param_name);
    mp_field_noPassingForTrucks->set_id(new Module_Param_FieldName(mcopystr("noPassingForTrucks")));
    mp->add_elem(mp_field_noPassingForTrucks);
    Module_Param* mp_field_speedLimit = single_value->field_speedLimit.get_param(param_name);
    mp_field_speedLimit->set_id(new Module_Param_FieldName(mcopystr("speedLimit")));
    mp->add_elem(mp_field_speedLimit);
    Module_Param* mp_field_reserved1 = single_value->field_reserved1.get_param(param_name);
    mp_field_reserved1->set_id(new Module_Param_FieldName(mcopystr("reserved1")));
    mp->add_elem(mp_field_reserved1);
    Module_Param* mp_field_reserved2 = single_value->field_reserved2.get_param(param_name);
    mp_field_reserved2->set_id(new Module_Param_FieldName(mcopystr("reserved2")));
    mp->add_elem(mp_field_reserved2);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SspCAM_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_cenDsrcTollingZone.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspCAM");
single_value->field_publicTransport.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspCAM");
single_value->field_specialTransport.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspCAM");
single_value->field_dangerousGoods.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspCAM");
single_value->field_roadwork.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspCAM");
single_value->field_rescue.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspCAM");
single_value->field_emergency.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspCAM");
single_value->field_safetyCar.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspCAM");
single_value->field_closedLanes.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspCAM");
single_value->field_requestForRightOfWay.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspCAM");
single_value->field_requestForFreeCrossingAtATrafficLight.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspCAM");
single_value->field_noPassing.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspCAM");
single_value->field_noPassingForTrucks.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspCAM");
single_value->field_speedLimit.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspCAM");
single_value->field_reserved1.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspCAM");
single_value->field_reserved2.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspCAM");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspCAM");
}

boolean SspCAM_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SspCAM_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SspDENM::SspDENM()
{
  bound_flag = FALSE;
}

SspDENM::SspDENM(const BITSTRING& par_trafficCondition,
    const BITSTRING& par_accident,
    const BITSTRING& par_roadworks,
    const BITSTRING& par_adverseWeatherCondition__Adhesion,
    const BITSTRING& par_hazardousLocation__SurfaceCondition,
    const BITSTRING& par_hazardousLocation__ObstacleOnTheRoad,
    const BITSTRING& par_hazardousLocation__AnimalOnTheRoad,
    const BITSTRING& par_humanPresenceOnTheRoad,
    const BITSTRING& par_wrongWayDriving,
    const BITSTRING& par_rescueAndRecoveryWorkInProgress,
    const BITSTRING& par_adverseWeatherCondition__ExtremeWeatherCondition,
    const BITSTRING& par_adverseWeatherCondition__Visibility,
    const BITSTRING& par_adverseWeatherCondition__Precipitation,
    const BITSTRING& par_slowVehicle,
    const BITSTRING& par_dangerousEndOfQueue,
    const BITSTRING& par_vehicleBreakdown,
    const BITSTRING& par_postCrash,
    const BITSTRING& par_humanProblem,
    const BITSTRING& par_stationaryVehicle,
    const BITSTRING& par_emergencyVehicleApproaching,
    const BITSTRING& par_hazardousLocation__DangerousCurve,
    const BITSTRING& par_collisionRisk,
    const BITSTRING& par_signalViolation,
    const BITSTRING& par_dangerousSituation)
  :   field_trafficCondition(par_trafficCondition),
  field_accident(par_accident),
  field_roadworks(par_roadworks),
  field_adverseWeatherCondition__Adhesion(par_adverseWeatherCondition__Adhesion),
  field_hazardousLocation__SurfaceCondition(par_hazardousLocation__SurfaceCondition),
  field_hazardousLocation__ObstacleOnTheRoad(par_hazardousLocation__ObstacleOnTheRoad),
  field_hazardousLocation__AnimalOnTheRoad(par_hazardousLocation__AnimalOnTheRoad),
  field_humanPresenceOnTheRoad(par_humanPresenceOnTheRoad),
  field_wrongWayDriving(par_wrongWayDriving),
  field_rescueAndRecoveryWorkInProgress(par_rescueAndRecoveryWorkInProgress),
  field_adverseWeatherCondition__ExtremeWeatherCondition(par_adverseWeatherCondition__ExtremeWeatherCondition),
  field_adverseWeatherCondition__Visibility(par_adverseWeatherCondition__Visibility),
  field_adverseWeatherCondition__Precipitation(par_adverseWeatherCondition__Precipitation),
  field_slowVehicle(par_slowVehicle),
  field_dangerousEndOfQueue(par_dangerousEndOfQueue),
  field_vehicleBreakdown(par_vehicleBreakdown),
  field_postCrash(par_postCrash),
  field_humanProblem(par_humanProblem),
  field_stationaryVehicle(par_stationaryVehicle),
  field_emergencyVehicleApproaching(par_emergencyVehicleApproaching),
  field_hazardousLocation__DangerousCurve(par_hazardousLocation__DangerousCurve),
  field_collisionRisk(par_collisionRisk),
  field_signalViolation(par_signalViolation),
  field_dangerousSituation(par_dangerousSituation)
{
  bound_flag = TRUE;
}

SspDENM::SspDENM(const SspDENM& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.SspDENM.");
bound_flag = TRUE;
if (other_value.trafficCondition().is_bound()) field_trafficCondition = other_value.trafficCondition();
else field_trafficCondition.clean_up();
if (other_value.accident().is_bound()) field_accident = other_value.accident();
else field_accident.clean_up();
if (other_value.roadworks().is_bound()) field_roadworks = other_value.roadworks();
else field_roadworks.clean_up();
if (other_value.adverseWeatherCondition__Adhesion().is_bound()) field_adverseWeatherCondition__Adhesion = other_value.adverseWeatherCondition__Adhesion();
else field_adverseWeatherCondition__Adhesion.clean_up();
if (other_value.hazardousLocation__SurfaceCondition().is_bound()) field_hazardousLocation__SurfaceCondition = other_value.hazardousLocation__SurfaceCondition();
else field_hazardousLocation__SurfaceCondition.clean_up();
if (other_value.hazardousLocation__ObstacleOnTheRoad().is_bound()) field_hazardousLocation__ObstacleOnTheRoad = other_value.hazardousLocation__ObstacleOnTheRoad();
else field_hazardousLocation__ObstacleOnTheRoad.clean_up();
if (other_value.hazardousLocation__AnimalOnTheRoad().is_bound()) field_hazardousLocation__AnimalOnTheRoad = other_value.hazardousLocation__AnimalOnTheRoad();
else field_hazardousLocation__AnimalOnTheRoad.clean_up();
if (other_value.humanPresenceOnTheRoad().is_bound()) field_humanPresenceOnTheRoad = other_value.humanPresenceOnTheRoad();
else field_humanPresenceOnTheRoad.clean_up();
if (other_value.wrongWayDriving().is_bound()) field_wrongWayDriving = other_value.wrongWayDriving();
else field_wrongWayDriving.clean_up();
if (other_value.rescueAndRecoveryWorkInProgress().is_bound()) field_rescueAndRecoveryWorkInProgress = other_value.rescueAndRecoveryWorkInProgress();
else field_rescueAndRecoveryWorkInProgress.clean_up();
if (other_value.adverseWeatherCondition__ExtremeWeatherCondition().is_bound()) field_adverseWeatherCondition__ExtremeWeatherCondition = other_value.adverseWeatherCondition__ExtremeWeatherCondition();
else field_adverseWeatherCondition__ExtremeWeatherCondition.clean_up();
if (other_value.adverseWeatherCondition__Visibility().is_bound()) field_adverseWeatherCondition__Visibility = other_value.adverseWeatherCondition__Visibility();
else field_adverseWeatherCondition__Visibility.clean_up();
if (other_value.adverseWeatherCondition__Precipitation().is_bound()) field_adverseWeatherCondition__Precipitation = other_value.adverseWeatherCondition__Precipitation();
else field_adverseWeatherCondition__Precipitation.clean_up();
if (other_value.slowVehicle().is_bound()) field_slowVehicle = other_value.slowVehicle();
else field_slowVehicle.clean_up();
if (other_value.dangerousEndOfQueue().is_bound()) field_dangerousEndOfQueue = other_value.dangerousEndOfQueue();
else field_dangerousEndOfQueue.clean_up();
if (other_value.vehicleBreakdown().is_bound()) field_vehicleBreakdown = other_value.vehicleBreakdown();
else field_vehicleBreakdown.clean_up();
if (other_value.postCrash().is_bound()) field_postCrash = other_value.postCrash();
else field_postCrash.clean_up();
if (other_value.humanProblem().is_bound()) field_humanProblem = other_value.humanProblem();
else field_humanProblem.clean_up();
if (other_value.stationaryVehicle().is_bound()) field_stationaryVehicle = other_value.stationaryVehicle();
else field_stationaryVehicle.clean_up();
if (other_value.emergencyVehicleApproaching().is_bound()) field_emergencyVehicleApproaching = other_value.emergencyVehicleApproaching();
else field_emergencyVehicleApproaching.clean_up();
if (other_value.hazardousLocation__DangerousCurve().is_bound()) field_hazardousLocation__DangerousCurve = other_value.hazardousLocation__DangerousCurve();
else field_hazardousLocation__DangerousCurve.clean_up();
if (other_value.collisionRisk().is_bound()) field_collisionRisk = other_value.collisionRisk();
else field_collisionRisk.clean_up();
if (other_value.signalViolation().is_bound()) field_signalViolation = other_value.signalViolation();
else field_signalViolation.clean_up();
if (other_value.dangerousSituation().is_bound()) field_dangerousSituation = other_value.dangerousSituation();
else field_dangerousSituation.clean_up();
}

void SspDENM::clean_up()
{
field_trafficCondition.clean_up();
field_accident.clean_up();
field_roadworks.clean_up();
field_adverseWeatherCondition__Adhesion.clean_up();
field_hazardousLocation__SurfaceCondition.clean_up();
field_hazardousLocation__ObstacleOnTheRoad.clean_up();
field_hazardousLocation__AnimalOnTheRoad.clean_up();
field_humanPresenceOnTheRoad.clean_up();
field_wrongWayDriving.clean_up();
field_rescueAndRecoveryWorkInProgress.clean_up();
field_adverseWeatherCondition__ExtremeWeatherCondition.clean_up();
field_adverseWeatherCondition__Visibility.clean_up();
field_adverseWeatherCondition__Precipitation.clean_up();
field_slowVehicle.clean_up();
field_dangerousEndOfQueue.clean_up();
field_vehicleBreakdown.clean_up();
field_postCrash.clean_up();
field_humanProblem.clean_up();
field_stationaryVehicle.clean_up();
field_emergencyVehicleApproaching.clean_up();
field_hazardousLocation__DangerousCurve.clean_up();
field_collisionRisk.clean_up();
field_signalViolation.clean_up();
field_dangerousSituation.clean_up();
bound_flag = FALSE;
}

SspDENM& SspDENM::operator=(const SspDENM& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.SspDENM.");
  bound_flag = TRUE;
  if (other_value.trafficCondition().is_bound()) field_trafficCondition = other_value.trafficCondition();
  else field_trafficCondition.clean_up();
  if (other_value.accident().is_bound()) field_accident = other_value.accident();
  else field_accident.clean_up();
  if (other_value.roadworks().is_bound()) field_roadworks = other_value.roadworks();
  else field_roadworks.clean_up();
  if (other_value.adverseWeatherCondition__Adhesion().is_bound()) field_adverseWeatherCondition__Adhesion = other_value.adverseWeatherCondition__Adhesion();
  else field_adverseWeatherCondition__Adhesion.clean_up();
  if (other_value.hazardousLocation__SurfaceCondition().is_bound()) field_hazardousLocation__SurfaceCondition = other_value.hazardousLocation__SurfaceCondition();
  else field_hazardousLocation__SurfaceCondition.clean_up();
  if (other_value.hazardousLocation__ObstacleOnTheRoad().is_bound()) field_hazardousLocation__ObstacleOnTheRoad = other_value.hazardousLocation__ObstacleOnTheRoad();
  else field_hazardousLocation__ObstacleOnTheRoad.clean_up();
  if (other_value.hazardousLocation__AnimalOnTheRoad().is_bound()) field_hazardousLocation__AnimalOnTheRoad = other_value.hazardousLocation__AnimalOnTheRoad();
  else field_hazardousLocation__AnimalOnTheRoad.clean_up();
  if (other_value.humanPresenceOnTheRoad().is_bound()) field_humanPresenceOnTheRoad = other_value.humanPresenceOnTheRoad();
  else field_humanPresenceOnTheRoad.clean_up();
  if (other_value.wrongWayDriving().is_bound()) field_wrongWayDriving = other_value.wrongWayDriving();
  else field_wrongWayDriving.clean_up();
  if (other_value.rescueAndRecoveryWorkInProgress().is_bound()) field_rescueAndRecoveryWorkInProgress = other_value.rescueAndRecoveryWorkInProgress();
  else field_rescueAndRecoveryWorkInProgress.clean_up();
  if (other_value.adverseWeatherCondition__ExtremeWeatherCondition().is_bound()) field_adverseWeatherCondition__ExtremeWeatherCondition = other_value.adverseWeatherCondition__ExtremeWeatherCondition();
  else field_adverseWeatherCondition__ExtremeWeatherCondition.clean_up();
  if (other_value.adverseWeatherCondition__Visibility().is_bound()) field_adverseWeatherCondition__Visibility = other_value.adverseWeatherCondition__Visibility();
  else field_adverseWeatherCondition__Visibility.clean_up();
  if (other_value.adverseWeatherCondition__Precipitation().is_bound()) field_adverseWeatherCondition__Precipitation = other_value.adverseWeatherCondition__Precipitation();
  else field_adverseWeatherCondition__Precipitation.clean_up();
  if (other_value.slowVehicle().is_bound()) field_slowVehicle = other_value.slowVehicle();
  else field_slowVehicle.clean_up();
  if (other_value.dangerousEndOfQueue().is_bound()) field_dangerousEndOfQueue = other_value.dangerousEndOfQueue();
  else field_dangerousEndOfQueue.clean_up();
  if (other_value.vehicleBreakdown().is_bound()) field_vehicleBreakdown = other_value.vehicleBreakdown();
  else field_vehicleBreakdown.clean_up();
  if (other_value.postCrash().is_bound()) field_postCrash = other_value.postCrash();
  else field_postCrash.clean_up();
  if (other_value.humanProblem().is_bound()) field_humanProblem = other_value.humanProblem();
  else field_humanProblem.clean_up();
  if (other_value.stationaryVehicle().is_bound()) field_stationaryVehicle = other_value.stationaryVehicle();
  else field_stationaryVehicle.clean_up();
  if (other_value.emergencyVehicleApproaching().is_bound()) field_emergencyVehicleApproaching = other_value.emergencyVehicleApproaching();
  else field_emergencyVehicleApproaching.clean_up();
  if (other_value.hazardousLocation__DangerousCurve().is_bound()) field_hazardousLocation__DangerousCurve = other_value.hazardousLocation__DangerousCurve();
  else field_hazardousLocation__DangerousCurve.clean_up();
  if (other_value.collisionRisk().is_bound()) field_collisionRisk = other_value.collisionRisk();
  else field_collisionRisk.clean_up();
  if (other_value.signalViolation().is_bound()) field_signalViolation = other_value.signalViolation();
  else field_signalViolation.clean_up();
  if (other_value.dangerousSituation().is_bound()) field_dangerousSituation = other_value.dangerousSituation();
  else field_dangerousSituation.clean_up();
}
return *this;
}

boolean SspDENM::operator==(const SspDENM& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_trafficCondition==other_value.field_trafficCondition
  && field_accident==other_value.field_accident
  && field_roadworks==other_value.field_roadworks
  && field_adverseWeatherCondition__Adhesion==other_value.field_adverseWeatherCondition__Adhesion
  && field_hazardousLocation__SurfaceCondition==other_value.field_hazardousLocation__SurfaceCondition
  && field_hazardousLocation__ObstacleOnTheRoad==other_value.field_hazardousLocation__ObstacleOnTheRoad
  && field_hazardousLocation__AnimalOnTheRoad==other_value.field_hazardousLocation__AnimalOnTheRoad
  && field_humanPresenceOnTheRoad==other_value.field_humanPresenceOnTheRoad
  && field_wrongWayDriving==other_value.field_wrongWayDriving
  && field_rescueAndRecoveryWorkInProgress==other_value.field_rescueAndRecoveryWorkInProgress
  && field_adverseWeatherCondition__ExtremeWeatherCondition==other_value.field_adverseWeatherCondition__ExtremeWeatherCondition
  && field_adverseWeatherCondition__Visibility==other_value.field_adverseWeatherCondition__Visibility
  && field_adverseWeatherCondition__Precipitation==other_value.field_adverseWeatherCondition__Precipitation
  && field_slowVehicle==other_value.field_slowVehicle
  && field_dangerousEndOfQueue==other_value.field_dangerousEndOfQueue
  && field_vehicleBreakdown==other_value.field_vehicleBreakdown
  && field_postCrash==other_value.field_postCrash
  && field_humanProblem==other_value.field_humanProblem
  && field_stationaryVehicle==other_value.field_stationaryVehicle
  && field_emergencyVehicleApproaching==other_value.field_emergencyVehicleApproaching
  && field_hazardousLocation__DangerousCurve==other_value.field_hazardousLocation__DangerousCurve
  && field_collisionRisk==other_value.field_collisionRisk
  && field_signalViolation==other_value.field_signalViolation
  && field_dangerousSituation==other_value.field_dangerousSituation;
}

boolean SspDENM::is_bound() const
{
if (bound_flag) return TRUE;
if(field_trafficCondition.is_bound()) return TRUE;
if(field_accident.is_bound()) return TRUE;
if(field_roadworks.is_bound()) return TRUE;
if(field_adverseWeatherCondition__Adhesion.is_bound()) return TRUE;
if(field_hazardousLocation__SurfaceCondition.is_bound()) return TRUE;
if(field_hazardousLocation__ObstacleOnTheRoad.is_bound()) return TRUE;
if(field_hazardousLocation__AnimalOnTheRoad.is_bound()) return TRUE;
if(field_humanPresenceOnTheRoad.is_bound()) return TRUE;
if(field_wrongWayDriving.is_bound()) return TRUE;
if(field_rescueAndRecoveryWorkInProgress.is_bound()) return TRUE;
if(field_adverseWeatherCondition__ExtremeWeatherCondition.is_bound()) return TRUE;
if(field_adverseWeatherCondition__Visibility.is_bound()) return TRUE;
if(field_adverseWeatherCondition__Precipitation.is_bound()) return TRUE;
if(field_slowVehicle.is_bound()) return TRUE;
if(field_dangerousEndOfQueue.is_bound()) return TRUE;
if(field_vehicleBreakdown.is_bound()) return TRUE;
if(field_postCrash.is_bound()) return TRUE;
if(field_humanProblem.is_bound()) return TRUE;
if(field_stationaryVehicle.is_bound()) return TRUE;
if(field_emergencyVehicleApproaching.is_bound()) return TRUE;
if(field_hazardousLocation__DangerousCurve.is_bound()) return TRUE;
if(field_collisionRisk.is_bound()) return TRUE;
if(field_signalViolation.is_bound()) return TRUE;
if(field_dangerousSituation.is_bound()) return TRUE;
return FALSE;
}
boolean SspDENM::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_trafficCondition.is_value()) return FALSE;
if(!field_accident.is_value()) return FALSE;
if(!field_roadworks.is_value()) return FALSE;
if(!field_adverseWeatherCondition__Adhesion.is_value()) return FALSE;
if(!field_hazardousLocation__SurfaceCondition.is_value()) return FALSE;
if(!field_hazardousLocation__ObstacleOnTheRoad.is_value()) return FALSE;
if(!field_hazardousLocation__AnimalOnTheRoad.is_value()) return FALSE;
if(!field_humanPresenceOnTheRoad.is_value()) return FALSE;
if(!field_wrongWayDriving.is_value()) return FALSE;
if(!field_rescueAndRecoveryWorkInProgress.is_value()) return FALSE;
if(!field_adverseWeatherCondition__ExtremeWeatherCondition.is_value()) return FALSE;
if(!field_adverseWeatherCondition__Visibility.is_value()) return FALSE;
if(!field_adverseWeatherCondition__Precipitation.is_value()) return FALSE;
if(!field_slowVehicle.is_value()) return FALSE;
if(!field_dangerousEndOfQueue.is_value()) return FALSE;
if(!field_vehicleBreakdown.is_value()) return FALSE;
if(!field_postCrash.is_value()) return FALSE;
if(!field_humanProblem.is_value()) return FALSE;
if(!field_stationaryVehicle.is_value()) return FALSE;
if(!field_emergencyVehicleApproaching.is_value()) return FALSE;
if(!field_hazardousLocation__DangerousCurve.is_value()) return FALSE;
if(!field_collisionRisk.is_value()) return FALSE;
if(!field_signalViolation.is_value()) return FALSE;
if(!field_dangerousSituation.is_value()) return FALSE;
return TRUE;
}
int SspDENM::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.SspDENM");
  return 24;
}

void SspDENM::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ trafficCondition := ");
field_trafficCondition.log();
TTCN_Logger::log_event_str(", accident := ");
field_accident.log();
TTCN_Logger::log_event_str(", roadworks := ");
field_roadworks.log();
TTCN_Logger::log_event_str(", adverseWeatherCondition_Adhesion := ");
field_adverseWeatherCondition__Adhesion.log();
TTCN_Logger::log_event_str(", hazardousLocation_SurfaceCondition := ");
field_hazardousLocation__SurfaceCondition.log();
TTCN_Logger::log_event_str(", hazardousLocation_ObstacleOnTheRoad := ");
field_hazardousLocation__ObstacleOnTheRoad.log();
TTCN_Logger::log_event_str(", hazardousLocation_AnimalOnTheRoad := ");
field_hazardousLocation__AnimalOnTheRoad.log();
TTCN_Logger::log_event_str(", humanPresenceOnTheRoad := ");
field_humanPresenceOnTheRoad.log();
TTCN_Logger::log_event_str(", wrongWayDriving := ");
field_wrongWayDriving.log();
TTCN_Logger::log_event_str(", rescueAndRecoveryWorkInProgress := ");
field_rescueAndRecoveryWorkInProgress.log();
TTCN_Logger::log_event_str(", adverseWeatherCondition_ExtremeWeatherCondition := ");
field_adverseWeatherCondition__ExtremeWeatherCondition.log();
TTCN_Logger::log_event_str(", adverseWeatherCondition_Visibility := ");
field_adverseWeatherCondition__Visibility.log();
TTCN_Logger::log_event_str(", adverseWeatherCondition_Precipitation := ");
field_adverseWeatherCondition__Precipitation.log();
TTCN_Logger::log_event_str(", slowVehicle := ");
field_slowVehicle.log();
TTCN_Logger::log_event_str(", dangerousEndOfQueue := ");
field_dangerousEndOfQueue.log();
TTCN_Logger::log_event_str(", vehicleBreakdown := ");
field_vehicleBreakdown.log();
TTCN_Logger::log_event_str(", postCrash := ");
field_postCrash.log();
TTCN_Logger::log_event_str(", humanProblem := ");
field_humanProblem.log();
TTCN_Logger::log_event_str(", stationaryVehicle := ");
field_stationaryVehicle.log();
TTCN_Logger::log_event_str(", emergencyVehicleApproaching := ");
field_emergencyVehicleApproaching.log();
TTCN_Logger::log_event_str(", hazardousLocation_DangerousCurve := ");
field_hazardousLocation__DangerousCurve.log();
TTCN_Logger::log_event_str(", collisionRisk := ");
field_collisionRisk.log();
TTCN_Logger::log_event_str(", signalViolation := ");
field_signalViolation.log();
TTCN_Logger::log_event_str(", dangerousSituation := ");
field_dangerousSituation.log();
TTCN_Logger::log_event_str(" }");
}

void SspDENM::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.SspDENM'");
    }
    if (strcmp("trafficCondition", param_field) == 0) {
      trafficCondition().set_param(param);
      return;
    } else if (strcmp("accident", param_field) == 0) {
      accident().set_param(param);
      return;
    } else if (strcmp("roadworks", param_field) == 0) {
      roadworks().set_param(param);
      return;
    } else if (strcmp("adverseWeatherCondition_Adhesion", param_field) == 0) {
      adverseWeatherCondition__Adhesion().set_param(param);
      return;
    } else if (strcmp("hazardousLocation_SurfaceCondition", param_field) == 0) {
      hazardousLocation__SurfaceCondition().set_param(param);
      return;
    } else if (strcmp("hazardousLocation_ObstacleOnTheRoad", param_field) == 0) {
      hazardousLocation__ObstacleOnTheRoad().set_param(param);
      return;
    } else if (strcmp("hazardousLocation_AnimalOnTheRoad", param_field) == 0) {
      hazardousLocation__AnimalOnTheRoad().set_param(param);
      return;
    } else if (strcmp("humanPresenceOnTheRoad", param_field) == 0) {
      humanPresenceOnTheRoad().set_param(param);
      return;
    } else if (strcmp("wrongWayDriving", param_field) == 0) {
      wrongWayDriving().set_param(param);
      return;
    } else if (strcmp("rescueAndRecoveryWorkInProgress", param_field) == 0) {
      rescueAndRecoveryWorkInProgress().set_param(param);
      return;
    } else if (strcmp("adverseWeatherCondition_ExtremeWeatherCondition", param_field) == 0) {
      adverseWeatherCondition__ExtremeWeatherCondition().set_param(param);
      return;
    } else if (strcmp("adverseWeatherCondition_Visibility", param_field) == 0) {
      adverseWeatherCondition__Visibility().set_param(param);
      return;
    } else if (strcmp("adverseWeatherCondition_Precipitation", param_field) == 0) {
      adverseWeatherCondition__Precipitation().set_param(param);
      return;
    } else if (strcmp("slowVehicle", param_field) == 0) {
      slowVehicle().set_param(param);
      return;
    } else if (strcmp("dangerousEndOfQueue", param_field) == 0) {
      dangerousEndOfQueue().set_param(param);
      return;
    } else if (strcmp("vehicleBreakdown", param_field) == 0) {
      vehicleBreakdown().set_param(param);
      return;
    } else if (strcmp("postCrash", param_field) == 0) {
      postCrash().set_param(param);
      return;
    } else if (strcmp("humanProblem", param_field) == 0) {
      humanProblem().set_param(param);
      return;
    } else if (strcmp("stationaryVehicle", param_field) == 0) {
      stationaryVehicle().set_param(param);
      return;
    } else if (strcmp("emergencyVehicleApproaching", param_field) == 0) {
      emergencyVehicleApproaching().set_param(param);
      return;
    } else if (strcmp("hazardousLocation_DangerousCurve", param_field) == 0) {
      hazardousLocation__DangerousCurve().set_param(param);
      return;
    } else if (strcmp("collisionRisk", param_field) == 0) {
      collisionRisk().set_param(param);
      return;
    } else if (strcmp("signalViolation", param_field) == 0) {
      signalViolation().set_param(param);
      return;
    } else if (strcmp("dangerousSituation", param_field) == 0) {
      dangerousSituation().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SspDENM'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (24<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.SspDENM has 24 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) trafficCondition().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) accident().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) roadworks().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) adverseWeatherCondition__Adhesion().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) hazardousLocation__SurfaceCondition().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) hazardousLocation__ObstacleOnTheRoad().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) hazardousLocation__AnimalOnTheRoad().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) humanPresenceOnTheRoad().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) wrongWayDriving().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) rescueAndRecoveryWorkInProgress().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) adverseWeatherCondition__ExtremeWeatherCondition().set_param(*mp->get_elem(10));
    if (mp->get_size()>11 && mp->get_elem(11)->get_type()!=Module_Param::MP_NotUsed) adverseWeatherCondition__Visibility().set_param(*mp->get_elem(11));
    if (mp->get_size()>12 && mp->get_elem(12)->get_type()!=Module_Param::MP_NotUsed) adverseWeatherCondition__Precipitation().set_param(*mp->get_elem(12));
    if (mp->get_size()>13 && mp->get_elem(13)->get_type()!=Module_Param::MP_NotUsed) slowVehicle().set_param(*mp->get_elem(13));
    if (mp->get_size()>14 && mp->get_elem(14)->get_type()!=Module_Param::MP_NotUsed) dangerousEndOfQueue().set_param(*mp->get_elem(14));
    if (mp->get_size()>15 && mp->get_elem(15)->get_type()!=Module_Param::MP_NotUsed) vehicleBreakdown().set_param(*mp->get_elem(15));
    if (mp->get_size()>16 && mp->get_elem(16)->get_type()!=Module_Param::MP_NotUsed) postCrash().set_param(*mp->get_elem(16));
    if (mp->get_size()>17 && mp->get_elem(17)->get_type()!=Module_Param::MP_NotUsed) humanProblem().set_param(*mp->get_elem(17));
    if (mp->get_size()>18 && mp->get_elem(18)->get_type()!=Module_Param::MP_NotUsed) stationaryVehicle().set_param(*mp->get_elem(18));
    if (mp->get_size()>19 && mp->get_elem(19)->get_type()!=Module_Param::MP_NotUsed) emergencyVehicleApproaching().set_param(*mp->get_elem(19));
    if (mp->get_size()>20 && mp->get_elem(20)->get_type()!=Module_Param::MP_NotUsed) hazardousLocation__DangerousCurve().set_param(*mp->get_elem(20));
    if (mp->get_size()>21 && mp->get_elem(21)->get_type()!=Module_Param::MP_NotUsed) collisionRisk().set_param(*mp->get_elem(21));
    if (mp->get_size()>22 && mp->get_elem(22)->get_type()!=Module_Param::MP_NotUsed) signalViolation().set_param(*mp->get_elem(22));
    if (mp->get_size()>23 && mp->get_elem(23)->get_type()!=Module_Param::MP_NotUsed) dangerousSituation().set_param(*mp->get_elem(23));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficCondition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficCondition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "accident")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          accident().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "roadworks")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          roadworks().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "adverseWeatherCondition_Adhesion")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          adverseWeatherCondition__Adhesion().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hazardousLocation_SurfaceCondition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hazardousLocation__SurfaceCondition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hazardousLocation_ObstacleOnTheRoad")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hazardousLocation__ObstacleOnTheRoad().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hazardousLocation_AnimalOnTheRoad")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hazardousLocation__AnimalOnTheRoad().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "humanPresenceOnTheRoad")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          humanPresenceOnTheRoad().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "wrongWayDriving")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          wrongWayDriving().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rescueAndRecoveryWorkInProgress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rescueAndRecoveryWorkInProgress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "adverseWeatherCondition_ExtremeWeatherCondition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          adverseWeatherCondition__ExtremeWeatherCondition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "adverseWeatherCondition_Visibility")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          adverseWeatherCondition__Visibility().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "adverseWeatherCondition_Precipitation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          adverseWeatherCondition__Precipitation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "slowVehicle")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          slowVehicle().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dangerousEndOfQueue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dangerousEndOfQueue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vehicleBreakdown")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vehicleBreakdown().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "postCrash")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          postCrash().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "humanProblem")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          humanProblem().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationaryVehicle")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationaryVehicle().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "emergencyVehicleApproaching")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          emergencyVehicleApproaching().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hazardousLocation_DangerousCurve")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hazardousLocation__DangerousCurve().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "collisionRisk")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          collisionRisk().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signalViolation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signalViolation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dangerousSituation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dangerousSituation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.SspDENM: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.SspDENM");
  }
}

Module_Param* SspDENM::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.SspDENM'");
    }
    if (strcmp("trafficCondition", param_field) == 0) {
      return trafficCondition().get_param(param_name);
    } else if (strcmp("accident", param_field) == 0) {
      return accident().get_param(param_name);
    } else if (strcmp("roadworks", param_field) == 0) {
      return roadworks().get_param(param_name);
    } else if (strcmp("adverseWeatherCondition_Adhesion", param_field) == 0) {
      return adverseWeatherCondition__Adhesion().get_param(param_name);
    } else if (strcmp("hazardousLocation_SurfaceCondition", param_field) == 0) {
      return hazardousLocation__SurfaceCondition().get_param(param_name);
    } else if (strcmp("hazardousLocation_ObstacleOnTheRoad", param_field) == 0) {
      return hazardousLocation__ObstacleOnTheRoad().get_param(param_name);
    } else if (strcmp("hazardousLocation_AnimalOnTheRoad", param_field) == 0) {
      return hazardousLocation__AnimalOnTheRoad().get_param(param_name);
    } else if (strcmp("humanPresenceOnTheRoad", param_field) == 0) {
      return humanPresenceOnTheRoad().get_param(param_name);
    } else if (strcmp("wrongWayDriving", param_field) == 0) {
      return wrongWayDriving().get_param(param_name);
    } else if (strcmp("rescueAndRecoveryWorkInProgress", param_field) == 0) {
      return rescueAndRecoveryWorkInProgress().get_param(param_name);
    } else if (strcmp("adverseWeatherCondition_ExtremeWeatherCondition", param_field) == 0) {
      return adverseWeatherCondition__ExtremeWeatherCondition().get_param(param_name);
    } else if (strcmp("adverseWeatherCondition_Visibility", param_field) == 0) {
      return adverseWeatherCondition__Visibility().get_param(param_name);
    } else if (strcmp("adverseWeatherCondition_Precipitation", param_field) == 0) {
      return adverseWeatherCondition__Precipitation().get_param(param_name);
    } else if (strcmp("slowVehicle", param_field) == 0) {
      return slowVehicle().get_param(param_name);
    } else if (strcmp("dangerousEndOfQueue", param_field) == 0) {
      return dangerousEndOfQueue().get_param(param_name);
    } else if (strcmp("vehicleBreakdown", param_field) == 0) {
      return vehicleBreakdown().get_param(param_name);
    } else if (strcmp("postCrash", param_field) == 0) {
      return postCrash().get_param(param_name);
    } else if (strcmp("humanProblem", param_field) == 0) {
      return humanProblem().get_param(param_name);
    } else if (strcmp("stationaryVehicle", param_field) == 0) {
      return stationaryVehicle().get_param(param_name);
    } else if (strcmp("emergencyVehicleApproaching", param_field) == 0) {
      return emergencyVehicleApproaching().get_param(param_name);
    } else if (strcmp("hazardousLocation_DangerousCurve", param_field) == 0) {
      return hazardousLocation__DangerousCurve().get_param(param_name);
    } else if (strcmp("collisionRisk", param_field) == 0) {
      return collisionRisk().get_param(param_name);
    } else if (strcmp("signalViolation", param_field) == 0) {
      return signalViolation().get_param(param_name);
    } else if (strcmp("dangerousSituation", param_field) == 0) {
      return dangerousSituation().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SspDENM'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_trafficCondition = field_trafficCondition.get_param(param_name);
  mp_field_trafficCondition->set_id(new Module_Param_FieldName(mcopystr("trafficCondition")));
  mp->add_elem(mp_field_trafficCondition);
  Module_Param* mp_field_accident = field_accident.get_param(param_name);
  mp_field_accident->set_id(new Module_Param_FieldName(mcopystr("accident")));
  mp->add_elem(mp_field_accident);
  Module_Param* mp_field_roadworks = field_roadworks.get_param(param_name);
  mp_field_roadworks->set_id(new Module_Param_FieldName(mcopystr("roadworks")));
  mp->add_elem(mp_field_roadworks);
  Module_Param* mp_field_adverseWeatherCondition__Adhesion = field_adverseWeatherCondition__Adhesion.get_param(param_name);
  mp_field_adverseWeatherCondition__Adhesion->set_id(new Module_Param_FieldName(mcopystr("adverseWeatherCondition_Adhesion")));
  mp->add_elem(mp_field_adverseWeatherCondition__Adhesion);
  Module_Param* mp_field_hazardousLocation__SurfaceCondition = field_hazardousLocation__SurfaceCondition.get_param(param_name);
  mp_field_hazardousLocation__SurfaceCondition->set_id(new Module_Param_FieldName(mcopystr("hazardousLocation_SurfaceCondition")));
  mp->add_elem(mp_field_hazardousLocation__SurfaceCondition);
  Module_Param* mp_field_hazardousLocation__ObstacleOnTheRoad = field_hazardousLocation__ObstacleOnTheRoad.get_param(param_name);
  mp_field_hazardousLocation__ObstacleOnTheRoad->set_id(new Module_Param_FieldName(mcopystr("hazardousLocation_ObstacleOnTheRoad")));
  mp->add_elem(mp_field_hazardousLocation__ObstacleOnTheRoad);
  Module_Param* mp_field_hazardousLocation__AnimalOnTheRoad = field_hazardousLocation__AnimalOnTheRoad.get_param(param_name);
  mp_field_hazardousLocation__AnimalOnTheRoad->set_id(new Module_Param_FieldName(mcopystr("hazardousLocation_AnimalOnTheRoad")));
  mp->add_elem(mp_field_hazardousLocation__AnimalOnTheRoad);
  Module_Param* mp_field_humanPresenceOnTheRoad = field_humanPresenceOnTheRoad.get_param(param_name);
  mp_field_humanPresenceOnTheRoad->set_id(new Module_Param_FieldName(mcopystr("humanPresenceOnTheRoad")));
  mp->add_elem(mp_field_humanPresenceOnTheRoad);
  Module_Param* mp_field_wrongWayDriving = field_wrongWayDriving.get_param(param_name);
  mp_field_wrongWayDriving->set_id(new Module_Param_FieldName(mcopystr("wrongWayDriving")));
  mp->add_elem(mp_field_wrongWayDriving);
  Module_Param* mp_field_rescueAndRecoveryWorkInProgress = field_rescueAndRecoveryWorkInProgress.get_param(param_name);
  mp_field_rescueAndRecoveryWorkInProgress->set_id(new Module_Param_FieldName(mcopystr("rescueAndRecoveryWorkInProgress")));
  mp->add_elem(mp_field_rescueAndRecoveryWorkInProgress);
  Module_Param* mp_field_adverseWeatherCondition__ExtremeWeatherCondition = field_adverseWeatherCondition__ExtremeWeatherCondition.get_param(param_name);
  mp_field_adverseWeatherCondition__ExtremeWeatherCondition->set_id(new Module_Param_FieldName(mcopystr("adverseWeatherCondition_ExtremeWeatherCondition")));
  mp->add_elem(mp_field_adverseWeatherCondition__ExtremeWeatherCondition);
  Module_Param* mp_field_adverseWeatherCondition__Visibility = field_adverseWeatherCondition__Visibility.get_param(param_name);
  mp_field_adverseWeatherCondition__Visibility->set_id(new Module_Param_FieldName(mcopystr("adverseWeatherCondition_Visibility")));
  mp->add_elem(mp_field_adverseWeatherCondition__Visibility);
  Module_Param* mp_field_adverseWeatherCondition__Precipitation = field_adverseWeatherCondition__Precipitation.get_param(param_name);
  mp_field_adverseWeatherCondition__Precipitation->set_id(new Module_Param_FieldName(mcopystr("adverseWeatherCondition_Precipitation")));
  mp->add_elem(mp_field_adverseWeatherCondition__Precipitation);
  Module_Param* mp_field_slowVehicle = field_slowVehicle.get_param(param_name);
  mp_field_slowVehicle->set_id(new Module_Param_FieldName(mcopystr("slowVehicle")));
  mp->add_elem(mp_field_slowVehicle);
  Module_Param* mp_field_dangerousEndOfQueue = field_dangerousEndOfQueue.get_param(param_name);
  mp_field_dangerousEndOfQueue->set_id(new Module_Param_FieldName(mcopystr("dangerousEndOfQueue")));
  mp->add_elem(mp_field_dangerousEndOfQueue);
  Module_Param* mp_field_vehicleBreakdown = field_vehicleBreakdown.get_param(param_name);
  mp_field_vehicleBreakdown->set_id(new Module_Param_FieldName(mcopystr("vehicleBreakdown")));
  mp->add_elem(mp_field_vehicleBreakdown);
  Module_Param* mp_field_postCrash = field_postCrash.get_param(param_name);
  mp_field_postCrash->set_id(new Module_Param_FieldName(mcopystr("postCrash")));
  mp->add_elem(mp_field_postCrash);
  Module_Param* mp_field_humanProblem = field_humanProblem.get_param(param_name);
  mp_field_humanProblem->set_id(new Module_Param_FieldName(mcopystr("humanProblem")));
  mp->add_elem(mp_field_humanProblem);
  Module_Param* mp_field_stationaryVehicle = field_stationaryVehicle.get_param(param_name);
  mp_field_stationaryVehicle->set_id(new Module_Param_FieldName(mcopystr("stationaryVehicle")));
  mp->add_elem(mp_field_stationaryVehicle);
  Module_Param* mp_field_emergencyVehicleApproaching = field_emergencyVehicleApproaching.get_param(param_name);
  mp_field_emergencyVehicleApproaching->set_id(new Module_Param_FieldName(mcopystr("emergencyVehicleApproaching")));
  mp->add_elem(mp_field_emergencyVehicleApproaching);
  Module_Param* mp_field_hazardousLocation__DangerousCurve = field_hazardousLocation__DangerousCurve.get_param(param_name);
  mp_field_hazardousLocation__DangerousCurve->set_id(new Module_Param_FieldName(mcopystr("hazardousLocation_DangerousCurve")));
  mp->add_elem(mp_field_hazardousLocation__DangerousCurve);
  Module_Param* mp_field_collisionRisk = field_collisionRisk.get_param(param_name);
  mp_field_collisionRisk->set_id(new Module_Param_FieldName(mcopystr("collisionRisk")));
  mp->add_elem(mp_field_collisionRisk);
  Module_Param* mp_field_signalViolation = field_signalViolation.get_param(param_name);
  mp_field_signalViolation->set_id(new Module_Param_FieldName(mcopystr("signalViolation")));
  mp->add_elem(mp_field_signalViolation);
  Module_Param* mp_field_dangerousSituation = field_dangerousSituation.get_param(param_name);
  mp_field_dangerousSituation->set_id(new Module_Param_FieldName(mcopystr("dangerousSituation")));
  mp->add_elem(mp_field_dangerousSituation);
  return mp;
  }

void SspDENM::set_implicit_omit()
{
if (trafficCondition().is_bound()) trafficCondition().set_implicit_omit();
if (accident().is_bound()) accident().set_implicit_omit();
if (roadworks().is_bound()) roadworks().set_implicit_omit();
if (adverseWeatherCondition__Adhesion().is_bound()) adverseWeatherCondition__Adhesion().set_implicit_omit();
if (hazardousLocation__SurfaceCondition().is_bound()) hazardousLocation__SurfaceCondition().set_implicit_omit();
if (hazardousLocation__ObstacleOnTheRoad().is_bound()) hazardousLocation__ObstacleOnTheRoad().set_implicit_omit();
if (hazardousLocation__AnimalOnTheRoad().is_bound()) hazardousLocation__AnimalOnTheRoad().set_implicit_omit();
if (humanPresenceOnTheRoad().is_bound()) humanPresenceOnTheRoad().set_implicit_omit();
if (wrongWayDriving().is_bound()) wrongWayDriving().set_implicit_omit();
if (rescueAndRecoveryWorkInProgress().is_bound()) rescueAndRecoveryWorkInProgress().set_implicit_omit();
if (adverseWeatherCondition__ExtremeWeatherCondition().is_bound()) adverseWeatherCondition__ExtremeWeatherCondition().set_implicit_omit();
if (adverseWeatherCondition__Visibility().is_bound()) adverseWeatherCondition__Visibility().set_implicit_omit();
if (adverseWeatherCondition__Precipitation().is_bound()) adverseWeatherCondition__Precipitation().set_implicit_omit();
if (slowVehicle().is_bound()) slowVehicle().set_implicit_omit();
if (dangerousEndOfQueue().is_bound()) dangerousEndOfQueue().set_implicit_omit();
if (vehicleBreakdown().is_bound()) vehicleBreakdown().set_implicit_omit();
if (postCrash().is_bound()) postCrash().set_implicit_omit();
if (humanProblem().is_bound()) humanProblem().set_implicit_omit();
if (stationaryVehicle().is_bound()) stationaryVehicle().set_implicit_omit();
if (emergencyVehicleApproaching().is_bound()) emergencyVehicleApproaching().set_implicit_omit();
if (hazardousLocation__DangerousCurve().is_bound()) hazardousLocation__DangerousCurve().set_implicit_omit();
if (collisionRisk().is_bound()) collisionRisk().set_implicit_omit();
if (signalViolation().is_bound()) signalViolation().set_implicit_omit();
if (dangerousSituation().is_bound()) dangerousSituation().set_implicit_omit();
}

void SspDENM::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.SspDENM.");
field_trafficCondition.encode_text(text_buf);
field_accident.encode_text(text_buf);
field_roadworks.encode_text(text_buf);
field_adverseWeatherCondition__Adhesion.encode_text(text_buf);
field_hazardousLocation__SurfaceCondition.encode_text(text_buf);
field_hazardousLocation__ObstacleOnTheRoad.encode_text(text_buf);
field_hazardousLocation__AnimalOnTheRoad.encode_text(text_buf);
field_humanPresenceOnTheRoad.encode_text(text_buf);
field_wrongWayDriving.encode_text(text_buf);
field_rescueAndRecoveryWorkInProgress.encode_text(text_buf);
field_adverseWeatherCondition__ExtremeWeatherCondition.encode_text(text_buf);
field_adverseWeatherCondition__Visibility.encode_text(text_buf);
field_adverseWeatherCondition__Precipitation.encode_text(text_buf);
field_slowVehicle.encode_text(text_buf);
field_dangerousEndOfQueue.encode_text(text_buf);
field_vehicleBreakdown.encode_text(text_buf);
field_postCrash.encode_text(text_buf);
field_humanProblem.encode_text(text_buf);
field_stationaryVehicle.encode_text(text_buf);
field_emergencyVehicleApproaching.encode_text(text_buf);
field_hazardousLocation__DangerousCurve.encode_text(text_buf);
field_collisionRisk.encode_text(text_buf);
field_signalViolation.encode_text(text_buf);
field_dangerousSituation.encode_text(text_buf);
}

void SspDENM::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_trafficCondition.decode_text(text_buf);
field_accident.decode_text(text_buf);
field_roadworks.decode_text(text_buf);
field_adverseWeatherCondition__Adhesion.decode_text(text_buf);
field_hazardousLocation__SurfaceCondition.decode_text(text_buf);
field_hazardousLocation__ObstacleOnTheRoad.decode_text(text_buf);
field_hazardousLocation__AnimalOnTheRoad.decode_text(text_buf);
field_humanPresenceOnTheRoad.decode_text(text_buf);
field_wrongWayDriving.decode_text(text_buf);
field_rescueAndRecoveryWorkInProgress.decode_text(text_buf);
field_adverseWeatherCondition__ExtremeWeatherCondition.decode_text(text_buf);
field_adverseWeatherCondition__Visibility.decode_text(text_buf);
field_adverseWeatherCondition__Precipitation.decode_text(text_buf);
field_slowVehicle.decode_text(text_buf);
field_dangerousEndOfQueue.decode_text(text_buf);
field_vehicleBreakdown.decode_text(text_buf);
field_postCrash.decode_text(text_buf);
field_humanProblem.decode_text(text_buf);
field_stationaryVehicle.decode_text(text_buf);
field_emergencyVehicleApproaching.decode_text(text_buf);
field_hazardousLocation__DangerousCurve.decode_text(text_buf);
field_collisionRisk.decode_text(text_buf);
field_signalViolation.decode_text(text_buf);
field_dangerousSituation.decode_text(text_buf);
}

void SspDENM::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SspDENM::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SspDENM::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_trafficCondition.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_accident.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_roadworks.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_adverseWeatherCondition__Adhesion.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_hazardousLocation__SurfaceCondition.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_hazardousLocation__ObstacleOnTheRoad.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_hazardousLocation__AnimalOnTheRoad.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_humanPresenceOnTheRoad.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_wrongWayDriving.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_rescueAndRecoveryWorkInProgress.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_adverseWeatherCondition__ExtremeWeatherCondition.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_adverseWeatherCondition__Visibility.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_adverseWeatherCondition__Precipitation.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_slowVehicle.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_dangerousEndOfQueue.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_vehicleBreakdown.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_postCrash.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_humanProblem.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_stationaryVehicle.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_emergencyVehicleApproaching.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_hazardousLocation__DangerousCurve.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_collisionRisk.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_signalViolation.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_dangerousSituation.RAW_decode(LibCommon__DataStrings::Bit1_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int SspDENM::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 24;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(24);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[6] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 6, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[7] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 7, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[8] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 8, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[9] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 9, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[10] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 10, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[11] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 11, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[12] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 12, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[13] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 13, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[14] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 14, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[15] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 15, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[16] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 16, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[17] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 17, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[18] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 18, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[19] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 19, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[20] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 20, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[21] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 21, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[22] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 22, LibCommon__DataStrings::Bit1_descr_.raw);
  myleaf.body.node.nodes[23] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 23, LibCommon__DataStrings::Bit1_descr_.raw);
  encoded_length += field_trafficCondition.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_accident.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_roadworks.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_adverseWeatherCondition__Adhesion.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_hazardousLocation__SurfaceCondition.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_hazardousLocation__ObstacleOnTheRoad.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[5]);
  encoded_length += field_hazardousLocation__AnimalOnTheRoad.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[6]);
  encoded_length += field_humanPresenceOnTheRoad.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[7]);
  encoded_length += field_wrongWayDriving.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[8]);
  encoded_length += field_rescueAndRecoveryWorkInProgress.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[9]);
  encoded_length += field_adverseWeatherCondition__ExtremeWeatherCondition.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[10]);
  encoded_length += field_adverseWeatherCondition__Visibility.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[11]);
  encoded_length += field_adverseWeatherCondition__Precipitation.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[12]);
  encoded_length += field_slowVehicle.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[13]);
  encoded_length += field_dangerousEndOfQueue.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[14]);
  encoded_length += field_vehicleBreakdown.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[15]);
  encoded_length += field_postCrash.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[16]);
  encoded_length += field_humanProblem.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[17]);
  encoded_length += field_stationaryVehicle.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[18]);
  encoded_length += field_emergencyVehicleApproaching.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[19]);
  encoded_length += field_hazardousLocation__DangerousCurve.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[20]);
  encoded_length += field_collisionRisk.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[21]);
  encoded_length += field_signalViolation.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[22]);
  encoded_length += field_dangerousSituation.RAW_encode(LibCommon__DataStrings::Bit1_descr_, *myleaf.body.node.nodes[23]);
  return myleaf.length = encoded_length;
}

int SspDENM::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.SspDENM.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "trafficCondition");
    enc_len += field_trafficCondition.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "accident");
    enc_len += field_accident.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "roadworks");
    enc_len += field_roadworks.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "adverseWeatherCondition_Adhesion");
    enc_len += field_adverseWeatherCondition__Adhesion.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "hazardousLocation_SurfaceCondition");
    enc_len += field_hazardousLocation__SurfaceCondition.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "hazardousLocation_ObstacleOnTheRoad");
    enc_len += field_hazardousLocation__ObstacleOnTheRoad.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "hazardousLocation_AnimalOnTheRoad");
    enc_len += field_hazardousLocation__AnimalOnTheRoad.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "humanPresenceOnTheRoad");
    enc_len += field_humanPresenceOnTheRoad.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "wrongWayDriving");
    enc_len += field_wrongWayDriving.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "rescueAndRecoveryWorkInProgress");
    enc_len += field_rescueAndRecoveryWorkInProgress.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "adverseWeatherCondition_ExtremeWeatherCondition");
    enc_len += field_adverseWeatherCondition__ExtremeWeatherCondition.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "adverseWeatherCondition_Visibility");
    enc_len += field_adverseWeatherCondition__Visibility.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "adverseWeatherCondition_Precipitation");
    enc_len += field_adverseWeatherCondition__Precipitation.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "slowVehicle");
    enc_len += field_slowVehicle.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "dangerousEndOfQueue");
    enc_len += field_dangerousEndOfQueue.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "vehicleBreakdown");
    enc_len += field_vehicleBreakdown.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "postCrash");
    enc_len += field_postCrash.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "humanProblem");
    enc_len += field_humanProblem.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "stationaryVehicle");
    enc_len += field_stationaryVehicle.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "emergencyVehicleApproaching");
    enc_len += field_emergencyVehicleApproaching.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "hazardousLocation_DangerousCurve");
    enc_len += field_hazardousLocation__DangerousCurve.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "collisionRisk");
    enc_len += field_collisionRisk.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "signalViolation");
    enc_len += field_signalViolation.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "dangerousSituation");
    enc_len += field_dangerousSituation.JSON_encode(LibCommon__DataStrings::Bit1_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SspDENM::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (16 == name_len && 0 == strncmp(fld_name, "trafficCondition", name_len)) {
         int ret_val = field_trafficCondition.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "trafficCondition");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "accident", name_len)) {
         int ret_val = field_accident.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "accident");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "roadworks", name_len)) {
         int ret_val = field_roadworks.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "roadworks");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (32 == name_len && 0 == strncmp(fld_name, "adverseWeatherCondition_Adhesion", name_len)) {
         int ret_val = field_adverseWeatherCondition__Adhesion.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "adverseWeatherCondition_Adhesion");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (34 == name_len && 0 == strncmp(fld_name, "hazardousLocation_SurfaceCondition", name_len)) {
         int ret_val = field_hazardousLocation__SurfaceCondition.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "hazardousLocation_SurfaceCondition");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (35 == name_len && 0 == strncmp(fld_name, "hazardousLocation_ObstacleOnTheRoad", name_len)) {
         int ret_val = field_hazardousLocation__ObstacleOnTheRoad.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "hazardousLocation_ObstacleOnTheRoad");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (33 == name_len && 0 == strncmp(fld_name, "hazardousLocation_AnimalOnTheRoad", name_len)) {
         int ret_val = field_hazardousLocation__AnimalOnTheRoad.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "hazardousLocation_AnimalOnTheRoad");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (22 == name_len && 0 == strncmp(fld_name, "humanPresenceOnTheRoad", name_len)) {
         int ret_val = field_humanPresenceOnTheRoad.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "humanPresenceOnTheRoad");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "wrongWayDriving", name_len)) {
         int ret_val = field_wrongWayDriving.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "wrongWayDriving");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (31 == name_len && 0 == strncmp(fld_name, "rescueAndRecoveryWorkInProgress", name_len)) {
         int ret_val = field_rescueAndRecoveryWorkInProgress.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "rescueAndRecoveryWorkInProgress");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (47 == name_len && 0 == strncmp(fld_name, "adverseWeatherCondition_ExtremeWeatherCondition", name_len)) {
         int ret_val = field_adverseWeatherCondition__ExtremeWeatherCondition.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "adverseWeatherCondition_ExtremeWeatherCondition");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (34 == name_len && 0 == strncmp(fld_name, "adverseWeatherCondition_Visibility", name_len)) {
         int ret_val = field_adverseWeatherCondition__Visibility.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "adverseWeatherCondition_Visibility");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (37 == name_len && 0 == strncmp(fld_name, "adverseWeatherCondition_Precipitation", name_len)) {
         int ret_val = field_adverseWeatherCondition__Precipitation.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "adverseWeatherCondition_Precipitation");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "slowVehicle", name_len)) {
         int ret_val = field_slowVehicle.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "slowVehicle");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (19 == name_len && 0 == strncmp(fld_name, "dangerousEndOfQueue", name_len)) {
         int ret_val = field_dangerousEndOfQueue.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "dangerousEndOfQueue");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (16 == name_len && 0 == strncmp(fld_name, "vehicleBreakdown", name_len)) {
         int ret_val = field_vehicleBreakdown.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "vehicleBreakdown");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "postCrash", name_len)) {
         int ret_val = field_postCrash.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "postCrash");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "humanProblem", name_len)) {
         int ret_val = field_humanProblem.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "humanProblem");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "stationaryVehicle", name_len)) {
         int ret_val = field_stationaryVehicle.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "stationaryVehicle");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (27 == name_len && 0 == strncmp(fld_name, "emergencyVehicleApproaching", name_len)) {
         int ret_val = field_emergencyVehicleApproaching.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "emergencyVehicleApproaching");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (32 == name_len && 0 == strncmp(fld_name, "hazardousLocation_DangerousCurve", name_len)) {
         int ret_val = field_hazardousLocation__DangerousCurve.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "hazardousLocation_DangerousCurve");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "collisionRisk", name_len)) {
         int ret_val = field_collisionRisk.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "collisionRisk");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (15 == name_len && 0 == strncmp(fld_name, "signalViolation", name_len)) {
         int ret_val = field_signalViolation.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "signalViolation");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "dangerousSituation", name_len)) {
         int ret_val = field_dangerousSituation.JSON_decode(LibCommon__DataStrings::Bit1_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "dangerousSituation");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_trafficCondition.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "trafficCondition");
    return JSON_ERROR_FATAL;
  }
if (!field_accident.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "accident");
    return JSON_ERROR_FATAL;
  }
if (!field_roadworks.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "roadworks");
    return JSON_ERROR_FATAL;
  }
if (!field_adverseWeatherCondition__Adhesion.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "adverseWeatherCondition_Adhesion");
    return JSON_ERROR_FATAL;
  }
if (!field_hazardousLocation__SurfaceCondition.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "hazardousLocation_SurfaceCondition");
    return JSON_ERROR_FATAL;
  }
if (!field_hazardousLocation__ObstacleOnTheRoad.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "hazardousLocation_ObstacleOnTheRoad");
    return JSON_ERROR_FATAL;
  }
if (!field_hazardousLocation__AnimalOnTheRoad.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "hazardousLocation_AnimalOnTheRoad");
    return JSON_ERROR_FATAL;
  }
if (!field_humanPresenceOnTheRoad.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "humanPresenceOnTheRoad");
    return JSON_ERROR_FATAL;
  }
if (!field_wrongWayDriving.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "wrongWayDriving");
    return JSON_ERROR_FATAL;
  }
if (!field_rescueAndRecoveryWorkInProgress.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "rescueAndRecoveryWorkInProgress");
    return JSON_ERROR_FATAL;
  }
if (!field_adverseWeatherCondition__ExtremeWeatherCondition.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "adverseWeatherCondition_ExtremeWeatherCondition");
    return JSON_ERROR_FATAL;
  }
if (!field_adverseWeatherCondition__Visibility.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "adverseWeatherCondition_Visibility");
    return JSON_ERROR_FATAL;
  }
if (!field_adverseWeatherCondition__Precipitation.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "adverseWeatherCondition_Precipitation");
    return JSON_ERROR_FATAL;
  }
if (!field_slowVehicle.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "slowVehicle");
    return JSON_ERROR_FATAL;
  }
if (!field_dangerousEndOfQueue.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "dangerousEndOfQueue");
    return JSON_ERROR_FATAL;
  }
if (!field_vehicleBreakdown.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "vehicleBreakdown");
    return JSON_ERROR_FATAL;
  }
if (!field_postCrash.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "postCrash");
    return JSON_ERROR_FATAL;
  }
if (!field_humanProblem.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "humanProblem");
    return JSON_ERROR_FATAL;
  }
if (!field_stationaryVehicle.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "stationaryVehicle");
    return JSON_ERROR_FATAL;
  }
if (!field_emergencyVehicleApproaching.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "emergencyVehicleApproaching");
    return JSON_ERROR_FATAL;
  }
if (!field_hazardousLocation__DangerousCurve.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "hazardousLocation_DangerousCurve");
    return JSON_ERROR_FATAL;
  }
if (!field_collisionRisk.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "collisionRisk");
    return JSON_ERROR_FATAL;
  }
if (!field_signalViolation.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "signalViolation");
    return JSON_ERROR_FATAL;
  }
if (!field_dangerousSituation.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "dangerousSituation");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct SspDENM_template::single_value_struct {
BITSTRING_template field_trafficCondition;
BITSTRING_template field_accident;
BITSTRING_template field_roadworks;
BITSTRING_template field_adverseWeatherCondition__Adhesion;
BITSTRING_template field_hazardousLocation__SurfaceCondition;
BITSTRING_template field_hazardousLocation__ObstacleOnTheRoad;
BITSTRING_template field_hazardousLocation__AnimalOnTheRoad;
BITSTRING_template field_humanPresenceOnTheRoad;
BITSTRING_template field_wrongWayDriving;
BITSTRING_template field_rescueAndRecoveryWorkInProgress;
BITSTRING_template field_adverseWeatherCondition__ExtremeWeatherCondition;
BITSTRING_template field_adverseWeatherCondition__Visibility;
BITSTRING_template field_adverseWeatherCondition__Precipitation;
BITSTRING_template field_slowVehicle;
BITSTRING_template field_dangerousEndOfQueue;
BITSTRING_template field_vehicleBreakdown;
BITSTRING_template field_postCrash;
BITSTRING_template field_humanProblem;
BITSTRING_template field_stationaryVehicle;
BITSTRING_template field_emergencyVehicleApproaching;
BITSTRING_template field_hazardousLocation__DangerousCurve;
BITSTRING_template field_collisionRisk;
BITSTRING_template field_signalViolation;
BITSTRING_template field_dangerousSituation;
};

void SspDENM_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_trafficCondition = ANY_VALUE;
single_value->field_accident = ANY_VALUE;
single_value->field_roadworks = ANY_VALUE;
single_value->field_adverseWeatherCondition__Adhesion = ANY_VALUE;
single_value->field_hazardousLocation__SurfaceCondition = ANY_VALUE;
single_value->field_hazardousLocation__ObstacleOnTheRoad = ANY_VALUE;
single_value->field_hazardousLocation__AnimalOnTheRoad = ANY_VALUE;
single_value->field_humanPresenceOnTheRoad = ANY_VALUE;
single_value->field_wrongWayDriving = ANY_VALUE;
single_value->field_rescueAndRecoveryWorkInProgress = ANY_VALUE;
single_value->field_adverseWeatherCondition__ExtremeWeatherCondition = ANY_VALUE;
single_value->field_adverseWeatherCondition__Visibility = ANY_VALUE;
single_value->field_adverseWeatherCondition__Precipitation = ANY_VALUE;
single_value->field_slowVehicle = ANY_VALUE;
single_value->field_dangerousEndOfQueue = ANY_VALUE;
single_value->field_vehicleBreakdown = ANY_VALUE;
single_value->field_postCrash = ANY_VALUE;
single_value->field_humanProblem = ANY_VALUE;
single_value->field_stationaryVehicle = ANY_VALUE;
single_value->field_emergencyVehicleApproaching = ANY_VALUE;
single_value->field_hazardousLocation__DangerousCurve = ANY_VALUE;
single_value->field_collisionRisk = ANY_VALUE;
single_value->field_signalViolation = ANY_VALUE;
single_value->field_dangerousSituation = ANY_VALUE;
}
}
}

void SspDENM_template::copy_value(const SspDENM& other_value)
{
single_value = new single_value_struct;
if (other_value.trafficCondition().is_bound()) {
  single_value->field_trafficCondition = other_value.trafficCondition();
} else {
  single_value->field_trafficCondition.clean_up();
}
if (other_value.accident().is_bound()) {
  single_value->field_accident = other_value.accident();
} else {
  single_value->field_accident.clean_up();
}
if (other_value.roadworks().is_bound()) {
  single_value->field_roadworks = other_value.roadworks();
} else {
  single_value->field_roadworks.clean_up();
}
if (other_value.adverseWeatherCondition__Adhesion().is_bound()) {
  single_value->field_adverseWeatherCondition__Adhesion = other_value.adverseWeatherCondition__Adhesion();
} else {
  single_value->field_adverseWeatherCondition__Adhesion.clean_up();
}
if (other_value.hazardousLocation__SurfaceCondition().is_bound()) {
  single_value->field_hazardousLocation__SurfaceCondition = other_value.hazardousLocation__SurfaceCondition();
} else {
  single_value->field_hazardousLocation__SurfaceCondition.clean_up();
}
if (other_value.hazardousLocation__ObstacleOnTheRoad().is_bound()) {
  single_value->field_hazardousLocation__ObstacleOnTheRoad = other_value.hazardousLocation__ObstacleOnTheRoad();
} else {
  single_value->field_hazardousLocation__ObstacleOnTheRoad.clean_up();
}
if (other_value.hazardousLocation__AnimalOnTheRoad().is_bound()) {
  single_value->field_hazardousLocation__AnimalOnTheRoad = other_value.hazardousLocation__AnimalOnTheRoad();
} else {
  single_value->field_hazardousLocation__AnimalOnTheRoad.clean_up();
}
if (other_value.humanPresenceOnTheRoad().is_bound()) {
  single_value->field_humanPresenceOnTheRoad = other_value.humanPresenceOnTheRoad();
} else {
  single_value->field_humanPresenceOnTheRoad.clean_up();
}
if (other_value.wrongWayDriving().is_bound()) {
  single_value->field_wrongWayDriving = other_value.wrongWayDriving();
} else {
  single_value->field_wrongWayDriving.clean_up();
}
if (other_value.rescueAndRecoveryWorkInProgress().is_bound()) {
  single_value->field_rescueAndRecoveryWorkInProgress = other_value.rescueAndRecoveryWorkInProgress();
} else {
  single_value->field_rescueAndRecoveryWorkInProgress.clean_up();
}
if (other_value.adverseWeatherCondition__ExtremeWeatherCondition().is_bound()) {
  single_value->field_adverseWeatherCondition__ExtremeWeatherCondition = other_value.adverseWeatherCondition__ExtremeWeatherCondition();
} else {
  single_value->field_adverseWeatherCondition__ExtremeWeatherCondition.clean_up();
}
if (other_value.adverseWeatherCondition__Visibility().is_bound()) {
  single_value->field_adverseWeatherCondition__Visibility = other_value.adverseWeatherCondition__Visibility();
} else {
  single_value->field_adverseWeatherCondition__Visibility.clean_up();
}
if (other_value.adverseWeatherCondition__Precipitation().is_bound()) {
  single_value->field_adverseWeatherCondition__Precipitation = other_value.adverseWeatherCondition__Precipitation();
} else {
  single_value->field_adverseWeatherCondition__Precipitation.clean_up();
}
if (other_value.slowVehicle().is_bound()) {
  single_value->field_slowVehicle = other_value.slowVehicle();
} else {
  single_value->field_slowVehicle.clean_up();
}
if (other_value.dangerousEndOfQueue().is_bound()) {
  single_value->field_dangerousEndOfQueue = other_value.dangerousEndOfQueue();
} else {
  single_value->field_dangerousEndOfQueue.clean_up();
}
if (other_value.vehicleBreakdown().is_bound()) {
  single_value->field_vehicleBreakdown = other_value.vehicleBreakdown();
} else {
  single_value->field_vehicleBreakdown.clean_up();
}
if (other_value.postCrash().is_bound()) {
  single_value->field_postCrash = other_value.postCrash();
} else {
  single_value->field_postCrash.clean_up();
}
if (other_value.humanProblem().is_bound()) {
  single_value->field_humanProblem = other_value.humanProblem();
} else {
  single_value->field_humanProblem.clean_up();
}
if (other_value.stationaryVehicle().is_bound()) {
  single_value->field_stationaryVehicle = other_value.stationaryVehicle();
} else {
  single_value->field_stationaryVehicle.clean_up();
}
if (other_value.emergencyVehicleApproaching().is_bound()) {
  single_value->field_emergencyVehicleApproaching = other_value.emergencyVehicleApproaching();
} else {
  single_value->field_emergencyVehicleApproaching.clean_up();
}
if (other_value.hazardousLocation__DangerousCurve().is_bound()) {
  single_value->field_hazardousLocation__DangerousCurve = other_value.hazardousLocation__DangerousCurve();
} else {
  single_value->field_hazardousLocation__DangerousCurve.clean_up();
}
if (other_value.collisionRisk().is_bound()) {
  single_value->field_collisionRisk = other_value.collisionRisk();
} else {
  single_value->field_collisionRisk.clean_up();
}
if (other_value.signalViolation().is_bound()) {
  single_value->field_signalViolation = other_value.signalViolation();
} else {
  single_value->field_signalViolation.clean_up();
}
if (other_value.dangerousSituation().is_bound()) {
  single_value->field_dangerousSituation = other_value.dangerousSituation();
} else {
  single_value->field_dangerousSituation.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SspDENM_template::copy_template(const SspDENM_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.trafficCondition().get_selection()) {
single_value->field_trafficCondition = other_value.trafficCondition();
} else {
single_value->field_trafficCondition.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.accident().get_selection()) {
single_value->field_accident = other_value.accident();
} else {
single_value->field_accident.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.roadworks().get_selection()) {
single_value->field_roadworks = other_value.roadworks();
} else {
single_value->field_roadworks.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.adverseWeatherCondition__Adhesion().get_selection()) {
single_value->field_adverseWeatherCondition__Adhesion = other_value.adverseWeatherCondition__Adhesion();
} else {
single_value->field_adverseWeatherCondition__Adhesion.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.hazardousLocation__SurfaceCondition().get_selection()) {
single_value->field_hazardousLocation__SurfaceCondition = other_value.hazardousLocation__SurfaceCondition();
} else {
single_value->field_hazardousLocation__SurfaceCondition.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.hazardousLocation__ObstacleOnTheRoad().get_selection()) {
single_value->field_hazardousLocation__ObstacleOnTheRoad = other_value.hazardousLocation__ObstacleOnTheRoad();
} else {
single_value->field_hazardousLocation__ObstacleOnTheRoad.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.hazardousLocation__AnimalOnTheRoad().get_selection()) {
single_value->field_hazardousLocation__AnimalOnTheRoad = other_value.hazardousLocation__AnimalOnTheRoad();
} else {
single_value->field_hazardousLocation__AnimalOnTheRoad.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.humanPresenceOnTheRoad().get_selection()) {
single_value->field_humanPresenceOnTheRoad = other_value.humanPresenceOnTheRoad();
} else {
single_value->field_humanPresenceOnTheRoad.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.wrongWayDriving().get_selection()) {
single_value->field_wrongWayDriving = other_value.wrongWayDriving();
} else {
single_value->field_wrongWayDriving.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.rescueAndRecoveryWorkInProgress().get_selection()) {
single_value->field_rescueAndRecoveryWorkInProgress = other_value.rescueAndRecoveryWorkInProgress();
} else {
single_value->field_rescueAndRecoveryWorkInProgress.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.adverseWeatherCondition__ExtremeWeatherCondition().get_selection()) {
single_value->field_adverseWeatherCondition__ExtremeWeatherCondition = other_value.adverseWeatherCondition__ExtremeWeatherCondition();
} else {
single_value->field_adverseWeatherCondition__ExtremeWeatherCondition.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.adverseWeatherCondition__Visibility().get_selection()) {
single_value->field_adverseWeatherCondition__Visibility = other_value.adverseWeatherCondition__Visibility();
} else {
single_value->field_adverseWeatherCondition__Visibility.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.adverseWeatherCondition__Precipitation().get_selection()) {
single_value->field_adverseWeatherCondition__Precipitation = other_value.adverseWeatherCondition__Precipitation();
} else {
single_value->field_adverseWeatherCondition__Precipitation.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.slowVehicle().get_selection()) {
single_value->field_slowVehicle = other_value.slowVehicle();
} else {
single_value->field_slowVehicle.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.dangerousEndOfQueue().get_selection()) {
single_value->field_dangerousEndOfQueue = other_value.dangerousEndOfQueue();
} else {
single_value->field_dangerousEndOfQueue.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.vehicleBreakdown().get_selection()) {
single_value->field_vehicleBreakdown = other_value.vehicleBreakdown();
} else {
single_value->field_vehicleBreakdown.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.postCrash().get_selection()) {
single_value->field_postCrash = other_value.postCrash();
} else {
single_value->field_postCrash.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.humanProblem().get_selection()) {
single_value->field_humanProblem = other_value.humanProblem();
} else {
single_value->field_humanProblem.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.stationaryVehicle().get_selection()) {
single_value->field_stationaryVehicle = other_value.stationaryVehicle();
} else {
single_value->field_stationaryVehicle.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.emergencyVehicleApproaching().get_selection()) {
single_value->field_emergencyVehicleApproaching = other_value.emergencyVehicleApproaching();
} else {
single_value->field_emergencyVehicleApproaching.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.hazardousLocation__DangerousCurve().get_selection()) {
single_value->field_hazardousLocation__DangerousCurve = other_value.hazardousLocation__DangerousCurve();
} else {
single_value->field_hazardousLocation__DangerousCurve.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.collisionRisk().get_selection()) {
single_value->field_collisionRisk = other_value.collisionRisk();
} else {
single_value->field_collisionRisk.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.signalViolation().get_selection()) {
single_value->field_signalViolation = other_value.signalViolation();
} else {
single_value->field_signalViolation.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.dangerousSituation().get_selection()) {
single_value->field_dangerousSituation = other_value.dangerousSituation();
} else {
single_value->field_dangerousSituation.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SspDENM_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SspDENM.");
break;
}
set_selection(other_value);
}

SspDENM_template::SspDENM_template()
{
}

SspDENM_template::SspDENM_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SspDENM_template::SspDENM_template(const SspDENM& other_value)
{
copy_value(other_value);
}

SspDENM_template::SspDENM_template(const OPTIONAL<SspDENM>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SspDENM&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.SspDENM from an unbound optional field.");
}
}

SspDENM_template::SspDENM_template(const SspDENM_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SspDENM_template::~SspDENM_template()
{
clean_up();
}

SspDENM_template& SspDENM_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SspDENM_template& SspDENM_template::operator=(const SspDENM& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SspDENM_template& SspDENM_template::operator=(const OPTIONAL<SspDENM>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SspDENM&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.SspDENM.");
}
return *this;
}

SspDENM_template& SspDENM_template::operator=(const SspDENM_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SspDENM_template::match(const SspDENM& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.trafficCondition().is_bound()) return FALSE;
if(!single_value->field_trafficCondition.match(other_value.trafficCondition(), legacy))return FALSE;
if(!other_value.accident().is_bound()) return FALSE;
if(!single_value->field_accident.match(other_value.accident(), legacy))return FALSE;
if(!other_value.roadworks().is_bound()) return FALSE;
if(!single_value->field_roadworks.match(other_value.roadworks(), legacy))return FALSE;
if(!other_value.adverseWeatherCondition__Adhesion().is_bound()) return FALSE;
if(!single_value->field_adverseWeatherCondition__Adhesion.match(other_value.adverseWeatherCondition__Adhesion(), legacy))return FALSE;
if(!other_value.hazardousLocation__SurfaceCondition().is_bound()) return FALSE;
if(!single_value->field_hazardousLocation__SurfaceCondition.match(other_value.hazardousLocation__SurfaceCondition(), legacy))return FALSE;
if(!other_value.hazardousLocation__ObstacleOnTheRoad().is_bound()) return FALSE;
if(!single_value->field_hazardousLocation__ObstacleOnTheRoad.match(other_value.hazardousLocation__ObstacleOnTheRoad(), legacy))return FALSE;
if(!other_value.hazardousLocation__AnimalOnTheRoad().is_bound()) return FALSE;
if(!single_value->field_hazardousLocation__AnimalOnTheRoad.match(other_value.hazardousLocation__AnimalOnTheRoad(), legacy))return FALSE;
if(!other_value.humanPresenceOnTheRoad().is_bound()) return FALSE;
if(!single_value->field_humanPresenceOnTheRoad.match(other_value.humanPresenceOnTheRoad(), legacy))return FALSE;
if(!other_value.wrongWayDriving().is_bound()) return FALSE;
if(!single_value->field_wrongWayDriving.match(other_value.wrongWayDriving(), legacy))return FALSE;
if(!other_value.rescueAndRecoveryWorkInProgress().is_bound()) return FALSE;
if(!single_value->field_rescueAndRecoveryWorkInProgress.match(other_value.rescueAndRecoveryWorkInProgress(), legacy))return FALSE;
if(!other_value.adverseWeatherCondition__ExtremeWeatherCondition().is_bound()) return FALSE;
if(!single_value->field_adverseWeatherCondition__ExtremeWeatherCondition.match(other_value.adverseWeatherCondition__ExtremeWeatherCondition(), legacy))return FALSE;
if(!other_value.adverseWeatherCondition__Visibility().is_bound()) return FALSE;
if(!single_value->field_adverseWeatherCondition__Visibility.match(other_value.adverseWeatherCondition__Visibility(), legacy))return FALSE;
if(!other_value.adverseWeatherCondition__Precipitation().is_bound()) return FALSE;
if(!single_value->field_adverseWeatherCondition__Precipitation.match(other_value.adverseWeatherCondition__Precipitation(), legacy))return FALSE;
if(!other_value.slowVehicle().is_bound()) return FALSE;
if(!single_value->field_slowVehicle.match(other_value.slowVehicle(), legacy))return FALSE;
if(!other_value.dangerousEndOfQueue().is_bound()) return FALSE;
if(!single_value->field_dangerousEndOfQueue.match(other_value.dangerousEndOfQueue(), legacy))return FALSE;
if(!other_value.vehicleBreakdown().is_bound()) return FALSE;
if(!single_value->field_vehicleBreakdown.match(other_value.vehicleBreakdown(), legacy))return FALSE;
if(!other_value.postCrash().is_bound()) return FALSE;
if(!single_value->field_postCrash.match(other_value.postCrash(), legacy))return FALSE;
if(!other_value.humanProblem().is_bound()) return FALSE;
if(!single_value->field_humanProblem.match(other_value.humanProblem(), legacy))return FALSE;
if(!other_value.stationaryVehicle().is_bound()) return FALSE;
if(!single_value->field_stationaryVehicle.match(other_value.stationaryVehicle(), legacy))return FALSE;
if(!other_value.emergencyVehicleApproaching().is_bound()) return FALSE;
if(!single_value->field_emergencyVehicleApproaching.match(other_value.emergencyVehicleApproaching(), legacy))return FALSE;
if(!other_value.hazardousLocation__DangerousCurve().is_bound()) return FALSE;
if(!single_value->field_hazardousLocation__DangerousCurve.match(other_value.hazardousLocation__DangerousCurve(), legacy))return FALSE;
if(!other_value.collisionRisk().is_bound()) return FALSE;
if(!single_value->field_collisionRisk.match(other_value.collisionRisk(), legacy))return FALSE;
if(!other_value.signalViolation().is_bound()) return FALSE;
if(!single_value->field_signalViolation.match(other_value.signalViolation(), legacy))return FALSE;
if(!other_value.dangerousSituation().is_bound()) return FALSE;
if(!single_value->field_dangerousSituation.match(other_value.dangerousSituation(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SspDENM.");
}
return FALSE;
}

boolean SspDENM_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_trafficCondition.is_bound()) return TRUE;
if (single_value->field_accident.is_bound()) return TRUE;
if (single_value->field_roadworks.is_bound()) return TRUE;
if (single_value->field_adverseWeatherCondition__Adhesion.is_bound()) return TRUE;
if (single_value->field_hazardousLocation__SurfaceCondition.is_bound()) return TRUE;
if (single_value->field_hazardousLocation__ObstacleOnTheRoad.is_bound()) return TRUE;
if (single_value->field_hazardousLocation__AnimalOnTheRoad.is_bound()) return TRUE;
if (single_value->field_humanPresenceOnTheRoad.is_bound()) return TRUE;
if (single_value->field_wrongWayDriving.is_bound()) return TRUE;
if (single_value->field_rescueAndRecoveryWorkInProgress.is_bound()) return TRUE;
if (single_value->field_adverseWeatherCondition__ExtremeWeatherCondition.is_bound()) return TRUE;
if (single_value->field_adverseWeatherCondition__Visibility.is_bound()) return TRUE;
if (single_value->field_adverseWeatherCondition__Precipitation.is_bound()) return TRUE;
if (single_value->field_slowVehicle.is_bound()) return TRUE;
if (single_value->field_dangerousEndOfQueue.is_bound()) return TRUE;
if (single_value->field_vehicleBreakdown.is_bound()) return TRUE;
if (single_value->field_postCrash.is_bound()) return TRUE;
if (single_value->field_humanProblem.is_bound()) return TRUE;
if (single_value->field_stationaryVehicle.is_bound()) return TRUE;
if (single_value->field_emergencyVehicleApproaching.is_bound()) return TRUE;
if (single_value->field_hazardousLocation__DangerousCurve.is_bound()) return TRUE;
if (single_value->field_collisionRisk.is_bound()) return TRUE;
if (single_value->field_signalViolation.is_bound()) return TRUE;
if (single_value->field_dangerousSituation.is_bound()) return TRUE;
return FALSE;
}

boolean SspDENM_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_trafficCondition.is_value()) return FALSE;
if (!single_value->field_accident.is_value()) return FALSE;
if (!single_value->field_roadworks.is_value()) return FALSE;
if (!single_value->field_adverseWeatherCondition__Adhesion.is_value()) return FALSE;
if (!single_value->field_hazardousLocation__SurfaceCondition.is_value()) return FALSE;
if (!single_value->field_hazardousLocation__ObstacleOnTheRoad.is_value()) return FALSE;
if (!single_value->field_hazardousLocation__AnimalOnTheRoad.is_value()) return FALSE;
if (!single_value->field_humanPresenceOnTheRoad.is_value()) return FALSE;
if (!single_value->field_wrongWayDriving.is_value()) return FALSE;
if (!single_value->field_rescueAndRecoveryWorkInProgress.is_value()) return FALSE;
if (!single_value->field_adverseWeatherCondition__ExtremeWeatherCondition.is_value()) return FALSE;
if (!single_value->field_adverseWeatherCondition__Visibility.is_value()) return FALSE;
if (!single_value->field_adverseWeatherCondition__Precipitation.is_value()) return FALSE;
if (!single_value->field_slowVehicle.is_value()) return FALSE;
if (!single_value->field_dangerousEndOfQueue.is_value()) return FALSE;
if (!single_value->field_vehicleBreakdown.is_value()) return FALSE;
if (!single_value->field_postCrash.is_value()) return FALSE;
if (!single_value->field_humanProblem.is_value()) return FALSE;
if (!single_value->field_stationaryVehicle.is_value()) return FALSE;
if (!single_value->field_emergencyVehicleApproaching.is_value()) return FALSE;
if (!single_value->field_hazardousLocation__DangerousCurve.is_value()) return FALSE;
if (!single_value->field_collisionRisk.is_value()) return FALSE;
if (!single_value->field_signalViolation.is_value()) return FALSE;
if (!single_value->field_dangerousSituation.is_value()) return FALSE;
return TRUE;
}

void SspDENM_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SspDENM SspDENM_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
SspDENM ret_val;
if (single_value->field_trafficCondition.is_bound()) {
ret_val.trafficCondition() = single_value->field_trafficCondition.valueof();
}
if (single_value->field_accident.is_bound()) {
ret_val.accident() = single_value->field_accident.valueof();
}
if (single_value->field_roadworks.is_bound()) {
ret_val.roadworks() = single_value->field_roadworks.valueof();
}
if (single_value->field_adverseWeatherCondition__Adhesion.is_bound()) {
ret_val.adverseWeatherCondition__Adhesion() = single_value->field_adverseWeatherCondition__Adhesion.valueof();
}
if (single_value->field_hazardousLocation__SurfaceCondition.is_bound()) {
ret_val.hazardousLocation__SurfaceCondition() = single_value->field_hazardousLocation__SurfaceCondition.valueof();
}
if (single_value->field_hazardousLocation__ObstacleOnTheRoad.is_bound()) {
ret_val.hazardousLocation__ObstacleOnTheRoad() = single_value->field_hazardousLocation__ObstacleOnTheRoad.valueof();
}
if (single_value->field_hazardousLocation__AnimalOnTheRoad.is_bound()) {
ret_val.hazardousLocation__AnimalOnTheRoad() = single_value->field_hazardousLocation__AnimalOnTheRoad.valueof();
}
if (single_value->field_humanPresenceOnTheRoad.is_bound()) {
ret_val.humanPresenceOnTheRoad() = single_value->field_humanPresenceOnTheRoad.valueof();
}
if (single_value->field_wrongWayDriving.is_bound()) {
ret_val.wrongWayDriving() = single_value->field_wrongWayDriving.valueof();
}
if (single_value->field_rescueAndRecoveryWorkInProgress.is_bound()) {
ret_val.rescueAndRecoveryWorkInProgress() = single_value->field_rescueAndRecoveryWorkInProgress.valueof();
}
if (single_value->field_adverseWeatherCondition__ExtremeWeatherCondition.is_bound()) {
ret_val.adverseWeatherCondition__ExtremeWeatherCondition() = single_value->field_adverseWeatherCondition__ExtremeWeatherCondition.valueof();
}
if (single_value->field_adverseWeatherCondition__Visibility.is_bound()) {
ret_val.adverseWeatherCondition__Visibility() = single_value->field_adverseWeatherCondition__Visibility.valueof();
}
if (single_value->field_adverseWeatherCondition__Precipitation.is_bound()) {
ret_val.adverseWeatherCondition__Precipitation() = single_value->field_adverseWeatherCondition__Precipitation.valueof();
}
if (single_value->field_slowVehicle.is_bound()) {
ret_val.slowVehicle() = single_value->field_slowVehicle.valueof();
}
if (single_value->field_dangerousEndOfQueue.is_bound()) {
ret_val.dangerousEndOfQueue() = single_value->field_dangerousEndOfQueue.valueof();
}
if (single_value->field_vehicleBreakdown.is_bound()) {
ret_val.vehicleBreakdown() = single_value->field_vehicleBreakdown.valueof();
}
if (single_value->field_postCrash.is_bound()) {
ret_val.postCrash() = single_value->field_postCrash.valueof();
}
if (single_value->field_humanProblem.is_bound()) {
ret_val.humanProblem() = single_value->field_humanProblem.valueof();
}
if (single_value->field_stationaryVehicle.is_bound()) {
ret_val.stationaryVehicle() = single_value->field_stationaryVehicle.valueof();
}
if (single_value->field_emergencyVehicleApproaching.is_bound()) {
ret_val.emergencyVehicleApproaching() = single_value->field_emergencyVehicleApproaching.valueof();
}
if (single_value->field_hazardousLocation__DangerousCurve.is_bound()) {
ret_val.hazardousLocation__DangerousCurve() = single_value->field_hazardousLocation__DangerousCurve.valueof();
}
if (single_value->field_collisionRisk.is_bound()) {
ret_val.collisionRisk() = single_value->field_collisionRisk.valueof();
}
if (single_value->field_signalViolation.is_bound()) {
ret_val.signalViolation() = single_value->field_signalViolation.valueof();
}
if (single_value->field_dangerousSituation.is_bound()) {
ret_val.dangerousSituation() = single_value->field_dangerousSituation.valueof();
}
return ret_val;
}

void SspDENM_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.SspDENM.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SspDENM_template[list_length];
}

SspDENM_template& SspDENM_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.SspDENM.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return value_list.list_value[list_index];
}

BITSTRING_template& SspDENM_template::trafficCondition()
{
set_specific();
return single_value->field_trafficCondition;
}

const BITSTRING_template& SspDENM_template::trafficCondition() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trafficCondition of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_trafficCondition;
}

BITSTRING_template& SspDENM_template::accident()
{
set_specific();
return single_value->field_accident;
}

const BITSTRING_template& SspDENM_template::accident() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field accident of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_accident;
}

BITSTRING_template& SspDENM_template::roadworks()
{
set_specific();
return single_value->field_roadworks;
}

const BITSTRING_template& SspDENM_template::roadworks() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field roadworks of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_roadworks;
}

BITSTRING_template& SspDENM_template::adverseWeatherCondition__Adhesion()
{
set_specific();
return single_value->field_adverseWeatherCondition__Adhesion;
}

const BITSTRING_template& SspDENM_template::adverseWeatherCondition__Adhesion() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field adverseWeatherCondition_Adhesion of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_adverseWeatherCondition__Adhesion;
}

BITSTRING_template& SspDENM_template::hazardousLocation__SurfaceCondition()
{
set_specific();
return single_value->field_hazardousLocation__SurfaceCondition;
}

const BITSTRING_template& SspDENM_template::hazardousLocation__SurfaceCondition() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field hazardousLocation_SurfaceCondition of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_hazardousLocation__SurfaceCondition;
}

BITSTRING_template& SspDENM_template::hazardousLocation__ObstacleOnTheRoad()
{
set_specific();
return single_value->field_hazardousLocation__ObstacleOnTheRoad;
}

const BITSTRING_template& SspDENM_template::hazardousLocation__ObstacleOnTheRoad() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field hazardousLocation_ObstacleOnTheRoad of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_hazardousLocation__ObstacleOnTheRoad;
}

BITSTRING_template& SspDENM_template::hazardousLocation__AnimalOnTheRoad()
{
set_specific();
return single_value->field_hazardousLocation__AnimalOnTheRoad;
}

const BITSTRING_template& SspDENM_template::hazardousLocation__AnimalOnTheRoad() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field hazardousLocation_AnimalOnTheRoad of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_hazardousLocation__AnimalOnTheRoad;
}

BITSTRING_template& SspDENM_template::humanPresenceOnTheRoad()
{
set_specific();
return single_value->field_humanPresenceOnTheRoad;
}

const BITSTRING_template& SspDENM_template::humanPresenceOnTheRoad() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field humanPresenceOnTheRoad of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_humanPresenceOnTheRoad;
}

BITSTRING_template& SspDENM_template::wrongWayDriving()
{
set_specific();
return single_value->field_wrongWayDriving;
}

const BITSTRING_template& SspDENM_template::wrongWayDriving() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field wrongWayDriving of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_wrongWayDriving;
}

BITSTRING_template& SspDENM_template::rescueAndRecoveryWorkInProgress()
{
set_specific();
return single_value->field_rescueAndRecoveryWorkInProgress;
}

const BITSTRING_template& SspDENM_template::rescueAndRecoveryWorkInProgress() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field rescueAndRecoveryWorkInProgress of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_rescueAndRecoveryWorkInProgress;
}

BITSTRING_template& SspDENM_template::adverseWeatherCondition__ExtremeWeatherCondition()
{
set_specific();
return single_value->field_adverseWeatherCondition__ExtremeWeatherCondition;
}

const BITSTRING_template& SspDENM_template::adverseWeatherCondition__ExtremeWeatherCondition() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field adverseWeatherCondition_ExtremeWeatherCondition of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_adverseWeatherCondition__ExtremeWeatherCondition;
}

BITSTRING_template& SspDENM_template::adverseWeatherCondition__Visibility()
{
set_specific();
return single_value->field_adverseWeatherCondition__Visibility;
}

const BITSTRING_template& SspDENM_template::adverseWeatherCondition__Visibility() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field adverseWeatherCondition_Visibility of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_adverseWeatherCondition__Visibility;
}

BITSTRING_template& SspDENM_template::adverseWeatherCondition__Precipitation()
{
set_specific();
return single_value->field_adverseWeatherCondition__Precipitation;
}

const BITSTRING_template& SspDENM_template::adverseWeatherCondition__Precipitation() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field adverseWeatherCondition_Precipitation of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_adverseWeatherCondition__Precipitation;
}

BITSTRING_template& SspDENM_template::slowVehicle()
{
set_specific();
return single_value->field_slowVehicle;
}

const BITSTRING_template& SspDENM_template::slowVehicle() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field slowVehicle of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_slowVehicle;
}

BITSTRING_template& SspDENM_template::dangerousEndOfQueue()
{
set_specific();
return single_value->field_dangerousEndOfQueue;
}

const BITSTRING_template& SspDENM_template::dangerousEndOfQueue() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field dangerousEndOfQueue of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_dangerousEndOfQueue;
}

BITSTRING_template& SspDENM_template::vehicleBreakdown()
{
set_specific();
return single_value->field_vehicleBreakdown;
}

const BITSTRING_template& SspDENM_template::vehicleBreakdown() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field vehicleBreakdown of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_vehicleBreakdown;
}

BITSTRING_template& SspDENM_template::postCrash()
{
set_specific();
return single_value->field_postCrash;
}

const BITSTRING_template& SspDENM_template::postCrash() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field postCrash of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_postCrash;
}

BITSTRING_template& SspDENM_template::humanProblem()
{
set_specific();
return single_value->field_humanProblem;
}

const BITSTRING_template& SspDENM_template::humanProblem() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field humanProblem of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_humanProblem;
}

BITSTRING_template& SspDENM_template::stationaryVehicle()
{
set_specific();
return single_value->field_stationaryVehicle;
}

const BITSTRING_template& SspDENM_template::stationaryVehicle() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field stationaryVehicle of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_stationaryVehicle;
}

BITSTRING_template& SspDENM_template::emergencyVehicleApproaching()
{
set_specific();
return single_value->field_emergencyVehicleApproaching;
}

const BITSTRING_template& SspDENM_template::emergencyVehicleApproaching() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field emergencyVehicleApproaching of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_emergencyVehicleApproaching;
}

BITSTRING_template& SspDENM_template::hazardousLocation__DangerousCurve()
{
set_specific();
return single_value->field_hazardousLocation__DangerousCurve;
}

const BITSTRING_template& SspDENM_template::hazardousLocation__DangerousCurve() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field hazardousLocation_DangerousCurve of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_hazardousLocation__DangerousCurve;
}

BITSTRING_template& SspDENM_template::collisionRisk()
{
set_specific();
return single_value->field_collisionRisk;
}

const BITSTRING_template& SspDENM_template::collisionRisk() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field collisionRisk of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_collisionRisk;
}

BITSTRING_template& SspDENM_template::signalViolation()
{
set_specific();
return single_value->field_signalViolation;
}

const BITSTRING_template& SspDENM_template::signalViolation() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field signalViolation of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_signalViolation;
}

BITSTRING_template& SspDENM_template::dangerousSituation()
{
set_specific();
return single_value->field_dangerousSituation;
}

const BITSTRING_template& SspDENM_template::dangerousSituation() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field dangerousSituation of a non-specific template of type @LibItsSecurity_TypesAndValues.SspDENM.");
return single_value->field_dangerousSituation;
}

int SspDENM_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SspDENM which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 24;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SspDENM containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SspDENM containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SspDENM containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SspDENM containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SspDENM containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SspDENM.");
  }
  return 0;
}

void SspDENM_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ trafficCondition := ");
single_value->field_trafficCondition.log();
TTCN_Logger::log_event_str(", accident := ");
single_value->field_accident.log();
TTCN_Logger::log_event_str(", roadworks := ");
single_value->field_roadworks.log();
TTCN_Logger::log_event_str(", adverseWeatherCondition_Adhesion := ");
single_value->field_adverseWeatherCondition__Adhesion.log();
TTCN_Logger::log_event_str(", hazardousLocation_SurfaceCondition := ");
single_value->field_hazardousLocation__SurfaceCondition.log();
TTCN_Logger::log_event_str(", hazardousLocation_ObstacleOnTheRoad := ");
single_value->field_hazardousLocation__ObstacleOnTheRoad.log();
TTCN_Logger::log_event_str(", hazardousLocation_AnimalOnTheRoad := ");
single_value->field_hazardousLocation__AnimalOnTheRoad.log();
TTCN_Logger::log_event_str(", humanPresenceOnTheRoad := ");
single_value->field_humanPresenceOnTheRoad.log();
TTCN_Logger::log_event_str(", wrongWayDriving := ");
single_value->field_wrongWayDriving.log();
TTCN_Logger::log_event_str(", rescueAndRecoveryWorkInProgress := ");
single_value->field_rescueAndRecoveryWorkInProgress.log();
TTCN_Logger::log_event_str(", adverseWeatherCondition_ExtremeWeatherCondition := ");
single_value->field_adverseWeatherCondition__ExtremeWeatherCondition.log();
TTCN_Logger::log_event_str(", adverseWeatherCondition_Visibility := ");
single_value->field_adverseWeatherCondition__Visibility.log();
TTCN_Logger::log_event_str(", adverseWeatherCondition_Precipitation := ");
single_value->field_adverseWeatherCondition__Precipitation.log();
TTCN_Logger::log_event_str(", slowVehicle := ");
single_value->field_slowVehicle.log();
TTCN_Logger::log_event_str(", dangerousEndOfQueue := ");
single_value->field_dangerousEndOfQueue.log();
TTCN_Logger::log_event_str(", vehicleBreakdown := ");
single_value->field_vehicleBreakdown.log();
TTCN_Logger::log_event_str(", postCrash := ");
single_value->field_postCrash.log();
TTCN_Logger::log_event_str(", humanProblem := ");
single_value->field_humanProblem.log();
TTCN_Logger::log_event_str(", stationaryVehicle := ");
single_value->field_stationaryVehicle.log();
TTCN_Logger::log_event_str(", emergencyVehicleApproaching := ");
single_value->field_emergencyVehicleApproaching.log();
TTCN_Logger::log_event_str(", hazardousLocation_DangerousCurve := ");
single_value->field_hazardousLocation__DangerousCurve.log();
TTCN_Logger::log_event_str(", collisionRisk := ");
single_value->field_collisionRisk.log();
TTCN_Logger::log_event_str(", signalViolation := ");
single_value->field_signalViolation.log();
TTCN_Logger::log_event_str(", dangerousSituation := ");
single_value->field_dangerousSituation.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SspDENM_template::log_match(const SspDENM& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_trafficCondition.match(match_value.trafficCondition(), legacy)){
TTCN_Logger::log_logmatch_info(".trafficCondition");
single_value->field_trafficCondition.log_match(match_value.trafficCondition(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_accident.match(match_value.accident(), legacy)){
TTCN_Logger::log_logmatch_info(".accident");
single_value->field_accident.log_match(match_value.accident(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_roadworks.match(match_value.roadworks(), legacy)){
TTCN_Logger::log_logmatch_info(".roadworks");
single_value->field_roadworks.log_match(match_value.roadworks(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_adverseWeatherCondition__Adhesion.match(match_value.adverseWeatherCondition__Adhesion(), legacy)){
TTCN_Logger::log_logmatch_info(".adverseWeatherCondition_Adhesion");
single_value->field_adverseWeatherCondition__Adhesion.log_match(match_value.adverseWeatherCondition__Adhesion(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_hazardousLocation__SurfaceCondition.match(match_value.hazardousLocation__SurfaceCondition(), legacy)){
TTCN_Logger::log_logmatch_info(".hazardousLocation_SurfaceCondition");
single_value->field_hazardousLocation__SurfaceCondition.log_match(match_value.hazardousLocation__SurfaceCondition(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_hazardousLocation__ObstacleOnTheRoad.match(match_value.hazardousLocation__ObstacleOnTheRoad(), legacy)){
TTCN_Logger::log_logmatch_info(".hazardousLocation_ObstacleOnTheRoad");
single_value->field_hazardousLocation__ObstacleOnTheRoad.log_match(match_value.hazardousLocation__ObstacleOnTheRoad(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_hazardousLocation__AnimalOnTheRoad.match(match_value.hazardousLocation__AnimalOnTheRoad(), legacy)){
TTCN_Logger::log_logmatch_info(".hazardousLocation_AnimalOnTheRoad");
single_value->field_hazardousLocation__AnimalOnTheRoad.log_match(match_value.hazardousLocation__AnimalOnTheRoad(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_humanPresenceOnTheRoad.match(match_value.humanPresenceOnTheRoad(), legacy)){
TTCN_Logger::log_logmatch_info(".humanPresenceOnTheRoad");
single_value->field_humanPresenceOnTheRoad.log_match(match_value.humanPresenceOnTheRoad(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_wrongWayDriving.match(match_value.wrongWayDriving(), legacy)){
TTCN_Logger::log_logmatch_info(".wrongWayDriving");
single_value->field_wrongWayDriving.log_match(match_value.wrongWayDriving(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_rescueAndRecoveryWorkInProgress.match(match_value.rescueAndRecoveryWorkInProgress(), legacy)){
TTCN_Logger::log_logmatch_info(".rescueAndRecoveryWorkInProgress");
single_value->field_rescueAndRecoveryWorkInProgress.log_match(match_value.rescueAndRecoveryWorkInProgress(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_adverseWeatherCondition__ExtremeWeatherCondition.match(match_value.adverseWeatherCondition__ExtremeWeatherCondition(), legacy)){
TTCN_Logger::log_logmatch_info(".adverseWeatherCondition_ExtremeWeatherCondition");
single_value->field_adverseWeatherCondition__ExtremeWeatherCondition.log_match(match_value.adverseWeatherCondition__ExtremeWeatherCondition(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_adverseWeatherCondition__Visibility.match(match_value.adverseWeatherCondition__Visibility(), legacy)){
TTCN_Logger::log_logmatch_info(".adverseWeatherCondition_Visibility");
single_value->field_adverseWeatherCondition__Visibility.log_match(match_value.adverseWeatherCondition__Visibility(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_adverseWeatherCondition__Precipitation.match(match_value.adverseWeatherCondition__Precipitation(), legacy)){
TTCN_Logger::log_logmatch_info(".adverseWeatherCondition_Precipitation");
single_value->field_adverseWeatherCondition__Precipitation.log_match(match_value.adverseWeatherCondition__Precipitation(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_slowVehicle.match(match_value.slowVehicle(), legacy)){
TTCN_Logger::log_logmatch_info(".slowVehicle");
single_value->field_slowVehicle.log_match(match_value.slowVehicle(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_dangerousEndOfQueue.match(match_value.dangerousEndOfQueue(), legacy)){
TTCN_Logger::log_logmatch_info(".dangerousEndOfQueue");
single_value->field_dangerousEndOfQueue.log_match(match_value.dangerousEndOfQueue(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_vehicleBreakdown.match(match_value.vehicleBreakdown(), legacy)){
TTCN_Logger::log_logmatch_info(".vehicleBreakdown");
single_value->field_vehicleBreakdown.log_match(match_value.vehicleBreakdown(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_postCrash.match(match_value.postCrash(), legacy)){
TTCN_Logger::log_logmatch_info(".postCrash");
single_value->field_postCrash.log_match(match_value.postCrash(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_humanProblem.match(match_value.humanProblem(), legacy)){
TTCN_Logger::log_logmatch_info(".humanProblem");
single_value->field_humanProblem.log_match(match_value.humanProblem(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_stationaryVehicle.match(match_value.stationaryVehicle(), legacy)){
TTCN_Logger::log_logmatch_info(".stationaryVehicle");
single_value->field_stationaryVehicle.log_match(match_value.stationaryVehicle(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_emergencyVehicleApproaching.match(match_value.emergencyVehicleApproaching(), legacy)){
TTCN_Logger::log_logmatch_info(".emergencyVehicleApproaching");
single_value->field_emergencyVehicleApproaching.log_match(match_value.emergencyVehicleApproaching(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_hazardousLocation__DangerousCurve.match(match_value.hazardousLocation__DangerousCurve(), legacy)){
TTCN_Logger::log_logmatch_info(".hazardousLocation_DangerousCurve");
single_value->field_hazardousLocation__DangerousCurve.log_match(match_value.hazardousLocation__DangerousCurve(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_collisionRisk.match(match_value.collisionRisk(), legacy)){
TTCN_Logger::log_logmatch_info(".collisionRisk");
single_value->field_collisionRisk.log_match(match_value.collisionRisk(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_signalViolation.match(match_value.signalViolation(), legacy)){
TTCN_Logger::log_logmatch_info(".signalViolation");
single_value->field_signalViolation.log_match(match_value.signalViolation(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_dangerousSituation.match(match_value.dangerousSituation(), legacy)){
TTCN_Logger::log_logmatch_info(".dangerousSituation");
single_value->field_dangerousSituation.log_match(match_value.dangerousSituation(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ trafficCondition := ");
single_value->field_trafficCondition.log_match(match_value.trafficCondition(), legacy);
TTCN_Logger::log_event_str(", accident := ");
single_value->field_accident.log_match(match_value.accident(), legacy);
TTCN_Logger::log_event_str(", roadworks := ");
single_value->field_roadworks.log_match(match_value.roadworks(), legacy);
TTCN_Logger::log_event_str(", adverseWeatherCondition_Adhesion := ");
single_value->field_adverseWeatherCondition__Adhesion.log_match(match_value.adverseWeatherCondition__Adhesion(), legacy);
TTCN_Logger::log_event_str(", hazardousLocation_SurfaceCondition := ");
single_value->field_hazardousLocation__SurfaceCondition.log_match(match_value.hazardousLocation__SurfaceCondition(), legacy);
TTCN_Logger::log_event_str(", hazardousLocation_ObstacleOnTheRoad := ");
single_value->field_hazardousLocation__ObstacleOnTheRoad.log_match(match_value.hazardousLocation__ObstacleOnTheRoad(), legacy);
TTCN_Logger::log_event_str(", hazardousLocation_AnimalOnTheRoad := ");
single_value->field_hazardousLocation__AnimalOnTheRoad.log_match(match_value.hazardousLocation__AnimalOnTheRoad(), legacy);
TTCN_Logger::log_event_str(", humanPresenceOnTheRoad := ");
single_value->field_humanPresenceOnTheRoad.log_match(match_value.humanPresenceOnTheRoad(), legacy);
TTCN_Logger::log_event_str(", wrongWayDriving := ");
single_value->field_wrongWayDriving.log_match(match_value.wrongWayDriving(), legacy);
TTCN_Logger::log_event_str(", rescueAndRecoveryWorkInProgress := ");
single_value->field_rescueAndRecoveryWorkInProgress.log_match(match_value.rescueAndRecoveryWorkInProgress(), legacy);
TTCN_Logger::log_event_str(", adverseWeatherCondition_ExtremeWeatherCondition := ");
single_value->field_adverseWeatherCondition__ExtremeWeatherCondition.log_match(match_value.adverseWeatherCondition__ExtremeWeatherCondition(), legacy);
TTCN_Logger::log_event_str(", adverseWeatherCondition_Visibility := ");
single_value->field_adverseWeatherCondition__Visibility.log_match(match_value.adverseWeatherCondition__Visibility(), legacy);
TTCN_Logger::log_event_str(", adverseWeatherCondition_Precipitation := ");
single_value->field_adverseWeatherCondition__Precipitation.log_match(match_value.adverseWeatherCondition__Precipitation(), legacy);
TTCN_Logger::log_event_str(", slowVehicle := ");
single_value->field_slowVehicle.log_match(match_value.slowVehicle(), legacy);
TTCN_Logger::log_event_str(", dangerousEndOfQueue := ");
single_value->field_dangerousEndOfQueue.log_match(match_value.dangerousEndOfQueue(), legacy);
TTCN_Logger::log_event_str(", vehicleBreakdown := ");
single_value->field_vehicleBreakdown.log_match(match_value.vehicleBreakdown(), legacy);
TTCN_Logger::log_event_str(", postCrash := ");
single_value->field_postCrash.log_match(match_value.postCrash(), legacy);
TTCN_Logger::log_event_str(", humanProblem := ");
single_value->field_humanProblem.log_match(match_value.humanProblem(), legacy);
TTCN_Logger::log_event_str(", stationaryVehicle := ");
single_value->field_stationaryVehicle.log_match(match_value.stationaryVehicle(), legacy);
TTCN_Logger::log_event_str(", emergencyVehicleApproaching := ");
single_value->field_emergencyVehicleApproaching.log_match(match_value.emergencyVehicleApproaching(), legacy);
TTCN_Logger::log_event_str(", hazardousLocation_DangerousCurve := ");
single_value->field_hazardousLocation__DangerousCurve.log_match(match_value.hazardousLocation__DangerousCurve(), legacy);
TTCN_Logger::log_event_str(", collisionRisk := ");
single_value->field_collisionRisk.log_match(match_value.collisionRisk(), legacy);
TTCN_Logger::log_event_str(", signalViolation := ");
single_value->field_signalViolation.log_match(match_value.signalViolation(), legacy);
TTCN_Logger::log_event_str(", dangerousSituation := ");
single_value->field_dangerousSituation.log_match(match_value.dangerousSituation(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SspDENM_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_trafficCondition.encode_text(text_buf);
single_value->field_accident.encode_text(text_buf);
single_value->field_roadworks.encode_text(text_buf);
single_value->field_adverseWeatherCondition__Adhesion.encode_text(text_buf);
single_value->field_hazardousLocation__SurfaceCondition.encode_text(text_buf);
single_value->field_hazardousLocation__ObstacleOnTheRoad.encode_text(text_buf);
single_value->field_hazardousLocation__AnimalOnTheRoad.encode_text(text_buf);
single_value->field_humanPresenceOnTheRoad.encode_text(text_buf);
single_value->field_wrongWayDriving.encode_text(text_buf);
single_value->field_rescueAndRecoveryWorkInProgress.encode_text(text_buf);
single_value->field_adverseWeatherCondition__ExtremeWeatherCondition.encode_text(text_buf);
single_value->field_adverseWeatherCondition__Visibility.encode_text(text_buf);
single_value->field_adverseWeatherCondition__Precipitation.encode_text(text_buf);
single_value->field_slowVehicle.encode_text(text_buf);
single_value->field_dangerousEndOfQueue.encode_text(text_buf);
single_value->field_vehicleBreakdown.encode_text(text_buf);
single_value->field_postCrash.encode_text(text_buf);
single_value->field_humanProblem.encode_text(text_buf);
single_value->field_stationaryVehicle.encode_text(text_buf);
single_value->field_emergencyVehicleApproaching.encode_text(text_buf);
single_value->field_hazardousLocation__DangerousCurve.encode_text(text_buf);
single_value->field_collisionRisk.encode_text(text_buf);
single_value->field_signalViolation.encode_text(text_buf);
single_value->field_dangerousSituation.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SspDENM.");
}
}

void SspDENM_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_trafficCondition.decode_text(text_buf);
single_value->field_accident.decode_text(text_buf);
single_value->field_roadworks.decode_text(text_buf);
single_value->field_adverseWeatherCondition__Adhesion.decode_text(text_buf);
single_value->field_hazardousLocation__SurfaceCondition.decode_text(text_buf);
single_value->field_hazardousLocation__ObstacleOnTheRoad.decode_text(text_buf);
single_value->field_hazardousLocation__AnimalOnTheRoad.decode_text(text_buf);
single_value->field_humanPresenceOnTheRoad.decode_text(text_buf);
single_value->field_wrongWayDriving.decode_text(text_buf);
single_value->field_rescueAndRecoveryWorkInProgress.decode_text(text_buf);
single_value->field_adverseWeatherCondition__ExtremeWeatherCondition.decode_text(text_buf);
single_value->field_adverseWeatherCondition__Visibility.decode_text(text_buf);
single_value->field_adverseWeatherCondition__Precipitation.decode_text(text_buf);
single_value->field_slowVehicle.decode_text(text_buf);
single_value->field_dangerousEndOfQueue.decode_text(text_buf);
single_value->field_vehicleBreakdown.decode_text(text_buf);
single_value->field_postCrash.decode_text(text_buf);
single_value->field_humanProblem.decode_text(text_buf);
single_value->field_stationaryVehicle.decode_text(text_buf);
single_value->field_emergencyVehicleApproaching.decode_text(text_buf);
single_value->field_hazardousLocation__DangerousCurve.decode_text(text_buf);
single_value->field_collisionRisk.decode_text(text_buf);
single_value->field_signalViolation.decode_text(text_buf);
single_value->field_dangerousSituation.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SspDENM_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.SspDENM.");
}
}

void SspDENM_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.SspDENM'");
    }
    if (strcmp("trafficCondition", param_field) == 0) {
      trafficCondition().set_param(param);
      return;
    } else if (strcmp("accident", param_field) == 0) {
      accident().set_param(param);
      return;
    } else if (strcmp("roadworks", param_field) == 0) {
      roadworks().set_param(param);
      return;
    } else if (strcmp("adverseWeatherCondition_Adhesion", param_field) == 0) {
      adverseWeatherCondition__Adhesion().set_param(param);
      return;
    } else if (strcmp("hazardousLocation_SurfaceCondition", param_field) == 0) {
      hazardousLocation__SurfaceCondition().set_param(param);
      return;
    } else if (strcmp("hazardousLocation_ObstacleOnTheRoad", param_field) == 0) {
      hazardousLocation__ObstacleOnTheRoad().set_param(param);
      return;
    } else if (strcmp("hazardousLocation_AnimalOnTheRoad", param_field) == 0) {
      hazardousLocation__AnimalOnTheRoad().set_param(param);
      return;
    } else if (strcmp("humanPresenceOnTheRoad", param_field) == 0) {
      humanPresenceOnTheRoad().set_param(param);
      return;
    } else if (strcmp("wrongWayDriving", param_field) == 0) {
      wrongWayDriving().set_param(param);
      return;
    } else if (strcmp("rescueAndRecoveryWorkInProgress", param_field) == 0) {
      rescueAndRecoveryWorkInProgress().set_param(param);
      return;
    } else if (strcmp("adverseWeatherCondition_ExtremeWeatherCondition", param_field) == 0) {
      adverseWeatherCondition__ExtremeWeatherCondition().set_param(param);
      return;
    } else if (strcmp("adverseWeatherCondition_Visibility", param_field) == 0) {
      adverseWeatherCondition__Visibility().set_param(param);
      return;
    } else if (strcmp("adverseWeatherCondition_Precipitation", param_field) == 0) {
      adverseWeatherCondition__Precipitation().set_param(param);
      return;
    } else if (strcmp("slowVehicle", param_field) == 0) {
      slowVehicle().set_param(param);
      return;
    } else if (strcmp("dangerousEndOfQueue", param_field) == 0) {
      dangerousEndOfQueue().set_param(param);
      return;
    } else if (strcmp("vehicleBreakdown", param_field) == 0) {
      vehicleBreakdown().set_param(param);
      return;
    } else if (strcmp("postCrash", param_field) == 0) {
      postCrash().set_param(param);
      return;
    } else if (strcmp("humanProblem", param_field) == 0) {
      humanProblem().set_param(param);
      return;
    } else if (strcmp("stationaryVehicle", param_field) == 0) {
      stationaryVehicle().set_param(param);
      return;
    } else if (strcmp("emergencyVehicleApproaching", param_field) == 0) {
      emergencyVehicleApproaching().set_param(param);
      return;
    } else if (strcmp("hazardousLocation_DangerousCurve", param_field) == 0) {
      hazardousLocation__DangerousCurve().set_param(param);
      return;
    } else if (strcmp("collisionRisk", param_field) == 0) {
      collisionRisk().set_param(param);
      return;
    } else if (strcmp("signalViolation", param_field) == 0) {
      signalViolation().set_param(param);
      return;
    } else if (strcmp("dangerousSituation", param_field) == 0) {
      dangerousSituation().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.SspDENM'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SspDENM_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (24<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.SspDENM has 24 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) trafficCondition().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) accident().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) roadworks().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) adverseWeatherCondition__Adhesion().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) hazardousLocation__SurfaceCondition().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) hazardousLocation__ObstacleOnTheRoad().set_param(*mp->get_elem(5));
    if (mp->get_size()>6 && mp->get_elem(6)->get_type()!=Module_Param::MP_NotUsed) hazardousLocation__AnimalOnTheRoad().set_param(*mp->get_elem(6));
    if (mp->get_size()>7 && mp->get_elem(7)->get_type()!=Module_Param::MP_NotUsed) humanPresenceOnTheRoad().set_param(*mp->get_elem(7));
    if (mp->get_size()>8 && mp->get_elem(8)->get_type()!=Module_Param::MP_NotUsed) wrongWayDriving().set_param(*mp->get_elem(8));
    if (mp->get_size()>9 && mp->get_elem(9)->get_type()!=Module_Param::MP_NotUsed) rescueAndRecoveryWorkInProgress().set_param(*mp->get_elem(9));
    if (mp->get_size()>10 && mp->get_elem(10)->get_type()!=Module_Param::MP_NotUsed) adverseWeatherCondition__ExtremeWeatherCondition().set_param(*mp->get_elem(10));
    if (mp->get_size()>11 && mp->get_elem(11)->get_type()!=Module_Param::MP_NotUsed) adverseWeatherCondition__Visibility().set_param(*mp->get_elem(11));
    if (mp->get_size()>12 && mp->get_elem(12)->get_type()!=Module_Param::MP_NotUsed) adverseWeatherCondition__Precipitation().set_param(*mp->get_elem(12));
    if (mp->get_size()>13 && mp->get_elem(13)->get_type()!=Module_Param::MP_NotUsed) slowVehicle().set_param(*mp->get_elem(13));
    if (mp->get_size()>14 && mp->get_elem(14)->get_type()!=Module_Param::MP_NotUsed) dangerousEndOfQueue().set_param(*mp->get_elem(14));
    if (mp->get_size()>15 && mp->get_elem(15)->get_type()!=Module_Param::MP_NotUsed) vehicleBreakdown().set_param(*mp->get_elem(15));
    if (mp->get_size()>16 && mp->get_elem(16)->get_type()!=Module_Param::MP_NotUsed) postCrash().set_param(*mp->get_elem(16));
    if (mp->get_size()>17 && mp->get_elem(17)->get_type()!=Module_Param::MP_NotUsed) humanProblem().set_param(*mp->get_elem(17));
    if (mp->get_size()>18 && mp->get_elem(18)->get_type()!=Module_Param::MP_NotUsed) stationaryVehicle().set_param(*mp->get_elem(18));
    if (mp->get_size()>19 && mp->get_elem(19)->get_type()!=Module_Param::MP_NotUsed) emergencyVehicleApproaching().set_param(*mp->get_elem(19));
    if (mp->get_size()>20 && mp->get_elem(20)->get_type()!=Module_Param::MP_NotUsed) hazardousLocation__DangerousCurve().set_param(*mp->get_elem(20));
    if (mp->get_size()>21 && mp->get_elem(21)->get_type()!=Module_Param::MP_NotUsed) collisionRisk().set_param(*mp->get_elem(21));
    if (mp->get_size()>22 && mp->get_elem(22)->get_type()!=Module_Param::MP_NotUsed) signalViolation().set_param(*mp->get_elem(22));
    if (mp->get_size()>23 && mp->get_elem(23)->get_type()!=Module_Param::MP_NotUsed) dangerousSituation().set_param(*mp->get_elem(23));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trafficCondition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trafficCondition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "accident")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          accident().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "roadworks")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          roadworks().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "adverseWeatherCondition_Adhesion")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          adverseWeatherCondition__Adhesion().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hazardousLocation_SurfaceCondition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hazardousLocation__SurfaceCondition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hazardousLocation_ObstacleOnTheRoad")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hazardousLocation__ObstacleOnTheRoad().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hazardousLocation_AnimalOnTheRoad")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hazardousLocation__AnimalOnTheRoad().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "humanPresenceOnTheRoad")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          humanPresenceOnTheRoad().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "wrongWayDriving")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          wrongWayDriving().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "rescueAndRecoveryWorkInProgress")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          rescueAndRecoveryWorkInProgress().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "adverseWeatherCondition_ExtremeWeatherCondition")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          adverseWeatherCondition__ExtremeWeatherCondition().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "adverseWeatherCondition_Visibility")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          adverseWeatherCondition__Visibility().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "adverseWeatherCondition_Precipitation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          adverseWeatherCondition__Precipitation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "slowVehicle")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          slowVehicle().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dangerousEndOfQueue")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dangerousEndOfQueue().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "vehicleBreakdown")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          vehicleBreakdown().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "postCrash")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          postCrash().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "humanProblem")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          humanProblem().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "stationaryVehicle")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          stationaryVehicle().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "emergencyVehicleApproaching")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          emergencyVehicleApproaching().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "hazardousLocation_DangerousCurve")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          hazardousLocation__DangerousCurve().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "collisionRisk")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          collisionRisk().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signalViolation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signalViolation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "dangerousSituation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          dangerousSituation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.SspDENM: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.SspDENM");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SspDENM_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.SspDENM'");
    }
    if (strcmp("trafficCondition", param_field) == 0) {
      return trafficCondition().get_param(param_name);
    } else if (strcmp("accident", param_field) == 0) {
      return accident().get_param(param_name);
    } else if (strcmp("roadworks", param_field) == 0) {
      return roadworks().get_param(param_name);
    } else if (strcmp("adverseWeatherCondition_Adhesion", param_field) == 0) {
      return adverseWeatherCondition__Adhesion().get_param(param_name);
    } else if (strcmp("hazardousLocation_SurfaceCondition", param_field) == 0) {
      return hazardousLocation__SurfaceCondition().get_param(param_name);
    } else if (strcmp("hazardousLocation_ObstacleOnTheRoad", param_field) == 0) {
      return hazardousLocation__ObstacleOnTheRoad().get_param(param_name);
    } else if (strcmp("hazardousLocation_AnimalOnTheRoad", param_field) == 0) {
      return hazardousLocation__AnimalOnTheRoad().get_param(param_name);
    } else if (strcmp("humanPresenceOnTheRoad", param_field) == 0) {
      return humanPresenceOnTheRoad().get_param(param_name);
    } else if (strcmp("wrongWayDriving", param_field) == 0) {
      return wrongWayDriving().get_param(param_name);
    } else if (strcmp("rescueAndRecoveryWorkInProgress", param_field) == 0) {
      return rescueAndRecoveryWorkInProgress().get_param(param_name);
    } else if (strcmp("adverseWeatherCondition_ExtremeWeatherCondition", param_field) == 0) {
      return adverseWeatherCondition__ExtremeWeatherCondition().get_param(param_name);
    } else if (strcmp("adverseWeatherCondition_Visibility", param_field) == 0) {
      return adverseWeatherCondition__Visibility().get_param(param_name);
    } else if (strcmp("adverseWeatherCondition_Precipitation", param_field) == 0) {
      return adverseWeatherCondition__Precipitation().get_param(param_name);
    } else if (strcmp("slowVehicle", param_field) == 0) {
      return slowVehicle().get_param(param_name);
    } else if (strcmp("dangerousEndOfQueue", param_field) == 0) {
      return dangerousEndOfQueue().get_param(param_name);
    } else if (strcmp("vehicleBreakdown", param_field) == 0) {
      return vehicleBreakdown().get_param(param_name);
    } else if (strcmp("postCrash", param_field) == 0) {
      return postCrash().get_param(param_name);
    } else if (strcmp("humanProblem", param_field) == 0) {
      return humanProblem().get_param(param_name);
    } else if (strcmp("stationaryVehicle", param_field) == 0) {
      return stationaryVehicle().get_param(param_name);
    } else if (strcmp("emergencyVehicleApproaching", param_field) == 0) {
      return emergencyVehicleApproaching().get_param(param_name);
    } else if (strcmp("hazardousLocation_DangerousCurve", param_field) == 0) {
      return hazardousLocation__DangerousCurve().get_param(param_name);
    } else if (strcmp("collisionRisk", param_field) == 0) {
      return collisionRisk().get_param(param_name);
    } else if (strcmp("signalViolation", param_field) == 0) {
      return signalViolation().get_param(param_name);
    } else if (strcmp("dangerousSituation", param_field) == 0) {
      return dangerousSituation().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SspDENM'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_trafficCondition = single_value->field_trafficCondition.get_param(param_name);
    mp_field_trafficCondition->set_id(new Module_Param_FieldName(mcopystr("trafficCondition")));
    mp->add_elem(mp_field_trafficCondition);
    Module_Param* mp_field_accident = single_value->field_accident.get_param(param_name);
    mp_field_accident->set_id(new Module_Param_FieldName(mcopystr("accident")));
    mp->add_elem(mp_field_accident);
    Module_Param* mp_field_roadworks = single_value->field_roadworks.get_param(param_name);
    mp_field_roadworks->set_id(new Module_Param_FieldName(mcopystr("roadworks")));
    mp->add_elem(mp_field_roadworks);
    Module_Param* mp_field_adverseWeatherCondition__Adhesion = single_value->field_adverseWeatherCondition__Adhesion.get_param(param_name);
    mp_field_adverseWeatherCondition__Adhesion->set_id(new Module_Param_FieldName(mcopystr("adverseWeatherCondition_Adhesion")));
    mp->add_elem(mp_field_adverseWeatherCondition__Adhesion);
    Module_Param* mp_field_hazardousLocation__SurfaceCondition = single_value->field_hazardousLocation__SurfaceCondition.get_param(param_name);
    mp_field_hazardousLocation__SurfaceCondition->set_id(new Module_Param_FieldName(mcopystr("hazardousLocation_SurfaceCondition")));
    mp->add_elem(mp_field_hazardousLocation__SurfaceCondition);
    Module_Param* mp_field_hazardousLocation__ObstacleOnTheRoad = single_value->field_hazardousLocation__ObstacleOnTheRoad.get_param(param_name);
    mp_field_hazardousLocation__ObstacleOnTheRoad->set_id(new Module_Param_FieldName(mcopystr("hazardousLocation_ObstacleOnTheRoad")));
    mp->add_elem(mp_field_hazardousLocation__ObstacleOnTheRoad);
    Module_Param* mp_field_hazardousLocation__AnimalOnTheRoad = single_value->field_hazardousLocation__AnimalOnTheRoad.get_param(param_name);
    mp_field_hazardousLocation__AnimalOnTheRoad->set_id(new Module_Param_FieldName(mcopystr("hazardousLocation_AnimalOnTheRoad")));
    mp->add_elem(mp_field_hazardousLocation__AnimalOnTheRoad);
    Module_Param* mp_field_humanPresenceOnTheRoad = single_value->field_humanPresenceOnTheRoad.get_param(param_name);
    mp_field_humanPresenceOnTheRoad->set_id(new Module_Param_FieldName(mcopystr("humanPresenceOnTheRoad")));
    mp->add_elem(mp_field_humanPresenceOnTheRoad);
    Module_Param* mp_field_wrongWayDriving = single_value->field_wrongWayDriving.get_param(param_name);
    mp_field_wrongWayDriving->set_id(new Module_Param_FieldName(mcopystr("wrongWayDriving")));
    mp->add_elem(mp_field_wrongWayDriving);
    Module_Param* mp_field_rescueAndRecoveryWorkInProgress = single_value->field_rescueAndRecoveryWorkInProgress.get_param(param_name);
    mp_field_rescueAndRecoveryWorkInProgress->set_id(new Module_Param_FieldName(mcopystr("rescueAndRecoveryWorkInProgress")));
    mp->add_elem(mp_field_rescueAndRecoveryWorkInProgress);
    Module_Param* mp_field_adverseWeatherCondition__ExtremeWeatherCondition = single_value->field_adverseWeatherCondition__ExtremeWeatherCondition.get_param(param_name);
    mp_field_adverseWeatherCondition__ExtremeWeatherCondition->set_id(new Module_Param_FieldName(mcopystr("adverseWeatherCondition_ExtremeWeatherCondition")));
    mp->add_elem(mp_field_adverseWeatherCondition__ExtremeWeatherCondition);
    Module_Param* mp_field_adverseWeatherCondition__Visibility = single_value->field_adverseWeatherCondition__Visibility.get_param(param_name);
    mp_field_adverseWeatherCondition__Visibility->set_id(new Module_Param_FieldName(mcopystr("adverseWeatherCondition_Visibility")));
    mp->add_elem(mp_field_adverseWeatherCondition__Visibility);
    Module_Param* mp_field_adverseWeatherCondition__Precipitation = single_value->field_adverseWeatherCondition__Precipitation.get_param(param_name);
    mp_field_adverseWeatherCondition__Precipitation->set_id(new Module_Param_FieldName(mcopystr("adverseWeatherCondition_Precipitation")));
    mp->add_elem(mp_field_adverseWeatherCondition__Precipitation);
    Module_Param* mp_field_slowVehicle = single_value->field_slowVehicle.get_param(param_name);
    mp_field_slowVehicle->set_id(new Module_Param_FieldName(mcopystr("slowVehicle")));
    mp->add_elem(mp_field_slowVehicle);
    Module_Param* mp_field_dangerousEndOfQueue = single_value->field_dangerousEndOfQueue.get_param(param_name);
    mp_field_dangerousEndOfQueue->set_id(new Module_Param_FieldName(mcopystr("dangerousEndOfQueue")));
    mp->add_elem(mp_field_dangerousEndOfQueue);
    Module_Param* mp_field_vehicleBreakdown = single_value->field_vehicleBreakdown.get_param(param_name);
    mp_field_vehicleBreakdown->set_id(new Module_Param_FieldName(mcopystr("vehicleBreakdown")));
    mp->add_elem(mp_field_vehicleBreakdown);
    Module_Param* mp_field_postCrash = single_value->field_postCrash.get_param(param_name);
    mp_field_postCrash->set_id(new Module_Param_FieldName(mcopystr("postCrash")));
    mp->add_elem(mp_field_postCrash);
    Module_Param* mp_field_humanProblem = single_value->field_humanProblem.get_param(param_name);
    mp_field_humanProblem->set_id(new Module_Param_FieldName(mcopystr("humanProblem")));
    mp->add_elem(mp_field_humanProblem);
    Module_Param* mp_field_stationaryVehicle = single_value->field_stationaryVehicle.get_param(param_name);
    mp_field_stationaryVehicle->set_id(new Module_Param_FieldName(mcopystr("stationaryVehicle")));
    mp->add_elem(mp_field_stationaryVehicle);
    Module_Param* mp_field_emergencyVehicleApproaching = single_value->field_emergencyVehicleApproaching.get_param(param_name);
    mp_field_emergencyVehicleApproaching->set_id(new Module_Param_FieldName(mcopystr("emergencyVehicleApproaching")));
    mp->add_elem(mp_field_emergencyVehicleApproaching);
    Module_Param* mp_field_hazardousLocation__DangerousCurve = single_value->field_hazardousLocation__DangerousCurve.get_param(param_name);
    mp_field_hazardousLocation__DangerousCurve->set_id(new Module_Param_FieldName(mcopystr("hazardousLocation_DangerousCurve")));
    mp->add_elem(mp_field_hazardousLocation__DangerousCurve);
    Module_Param* mp_field_collisionRisk = single_value->field_collisionRisk.get_param(param_name);
    mp_field_collisionRisk->set_id(new Module_Param_FieldName(mcopystr("collisionRisk")));
    mp->add_elem(mp_field_collisionRisk);
    Module_Param* mp_field_signalViolation = single_value->field_signalViolation.get_param(param_name);
    mp_field_signalViolation->set_id(new Module_Param_FieldName(mcopystr("signalViolation")));
    mp->add_elem(mp_field_signalViolation);
    Module_Param* mp_field_dangerousSituation = single_value->field_dangerousSituation.get_param(param_name);
    mp_field_dangerousSituation->set_id(new Module_Param_FieldName(mcopystr("dangerousSituation")));
    mp->add_elem(mp_field_dangerousSituation);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SspDENM_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_trafficCondition.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_accident.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_roadworks.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_adverseWeatherCondition__Adhesion.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_hazardousLocation__SurfaceCondition.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_hazardousLocation__ObstacleOnTheRoad.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_hazardousLocation__AnimalOnTheRoad.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_humanPresenceOnTheRoad.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_wrongWayDriving.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_rescueAndRecoveryWorkInProgress.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_adverseWeatherCondition__ExtremeWeatherCondition.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_adverseWeatherCondition__Visibility.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_adverseWeatherCondition__Precipitation.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_slowVehicle.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_dangerousEndOfQueue.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_vehicleBreakdown.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_postCrash.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_humanProblem.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_stationaryVehicle.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_emergencyVehicleApproaching.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_hazardousLocation__DangerousCurve.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_collisionRisk.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_signalViolation.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
single_value->field_dangerousSituation.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.SspDENM");
}

boolean SspDENM_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SspDENM_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ItsAidSsp::ItsAidSsp()
{
  bound_flag = FALSE;
}

ItsAidSsp::ItsAidSsp(const INTEGER& par_its__aid,
    const ServiceSpecificPermissions& par_service__specific__permissions)
  :   field_its__aid(par_its__aid),
  field_service__specific__permissions(par_service__specific__permissions)
{
  bound_flag = TRUE;
}

ItsAidSsp::ItsAidSsp(const ItsAidSsp& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsp.");
bound_flag = TRUE;
if (other_value.its__aid().is_bound()) field_its__aid = other_value.its__aid();
else field_its__aid.clean_up();
if (other_value.service__specific__permissions().is_bound()) field_service__specific__permissions = other_value.service__specific__permissions();
else field_service__specific__permissions.clean_up();
}

void ItsAidSsp::clean_up()
{
field_its__aid.clean_up();
field_service__specific__permissions.clean_up();
bound_flag = FALSE;
}

ItsAidSsp& ItsAidSsp::operator=(const ItsAidSsp& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsp.");
  bound_flag = TRUE;
  if (other_value.its__aid().is_bound()) field_its__aid = other_value.its__aid();
  else field_its__aid.clean_up();
  if (other_value.service__specific__permissions().is_bound()) field_service__specific__permissions = other_value.service__specific__permissions();
  else field_service__specific__permissions.clean_up();
}
return *this;
}

boolean ItsAidSsp::operator==(const ItsAidSsp& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_its__aid==other_value.field_its__aid
  && field_service__specific__permissions==other_value.field_service__specific__permissions;
}

boolean ItsAidSsp::is_bound() const
{
if (bound_flag) return TRUE;
if(field_its__aid.is_bound()) return TRUE;
if(field_service__specific__permissions.is_bound()) return TRUE;
return FALSE;
}
boolean ItsAidSsp::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_its__aid.is_value()) return FALSE;
if(!field_service__specific__permissions.is_value()) return FALSE;
return TRUE;
}
int ItsAidSsp::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.ItsAidSsp");
  return 2;
}

void ItsAidSsp::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ its_aid := ");
field_its__aid.log();
TTCN_Logger::log_event_str(", service_specific_permissions := ");
field_service__specific__permissions.log();
TTCN_Logger::log_event_str(" }");
}

void ItsAidSsp::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.ItsAidSsp'");
    }
    if (strcmp("its_aid", param_field) == 0) {
      its__aid().set_param(param);
      return;
    } else if (strcmp("service_specific_permissions", param_field) == 0) {
      service__specific__permissions().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ItsAidSsp'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.ItsAidSsp has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) its__aid().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) service__specific__permissions().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "its_aid")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          its__aid().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "service_specific_permissions")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          service__specific__permissions().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.ItsAidSsp: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.ItsAidSsp");
  }
}

Module_Param* ItsAidSsp::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.ItsAidSsp'");
    }
    if (strcmp("its_aid", param_field) == 0) {
      return its__aid().get_param(param_name);
    } else if (strcmp("service_specific_permissions", param_field) == 0) {
      return service__specific__permissions().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ItsAidSsp'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_its__aid = field_its__aid.get_param(param_name);
  mp_field_its__aid->set_id(new Module_Param_FieldName(mcopystr("its_aid")));
  mp->add_elem(mp_field_its__aid);
  Module_Param* mp_field_service__specific__permissions = field_service__specific__permissions.get_param(param_name);
  mp_field_service__specific__permissions->set_id(new Module_Param_FieldName(mcopystr("service_specific_permissions")));
  mp->add_elem(mp_field_service__specific__permissions);
  return mp;
  }

void ItsAidSsp::set_implicit_omit()
{
if (its__aid().is_bound()) its__aid().set_implicit_omit();
if (service__specific__permissions().is_bound()) service__specific__permissions().set_implicit_omit();
}

void ItsAidSsp::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.ItsAidSsp.");
field_its__aid.encode_text(text_buf);
field_service__specific__permissions.encode_text(text_buf);
}

void ItsAidSsp::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_its__aid.decode_text(text_buf);
field_service__specific__permissions.decode_text(text_buf);
}

void ItsAidSsp::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ItsAidSsp::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ItsAidSsp::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_its__aid.RAW_decode(IntX_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_service__specific__permissions.RAW_decode(ServiceSpecificPermissions_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ItsAidSsp::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, IntX_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, ServiceSpecificPermissions_descr_.raw);
  encoded_length += field_its__aid.RAW_encode(IntX_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_service__specific__permissions.RAW_encode(ServiceSpecificPermissions_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int ItsAidSsp::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsp.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "its_aid");
    enc_len += field_its__aid.JSON_encode(IntX_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "service_specific_permissions");
    enc_len += field_service__specific__permissions.JSON_encode(ServiceSpecificPermissions_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ItsAidSsp::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (7 == name_len && 0 == strncmp(fld_name, "its_aid", name_len)) {
         int ret_val = field_its__aid.JSON_decode(IntX_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "its_aid");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (28 == name_len && 0 == strncmp(fld_name, "service_specific_permissions", name_len)) {
         int ret_val = field_service__specific__permissions.JSON_decode(ServiceSpecificPermissions_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "service_specific_permissions");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_its__aid.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "its_aid");
    return JSON_ERROR_FATAL;
  }
if (!field_service__specific__permissions.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "service_specific_permissions");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ItsAidSsp_template::single_value_struct {
INTEGER_template field_its__aid;
ServiceSpecificPermissions_template field_service__specific__permissions;
};

void ItsAidSsp_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_its__aid = ANY_VALUE;
single_value->field_service__specific__permissions = ANY_VALUE;
}
}
}

void ItsAidSsp_template::copy_value(const ItsAidSsp& other_value)
{
single_value = new single_value_struct;
if (other_value.its__aid().is_bound()) {
  single_value->field_its__aid = other_value.its__aid();
} else {
  single_value->field_its__aid.clean_up();
}
if (other_value.service__specific__permissions().is_bound()) {
  single_value->field_service__specific__permissions = other_value.service__specific__permissions();
} else {
  single_value->field_service__specific__permissions.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ItsAidSsp_template::copy_template(const ItsAidSsp_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.its__aid().get_selection()) {
single_value->field_its__aid = other_value.its__aid();
} else {
single_value->field_its__aid.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.service__specific__permissions().get_selection()) {
single_value->field_service__specific__permissions = other_value.service__specific__permissions();
} else {
single_value->field_service__specific__permissions.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ItsAidSsp_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ItsAidSsp.");
break;
}
set_selection(other_value);
}

ItsAidSsp_template::ItsAidSsp_template()
{
}

ItsAidSsp_template::ItsAidSsp_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ItsAidSsp_template::ItsAidSsp_template(const ItsAidSsp& other_value)
{
copy_value(other_value);
}

ItsAidSsp_template::ItsAidSsp_template(const OPTIONAL<ItsAidSsp>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ItsAidSsp&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.ItsAidSsp from an unbound optional field.");
}
}

ItsAidSsp_template::ItsAidSsp_template(const ItsAidSsp_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ItsAidSsp_template::~ItsAidSsp_template()
{
clean_up();
}

ItsAidSsp_template& ItsAidSsp_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ItsAidSsp_template& ItsAidSsp_template::operator=(const ItsAidSsp& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ItsAidSsp_template& ItsAidSsp_template::operator=(const OPTIONAL<ItsAidSsp>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ItsAidSsp&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.ItsAidSsp.");
}
return *this;
}

ItsAidSsp_template& ItsAidSsp_template::operator=(const ItsAidSsp_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ItsAidSsp_template::match(const ItsAidSsp& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.its__aid().is_bound()) return FALSE;
if(!single_value->field_its__aid.match(other_value.its__aid(), legacy))return FALSE;
if(!other_value.service__specific__permissions().is_bound()) return FALSE;
if(!single_value->field_service__specific__permissions.match(other_value.service__specific__permissions(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ItsAidSsp.");
}
return FALSE;
}

boolean ItsAidSsp_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_its__aid.is_bound()) return TRUE;
if (single_value->field_service__specific__permissions.is_bound()) return TRUE;
return FALSE;
}

boolean ItsAidSsp_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_its__aid.is_value()) return FALSE;
if (!single_value->field_service__specific__permissions.is_value()) return FALSE;
return TRUE;
}

void ItsAidSsp_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ItsAidSsp ItsAidSsp_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.ItsAidSsp.");
ItsAidSsp ret_val;
if (single_value->field_its__aid.is_bound()) {
ret_val.its__aid() = single_value->field_its__aid.valueof();
}
if (single_value->field_service__specific__permissions.is_bound()) {
ret_val.service__specific__permissions() = single_value->field_service__specific__permissions.valueof();
}
return ret_val;
}

void ItsAidSsp_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.ItsAidSsp.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ItsAidSsp_template[list_length];
}

ItsAidSsp_template& ItsAidSsp_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.ItsAidSsp.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.ItsAidSsp.");
return value_list.list_value[list_index];
}

INTEGER_template& ItsAidSsp_template::its__aid()
{
set_specific();
return single_value->field_its__aid;
}

const INTEGER_template& ItsAidSsp_template::its__aid() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field its_aid of a non-specific template of type @LibItsSecurity_TypesAndValues.ItsAidSsp.");
return single_value->field_its__aid;
}

ServiceSpecificPermissions_template& ItsAidSsp_template::service__specific__permissions()
{
set_specific();
return single_value->field_service__specific__permissions;
}

const ServiceSpecificPermissions_template& ItsAidSsp_template::service__specific__permissions() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field service_specific_permissions of a non-specific template of type @LibItsSecurity_TypesAndValues.ItsAidSsp.");
return single_value->field_service__specific__permissions;
}

int ItsAidSsp_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ItsAidSsp which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ItsAidSsp containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ItsAidSsp containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ItsAidSsp containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ItsAidSsp containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ItsAidSsp containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ItsAidSsp.");
  }
  return 0;
}

void ItsAidSsp_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ its_aid := ");
single_value->field_its__aid.log();
TTCN_Logger::log_event_str(", service_specific_permissions := ");
single_value->field_service__specific__permissions.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ItsAidSsp_template::log_match(const ItsAidSsp& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_its__aid.match(match_value.its__aid(), legacy)){
TTCN_Logger::log_logmatch_info(".its_aid");
single_value->field_its__aid.log_match(match_value.its__aid(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_service__specific__permissions.match(match_value.service__specific__permissions(), legacy)){
TTCN_Logger::log_logmatch_info(".service_specific_permissions");
single_value->field_service__specific__permissions.log_match(match_value.service__specific__permissions(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ its_aid := ");
single_value->field_its__aid.log_match(match_value.its__aid(), legacy);
TTCN_Logger::log_event_str(", service_specific_permissions := ");
single_value->field_service__specific__permissions.log_match(match_value.service__specific__permissions(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ItsAidSsp_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_its__aid.encode_text(text_buf);
single_value->field_service__specific__permissions.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ItsAidSsp.");
}
}

void ItsAidSsp_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_its__aid.decode_text(text_buf);
single_value->field_service__specific__permissions.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ItsAidSsp_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.ItsAidSsp.");
}
}

void ItsAidSsp_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.ItsAidSsp'");
    }
    if (strcmp("its_aid", param_field) == 0) {
      its__aid().set_param(param);
      return;
    } else if (strcmp("service_specific_permissions", param_field) == 0) {
      service__specific__permissions().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.ItsAidSsp'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ItsAidSsp_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.ItsAidSsp has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) its__aid().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) service__specific__permissions().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "its_aid")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          its__aid().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "service_specific_permissions")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          service__specific__permissions().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.ItsAidSsp: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.ItsAidSsp");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ItsAidSsp_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.ItsAidSsp'");
    }
    if (strcmp("its_aid", param_field) == 0) {
      return its__aid().get_param(param_name);
    } else if (strcmp("service_specific_permissions", param_field) == 0) {
      return service__specific__permissions().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ItsAidSsp'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_its__aid = single_value->field_its__aid.get_param(param_name);
    mp_field_its__aid->set_id(new Module_Param_FieldName(mcopystr("its_aid")));
    mp->add_elem(mp_field_its__aid);
    Module_Param* mp_field_service__specific__permissions = single_value->field_service__specific__permissions.get_param(param_name);
    mp_field_service__specific__permissions->set_id(new Module_Param_FieldName(mcopystr("service_specific_permissions")));
    mp->add_elem(mp_field_service__specific__permissions);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ItsAidSsp_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_its__aid.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ItsAidSsp");
single_value->field_service__specific__permissions.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ItsAidSsp");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.ItsAidSsp");
}

boolean ItsAidSsp_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ItsAidSsp_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SubjectAttribute::SubjectAttribute()
{
  bound_flag = FALSE;
}

SubjectAttribute::SubjectAttribute(const SubjectAttributeType& par_type__,
    const SubjectAttributeContainer& par_attribute)
  :   field_type__(par_type__),
  field_attribute(par_attribute)
{
  bound_flag = TRUE;
}

SubjectAttribute::SubjectAttribute(const SubjectAttribute& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttribute.");
bound_flag = TRUE;
if (other_value.type__().is_bound()) field_type__ = other_value.type__();
else field_type__.clean_up();
if (other_value.attribute().is_bound()) field_attribute = other_value.attribute();
else field_attribute.clean_up();
}

void SubjectAttribute::clean_up()
{
field_type__.clean_up();
field_attribute.clean_up();
bound_flag = FALSE;
}

SubjectAttribute& SubjectAttribute::operator=(const SubjectAttribute& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttribute.");
  bound_flag = TRUE;
  if (other_value.type__().is_bound()) field_type__ = other_value.type__();
  else field_type__.clean_up();
  if (other_value.attribute().is_bound()) field_attribute = other_value.attribute();
  else field_attribute.clean_up();
}
return *this;
}

boolean SubjectAttribute::operator==(const SubjectAttribute& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_type__==other_value.field_type__
  && field_attribute==other_value.field_attribute;
}

boolean SubjectAttribute::is_bound() const
{
if (bound_flag) return TRUE;
if(field_type__.is_bound()) return TRUE;
if(field_attribute.is_bound()) return TRUE;
return FALSE;
}
boolean SubjectAttribute::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_type__.is_value()) return FALSE;
if(!field_attribute.is_value()) return FALSE;
return TRUE;
}
int SubjectAttribute::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.SubjectAttribute");
  return 2;
}

void SubjectAttribute::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ type_ := ");
field_type__.log();
TTCN_Logger::log_event_str(", attribute := ");
field_attribute.log();
TTCN_Logger::log_event_str(" }");
}

void SubjectAttribute::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.SubjectAttribute'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("attribute", param_field) == 0) {
      attribute().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SubjectAttribute'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.SubjectAttribute has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) attribute().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "attribute")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          attribute().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.SubjectAttribute: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.SubjectAttribute");
  }
}

Module_Param* SubjectAttribute::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.SubjectAttribute'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("attribute", param_field) == 0) {
      return attribute().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SubjectAttribute'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_type__ = field_type__.get_param(param_name);
  mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
  mp->add_elem(mp_field_type__);
  Module_Param* mp_field_attribute = field_attribute.get_param(param_name);
  mp_field_attribute->set_id(new Module_Param_FieldName(mcopystr("attribute")));
  mp->add_elem(mp_field_attribute);
  return mp;
  }

void SubjectAttribute::set_implicit_omit()
{
if (type__().is_bound()) type__().set_implicit_omit();
if (attribute().is_bound()) attribute().set_implicit_omit();
}

void SubjectAttribute::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.SubjectAttribute.");
field_type__.encode_text(text_buf);
field_attribute.encode_text(text_buf);
}

void SubjectAttribute::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_type__.decode_text(text_buf);
field_attribute.decode_text(text_buf);
}

void SubjectAttribute::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SubjectAttribute::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SubjectAttribute::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_type__.RAW_decode(SubjectAttributeType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_attribute.RAW_decode(SubjectAttributeContainer_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int SubjectAttribute::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, SubjectAttributeType_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, SubjectAttributeContainer_descr_.raw);
  encoded_length += field_type__.RAW_encode(SubjectAttributeType_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_attribute.RAW_encode(SubjectAttributeContainer_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int SubjectAttribute::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttribute.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "type_");
    enc_len += field_type__.JSON_encode(SubjectAttributeType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "attribute");
    enc_len += field_attribute.JSON_encode(SubjectAttributeContainer_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SubjectAttribute::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (5 == name_len && 0 == strncmp(fld_name, "type_", name_len)) {
         int ret_val = field_type__.JSON_decode(SubjectAttributeType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "type_");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "attribute", name_len)) {
         int ret_val = field_attribute.JSON_decode(SubjectAttributeContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "attribute");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_type__.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "type_");
    return JSON_ERROR_FATAL;
  }
if (!field_attribute.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "attribute");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct SubjectAttribute_template::single_value_struct {
SubjectAttributeType_template field_type__;
SubjectAttributeContainer_template field_attribute;
};

void SubjectAttribute_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_type__ = ANY_VALUE;
single_value->field_attribute = ANY_VALUE;
}
}
}

void SubjectAttribute_template::copy_value(const SubjectAttribute& other_value)
{
single_value = new single_value_struct;
if (other_value.type__().is_bound()) {
  single_value->field_type__ = other_value.type__();
} else {
  single_value->field_type__.clean_up();
}
if (other_value.attribute().is_bound()) {
  single_value->field_attribute = other_value.attribute();
} else {
  single_value->field_attribute.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SubjectAttribute_template::copy_template(const SubjectAttribute_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.type__().get_selection()) {
single_value->field_type__ = other_value.type__();
} else {
single_value->field_type__.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.attribute().get_selection()) {
single_value->field_attribute = other_value.attribute();
} else {
single_value->field_attribute.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SubjectAttribute_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SubjectAttribute.");
break;
}
set_selection(other_value);
}

SubjectAttribute_template::SubjectAttribute_template()
{
}

SubjectAttribute_template::SubjectAttribute_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SubjectAttribute_template::SubjectAttribute_template(const SubjectAttribute& other_value)
{
copy_value(other_value);
}

SubjectAttribute_template::SubjectAttribute_template(const OPTIONAL<SubjectAttribute>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SubjectAttribute&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.SubjectAttribute from an unbound optional field.");
}
}

SubjectAttribute_template::SubjectAttribute_template(const SubjectAttribute_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SubjectAttribute_template::~SubjectAttribute_template()
{
clean_up();
}

SubjectAttribute_template& SubjectAttribute_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SubjectAttribute_template& SubjectAttribute_template::operator=(const SubjectAttribute& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SubjectAttribute_template& SubjectAttribute_template::operator=(const OPTIONAL<SubjectAttribute>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SubjectAttribute&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.SubjectAttribute.");
}
return *this;
}

SubjectAttribute_template& SubjectAttribute_template::operator=(const SubjectAttribute_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SubjectAttribute_template::match(const SubjectAttribute& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.type__().is_bound()) return FALSE;
if(!single_value->field_type__.match(other_value.type__(), legacy))return FALSE;
if(!other_value.attribute().is_bound()) return FALSE;
if(!single_value->field_attribute.match(other_value.attribute(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SubjectAttribute.");
}
return FALSE;
}

boolean SubjectAttribute_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_type__.is_bound()) return TRUE;
if (single_value->field_attribute.is_bound()) return TRUE;
return FALSE;
}

boolean SubjectAttribute_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_type__.is_value()) return FALSE;
if (!single_value->field_attribute.is_value()) return FALSE;
return TRUE;
}

void SubjectAttribute_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SubjectAttribute SubjectAttribute_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.SubjectAttribute.");
SubjectAttribute ret_val;
if (single_value->field_type__.is_bound()) {
ret_val.type__() = single_value->field_type__.valueof();
}
if (single_value->field_attribute.is_bound()) {
ret_val.attribute() = single_value->field_attribute.valueof();
}
return ret_val;
}

void SubjectAttribute_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.SubjectAttribute.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SubjectAttribute_template[list_length];
}

SubjectAttribute_template& SubjectAttribute_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.SubjectAttribute.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.SubjectAttribute.");
return value_list.list_value[list_index];
}

SubjectAttributeType_template& SubjectAttribute_template::type__()
{
set_specific();
return single_value->field_type__;
}

const SubjectAttributeType_template& SubjectAttribute_template::type__() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field type_ of a non-specific template of type @LibItsSecurity_TypesAndValues.SubjectAttribute.");
return single_value->field_type__;
}

SubjectAttributeContainer_template& SubjectAttribute_template::attribute()
{
set_specific();
return single_value->field_attribute;
}

const SubjectAttributeContainer_template& SubjectAttribute_template::attribute() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field attribute of a non-specific template of type @LibItsSecurity_TypesAndValues.SubjectAttribute.");
return single_value->field_attribute;
}

int SubjectAttribute_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAttribute which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAttribute containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAttribute containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAttribute containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAttribute containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SubjectAttribute containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SubjectAttribute.");
  }
  return 0;
}

void SubjectAttribute_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log();
TTCN_Logger::log_event_str(", attribute := ");
single_value->field_attribute.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SubjectAttribute_template::log_match(const SubjectAttribute& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_type__.match(match_value.type__(), legacy)){
TTCN_Logger::log_logmatch_info(".type_");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_attribute.match(match_value.attribute(), legacy)){
TTCN_Logger::log_logmatch_info(".attribute");
single_value->field_attribute.log_match(match_value.attribute(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::log_event_str(", attribute := ");
single_value->field_attribute.log_match(match_value.attribute(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SubjectAttribute_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_type__.encode_text(text_buf);
single_value->field_attribute.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SubjectAttribute.");
}
}

void SubjectAttribute_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_type__.decode_text(text_buf);
single_value->field_attribute.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SubjectAttribute_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.SubjectAttribute.");
}
}

void SubjectAttribute_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.SubjectAttribute'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("attribute", param_field) == 0) {
      attribute().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.SubjectAttribute'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SubjectAttribute_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.SubjectAttribute has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) attribute().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "attribute")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          attribute().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.SubjectAttribute: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.SubjectAttribute");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SubjectAttribute_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.SubjectAttribute'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("attribute", param_field) == 0) {
      return attribute().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SubjectAttribute'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_type__ = single_value->field_type__.get_param(param_name);
    mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
    mp->add_elem(mp_field_type__);
    Module_Param* mp_field_attribute = single_value->field_attribute.get_param(param_name);
    mp_field_attribute->set_id(new Module_Param_FieldName(mcopystr("attribute")));
    mp->add_elem(mp_field_attribute);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SubjectAttribute_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_type__.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectAttribute");
single_value->field_attribute.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectAttribute");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.SubjectAttribute");
}

boolean SubjectAttribute_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SubjectAttribute_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const ValidityRestriction ValidityRestrictions::UNBOUND_ELEM;
boolean ValidityRestrictions::compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index)
{
if (((const ValidityRestrictions*)left_ptr)->val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
if (((const ValidityRestrictions*)right_ptr)->val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
if (((const ValidityRestrictions*)left_ptr)->val_ptr->value_elements[left_index] != NULL){
if (((const ValidityRestrictions*)right_ptr)->val_ptr->value_elements[right_index] != NULL){
return *((const ValidityRestrictions*)left_ptr)->val_ptr->value_elements[left_index] == *((const ValidityRestrictions*)right_ptr)->val_ptr->value_elements[right_index];
} else return FALSE;
} else {
return ((const ValidityRestrictions*)right_ptr)->val_ptr->value_elements[right_index] == NULL;
}
}

ValidityRestrictions::ValidityRestrictions()
{
val_ptr = NULL;
}

ValidityRestrictions::ValidityRestrictions(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

ValidityRestrictions::ValidityRestrictions(const ValidityRestrictions& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

ValidityRestrictions::~ValidityRestrictions()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void ValidityRestrictions::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

ValidityRestrictions& ValidityRestrictions::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

ValidityRestrictions& ValidityRestrictions::operator=(const ValidityRestrictions& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean ValidityRestrictions::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
return val_ptr->n_elements == 0 ;
}

boolean ValidityRestrictions::operator==(const ValidityRestrictions& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
if (val_ptr == other_value.val_ptr) return TRUE;
return compare_set_of(this, val_ptr->n_elements, &other_value, (other_value.val_ptr)->n_elements, compare_function);
}

ValidityRestriction& ValidityRestrictions::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.ValidityRestrictions using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (ValidityRestriction**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new ValidityRestriction(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new ValidityRestriction;
}
return *val_ptr->value_elements[index_value];
}

ValidityRestriction& ValidityRestrictions::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
return (*this)[(int)index_value];
}

const ValidityRestriction& ValidityRestrictions::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.ValidityRestrictions using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const ValidityRestriction& ValidityRestrictions::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
return (*this)[(int)index_value];
}

ValidityRestrictions ValidityRestrictions::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

ValidityRestrictions ValidityRestrictions::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

ValidityRestrictions ValidityRestrictions::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

ValidityRestrictions ValidityRestrictions::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
ValidityRestrictions ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new ValidityRestriction(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

ValidityRestrictions ValidityRestrictions::operator+(const ValidityRestrictions& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsSecurity_TypesAndValues.ValidityRestrictions concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
ValidityRestrictions ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new ValidityRestriction(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new ValidityRestriction(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

ValidityRestrictions ValidityRestrictions::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsSecurity_TypesAndValues.ValidityRestrictions","element");
ValidityRestrictions ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new ValidityRestriction(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

ValidityRestrictions ValidityRestrictions::replace(int index, int len, const ValidityRestrictions& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsSecurity_TypesAndValues.ValidityRestrictions","element");
ValidityRestrictions ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new ValidityRestriction(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new ValidityRestriction(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new ValidityRestriction(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

ValidityRestrictions ValidityRestrictions::replace(int index, int len, const ValidityRestrictions_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void ValidityRestrictions::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (ValidityRestriction**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new ValidityRestriction(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (ValidityRestriction**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsSecurity_TypesAndValues.ValidityRestrictions: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (ValidityRestriction**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean ValidityRestrictions::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int ValidityRestrictions::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
return val_ptr->n_elements;
}

int ValidityRestrictions::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void ValidityRestrictions::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void ValidityRestrictions::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set of type `@LibItsSecurity_TypesAndValues.ValidityRestrictions'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "set of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.ValidityRestrictions");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.ValidityRestrictions");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* ValidityRestrictions::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of type `@LibItsSecurity_TypesAndValues.ValidityRestrictions'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void ValidityRestrictions::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void ValidityRestrictions::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void ValidityRestrictions::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
val_ptr->value_elements = (ValidityRestriction**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new ValidityRestriction;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void ValidityRestrictions::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ValidityRestrictions::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ValidityRestrictions::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int ValidityRestrictions::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

int ValidityRestrictions::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int ValidityRestrictions::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    ValidityRestriction* val = new ValidityRestriction;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (ValidityRestriction**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void ValidityRestrictions_template::copy_value(const ValidityRestrictions& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (ValidityRestriction_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new ValidityRestriction_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new ValidityRestriction_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void ValidityRestrictions_template::copy_template(const ValidityRestrictions_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (ValidityRestriction_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new ValidityRestriction_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new ValidityRestriction_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ValidityRestrictions_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = other_value.value_set.n_items;
value_set.set_items = new ValidityRestriction_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count] = other_value.value_set.set_items[set_count];
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
break;
}
set_selection(other_value);
}

boolean ValidityRestrictions_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const ValidityRestrictions_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const ValidityRestrictions*)value_ptr)[value_index], legacy);
else return ((const ValidityRestrictions_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

boolean ValidityRestrictions_template::match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const ValidityRestrictions_template*)template_ptr)->value_set.set_items[template_index].match((*(const ValidityRestrictions*)value_ptr)[value_index], legacy);
else return ((const ValidityRestrictions_template*)template_ptr)->value_set.set_items[template_index].is_any_or_omit();
}

void ValidityRestrictions_template::log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy)
{
if (value_ptr != NULL && template_ptr != NULL)((const ValidityRestrictions_template*)template_ptr)->single_value.value_elements[index_template]->log_match((*(const ValidityRestrictions*)value_ptr)[index_value], legacy);
else if (value_ptr != NULL) (*(const ValidityRestrictions*)value_ptr)[index_value].log();
else if (template_ptr != NULL) ((const ValidityRestrictions_template*)template_ptr)->single_value.value_elements[index_template]->log();
}

ValidityRestrictions_template::ValidityRestrictions_template()
{
}

ValidityRestrictions_template::ValidityRestrictions_template(template_sel other_value)
 : Restricted_Length_Template(other_value)
{
check_single_selection(other_value);
}

ValidityRestrictions_template::ValidityRestrictions_template(null_type)
 : Restricted_Length_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

ValidityRestrictions_template::ValidityRestrictions_template(const ValidityRestrictions& other_value)
{
copy_value(other_value);
}

ValidityRestrictions_template::ValidityRestrictions_template(const OPTIONAL<ValidityRestrictions>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ValidityRestrictions&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions from an unbound optional field.");
}
}

ValidityRestrictions_template::ValidityRestrictions_template(const ValidityRestrictions_template& other_value)
 : Restricted_Length_Template()
{
copy_template(other_value);
}

ValidityRestrictions_template::~ValidityRestrictions_template()
{
clean_up();
}

void ValidityRestrictions_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
delete [] value_set.set_items;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ValidityRestrictions_template& ValidityRestrictions_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ValidityRestrictions_template& ValidityRestrictions_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

ValidityRestrictions_template& ValidityRestrictions_template::operator=(const ValidityRestrictions& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ValidityRestrictions_template& ValidityRestrictions_template::operator=(const OPTIONAL<ValidityRestrictions>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ValidityRestrictions&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
}
return *this;
}

ValidityRestrictions_template& ValidityRestrictions_template::operator=(const ValidityRestrictions_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

ValidityRestriction_template& ValidityRestrictions_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.ValidityRestrictions using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
    break;
}
return *single_value.value_elements[index_value];
}

ValidityRestriction_template& ValidityRestrictions_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
return (*this)[(int)index_value];
}

const ValidityRestriction_template& ValidityRestrictions_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.ValidityRestrictions using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const ValidityRestriction_template& ValidityRestrictions_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
return (*this)[(int)index_value];
}

void ValidityRestrictions_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (ValidityRestriction_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new ValidityRestriction_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new ValidityRestriction_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (ValidityRestriction_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int ValidityRestrictions_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int ValidityRestrictions_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case SUPERSET_MATCH:
case SUBSET_MATCH: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = value_set.n_items;
  if (!is_size) { while (elem_count>0 && !value_set.set_items[elem_count-1].is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (value_set.set_items[i].get_selection())
    {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
  if (template_selection==SUPERSET_MATCH) {
    has_any_or_none = TRUE;
   } else {
    int max_size = min_size;
    min_size = 0;
    if (!has_any_or_none) { // [0,max_size]
      switch (length_restriction_type) {
      case NO_LENGTH_RESTRICTION:
        if (max_size==0) return 0;
        TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions with no exact size.", op_name);
      case SINGLE_LENGTH_RESTRICTION:
        if (length_restriction.single_length<=max_size)
          return length_restriction.single_length;
        TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions. The maximum size (%d) contradicts the length restriction (%d).", op_name, max_size, length_restriction.single_length);
      case RANGE_LENGTH_RESTRICTION:
        if (max_size==length_restriction.range_length.min_length) {
          return max_size;
        } else if (max_size>length_restriction.range_length.min_length){
          TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions with no exact size.", op_name);
        } else
          TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions. Maximum size (%d) contradicts the length restriction (%d..%d).", op_name, max_size, length_restriction.range_length.min_length, length_restriction.range_length.max_length);
      default:
        TTCN_error("Internal error: Template has invalid length restriction type.");
      }
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions");
}

boolean ValidityRestrictions_template::match(const ValidityRestrictions& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_set_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case SUPERSET_MATCH:
case SUBSET_MATCH:
return match_set_of(&other_value, value_length, this, value_set.n_items, match_function_set, legacy);
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
}
return FALSE;
}

boolean ValidityRestrictions_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

ValidityRestrictions ValidityRestrictions_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
ValidityRestrictions ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

ValidityRestrictions ValidityRestrictions_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

ValidityRestrictions ValidityRestrictions_template::replace(int index, int len, const ValidityRestrictions_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

ValidityRestrictions ValidityRestrictions_template::replace(int index, int len, const ValidityRestrictions& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void ValidityRestrictions_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new ValidityRestrictions_template[list_length];
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = list_length;
value_set.set_items = new ValidityRestriction_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
}
set_selection(template_type);
}

ValidityRestrictions_template& ValidityRestrictions_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
return value_list.list_value[list_index];
}

ValidityRestriction_template& ValidityRestrictions_template::set_item(unsigned int set_index)
{
if (template_selection != SUPERSET_MATCH && template_selection != SUBSET_MATCH) TTCN_error("Internal error: Accessing a set element of a non-set template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
if (set_index >= value_set.n_items) TTCN_error("Internal error: Index overflow in a set template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
return value_set.set_items[set_index];
}

void ValidityRestrictions_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log();
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
TTCN_Logger::log_event("%s(", template_selection == SUPERSET_MATCH ? "superset" : "subset");
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++) {
if (set_count > 0) TTCN_Logger::log_event_str(", ");
value_set.set_items[set_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void ValidityRestrictions_template::log_match(const ValidityRestrictions& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (template_selection == SPECIFIC_VALUE)
  log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
else{
if(previous_size != 0){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::set_logmatch_buffer_len(previous_size);
TTCN_Logger::log_event_str(":=");
}
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
return;
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else {
TTCN_Logger::log_event_str(" unmatched");
if (template_selection == SPECIFIC_VALUE) log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
}
}

void ValidityRestrictions_template::encode_text(Text_Buf& text_buf) const
{
encode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
text_buf.push_int(value_set.n_items);
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
}
}

void ValidityRestrictions_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
single_value.value_elements = (ValidityRestriction_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new ValidityRestriction_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ValidityRestrictions_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = text_buf.pull_int().get_val();
value_set.set_items = new ValidityRestriction_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
}
}

boolean ValidityRestrictions_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ValidityRestrictions_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ValidityRestrictions_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set template type `@LibItsSecurity_TypesAndValues.ValidityRestrictions'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "set of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ValidityRestrictions_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    set_size(mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      if (mp->get_elem(p_i)->get_type()!=Module_Param::MP_NotUsed) {
        (*this)[p_i].set_param(*mp->get_elem(p_i));
      }
    }
    break;
  case Module_Param::MP_Superset_Template:
  case Module_Param::MP_Subset_Template:
    set_type(mp->get_type()==Module_Param::MP_Superset_Template ? SUPERSET_MATCH : SUBSET_MATCH, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      set_item(p_i).set_param(*mp->get_elem(p_i));
    }
    break;
  default:
    param.type_error("set of template", "@LibItsSecurity_TypesAndValues.ValidityRestrictions");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* ValidityRestrictions_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of template type `@LibItsSecurity_TypesAndValues.ValidityRestrictions'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void ValidityRestrictions_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ValidityRestrictions");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.ValidityRestrictions");
}

ValidityRestrictionType::ValidityRestrictionType()
{
enum_value = UNBOUND_VALUE;
}

ValidityRestrictionType::ValidityRestrictionType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

ValidityRestrictionType::ValidityRestrictionType(enum_type other_value)
{
enum_value = other_value;
}

ValidityRestrictionType::ValidityRestrictionType(const ValidityRestrictionType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
enum_value = other_value.enum_value;
}

ValidityRestrictionType& ValidityRestrictionType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

ValidityRestrictionType& ValidityRestrictionType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

ValidityRestrictionType& ValidityRestrictionType::operator=(const ValidityRestrictionType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
enum_value = other_value.enum_value;
return *this;
}

boolean ValidityRestrictionType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
return enum_value == other_value;
}

boolean ValidityRestrictionType::operator==(const ValidityRestrictionType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
return enum_value == other_value.enum_value;
}

boolean ValidityRestrictionType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
return enum_value < other_value;
}

boolean ValidityRestrictionType::operator<(const ValidityRestrictionType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
return enum_value < other_value.enum_value;
}

boolean ValidityRestrictionType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
return enum_value > other_value;
}

boolean ValidityRestrictionType::operator>(const ValidityRestrictionType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
return enum_value > other_value.enum_value;
}

const char *ValidityRestrictionType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__time__end: return "e_time_end";
case e__time__start__and__end: return "e_time_start_and_end";
case e__time__start__and__duration: return "e_time_start_and_duration";
case e__region: return "e_region";
case e__unknown: return "e_unknown";
default: return "<unknown>";
}
}

ValidityRestrictionType::enum_type ValidityRestrictionType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_time_end")) return e__time__end;
else if (!strcmp(str_par, "e_time_start_and_end")) return e__time__start__and__end;
else if (!strcmp(str_par, "e_time_start_and_duration")) return e__time__start__and__duration;
else if (!strcmp(str_par, "e_region")) return e__region;
else if (!strcmp(str_par, "e_unknown")) return e__unknown;
else return UNKNOWN_VALUE;
}

boolean ValidityRestrictionType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
return TRUE;
default:
return FALSE;
}
}

int ValidityRestrictionType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int ValidityRestrictionType::enum2int(const ValidityRestrictionType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void ValidityRestrictionType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.", int_val);
enum_value = (enum_type)int_val;
}

ValidityRestrictionType::operator ValidityRestrictionType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
return enum_value;
}

void ValidityRestrictionType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void ValidityRestrictionType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsSecurity_TypesAndValues.ValidityRestrictionType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
  }
}

Module_Param* ValidityRestrictionType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void ValidityRestrictionType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
text_buf.push_int(enum_value);
}

void ValidityRestrictionType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.", enum_value);
}

void ValidityRestrictionType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ValidityRestrictionType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ValidityRestrictionType::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int ValidityRestrictionType::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

int ValidityRestrictionType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int ValidityRestrictionType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void ValidityRestrictionType_template::copy_template(const ValidityRestrictionType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ValidityRestrictionType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
}
}

ValidityRestrictionType_template::ValidityRestrictionType_template()
{
}

ValidityRestrictionType_template::ValidityRestrictionType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ValidityRestrictionType_template::ValidityRestrictionType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!ValidityRestrictionType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType with unknown numeric value %d.", other_value);
single_value = (ValidityRestrictionType::enum_type)other_value;
}

ValidityRestrictionType_template::ValidityRestrictionType_template(ValidityRestrictionType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

ValidityRestrictionType_template::ValidityRestrictionType_template(const ValidityRestrictionType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == ValidityRestrictionType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
single_value = other_value.enum_value;
}

ValidityRestrictionType_template::ValidityRestrictionType_template(const OPTIONAL<ValidityRestrictionType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (ValidityRestrictionType::enum_type)(const ValidityRestrictionType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType from an unbound optional field.");
}
}

ValidityRestrictionType_template::ValidityRestrictionType_template(const ValidityRestrictionType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

ValidityRestrictionType_template::~ValidityRestrictionType_template()
{
clean_up();
}

boolean ValidityRestrictionType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean ValidityRestrictionType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != ValidityRestrictionType::UNBOUND_VALUE;
}

void ValidityRestrictionType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

ValidityRestrictionType_template& ValidityRestrictionType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ValidityRestrictionType_template& ValidityRestrictionType_template::operator=(int other_value)
{
if (!ValidityRestrictionType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (ValidityRestrictionType::enum_type)other_value;
return *this;
}

ValidityRestrictionType_template& ValidityRestrictionType_template::operator=(ValidityRestrictionType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

ValidityRestrictionType_template& ValidityRestrictionType_template::operator=(const ValidityRestrictionType& other_value)
{
if (other_value.enum_value == ValidityRestrictionType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

ValidityRestrictionType_template& ValidityRestrictionType_template::operator=(const OPTIONAL<ValidityRestrictionType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (ValidityRestrictionType::enum_type)(const ValidityRestrictionType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
}
return *this;
}

ValidityRestrictionType_template& ValidityRestrictionType_template::operator=(const ValidityRestrictionType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ValidityRestrictionType_template::match(ValidityRestrictionType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
}
return FALSE;
}

boolean ValidityRestrictionType_template::match(const ValidityRestrictionType& other_value, boolean) const
{
if (other_value.enum_value == ValidityRestrictionType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType with an unbound value.");
return match(other_value.enum_value);
}

ValidityRestrictionType::enum_type ValidityRestrictionType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
return single_value;
}

void ValidityRestrictionType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ValidityRestrictionType_template[list_length];
}

ValidityRestrictionType_template& ValidityRestrictionType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
return value_list.list_value[list_index];
}

void ValidityRestrictionType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(ValidityRestrictionType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ValidityRestrictionType_template::log_match(const ValidityRestrictionType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void ValidityRestrictionType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
}
}

void ValidityRestrictionType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (ValidityRestrictionType::enum_type)text_buf.pull_int().get_val();
if (!ValidityRestrictionType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ValidityRestrictionType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
}
}

boolean ValidityRestrictionType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ValidityRestrictionType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ValidityRestrictionType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    ValidityRestrictionType::enum_type enum_val = (enum_name != NULL) ? ValidityRestrictionType::str_to_enum(enum_name) : ValidityRestrictionType::UNKNOWN_VALUE;
    if (ValidityRestrictionType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ValidityRestrictionType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    ValidityRestrictionType::enum_type enum_val = ValidityRestrictionType::str_to_enum(mp->get_enumerated());
    if (!ValidityRestrictionType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.ValidityRestrictionType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsSecurity_TypesAndValues.ValidityRestrictionType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ValidityRestrictionType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(ValidityRestrictionType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ValidityRestrictionType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.ValidityRestrictionType");
}

void ValidityRestrictionContainer::copy_value(const ValidityRestrictionContainer& other_value)
{
switch (other_value.union_selection) {
case ALT_end__validity:
field_end__validity = new INTEGER(*other_value.field_end__validity);
break;
case ALT_time__start__and__end:
field_time__start__and__end = new TimeStartEnd(*other_value.field_time__start__and__end);
break;
case ALT_time__start__and__duration:
field_time__start__and__duration = new TimeDuration(*other_value.field_time__start__and__duration);
break;
case ALT_region:
field_region = new GeographicRegion(*other_value.field_region);
break;
case ALT_data:
field_data = new OCTETSTRING(*other_value.field_data);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
}
union_selection = other_value.union_selection;
}

ValidityRestrictionContainer::ValidityRestrictionContainer()
{
union_selection = UNBOUND_VALUE;
}

ValidityRestrictionContainer::ValidityRestrictionContainer(const ValidityRestrictionContainer& other_value)
: Base_Type(){
copy_value(other_value);
}

ValidityRestrictionContainer::~ValidityRestrictionContainer()
{
clean_up();
}

ValidityRestrictionContainer& ValidityRestrictionContainer::operator=(const ValidityRestrictionContainer& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean ValidityRestrictionContainer::operator==(const ValidityRestrictionContainer& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_end__validity:
return *field_end__validity == *other_value.field_end__validity;
case ALT_time__start__and__end:
return *field_time__start__and__end == *other_value.field_time__start__and__end;
case ALT_time__start__and__duration:
return *field_time__start__and__duration == *other_value.field_time__start__and__duration;
case ALT_region:
return *field_region == *other_value.field_region;
case ALT_data:
return *field_data == *other_value.field_data;
default:
return FALSE;
}
}

INTEGER& ValidityRestrictionContainer::end__validity()
{
if (union_selection != ALT_end__validity) {
clean_up();
field_end__validity = new INTEGER;
union_selection = ALT_end__validity;
}
return *field_end__validity;
}

const INTEGER& ValidityRestrictionContainer::end__validity() const
{
if (union_selection != ALT_end__validity) TTCN_error("Using non-selected field end_validity in a value of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
return *field_end__validity;
}

TimeStartEnd& ValidityRestrictionContainer::time__start__and__end()
{
if (union_selection != ALT_time__start__and__end) {
clean_up();
field_time__start__and__end = new TimeStartEnd;
union_selection = ALT_time__start__and__end;
}
return *field_time__start__and__end;
}

const TimeStartEnd& ValidityRestrictionContainer::time__start__and__end() const
{
if (union_selection != ALT_time__start__and__end) TTCN_error("Using non-selected field time_start_and_end in a value of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
return *field_time__start__and__end;
}

TimeDuration& ValidityRestrictionContainer::time__start__and__duration()
{
if (union_selection != ALT_time__start__and__duration) {
clean_up();
field_time__start__and__duration = new TimeDuration;
union_selection = ALT_time__start__and__duration;
}
return *field_time__start__and__duration;
}

const TimeDuration& ValidityRestrictionContainer::time__start__and__duration() const
{
if (union_selection != ALT_time__start__and__duration) TTCN_error("Using non-selected field time_start_and_duration in a value of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
return *field_time__start__and__duration;
}

GeographicRegion& ValidityRestrictionContainer::region()
{
if (union_selection != ALT_region) {
clean_up();
field_region = new GeographicRegion;
union_selection = ALT_region;
}
return *field_region;
}

const GeographicRegion& ValidityRestrictionContainer::region() const
{
if (union_selection != ALT_region) TTCN_error("Using non-selected field region in a value of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
return *field_region;
}

OCTETSTRING& ValidityRestrictionContainer::data()
{
if (union_selection != ALT_data) {
clean_up();
field_data = new OCTETSTRING;
union_selection = ALT_data;
}
return *field_data;
}

const OCTETSTRING& ValidityRestrictionContainer::data() const
{
if (union_selection != ALT_data) TTCN_error("Using non-selected field data in a value of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
return *field_data;
}

boolean ValidityRestrictionContainer::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
return union_selection == checked_selection;
}

boolean ValidityRestrictionContainer::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean ValidityRestrictionContainer::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_end__validity: return field_end__validity->is_value();
case ALT_time__start__and__end: return field_time__start__and__end->is_value();
case ALT_time__start__and__duration: return field_time__start__and__duration->is_value();
case ALT_region: return field_region->is_value();
case ALT_data: return field_data->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void ValidityRestrictionContainer::clean_up()
{
switch (union_selection) {
case ALT_end__validity:
  delete field_end__validity;
  break;
case ALT_time__start__and__end:
  delete field_time__start__and__end;
  break;
case ALT_time__start__and__duration:
  delete field_time__start__and__duration;
  break;
case ALT_region:
  delete field_region;
  break;
case ALT_data:
  delete field_data;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void ValidityRestrictionContainer::log() const
{
switch (union_selection) {
case ALT_end__validity:
TTCN_Logger::log_event_str("{ end_validity := ");
field_end__validity->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_time__start__and__end:
TTCN_Logger::log_event_str("{ time_start_and_end := ");
field_time__start__and__end->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_time__start__and__duration:
TTCN_Logger::log_event_str("{ time_start_and_duration := ");
field_time__start__and__duration->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_region:
TTCN_Logger::log_event_str("{ region := ");
field_region->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_data:
TTCN_Logger::log_event_str("{ data := ");
field_data->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void ValidityRestrictionContainer::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsSecurity_TypesAndValues.ValidityRestrictionContainer'");
    }
    if (strcmp("end_validity", param_field) == 0) {
      end__validity().set_param(param);
      return;
    } else if (strcmp("time_start_and_end", param_field) == 0) {
      time__start__and__end().set_param(param);
      return;
    } else if (strcmp("time_start_and_duration", param_field) == 0) {
      time__start__and__duration().set_param(param);
      return;
    } else if (strcmp("region", param_field) == 0) {
      region().set_param(param);
      return;
    } else if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsSecurity_TypesAndValues.ValidityRestrictionContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "end_validity")) {
    end__validity().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "time_start_and_end")) {
    time__start__and__end().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "time_start_and_duration")) {
    time__start__and__duration().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "region")) {
    region().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "data")) {
    data().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.", mp_last->get_id()->get_name());
}

Module_Param* ValidityRestrictionContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsSecurity_TypesAndValues.ValidityRestrictionContainer'");
    }
    if (strcmp("end_validity", param_field) == 0) {
      return end__validity().get_param(param_name);
    } else if (strcmp("time_start_and_end", param_field) == 0) {
      return time__start__and__end().get_param(param_name);
    } else if (strcmp("time_start_and_duration", param_field) == 0) {
      return time__start__and__duration().get_param(param_name);
    } else if (strcmp("region", param_field) == 0) {
      return region().get_param(param_name);
    } else if (strcmp("data", param_field) == 0) {
      return data().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `ValidityRestrictionContainer'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_end__validity:
    mp_field = field_end__validity->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("end_validity")));
    break;
  case ALT_time__start__and__end:
    mp_field = field_time__start__and__end->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("time_start_and_end")));
    break;
  case ALT_time__start__and__duration:
    mp_field = field_time__start__and__duration->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("time_start_and_duration")));
    break;
  case ALT_region:
    mp_field = field_region->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("region")));
    break;
  case ALT_data:
    mp_field = field_data->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("data")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void ValidityRestrictionContainer::set_implicit_omit()
{
switch (union_selection) {
case ALT_end__validity:
field_end__validity->set_implicit_omit(); break;
case ALT_time__start__and__end:
field_time__start__and__end->set_implicit_omit(); break;
case ALT_time__start__and__duration:
field_time__start__and__duration->set_implicit_omit(); break;
case ALT_region:
field_region->set_implicit_omit(); break;
case ALT_data:
field_data->set_implicit_omit(); break;
default: break;
}
}

void ValidityRestrictionContainer::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_end__validity:
field_end__validity->encode_text(text_buf);
break;
case ALT_time__start__and__end:
field_time__start__and__end->encode_text(text_buf);
break;
case ALT_time__start__and__duration:
field_time__start__and__duration->encode_text(text_buf);
break;
case ALT_region:
field_region->encode_text(text_buf);
break;
case ALT_data:
field_data->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
}
}

void ValidityRestrictionContainer::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_end__validity:
end__validity().decode_text(text_buf);
break;
case ALT_time__start__and__end:
time__start__and__end().decode_text(text_buf);
break;
case ALT_time__start__and__duration:
time__start__and__duration().decode_text(text_buf);
break;
case ALT_region:
region().decode_text(text_buf);
break;
case ALT_data:
data().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
}
}

void ValidityRestrictionContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ValidityRestrictionContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ValidityRestrictionContainer::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = end__validity().RAW_decode(Time32_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = time__start__and__end().RAW_decode(TimeStartEnd_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 2:
      decoded_length = time__start__and__duration().RAW_decode(TimeDuration_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 3:
      decoded_length = region().RAW_decode(GeographicRegion_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 4:
      decoded_length = data().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = end__validity().RAW_decode(Time32_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = time__start__and__end().RAW_decode(TimeStartEnd_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = time__start__and__duration().RAW_decode(TimeDuration_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = region().RAW_decode(GeographicRegion_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = data().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int ValidityRestrictionContainer::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 5;  myleaf.body.node.nodes = init_nodes_of_enc_tree(5);
  memset(myleaf.body.node.nodes, 0, 5 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_end__validity:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, Time32_descr_.raw);
    encoded_length = field_end__validity->RAW_encode(Time32_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &Time32_descr_;
    break;
  case ALT_time__start__and__end:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, TimeStartEnd_descr_.raw);
    encoded_length = field_time__start__and__end->RAW_encode(TimeStartEnd_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &TimeStartEnd_descr_;
    break;
  case ALT_time__start__and__duration:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, TimeDuration_descr_.raw);
    encoded_length = field_time__start__and__duration->RAW_encode(TimeDuration_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &TimeDuration_descr_;
    break;
  case ALT_region:
    myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 3, GeographicRegion_descr_.raw);
    encoded_length = field_region->RAW_encode(GeographicRegion_descr_, *myleaf.body.node.nodes[3]);
    myleaf.body.node.nodes[3]->coding_descr = &GeographicRegion_descr_;
    break;
  case ALT_data:
    myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 4, OCTETSTRING_descr_.raw);
    encoded_length = field_data->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[4]);
    myleaf.body.node.nodes[4]->coding_descr = &OCTETSTRING_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int ValidityRestrictionContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_end__validity:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "end_validity");
    enc_len += field_end__validity->JSON_encode(Time32_descr_, p_tok);
    break;
  case ALT_time__start__and__end:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "time_start_and_end");
    enc_len += field_time__start__and__end->JSON_encode(TimeStartEnd_descr_, p_tok);
    break;
  case ALT_time__start__and__duration:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "time_start_and_duration");
    enc_len += field_time__start__and__duration->JSON_encode(TimeDuration_descr_, p_tok);
    break;
  case ALT_region:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "region");
    enc_len += field_region->JSON_encode(GeographicRegion_descr_, p_tok);
    break;
  case ALT_data:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "data");
    enc_len += field_data->JSON_encode(OCTETSTRING_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ValidityRestrictionContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "end_validity", name_len)) {
      int ret_val = end__validity().JSON_decode(Time32_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "end_validity");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "time_start_and_end", name_len)) {
      int ret_val = time__start__and__end().JSON_decode(TimeStartEnd_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "time_start_and_end");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "time_start_and_duration", name_len)) {
      int ret_val = time__start__and__duration().JSON_decode(TimeDuration_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "time_start_and_duration");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "region", name_len)) {
      int ret_val = region().JSON_decode(GeographicRegion_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "region");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "data", name_len)) {
      int ret_val = data().JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "data");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void ValidityRestrictionContainer_template::copy_value(const ValidityRestrictionContainer& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case ValidityRestrictionContainer::ALT_end__validity:
single_value.field_end__validity = new INTEGER_template(other_value.end__validity());
break;
case ValidityRestrictionContainer::ALT_time__start__and__end:
single_value.field_time__start__and__end = new TimeStartEnd_template(other_value.time__start__and__end());
break;
case ValidityRestrictionContainer::ALT_time__start__and__duration:
single_value.field_time__start__and__duration = new TimeDuration_template(other_value.time__start__and__duration());
break;
case ValidityRestrictionContainer::ALT_region:
single_value.field_region = new GeographicRegion_template(other_value.region());
break;
case ValidityRestrictionContainer::ALT_data:
single_value.field_data = new OCTETSTRING_template(other_value.data());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
}
set_selection(SPECIFIC_VALUE);
}

void ValidityRestrictionContainer_template::copy_template(const ValidityRestrictionContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case ValidityRestrictionContainer::ALT_end__validity:
single_value.field_end__validity = new INTEGER_template(*other_value.single_value.field_end__validity);
break;
case ValidityRestrictionContainer::ALT_time__start__and__end:
single_value.field_time__start__and__end = new TimeStartEnd_template(*other_value.single_value.field_time__start__and__end);
break;
case ValidityRestrictionContainer::ALT_time__start__and__duration:
single_value.field_time__start__and__duration = new TimeDuration_template(*other_value.single_value.field_time__start__and__duration);
break;
case ValidityRestrictionContainer::ALT_region:
single_value.field_region = new GeographicRegion_template(*other_value.single_value.field_region);
break;
case ValidityRestrictionContainer::ALT_data:
single_value.field_data = new OCTETSTRING_template(*other_value.single_value.field_data);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ValidityRestrictionContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
}
set_selection(other_value);
}

ValidityRestrictionContainer_template::ValidityRestrictionContainer_template()
{
}

ValidityRestrictionContainer_template::ValidityRestrictionContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ValidityRestrictionContainer_template::ValidityRestrictionContainer_template(const ValidityRestrictionContainer& other_value)
{
copy_value(other_value);
}

ValidityRestrictionContainer_template::ValidityRestrictionContainer_template(const OPTIONAL<ValidityRestrictionContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ValidityRestrictionContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer from an unbound optional field.");
}
}

ValidityRestrictionContainer_template::ValidityRestrictionContainer_template(const ValidityRestrictionContainer_template& other_value)
: Base_Template(){
copy_template(other_value);
}

ValidityRestrictionContainer_template::~ValidityRestrictionContainer_template()
{
clean_up();
}

void ValidityRestrictionContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ValidityRestrictionContainer::ALT_end__validity:
delete single_value.field_end__validity;
break;
case ValidityRestrictionContainer::ALT_time__start__and__end:
delete single_value.field_time__start__and__end;
break;
case ValidityRestrictionContainer::ALT_time__start__and__duration:
delete single_value.field_time__start__and__duration;
break;
case ValidityRestrictionContainer::ALT_region:
delete single_value.field_region;
break;
case ValidityRestrictionContainer::ALT_data:
delete single_value.field_data;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ValidityRestrictionContainer_template& ValidityRestrictionContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ValidityRestrictionContainer_template& ValidityRestrictionContainer_template::operator=(const ValidityRestrictionContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ValidityRestrictionContainer_template& ValidityRestrictionContainer_template::operator=(const OPTIONAL<ValidityRestrictionContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ValidityRestrictionContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
}
return *this;
}

ValidityRestrictionContainer_template& ValidityRestrictionContainer_template::operator=(const ValidityRestrictionContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ValidityRestrictionContainer_template::match(const ValidityRestrictionContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
ValidityRestrictionContainer::union_selection_type value_selection = other_value.get_selection();
if (value_selection == ValidityRestrictionContainer::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case ValidityRestrictionContainer::ALT_end__validity:
return single_value.field_end__validity->match(other_value.end__validity(), legacy);
case ValidityRestrictionContainer::ALT_time__start__and__end:
return single_value.field_time__start__and__end->match(other_value.time__start__and__end(), legacy);
case ValidityRestrictionContainer::ALT_time__start__and__duration:
return single_value.field_time__start__and__duration->match(other_value.time__start__and__duration(), legacy);
case ValidityRestrictionContainer::ALT_region:
return single_value.field_region->match(other_value.region(), legacy);
case ValidityRestrictionContainer::ALT_data:
return single_value.field_data->match(other_value.data(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
}
return FALSE;
}

boolean ValidityRestrictionContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case ValidityRestrictionContainer::ALT_end__validity:
return single_value.field_end__validity->is_value();
case ValidityRestrictionContainer::ALT_time__start__and__end:
return single_value.field_time__start__and__end->is_value();
case ValidityRestrictionContainer::ALT_time__start__and__duration:
return single_value.field_time__start__and__duration->is_value();
case ValidityRestrictionContainer::ALT_region:
return single_value.field_region->is_value();
case ValidityRestrictionContainer::ALT_data:
return single_value.field_data->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
}
}

ValidityRestrictionContainer ValidityRestrictionContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
ValidityRestrictionContainer ret_val;
switch (single_value.union_selection) {
case ValidityRestrictionContainer::ALT_end__validity:
ret_val.end__validity() = single_value.field_end__validity->valueof();
break;
case ValidityRestrictionContainer::ALT_time__start__and__end:
ret_val.time__start__and__end() = single_value.field_time__start__and__end->valueof();
break;
case ValidityRestrictionContainer::ALT_time__start__and__duration:
ret_val.time__start__and__duration() = single_value.field_time__start__and__duration->valueof();
break;
case ValidityRestrictionContainer::ALT_region:
ret_val.region() = single_value.field_region->valueof();
break;
case ValidityRestrictionContainer::ALT_data:
ret_val.data() = single_value.field_data->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
}
return ret_val;
}

ValidityRestrictionContainer_template& ValidityRestrictionContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
return value_list.list_value[list_index];
}
void ValidityRestrictionContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ValidityRestrictionContainer_template[list_length];
}

INTEGER_template& ValidityRestrictionContainer_template::end__validity()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ValidityRestrictionContainer::ALT_end__validity) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_end__validity = new INTEGER_template(ANY_VALUE);
else single_value.field_end__validity = new INTEGER_template;
single_value.union_selection = ValidityRestrictionContainer::ALT_end__validity;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_end__validity;
}

const INTEGER_template& ValidityRestrictionContainer_template::end__validity() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field end_validity in a non-specific template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
if (single_value.union_selection != ValidityRestrictionContainer::ALT_end__validity) TTCN_error("Accessing non-selected field end_validity in a template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
return *single_value.field_end__validity;
}

TimeStartEnd_template& ValidityRestrictionContainer_template::time__start__and__end()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ValidityRestrictionContainer::ALT_time__start__and__end) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_time__start__and__end = new TimeStartEnd_template(ANY_VALUE);
else single_value.field_time__start__and__end = new TimeStartEnd_template;
single_value.union_selection = ValidityRestrictionContainer::ALT_time__start__and__end;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_time__start__and__end;
}

const TimeStartEnd_template& ValidityRestrictionContainer_template::time__start__and__end() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field time_start_and_end in a non-specific template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
if (single_value.union_selection != ValidityRestrictionContainer::ALT_time__start__and__end) TTCN_error("Accessing non-selected field time_start_and_end in a template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
return *single_value.field_time__start__and__end;
}

TimeDuration_template& ValidityRestrictionContainer_template::time__start__and__duration()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ValidityRestrictionContainer::ALT_time__start__and__duration) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_time__start__and__duration = new TimeDuration_template(ANY_VALUE);
else single_value.field_time__start__and__duration = new TimeDuration_template;
single_value.union_selection = ValidityRestrictionContainer::ALT_time__start__and__duration;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_time__start__and__duration;
}

const TimeDuration_template& ValidityRestrictionContainer_template::time__start__and__duration() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field time_start_and_duration in a non-specific template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
if (single_value.union_selection != ValidityRestrictionContainer::ALT_time__start__and__duration) TTCN_error("Accessing non-selected field time_start_and_duration in a template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
return *single_value.field_time__start__and__duration;
}

GeographicRegion_template& ValidityRestrictionContainer_template::region()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ValidityRestrictionContainer::ALT_region) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_region = new GeographicRegion_template(ANY_VALUE);
else single_value.field_region = new GeographicRegion_template;
single_value.union_selection = ValidityRestrictionContainer::ALT_region;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_region;
}

const GeographicRegion_template& ValidityRestrictionContainer_template::region() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field region in a non-specific template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
if (single_value.union_selection != ValidityRestrictionContainer::ALT_region) TTCN_error("Accessing non-selected field region in a template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
return *single_value.field_region;
}

OCTETSTRING_template& ValidityRestrictionContainer_template::data()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != ValidityRestrictionContainer::ALT_data) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_data = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_data = new OCTETSTRING_template;
single_value.union_selection = ValidityRestrictionContainer::ALT_data;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_data;
}

const OCTETSTRING_template& ValidityRestrictionContainer_template::data() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field data in a non-specific template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
if (single_value.union_selection != ValidityRestrictionContainer::ALT_data) TTCN_error("Accessing non-selected field data in a template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
return *single_value.field_data;
}

boolean ValidityRestrictionContainer_template::ischosen(ValidityRestrictionContainer::union_selection_type checked_selection) const
{
if (checked_selection == ValidityRestrictionContainer::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == ValidityRestrictionContainer::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer");
}
return FALSE;
}

void ValidityRestrictionContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case ValidityRestrictionContainer::ALT_end__validity:
TTCN_Logger::log_event_str("{ end_validity := ");
single_value.field_end__validity->log();
TTCN_Logger::log_event_str(" }");
break;
case ValidityRestrictionContainer::ALT_time__start__and__end:
TTCN_Logger::log_event_str("{ time_start_and_end := ");
single_value.field_time__start__and__end->log();
TTCN_Logger::log_event_str(" }");
break;
case ValidityRestrictionContainer::ALT_time__start__and__duration:
TTCN_Logger::log_event_str("{ time_start_and_duration := ");
single_value.field_time__start__and__duration->log();
TTCN_Logger::log_event_str(" }");
break;
case ValidityRestrictionContainer::ALT_region:
TTCN_Logger::log_event_str("{ region := ");
single_value.field_region->log();
TTCN_Logger::log_event_str(" }");
break;
case ValidityRestrictionContainer::ALT_data:
TTCN_Logger::log_event_str("{ data := ");
single_value.field_data->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ValidityRestrictionContainer_template::log_match(const ValidityRestrictionContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case ValidityRestrictionContainer::ALT_end__validity:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".end_validity");
single_value.field_end__validity->log_match(match_value.end__validity(), legacy);
} else {
TTCN_Logger::log_event_str("{ end_validity := ");
single_value.field_end__validity->log_match(match_value.end__validity(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ValidityRestrictionContainer::ALT_time__start__and__end:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".time_start_and_end");
single_value.field_time__start__and__end->log_match(match_value.time__start__and__end(), legacy);
} else {
TTCN_Logger::log_event_str("{ time_start_and_end := ");
single_value.field_time__start__and__end->log_match(match_value.time__start__and__end(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ValidityRestrictionContainer::ALT_time__start__and__duration:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".time_start_and_duration");
single_value.field_time__start__and__duration->log_match(match_value.time__start__and__duration(), legacy);
} else {
TTCN_Logger::log_event_str("{ time_start_and_duration := ");
single_value.field_time__start__and__duration->log_match(match_value.time__start__and__duration(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ValidityRestrictionContainer::ALT_region:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".region");
single_value.field_region->log_match(match_value.region(), legacy);
} else {
TTCN_Logger::log_event_str("{ region := ");
single_value.field_region->log_match(match_value.region(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case ValidityRestrictionContainer::ALT_data:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".data");
single_value.field_data->log_match(match_value.data(), legacy);
} else {
TTCN_Logger::log_event_str("{ data := ");
single_value.field_data->log_match(match_value.data(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ValidityRestrictionContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case ValidityRestrictionContainer::ALT_end__validity:
single_value.field_end__validity->encode_text(text_buf);
break;
case ValidityRestrictionContainer::ALT_time__start__and__end:
single_value.field_time__start__and__end->encode_text(text_buf);
break;
case ValidityRestrictionContainer::ALT_time__start__and__duration:
single_value.field_time__start__and__duration->encode_text(text_buf);
break;
case ValidityRestrictionContainer::ALT_region:
single_value.field_region->encode_text(text_buf);
break;
case ValidityRestrictionContainer::ALT_data:
single_value.field_data->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
}
}

void ValidityRestrictionContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = ValidityRestrictionContainer::UNBOUND_VALUE;
ValidityRestrictionContainer::union_selection_type new_selection = (ValidityRestrictionContainer::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case ValidityRestrictionContainer::ALT_end__validity:
single_value.field_end__validity = new INTEGER_template;
single_value.field_end__validity->decode_text(text_buf);
break;
case ValidityRestrictionContainer::ALT_time__start__and__end:
single_value.field_time__start__and__end = new TimeStartEnd_template;
single_value.field_time__start__and__end->decode_text(text_buf);
break;
case ValidityRestrictionContainer::ALT_time__start__and__duration:
single_value.field_time__start__and__duration = new TimeDuration_template;
single_value.field_time__start__and__duration->decode_text(text_buf);
break;
case ValidityRestrictionContainer::ALT_region:
single_value.field_region = new GeographicRegion_template;
single_value.field_region->decode_text(text_buf);
break;
case ValidityRestrictionContainer::ALT_data:
single_value.field_data = new OCTETSTRING_template;
single_value.field_data->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ValidityRestrictionContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
}
}

boolean ValidityRestrictionContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ValidityRestrictionContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ValidityRestrictionContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsSecurity_TypesAndValues.ValidityRestrictionContainer'");
    }
    if (strcmp("end_validity", param_field) == 0) {
      end__validity().set_param(param);
      return;
    } else if (strcmp("time_start_and_end", param_field) == 0) {
      time__start__and__end().set_param(param);
      return;
    } else if (strcmp("time_start_and_duration", param_field) == 0) {
      time__start__and__duration().set_param(param);
      return;
    } else if (strcmp("region", param_field) == 0) {
      region().set_param(param);
      return;
    } else if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsSecurity_TypesAndValues.ValidityRestrictionContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ValidityRestrictionContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.ValidityRestrictionContainer");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "end_validity")) {
      end__validity().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "time_start_and_end")) {
      time__start__and__end().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "time_start_and_duration")) {
      time__start__and__duration().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "region")) {
      region().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "data")) {
      data().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.ValidityRestrictionContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ValidityRestrictionContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsSecurity_TypesAndValues.ValidityRestrictionContainer'");
    }
    if (strcmp("end_validity", param_field) == 0) {
      return end__validity().get_param(param_name);
    } else if (strcmp("time_start_and_end", param_field) == 0) {
      return time__start__and__end().get_param(param_name);
    } else if (strcmp("time_start_and_duration", param_field) == 0) {
      return time__start__and__duration().get_param(param_name);
    } else if (strcmp("region", param_field) == 0) {
      return region().get_param(param_name);
    } else if (strcmp("data", param_field) == 0) {
      return data().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `ValidityRestrictionContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case ValidityRestrictionContainer::ALT_end__validity:
      mp_field = single_value.field_end__validity->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("end_validity")));
      break;
    case ValidityRestrictionContainer::ALT_time__start__and__end:
      mp_field = single_value.field_time__start__and__end->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("time_start_and_end")));
      break;
    case ValidityRestrictionContainer::ALT_time__start__and__duration:
      mp_field = single_value.field_time__start__and__duration->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("time_start_and_duration")));
      break;
    case ValidityRestrictionContainer::ALT_region:
      mp_field = single_value.field_region->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("region")));
      break;
    case ValidityRestrictionContainer::ALT_data:
      mp_field = single_value.field_data->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("data")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ValidityRestrictionContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case ValidityRestrictionContainer::ALT_end__validity:
single_value.field_end__validity->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ValidityRestrictionContainer");
return;
case ValidityRestrictionContainer::ALT_time__start__and__end:
single_value.field_time__start__and__end->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ValidityRestrictionContainer");
return;
case ValidityRestrictionContainer::ALT_time__start__and__duration:
single_value.field_time__start__and__duration->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ValidityRestrictionContainer");
return;
case ValidityRestrictionContainer::ALT_region:
single_value.field_region->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ValidityRestrictionContainer");
return;
case ValidityRestrictionContainer::ALT_data:
single_value.field_data->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ValidityRestrictionContainer");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsSecurity_TypesAndValues.ValidityRestrictionContainer.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.ValidityRestrictionContainer");
}

TimeStartEnd::TimeStartEnd()
{
  bound_flag = FALSE;
}

TimeStartEnd::TimeStartEnd(const INTEGER& par_start__validity,
    const INTEGER& par_end__validity)
  :   field_start__validity(par_start__validity),
  field_end__validity(par_end__validity)
{
  bound_flag = TRUE;
}

TimeStartEnd::TimeStartEnd(const TimeStartEnd& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.TimeStartEnd.");
bound_flag = TRUE;
if (other_value.start__validity().is_bound()) field_start__validity = other_value.start__validity();
else field_start__validity.clean_up();
if (other_value.end__validity().is_bound()) field_end__validity = other_value.end__validity();
else field_end__validity.clean_up();
}

void TimeStartEnd::clean_up()
{
field_start__validity.clean_up();
field_end__validity.clean_up();
bound_flag = FALSE;
}

TimeStartEnd& TimeStartEnd::operator=(const TimeStartEnd& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.TimeStartEnd.");
  bound_flag = TRUE;
  if (other_value.start__validity().is_bound()) field_start__validity = other_value.start__validity();
  else field_start__validity.clean_up();
  if (other_value.end__validity().is_bound()) field_end__validity = other_value.end__validity();
  else field_end__validity.clean_up();
}
return *this;
}

boolean TimeStartEnd::operator==(const TimeStartEnd& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_start__validity==other_value.field_start__validity
  && field_end__validity==other_value.field_end__validity;
}

boolean TimeStartEnd::is_bound() const
{
if (bound_flag) return TRUE;
if(field_start__validity.is_bound()) return TRUE;
if(field_end__validity.is_bound()) return TRUE;
return FALSE;
}
boolean TimeStartEnd::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_start__validity.is_value()) return FALSE;
if(!field_end__validity.is_value()) return FALSE;
return TRUE;
}
int TimeStartEnd::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.TimeStartEnd");
  return 2;
}

void TimeStartEnd::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ start_validity := ");
field_start__validity.log();
TTCN_Logger::log_event_str(", end_validity := ");
field_end__validity.log();
TTCN_Logger::log_event_str(" }");
}

void TimeStartEnd::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.TimeStartEnd'");
    }
    if (strcmp("start_validity", param_field) == 0) {
      start__validity().set_param(param);
      return;
    } else if (strcmp("end_validity", param_field) == 0) {
      end__validity().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.TimeStartEnd'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.TimeStartEnd has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) start__validity().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) end__validity().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "start_validity")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          start__validity().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "end_validity")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          end__validity().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.TimeStartEnd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.TimeStartEnd");
  }
}

Module_Param* TimeStartEnd::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.TimeStartEnd'");
    }
    if (strcmp("start_validity", param_field) == 0) {
      return start__validity().get_param(param_name);
    } else if (strcmp("end_validity", param_field) == 0) {
      return end__validity().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.TimeStartEnd'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_start__validity = field_start__validity.get_param(param_name);
  mp_field_start__validity->set_id(new Module_Param_FieldName(mcopystr("start_validity")));
  mp->add_elem(mp_field_start__validity);
  Module_Param* mp_field_end__validity = field_end__validity.get_param(param_name);
  mp_field_end__validity->set_id(new Module_Param_FieldName(mcopystr("end_validity")));
  mp->add_elem(mp_field_end__validity);
  return mp;
  }

void TimeStartEnd::set_implicit_omit()
{
if (start__validity().is_bound()) start__validity().set_implicit_omit();
if (end__validity().is_bound()) end__validity().set_implicit_omit();
}

void TimeStartEnd::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.TimeStartEnd.");
field_start__validity.encode_text(text_buf);
field_end__validity.encode_text(text_buf);
}

void TimeStartEnd::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_start__validity.decode_text(text_buf);
field_end__validity.decode_text(text_buf);
}

void TimeStartEnd::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void TimeStartEnd::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int TimeStartEnd::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_start__validity.RAW_decode(Time32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_end__validity.RAW_decode(Time32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int TimeStartEnd::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, Time32_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, Time32_descr_.raw);
  encoded_length += field_start__validity.RAW_encode(Time32_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_end__validity.RAW_encode(Time32_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int TimeStartEnd::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.TimeStartEnd.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "start_validity");
    enc_len += field_start__validity.JSON_encode(Time32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "end_validity");
    enc_len += field_end__validity.JSON_encode(Time32_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int TimeStartEnd::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (14 == name_len && 0 == strncmp(fld_name, "start_validity", name_len)) {
         int ret_val = field_start__validity.JSON_decode(Time32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "start_validity");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "end_validity", name_len)) {
         int ret_val = field_end__validity.JSON_decode(Time32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "end_validity");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_start__validity.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "start_validity");
    return JSON_ERROR_FATAL;
  }
if (!field_end__validity.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "end_validity");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct TimeStartEnd_template::single_value_struct {
INTEGER_template field_start__validity;
INTEGER_template field_end__validity;
};

void TimeStartEnd_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_start__validity = ANY_VALUE;
single_value->field_end__validity = ANY_VALUE;
}
}
}

void TimeStartEnd_template::copy_value(const TimeStartEnd& other_value)
{
single_value = new single_value_struct;
if (other_value.start__validity().is_bound()) {
  single_value->field_start__validity = other_value.start__validity();
} else {
  single_value->field_start__validity.clean_up();
}
if (other_value.end__validity().is_bound()) {
  single_value->field_end__validity = other_value.end__validity();
} else {
  single_value->field_end__validity.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void TimeStartEnd_template::copy_template(const TimeStartEnd_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.start__validity().get_selection()) {
single_value->field_start__validity = other_value.start__validity();
} else {
single_value->field_start__validity.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.end__validity().get_selection()) {
single_value->field_end__validity = other_value.end__validity();
} else {
single_value->field_end__validity.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TimeStartEnd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TimeStartEnd.");
break;
}
set_selection(other_value);
}

TimeStartEnd_template::TimeStartEnd_template()
{
}

TimeStartEnd_template::TimeStartEnd_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

TimeStartEnd_template::TimeStartEnd_template(const TimeStartEnd& other_value)
{
copy_value(other_value);
}

TimeStartEnd_template::TimeStartEnd_template(const OPTIONAL<TimeStartEnd>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TimeStartEnd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.TimeStartEnd from an unbound optional field.");
}
}

TimeStartEnd_template::TimeStartEnd_template(const TimeStartEnd_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

TimeStartEnd_template::~TimeStartEnd_template()
{
clean_up();
}

TimeStartEnd_template& TimeStartEnd_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TimeStartEnd_template& TimeStartEnd_template::operator=(const TimeStartEnd& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

TimeStartEnd_template& TimeStartEnd_template::operator=(const OPTIONAL<TimeStartEnd>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TimeStartEnd&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.TimeStartEnd.");
}
return *this;
}

TimeStartEnd_template& TimeStartEnd_template::operator=(const TimeStartEnd_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean TimeStartEnd_template::match(const TimeStartEnd& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.start__validity().is_bound()) return FALSE;
if(!single_value->field_start__validity.match(other_value.start__validity(), legacy))return FALSE;
if(!other_value.end__validity().is_bound()) return FALSE;
if(!single_value->field_end__validity.match(other_value.end__validity(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TimeStartEnd.");
}
return FALSE;
}

boolean TimeStartEnd_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_start__validity.is_bound()) return TRUE;
if (single_value->field_end__validity.is_bound()) return TRUE;
return FALSE;
}

boolean TimeStartEnd_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_start__validity.is_value()) return FALSE;
if (!single_value->field_end__validity.is_value()) return FALSE;
return TRUE;
}

void TimeStartEnd_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

TimeStartEnd TimeStartEnd_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.TimeStartEnd.");
TimeStartEnd ret_val;
if (single_value->field_start__validity.is_bound()) {
ret_val.start__validity() = single_value->field_start__validity.valueof();
}
if (single_value->field_end__validity.is_bound()) {
ret_val.end__validity() = single_value->field_end__validity.valueof();
}
return ret_val;
}

void TimeStartEnd_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.TimeStartEnd.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new TimeStartEnd_template[list_length];
}

TimeStartEnd_template& TimeStartEnd_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.TimeStartEnd.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.TimeStartEnd.");
return value_list.list_value[list_index];
}

INTEGER_template& TimeStartEnd_template::start__validity()
{
set_specific();
return single_value->field_start__validity;
}

const INTEGER_template& TimeStartEnd_template::start__validity() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field start_validity of a non-specific template of type @LibItsSecurity_TypesAndValues.TimeStartEnd.");
return single_value->field_start__validity;
}

INTEGER_template& TimeStartEnd_template::end__validity()
{
set_specific();
return single_value->field_end__validity;
}

const INTEGER_template& TimeStartEnd_template::end__validity() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field end_validity of a non-specific template of type @LibItsSecurity_TypesAndValues.TimeStartEnd.");
return single_value->field_end__validity;
}

int TimeStartEnd_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TimeStartEnd which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TimeStartEnd containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TimeStartEnd containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TimeStartEnd containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TimeStartEnd containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TimeStartEnd containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TimeStartEnd.");
  }
  return 0;
}

void TimeStartEnd_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ start_validity := ");
single_value->field_start__validity.log();
TTCN_Logger::log_event_str(", end_validity := ");
single_value->field_end__validity.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void TimeStartEnd_template::log_match(const TimeStartEnd& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_start__validity.match(match_value.start__validity(), legacy)){
TTCN_Logger::log_logmatch_info(".start_validity");
single_value->field_start__validity.log_match(match_value.start__validity(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_end__validity.match(match_value.end__validity(), legacy)){
TTCN_Logger::log_logmatch_info(".end_validity");
single_value->field_end__validity.log_match(match_value.end__validity(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ start_validity := ");
single_value->field_start__validity.log_match(match_value.start__validity(), legacy);
TTCN_Logger::log_event_str(", end_validity := ");
single_value->field_end__validity.log_match(match_value.end__validity(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void TimeStartEnd_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_start__validity.encode_text(text_buf);
single_value->field_end__validity.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TimeStartEnd.");
}
}

void TimeStartEnd_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_start__validity.decode_text(text_buf);
single_value->field_end__validity.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TimeStartEnd_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.TimeStartEnd.");
}
}

void TimeStartEnd_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.TimeStartEnd'");
    }
    if (strcmp("start_validity", param_field) == 0) {
      start__validity().set_param(param);
      return;
    } else if (strcmp("end_validity", param_field) == 0) {
      end__validity().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.TimeStartEnd'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TimeStartEnd_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.TimeStartEnd has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) start__validity().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) end__validity().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "start_validity")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          start__validity().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "end_validity")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          end__validity().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.TimeStartEnd: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.TimeStartEnd");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* TimeStartEnd_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.TimeStartEnd'");
    }
    if (strcmp("start_validity", param_field) == 0) {
      return start__validity().get_param(param_name);
    } else if (strcmp("end_validity", param_field) == 0) {
      return end__validity().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.TimeStartEnd'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_start__validity = single_value->field_start__validity.get_param(param_name);
    mp_field_start__validity->set_id(new Module_Param_FieldName(mcopystr("start_validity")));
    mp->add_elem(mp_field_start__validity);
    Module_Param* mp_field_end__validity = single_value->field_end__validity.get_param(param_name);
    mp_field_end__validity->set_id(new Module_Param_FieldName(mcopystr("end_validity")));
    mp->add_elem(mp_field_end__validity);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void TimeStartEnd_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_start__validity.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TimeStartEnd");
single_value->field_end__validity.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TimeStartEnd");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.TimeStartEnd");
}

boolean TimeStartEnd_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TimeStartEnd_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

DurationUnitType::DurationUnitType()
{
enum_value = UNBOUND_VALUE;
}

DurationUnitType::DurationUnitType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

DurationUnitType::DurationUnitType(enum_type other_value)
{
enum_value = other_value;
}

DurationUnitType::DurationUnitType(const DurationUnitType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
enum_value = other_value.enum_value;
}

DurationUnitType& DurationUnitType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

DurationUnitType& DurationUnitType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

DurationUnitType& DurationUnitType::operator=(const DurationUnitType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
enum_value = other_value.enum_value;
return *this;
}

boolean DurationUnitType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
return enum_value == other_value;
}

boolean DurationUnitType::operator==(const DurationUnitType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
return enum_value == other_value.enum_value;
}

boolean DurationUnitType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
return enum_value < other_value;
}

boolean DurationUnitType::operator<(const DurationUnitType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
return enum_value < other_value.enum_value;
}

boolean DurationUnitType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
return enum_value > other_value;
}

boolean DurationUnitType::operator>(const DurationUnitType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
return enum_value > other_value.enum_value;
}

const char *DurationUnitType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__seconds: return "e_seconds";
case e__minutes: return "e_minutes";
case e__hours: return "e_hours";
case e__hoursBlock: return "e_hoursBlock";
case e__year: return "e_year";
default: return "<unknown>";
}
}

DurationUnitType::enum_type DurationUnitType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_seconds")) return e__seconds;
else if (!strcmp(str_par, "e_minutes")) return e__minutes;
else if (!strcmp(str_par, "e_hours")) return e__hours;
else if (!strcmp(str_par, "e_hoursBlock")) return e__hoursBlock;
else if (!strcmp(str_par, "e_year")) return e__year;
else return UNKNOWN_VALUE;
}

boolean DurationUnitType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
return TRUE;
default:
return FALSE;
}
}

int DurationUnitType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int DurationUnitType::enum2int(const DurationUnitType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void DurationUnitType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.", int_val);
enum_value = (enum_type)int_val;
}

DurationUnitType::operator DurationUnitType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
return enum_value;
}

void DurationUnitType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void DurationUnitType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsSecurity_TypesAndValues.DurationUnitType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.DurationUnitType.");
  }
}

Module_Param* DurationUnitType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void DurationUnitType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
text_buf.push_int(enum_value);
}

void DurationUnitType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.", enum_value);
}

void DurationUnitType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void DurationUnitType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int DurationUnitType::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int DurationUnitType::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

int DurationUnitType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int DurationUnitType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void DurationUnitType_template::copy_template(const DurationUnitType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new DurationUnitType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
}
}

DurationUnitType_template::DurationUnitType_template()
{
}

DurationUnitType_template::DurationUnitType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

DurationUnitType_template::DurationUnitType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!DurationUnitType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType with unknown numeric value %d.", other_value);
single_value = (DurationUnitType::enum_type)other_value;
}

DurationUnitType_template::DurationUnitType_template(DurationUnitType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

DurationUnitType_template::DurationUnitType_template(const DurationUnitType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == DurationUnitType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
single_value = other_value.enum_value;
}

DurationUnitType_template::DurationUnitType_template(const OPTIONAL<DurationUnitType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (DurationUnitType::enum_type)(const DurationUnitType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType from an unbound optional field.");
}
}

DurationUnitType_template::DurationUnitType_template(const DurationUnitType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

DurationUnitType_template::~DurationUnitType_template()
{
clean_up();
}

boolean DurationUnitType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean DurationUnitType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != DurationUnitType::UNBOUND_VALUE;
}

void DurationUnitType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

DurationUnitType_template& DurationUnitType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

DurationUnitType_template& DurationUnitType_template::operator=(int other_value)
{
if (!DurationUnitType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (DurationUnitType::enum_type)other_value;
return *this;
}

DurationUnitType_template& DurationUnitType_template::operator=(DurationUnitType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

DurationUnitType_template& DurationUnitType_template::operator=(const DurationUnitType& other_value)
{
if (other_value.enum_value == DurationUnitType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

DurationUnitType_template& DurationUnitType_template::operator=(const OPTIONAL<DurationUnitType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (DurationUnitType::enum_type)(const DurationUnitType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
}
return *this;
}

DurationUnitType_template& DurationUnitType_template::operator=(const DurationUnitType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean DurationUnitType_template::match(DurationUnitType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
}
return FALSE;
}

boolean DurationUnitType_template::match(const DurationUnitType& other_value, boolean) const
{
if (other_value.enum_value == DurationUnitType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType with an unbound value.");
return match(other_value.enum_value);
}

DurationUnitType::enum_type DurationUnitType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
return single_value;
}

void DurationUnitType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new DurationUnitType_template[list_length];
}

DurationUnitType_template& DurationUnitType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
return value_list.list_value[list_index];
}

void DurationUnitType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(DurationUnitType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void DurationUnitType_template::log_match(const DurationUnitType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void DurationUnitType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
}
}

void DurationUnitType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (DurationUnitType::enum_type)text_buf.pull_int().get_val();
if (!DurationUnitType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new DurationUnitType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsSecurity_TypesAndValues.DurationUnitType.");
}
}

boolean DurationUnitType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean DurationUnitType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void DurationUnitType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    DurationUnitType::enum_type enum_val = (enum_name != NULL) ? DurationUnitType::str_to_enum(enum_name) : DurationUnitType::UNKNOWN_VALUE;
    if (DurationUnitType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    DurationUnitType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    DurationUnitType::enum_type enum_val = DurationUnitType::str_to_enum(mp->get_enumerated());
    if (!DurationUnitType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.DurationUnitType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsSecurity_TypesAndValues.DurationUnitType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* DurationUnitType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(DurationUnitType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void DurationUnitType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.DurationUnitType");
}

Duration::Duration()
{
  bound_flag = FALSE;
}

Duration::Duration(const DurationUnitType& par_unit,
    const INTEGER& par_duration)
  :   field_unit(par_unit),
  field_duration(par_duration)
{
  bound_flag = TRUE;
}

Duration::Duration(const Duration& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.Duration.");
bound_flag = TRUE;
if (other_value.unit().is_bound()) field_unit = other_value.unit();
else field_unit.clean_up();
if (other_value.duration().is_bound()) field_duration = other_value.duration();
else field_duration.clean_up();
}

void Duration::clean_up()
{
field_unit.clean_up();
field_duration.clean_up();
bound_flag = FALSE;
}

Duration& Duration::operator=(const Duration& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.Duration.");
  bound_flag = TRUE;
  if (other_value.unit().is_bound()) field_unit = other_value.unit();
  else field_unit.clean_up();
  if (other_value.duration().is_bound()) field_duration = other_value.duration();
  else field_duration.clean_up();
}
return *this;
}

boolean Duration::operator==(const Duration& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_unit==other_value.field_unit
  && field_duration==other_value.field_duration;
}

boolean Duration::is_bound() const
{
if (bound_flag) return TRUE;
if(field_unit.is_bound()) return TRUE;
if(field_duration.is_bound()) return TRUE;
return FALSE;
}
boolean Duration::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_unit.is_value()) return FALSE;
if(!field_duration.is_value()) return FALSE;
return TRUE;
}
int Duration::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.Duration");
  return 2;
}

void Duration::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ unit := ");
field_unit.log();
TTCN_Logger::log_event_str(", duration := ");
field_duration.log();
TTCN_Logger::log_event_str(" }");
}

void Duration::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.Duration'");
    }
    if (strcmp("unit", param_field) == 0) {
      unit().set_param(param);
      return;
    } else if (strcmp("duration", param_field) == 0) {
      duration().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.Duration'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.Duration has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) unit().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) duration().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "unit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          unit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "duration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          duration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.Duration: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.Duration");
  }
}

Module_Param* Duration::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.Duration'");
    }
    if (strcmp("unit", param_field) == 0) {
      return unit().get_param(param_name);
    } else if (strcmp("duration", param_field) == 0) {
      return duration().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.Duration'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_unit = field_unit.get_param(param_name);
  mp_field_unit->set_id(new Module_Param_FieldName(mcopystr("unit")));
  mp->add_elem(mp_field_unit);
  Module_Param* mp_field_duration = field_duration.get_param(param_name);
  mp_field_duration->set_id(new Module_Param_FieldName(mcopystr("duration")));
  mp->add_elem(mp_field_duration);
  return mp;
  }

void Duration::set_implicit_omit()
{
if (unit().is_bound()) unit().set_implicit_omit();
if (duration().is_bound()) duration().set_implicit_omit();
}

void Duration::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.Duration.");
field_unit.encode_text(text_buf);
field_duration.encode_text(text_buf);
}

void Duration::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_unit.decode_text(text_buf);
field_duration.decode_text(text_buf);
}

void Duration::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Duration::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int Duration::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_unit.RAW_decode(DurationUnitType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_duration.RAW_decode(LibCommon__BasicTypesAndValues::Int13_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int Duration::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, DurationUnitType_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::Int13_descr_.raw);
  encoded_length += field_unit.RAW_encode(DurationUnitType_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_duration.RAW_encode(LibCommon__BasicTypesAndValues::Int13_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int Duration::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.Duration.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "unit");
    enc_len += field_unit.JSON_encode(DurationUnitType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "duration");
    enc_len += field_duration.JSON_encode(LibCommon__BasicTypesAndValues::Int13_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Duration::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (4 == name_len && 0 == strncmp(fld_name, "unit", name_len)) {
         int ret_val = field_unit.JSON_decode(DurationUnitType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "unit");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "duration", name_len)) {
         int ret_val = field_duration.JSON_decode(LibCommon__BasicTypesAndValues::Int13_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "duration");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_unit.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "unit");
    return JSON_ERROR_FATAL;
  }
if (!field_duration.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "duration");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct Duration_template::single_value_struct {
DurationUnitType_template field_unit;
INTEGER_template field_duration;
};

void Duration_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_unit = ANY_VALUE;
single_value->field_duration = ANY_VALUE;
}
}
}

void Duration_template::copy_value(const Duration& other_value)
{
single_value = new single_value_struct;
if (other_value.unit().is_bound()) {
  single_value->field_unit = other_value.unit();
} else {
  single_value->field_unit.clean_up();
}
if (other_value.duration().is_bound()) {
  single_value->field_duration = other_value.duration();
} else {
  single_value->field_duration.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Duration_template::copy_template(const Duration_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.unit().get_selection()) {
single_value->field_unit = other_value.unit();
} else {
single_value->field_unit.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.duration().get_selection()) {
single_value->field_duration = other_value.duration();
} else {
single_value->field_duration.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Duration_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.Duration.");
break;
}
set_selection(other_value);
}

Duration_template::Duration_template()
{
}

Duration_template::Duration_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Duration_template::Duration_template(const Duration& other_value)
{
copy_value(other_value);
}

Duration_template::Duration_template(const OPTIONAL<Duration>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Duration&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.Duration from an unbound optional field.");
}
}

Duration_template::Duration_template(const Duration_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Duration_template::~Duration_template()
{
clean_up();
}

Duration_template& Duration_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Duration_template& Duration_template::operator=(const Duration& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Duration_template& Duration_template::operator=(const OPTIONAL<Duration>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Duration&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.Duration.");
}
return *this;
}

Duration_template& Duration_template::operator=(const Duration_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Duration_template::match(const Duration& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.unit().is_bound()) return FALSE;
if(!single_value->field_unit.match(other_value.unit(), legacy))return FALSE;
if(!other_value.duration().is_bound()) return FALSE;
if(!single_value->field_duration.match(other_value.duration(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.Duration.");
}
return FALSE;
}

boolean Duration_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_unit.is_bound()) return TRUE;
if (single_value->field_duration.is_bound()) return TRUE;
return FALSE;
}

boolean Duration_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_unit.is_value()) return FALSE;
if (!single_value->field_duration.is_value()) return FALSE;
return TRUE;
}

void Duration_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Duration Duration_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.Duration.");
Duration ret_val;
if (single_value->field_unit.is_bound()) {
ret_val.unit() = single_value->field_unit.valueof();
}
if (single_value->field_duration.is_bound()) {
ret_val.duration() = single_value->field_duration.valueof();
}
return ret_val;
}

void Duration_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.Duration.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Duration_template[list_length];
}

Duration_template& Duration_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.Duration.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.Duration.");
return value_list.list_value[list_index];
}

DurationUnitType_template& Duration_template::unit()
{
set_specific();
return single_value->field_unit;
}

const DurationUnitType_template& Duration_template::unit() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field unit of a non-specific template of type @LibItsSecurity_TypesAndValues.Duration.");
return single_value->field_unit;
}

INTEGER_template& Duration_template::duration()
{
set_specific();
return single_value->field_duration;
}

const INTEGER_template& Duration_template::duration() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field duration of a non-specific template of type @LibItsSecurity_TypesAndValues.Duration.");
return single_value->field_duration;
}

int Duration_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Duration which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Duration containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Duration containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Duration containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Duration containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Duration containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.Duration.");
  }
  return 0;
}

void Duration_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ unit := ");
single_value->field_unit.log();
TTCN_Logger::log_event_str(", duration := ");
single_value->field_duration.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Duration_template::log_match(const Duration& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_unit.match(match_value.unit(), legacy)){
TTCN_Logger::log_logmatch_info(".unit");
single_value->field_unit.log_match(match_value.unit(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_duration.match(match_value.duration(), legacy)){
TTCN_Logger::log_logmatch_info(".duration");
single_value->field_duration.log_match(match_value.duration(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ unit := ");
single_value->field_unit.log_match(match_value.unit(), legacy);
TTCN_Logger::log_event_str(", duration := ");
single_value->field_duration.log_match(match_value.duration(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Duration_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_unit.encode_text(text_buf);
single_value->field_duration.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.Duration.");
}
}

void Duration_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_unit.decode_text(text_buf);
single_value->field_duration.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Duration_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.Duration.");
}
}

void Duration_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.Duration'");
    }
    if (strcmp("unit", param_field) == 0) {
      unit().set_param(param);
      return;
    } else if (strcmp("duration", param_field) == 0) {
      duration().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.Duration'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Duration_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.Duration has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) unit().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) duration().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "unit")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          unit().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "duration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          duration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.Duration: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.Duration");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Duration_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.Duration'");
    }
    if (strcmp("unit", param_field) == 0) {
      return unit().get_param(param_name);
    } else if (strcmp("duration", param_field) == 0) {
      return duration().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.Duration'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_unit = single_value->field_unit.get_param(param_name);
    mp_field_unit->set_id(new Module_Param_FieldName(mcopystr("unit")));
    mp->add_elem(mp_field_unit);
    Module_Param* mp_field_duration = single_value->field_duration.get_param(param_name);
    mp_field_duration->set_id(new Module_Param_FieldName(mcopystr("duration")));
    mp->add_elem(mp_field_duration);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Duration_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_unit.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.Duration");
single_value->field_duration.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.Duration");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.Duration");
}

boolean Duration_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Duration_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

TimeDuration::TimeDuration()
{
  bound_flag = FALSE;
}

TimeDuration::TimeDuration(const INTEGER& par_start__validity,
    const Duration& par_duration)
  :   field_start__validity(par_start__validity),
  field_duration(par_duration)
{
  bound_flag = TRUE;
}

TimeDuration::TimeDuration(const TimeDuration& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.TimeDuration.");
bound_flag = TRUE;
if (other_value.start__validity().is_bound()) field_start__validity = other_value.start__validity();
else field_start__validity.clean_up();
if (other_value.duration().is_bound()) field_duration = other_value.duration();
else field_duration.clean_up();
}

void TimeDuration::clean_up()
{
field_start__validity.clean_up();
field_duration.clean_up();
bound_flag = FALSE;
}

TimeDuration& TimeDuration::operator=(const TimeDuration& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.TimeDuration.");
  bound_flag = TRUE;
  if (other_value.start__validity().is_bound()) field_start__validity = other_value.start__validity();
  else field_start__validity.clean_up();
  if (other_value.duration().is_bound()) field_duration = other_value.duration();
  else field_duration.clean_up();
}
return *this;
}

boolean TimeDuration::operator==(const TimeDuration& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_start__validity==other_value.field_start__validity
  && field_duration==other_value.field_duration;
}

boolean TimeDuration::is_bound() const
{
if (bound_flag) return TRUE;
if(field_start__validity.is_bound()) return TRUE;
if(field_duration.is_bound()) return TRUE;
return FALSE;
}
boolean TimeDuration::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_start__validity.is_value()) return FALSE;
if(!field_duration.is_value()) return FALSE;
return TRUE;
}
int TimeDuration::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.TimeDuration");
  return 2;
}

void TimeDuration::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ start_validity := ");
field_start__validity.log();
TTCN_Logger::log_event_str(", duration := ");
field_duration.log();
TTCN_Logger::log_event_str(" }");
}

void TimeDuration::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.TimeDuration'");
    }
    if (strcmp("start_validity", param_field) == 0) {
      start__validity().set_param(param);
      return;
    } else if (strcmp("duration", param_field) == 0) {
      duration().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.TimeDuration'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.TimeDuration has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) start__validity().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) duration().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "start_validity")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          start__validity().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "duration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          duration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.TimeDuration: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.TimeDuration");
  }
}

Module_Param* TimeDuration::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.TimeDuration'");
    }
    if (strcmp("start_validity", param_field) == 0) {
      return start__validity().get_param(param_name);
    } else if (strcmp("duration", param_field) == 0) {
      return duration().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.TimeDuration'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_start__validity = field_start__validity.get_param(param_name);
  mp_field_start__validity->set_id(new Module_Param_FieldName(mcopystr("start_validity")));
  mp->add_elem(mp_field_start__validity);
  Module_Param* mp_field_duration = field_duration.get_param(param_name);
  mp_field_duration->set_id(new Module_Param_FieldName(mcopystr("duration")));
  mp->add_elem(mp_field_duration);
  return mp;
  }

void TimeDuration::set_implicit_omit()
{
if (start__validity().is_bound()) start__validity().set_implicit_omit();
if (duration().is_bound()) duration().set_implicit_omit();
}

void TimeDuration::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.TimeDuration.");
field_start__validity.encode_text(text_buf);
field_duration.encode_text(text_buf);
}

void TimeDuration::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_start__validity.decode_text(text_buf);
field_duration.decode_text(text_buf);
}

void TimeDuration::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void TimeDuration::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int TimeDuration::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_start__validity.RAW_decode(Time32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_duration.RAW_decode(Duration_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int TimeDuration::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, Time32_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, Duration_descr_.raw);
  encoded_length += field_start__validity.RAW_encode(Time32_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_duration.RAW_encode(Duration_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int TimeDuration::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.TimeDuration.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "start_validity");
    enc_len += field_start__validity.JSON_encode(Time32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "duration");
    enc_len += field_duration.JSON_encode(Duration_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int TimeDuration::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (14 == name_len && 0 == strncmp(fld_name, "start_validity", name_len)) {
         int ret_val = field_start__validity.JSON_decode(Time32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "start_validity");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "duration", name_len)) {
         int ret_val = field_duration.JSON_decode(Duration_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "duration");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_start__validity.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "start_validity");
    return JSON_ERROR_FATAL;
  }
if (!field_duration.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "duration");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct TimeDuration_template::single_value_struct {
INTEGER_template field_start__validity;
Duration_template field_duration;
};

void TimeDuration_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_start__validity = ANY_VALUE;
single_value->field_duration = ANY_VALUE;
}
}
}

void TimeDuration_template::copy_value(const TimeDuration& other_value)
{
single_value = new single_value_struct;
if (other_value.start__validity().is_bound()) {
  single_value->field_start__validity = other_value.start__validity();
} else {
  single_value->field_start__validity.clean_up();
}
if (other_value.duration().is_bound()) {
  single_value->field_duration = other_value.duration();
} else {
  single_value->field_duration.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void TimeDuration_template::copy_template(const TimeDuration_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.start__validity().get_selection()) {
single_value->field_start__validity = other_value.start__validity();
} else {
single_value->field_start__validity.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.duration().get_selection()) {
single_value->field_duration = other_value.duration();
} else {
single_value->field_duration.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TimeDuration_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TimeDuration.");
break;
}
set_selection(other_value);
}

TimeDuration_template::TimeDuration_template()
{
}

TimeDuration_template::TimeDuration_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

TimeDuration_template::TimeDuration_template(const TimeDuration& other_value)
{
copy_value(other_value);
}

TimeDuration_template::TimeDuration_template(const OPTIONAL<TimeDuration>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TimeDuration&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.TimeDuration from an unbound optional field.");
}
}

TimeDuration_template::TimeDuration_template(const TimeDuration_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

TimeDuration_template::~TimeDuration_template()
{
clean_up();
}

TimeDuration_template& TimeDuration_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TimeDuration_template& TimeDuration_template::operator=(const TimeDuration& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

TimeDuration_template& TimeDuration_template::operator=(const OPTIONAL<TimeDuration>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TimeDuration&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.TimeDuration.");
}
return *this;
}

TimeDuration_template& TimeDuration_template::operator=(const TimeDuration_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean TimeDuration_template::match(const TimeDuration& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.start__validity().is_bound()) return FALSE;
if(!single_value->field_start__validity.match(other_value.start__validity(), legacy))return FALSE;
if(!other_value.duration().is_bound()) return FALSE;
if(!single_value->field_duration.match(other_value.duration(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TimeDuration.");
}
return FALSE;
}

boolean TimeDuration_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_start__validity.is_bound()) return TRUE;
if (single_value->field_duration.is_bound()) return TRUE;
return FALSE;
}

boolean TimeDuration_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_start__validity.is_value()) return FALSE;
if (!single_value->field_duration.is_value()) return FALSE;
return TRUE;
}

void TimeDuration_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

TimeDuration TimeDuration_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.TimeDuration.");
TimeDuration ret_val;
if (single_value->field_start__validity.is_bound()) {
ret_val.start__validity() = single_value->field_start__validity.valueof();
}
if (single_value->field_duration.is_bound()) {
ret_val.duration() = single_value->field_duration.valueof();
}
return ret_val;
}

void TimeDuration_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.TimeDuration.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new TimeDuration_template[list_length];
}

TimeDuration_template& TimeDuration_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.TimeDuration.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.TimeDuration.");
return value_list.list_value[list_index];
}

INTEGER_template& TimeDuration_template::start__validity()
{
set_specific();
return single_value->field_start__validity;
}

const INTEGER_template& TimeDuration_template::start__validity() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field start_validity of a non-specific template of type @LibItsSecurity_TypesAndValues.TimeDuration.");
return single_value->field_start__validity;
}

Duration_template& TimeDuration_template::duration()
{
set_specific();
return single_value->field_duration;
}

const Duration_template& TimeDuration_template::duration() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field duration of a non-specific template of type @LibItsSecurity_TypesAndValues.TimeDuration.");
return single_value->field_duration;
}

int TimeDuration_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TimeDuration which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TimeDuration containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TimeDuration containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TimeDuration containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TimeDuration containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TimeDuration containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TimeDuration.");
  }
  return 0;
}

void TimeDuration_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ start_validity := ");
single_value->field_start__validity.log();
TTCN_Logger::log_event_str(", duration := ");
single_value->field_duration.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void TimeDuration_template::log_match(const TimeDuration& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_start__validity.match(match_value.start__validity(), legacy)){
TTCN_Logger::log_logmatch_info(".start_validity");
single_value->field_start__validity.log_match(match_value.start__validity(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_duration.match(match_value.duration(), legacy)){
TTCN_Logger::log_logmatch_info(".duration");
single_value->field_duration.log_match(match_value.duration(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ start_validity := ");
single_value->field_start__validity.log_match(match_value.start__validity(), legacy);
TTCN_Logger::log_event_str(", duration := ");
single_value->field_duration.log_match(match_value.duration(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void TimeDuration_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_start__validity.encode_text(text_buf);
single_value->field_duration.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TimeDuration.");
}
}

void TimeDuration_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_start__validity.decode_text(text_buf);
single_value->field_duration.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TimeDuration_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.TimeDuration.");
}
}

void TimeDuration_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.TimeDuration'");
    }
    if (strcmp("start_validity", param_field) == 0) {
      start__validity().set_param(param);
      return;
    } else if (strcmp("duration", param_field) == 0) {
      duration().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.TimeDuration'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TimeDuration_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.TimeDuration has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) start__validity().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) duration().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "start_validity")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          start__validity().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "duration")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          duration().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.TimeDuration: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.TimeDuration");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* TimeDuration_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.TimeDuration'");
    }
    if (strcmp("start_validity", param_field) == 0) {
      return start__validity().get_param(param_name);
    } else if (strcmp("duration", param_field) == 0) {
      return duration().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.TimeDuration'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_start__validity = single_value->field_start__validity.get_param(param_name);
    mp_field_start__validity->set_id(new Module_Param_FieldName(mcopystr("start_validity")));
    mp->add_elem(mp_field_start__validity);
    Module_Param* mp_field_duration = single_value->field_duration.get_param(param_name);
    mp_field_duration->set_id(new Module_Param_FieldName(mcopystr("duration")));
    mp->add_elem(mp_field_duration);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void TimeDuration_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_start__validity.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TimeDuration");
single_value->field_duration.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TimeDuration");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.TimeDuration");
}

boolean TimeDuration_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TimeDuration_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

RegionType::RegionType()
{
enum_value = UNBOUND_VALUE;
}

RegionType::RegionType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsSecurity_TypesAndValues.RegionType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

RegionType::RegionType(enum_type other_value)
{
enum_value = other_value;
}

RegionType::RegionType(const RegionType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
enum_value = other_value.enum_value;
}

RegionType& RegionType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.RegionType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

RegionType& RegionType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

RegionType& RegionType::operator=(const RegionType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
enum_value = other_value.enum_value;
return *this;
}

boolean RegionType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
return enum_value == other_value;
}

boolean RegionType::operator==(const RegionType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
return enum_value == other_value.enum_value;
}

boolean RegionType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
return enum_value < other_value;
}

boolean RegionType::operator<(const RegionType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
return enum_value < other_value.enum_value;
}

boolean RegionType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
return enum_value > other_value;
}

boolean RegionType::operator>(const RegionType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
return enum_value > other_value.enum_value;
}

const char *RegionType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__none: return "e_none";
case e__circle: return "e_circle";
case e__rectangle: return "e_rectangle";
case e__polygon: return "e_polygon";
case e__id: return "e_id";
default: return "<unknown>";
}
}

RegionType::enum_type RegionType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_none")) return e__none;
else if (!strcmp(str_par, "e_circle")) return e__circle;
else if (!strcmp(str_par, "e_rectangle")) return e__rectangle;
else if (!strcmp(str_par, "e_polygon")) return e__polygon;
else if (!strcmp(str_par, "e_id")) return e__id;
else return UNKNOWN_VALUE;
}

boolean RegionType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
return TRUE;
default:
return FALSE;
}
}

int RegionType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.RegionType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int RegionType::enum2int(const RegionType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.RegionType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void RegionType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.RegionType.", int_val);
enum_value = (enum_type)int_val;
}

RegionType::operator RegionType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
return enum_value;
}

void RegionType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void RegionType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsSecurity_TypesAndValues.RegionType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.RegionType.");
  }
}

Module_Param* RegionType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void RegionType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
text_buf.push_int(enum_value);
}

void RegionType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsSecurity_TypesAndValues.RegionType.", enum_value);
}

void RegionType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RegionType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int RegionType::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int RegionType::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

int RegionType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int RegionType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void RegionType_template::copy_template(const RegionType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RegionType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
}
}

RegionType_template::RegionType_template()
{
}

RegionType_template::RegionType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RegionType_template::RegionType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!RegionType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsSecurity_TypesAndValues.RegionType with unknown numeric value %d.", other_value);
single_value = (RegionType::enum_type)other_value;
}

RegionType_template::RegionType_template(RegionType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

RegionType_template::RegionType_template(const RegionType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == RegionType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
single_value = other_value.enum_value;
}

RegionType_template::RegionType_template(const OPTIONAL<RegionType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (RegionType::enum_type)(const RegionType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsSecurity_TypesAndValues.RegionType from an unbound optional field.");
}
}

RegionType_template::RegionType_template(const RegionType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

RegionType_template::~RegionType_template()
{
clean_up();
}

boolean RegionType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean RegionType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != RegionType::UNBOUND_VALUE;
}

void RegionType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

RegionType_template& RegionType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RegionType_template& RegionType_template::operator=(int other_value)
{
if (!RegionType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsSecurity_TypesAndValues.RegionType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (RegionType::enum_type)other_value;
return *this;
}

RegionType_template& RegionType_template::operator=(RegionType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

RegionType_template& RegionType_template::operator=(const RegionType& other_value)
{
if (other_value.enum_value == RegionType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

RegionType_template& RegionType_template::operator=(const OPTIONAL<RegionType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (RegionType::enum_type)(const RegionType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
}
return *this;
}

RegionType_template& RegionType_template::operator=(const RegionType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RegionType_template::match(RegionType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
}
return FALSE;
}

boolean RegionType_template::match(const RegionType& other_value, boolean) const
{
if (other_value.enum_value == RegionType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsSecurity_TypesAndValues.RegionType with an unbound value.");
return match(other_value.enum_value);
}

RegionType::enum_type RegionType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
return single_value;
}

void RegionType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RegionType_template[list_length];
}

RegionType_template& RegionType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
return value_list.list_value[list_index];
}

void RegionType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(RegionType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RegionType_template::log_match(const RegionType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void RegionType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
}
}

void RegionType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (RegionType::enum_type)text_buf.pull_int().get_val();
if (!RegionType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsSecurity_TypesAndValues.RegionType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RegionType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsSecurity_TypesAndValues.RegionType.");
}
}

boolean RegionType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RegionType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void RegionType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    RegionType::enum_type enum_val = (enum_name != NULL) ? RegionType::str_to_enum(enum_name) : RegionType::UNKNOWN_VALUE;
    if (RegionType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RegionType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    RegionType::enum_type enum_val = RegionType::str_to_enum(mp->get_enumerated());
    if (!RegionType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.RegionType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsSecurity_TypesAndValues.RegionType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RegionType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(RegionType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RegionType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.RegionType");
}

GeographicRegion::GeographicRegion()
{
  bound_flag = FALSE;
}

GeographicRegion::GeographicRegion(const RegionType& par_region__type,
    const OPTIONAL<GeographicRegionContainer>& par_region)
  :   field_region__type(par_region__type),
  field_region(par_region)
{
  bound_flag = TRUE;
}

GeographicRegion::GeographicRegion(const GeographicRegion& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.GeographicRegion.");
bound_flag = TRUE;
if (other_value.region__type().is_bound()) field_region__type = other_value.region__type();
else field_region__type.clean_up();
if (other_value.region().is_bound()) field_region = other_value.region();
else field_region.clean_up();
}

void GeographicRegion::clean_up()
{
field_region__type.clean_up();
field_region.clean_up();
bound_flag = FALSE;
}

GeographicRegion& GeographicRegion::operator=(const GeographicRegion& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.GeographicRegion.");
  bound_flag = TRUE;
  if (other_value.region__type().is_bound()) field_region__type = other_value.region__type();
  else field_region__type.clean_up();
  if (other_value.region().is_bound()) field_region = other_value.region();
  else field_region.clean_up();
}
return *this;
}

boolean GeographicRegion::operator==(const GeographicRegion& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_region__type==other_value.field_region__type
  && field_region==other_value.field_region;
}

boolean GeographicRegion::is_bound() const
{
if (bound_flag) return TRUE;
if(field_region__type.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_region.get_selection() || field_region.is_bound()) return TRUE;
return FALSE;
}
boolean GeographicRegion::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_region__type.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_region.get_selection() && !field_region.is_value()) return FALSE;
return TRUE;
}
int GeographicRegion::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.GeographicRegion");
  int ret_val = 1;
  if (field_region.ispresent()) ret_val++;
  return ret_val;
}

void GeographicRegion::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ region_type := ");
field_region__type.log();
TTCN_Logger::log_event_str(", region := ");
field_region.log();
TTCN_Logger::log_event_str(" }");
}

void GeographicRegion::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.GeographicRegion'");
    }
    if (strcmp("region_type", param_field) == 0) {
      region__type().set_param(param);
      return;
    } else if (strcmp("region", param_field) == 0) {
      region().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.GeographicRegion'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.GeographicRegion has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) region__type().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) region().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "region_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          region__type().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "region")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          region().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.GeographicRegion: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.GeographicRegion");
  }
}

Module_Param* GeographicRegion::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.GeographicRegion'");
    }
    if (strcmp("region_type", param_field) == 0) {
      return region__type().get_param(param_name);
    } else if (strcmp("region", param_field) == 0) {
      return region().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.GeographicRegion'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_region__type = field_region__type.get_param(param_name);
  mp_field_region__type->set_id(new Module_Param_FieldName(mcopystr("region_type")));
  mp->add_elem(mp_field_region__type);
  Module_Param* mp_field_region = field_region.get_param(param_name);
  mp_field_region->set_id(new Module_Param_FieldName(mcopystr("region")));
  mp->add_elem(mp_field_region);
  return mp;
  }

void GeographicRegion::set_implicit_omit()
{
if (region__type().is_bound()) region__type().set_implicit_omit();
if (!region().is_bound()) region() = OMIT_VALUE;
else region().set_implicit_omit();
}

void GeographicRegion::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.GeographicRegion.");
field_region__type.encode_text(text_buf);
field_region.encode_text(text_buf);
}

void GeographicRegion::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_region__type.decode_text(text_buf);
field_region.decode_text(text_buf);
}

void GeographicRegion::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GeographicRegion::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GeographicRegion::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_region__type.RAW_decode(RegionType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_region().RAW_decode(GeographicRegionContainer_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_region = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_region=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int GeographicRegion::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, RegionType_descr_.raw);
  if (field_region.ispresent()) {
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, GeographicRegionContainer_descr_.raw);
  }
  else myleaf.body.node.nodes[1] = NULL;
  encoded_length += field_region__type.RAW_encode(RegionType_descr_, *myleaf.body.node.nodes[0]);
  if (field_region.ispresent()) {
  encoded_length += field_region().RAW_encode(GeographicRegionContainer_descr_, *myleaf.body.node.nodes[1]);
  }
  return myleaf.length = encoded_length;
}

int GeographicRegion::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.GeographicRegion.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "region_type");
    enc_len += field_region__type.JSON_encode(RegionType_descr_, p_tok);
  }

  if (field_region.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "region");
    enc_len += field_region.JSON_encode(GeographicRegionContainer_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GeographicRegion::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (11 == name_len && 0 == strncmp(fld_name, "region_type", name_len)) {
         int ret_val = field_region__type.JSON_decode(RegionType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "region_type");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "region", name_len)) {
         int ret_val = field_region.JSON_decode(GeographicRegionContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "region");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_region__type.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "region_type");
    return JSON_ERROR_FATAL;
  }
if (!field_region.is_bound()) {
    field_region = OMIT_VALUE;
  }

  return dec_len;
}

struct GeographicRegion_template::single_value_struct {
RegionType_template field_region__type;
GeographicRegionContainer_template field_region;
};

void GeographicRegion_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_region__type = ANY_VALUE;
single_value->field_region = ANY_OR_OMIT;
}
}
}

void GeographicRegion_template::copy_value(const GeographicRegion& other_value)
{
single_value = new single_value_struct;
if (other_value.region__type().is_bound()) {
  single_value->field_region__type = other_value.region__type();
} else {
  single_value->field_region__type.clean_up();
}
if (other_value.region().is_bound()) {
  if (other_value.region().ispresent()) single_value->field_region = other_value.region()();
  else single_value->field_region = OMIT_VALUE;
} else {
  single_value->field_region.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void GeographicRegion_template::copy_template(const GeographicRegion_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.region__type().get_selection()) {
single_value->field_region__type = other_value.region__type();
} else {
single_value->field_region__type.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.region().get_selection()) {
single_value->field_region = other_value.region();
} else {
single_value->field_region.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GeographicRegion_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.GeographicRegion.");
break;
}
set_selection(other_value);
}

GeographicRegion_template::GeographicRegion_template()
{
}

GeographicRegion_template::GeographicRegion_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GeographicRegion_template::GeographicRegion_template(const GeographicRegion& other_value)
{
copy_value(other_value);
}

GeographicRegion_template::GeographicRegion_template(const OPTIONAL<GeographicRegion>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeographicRegion&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.GeographicRegion from an unbound optional field.");
}
}

GeographicRegion_template::GeographicRegion_template(const GeographicRegion_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

GeographicRegion_template::~GeographicRegion_template()
{
clean_up();
}

GeographicRegion_template& GeographicRegion_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GeographicRegion_template& GeographicRegion_template::operator=(const GeographicRegion& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GeographicRegion_template& GeographicRegion_template::operator=(const OPTIONAL<GeographicRegion>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeographicRegion&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.GeographicRegion.");
}
return *this;
}

GeographicRegion_template& GeographicRegion_template::operator=(const GeographicRegion_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GeographicRegion_template::match(const GeographicRegion& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.region__type().is_bound()) return FALSE;
if(!single_value->field_region__type.match(other_value.region__type(), legacy))return FALSE;
if(!other_value.region().is_bound()) return FALSE;
if((other_value.region().ispresent() ? !single_value->field_region.match((const GeographicRegionContainer&)other_value.region(), legacy) : !single_value->field_region.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.GeographicRegion.");
}
return FALSE;
}

boolean GeographicRegion_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_region__type.is_bound()) return TRUE;
if (single_value->field_region.is_omit() || single_value->field_region.is_bound()) return TRUE;
return FALSE;
}

boolean GeographicRegion_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_region__type.is_value()) return FALSE;
if (!single_value->field_region.is_omit() && !single_value->field_region.is_value()) return FALSE;
return TRUE;
}

void GeographicRegion_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GeographicRegion GeographicRegion_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.GeographicRegion.");
GeographicRegion ret_val;
if (single_value->field_region__type.is_bound()) {
ret_val.region__type() = single_value->field_region__type.valueof();
}
if (single_value->field_region.is_omit()) ret_val.region() = OMIT_VALUE;
else if (single_value->field_region.is_bound()) {
ret_val.region() = single_value->field_region.valueof();
}
return ret_val;
}

void GeographicRegion_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.GeographicRegion.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GeographicRegion_template[list_length];
}

GeographicRegion_template& GeographicRegion_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.GeographicRegion.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.GeographicRegion.");
return value_list.list_value[list_index];
}

RegionType_template& GeographicRegion_template::region__type()
{
set_specific();
return single_value->field_region__type;
}

const RegionType_template& GeographicRegion_template::region__type() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field region_type of a non-specific template of type @LibItsSecurity_TypesAndValues.GeographicRegion.");
return single_value->field_region__type;
}

GeographicRegionContainer_template& GeographicRegion_template::region()
{
set_specific();
return single_value->field_region;
}

const GeographicRegionContainer_template& GeographicRegion_template::region() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field region of a non-specific template of type @LibItsSecurity_TypesAndValues.GeographicRegion.");
return single_value->field_region;
}

int GeographicRegion_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.GeographicRegion which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_region.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.GeographicRegion containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.GeographicRegion containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.GeographicRegion containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.GeographicRegion containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.GeographicRegion containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.GeographicRegion.");
  }
  return 0;
}

void GeographicRegion_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ region_type := ");
single_value->field_region__type.log();
TTCN_Logger::log_event_str(", region := ");
single_value->field_region.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GeographicRegion_template::log_match(const GeographicRegion& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_region__type.match(match_value.region__type(), legacy)){
TTCN_Logger::log_logmatch_info(".region_type");
single_value->field_region__type.log_match(match_value.region__type(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.region().ispresent()){
if(!single_value->field_region.match(match_value.region(), legacy)){
TTCN_Logger::log_logmatch_info(".region");
single_value->field_region.log_match(match_value.region(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_region.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".region := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_region.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ region_type := ");
single_value->field_region__type.log_match(match_value.region__type(), legacy);
TTCN_Logger::log_event_str(", region := ");
if (match_value.region().ispresent()) single_value->field_region.log_match(match_value.region(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_region.log();
if (single_value->field_region.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GeographicRegion_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_region__type.encode_text(text_buf);
single_value->field_region.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.GeographicRegion.");
}
}

void GeographicRegion_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_region__type.decode_text(text_buf);
single_value->field_region.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GeographicRegion_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.GeographicRegion.");
}
}

void GeographicRegion_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.GeographicRegion'");
    }
    if (strcmp("region_type", param_field) == 0) {
      region__type().set_param(param);
      return;
    } else if (strcmp("region", param_field) == 0) {
      region().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.GeographicRegion'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GeographicRegion_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.GeographicRegion has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) region__type().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) region().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "region_type")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          region__type().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "region")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          region().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.GeographicRegion: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.GeographicRegion");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GeographicRegion_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.GeographicRegion'");
    }
    if (strcmp("region_type", param_field) == 0) {
      return region__type().get_param(param_name);
    } else if (strcmp("region", param_field) == 0) {
      return region().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.GeographicRegion'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_region__type = single_value->field_region__type.get_param(param_name);
    mp_field_region__type->set_id(new Module_Param_FieldName(mcopystr("region_type")));
    mp->add_elem(mp_field_region__type);
    Module_Param* mp_field_region = single_value->field_region.get_param(param_name);
    mp_field_region->set_id(new Module_Param_FieldName(mcopystr("region")));
    mp->add_elem(mp_field_region);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GeographicRegion_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_region__type.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.GeographicRegion");
single_value->field_region.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.GeographicRegion");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.GeographicRegion");
}

boolean GeographicRegion_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GeographicRegion_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GeographicRegionContainer::copy_value(const GeographicRegionContainer& other_value)
{
switch (other_value.union_selection) {
case ALT_circular__region:
field_circular__region = new CircularRegion(*other_value.field_circular__region);
break;
case ALT_rectangular__region:
field_rectangular__region = new RectangularRegions(*other_value.field_rectangular__region);
break;
case ALT_polygonal__region:
field_polygonal__region = new PolygonalRegion(*other_value.field_polygonal__region);
break;
case ALT_id__region:
field_id__region = new IdentifiedRegion(*other_value.field_id__region);
break;
case ALT_other__region:
field_other__region = new OCTETSTRING(*other_value.field_other__region);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
}
union_selection = other_value.union_selection;
}

GeographicRegionContainer::GeographicRegionContainer()
{
union_selection = UNBOUND_VALUE;
}

GeographicRegionContainer::GeographicRegionContainer(const GeographicRegionContainer& other_value)
: Base_Type(){
copy_value(other_value);
}

GeographicRegionContainer::~GeographicRegionContainer()
{
clean_up();
}

GeographicRegionContainer& GeographicRegionContainer::operator=(const GeographicRegionContainer& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean GeographicRegionContainer::operator==(const GeographicRegionContainer& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_circular__region:
return *field_circular__region == *other_value.field_circular__region;
case ALT_rectangular__region:
return *field_rectangular__region == *other_value.field_rectangular__region;
case ALT_polygonal__region:
return *field_polygonal__region == *other_value.field_polygonal__region;
case ALT_id__region:
return *field_id__region == *other_value.field_id__region;
case ALT_other__region:
return *field_other__region == *other_value.field_other__region;
default:
return FALSE;
}
}

CircularRegion& GeographicRegionContainer::circular__region()
{
if (union_selection != ALT_circular__region) {
clean_up();
field_circular__region = new CircularRegion;
union_selection = ALT_circular__region;
}
return *field_circular__region;
}

const CircularRegion& GeographicRegionContainer::circular__region() const
{
if (union_selection != ALT_circular__region) TTCN_error("Using non-selected field circular_region in a value of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
return *field_circular__region;
}

RectangularRegions& GeographicRegionContainer::rectangular__region()
{
if (union_selection != ALT_rectangular__region) {
clean_up();
field_rectangular__region = new RectangularRegions;
union_selection = ALT_rectangular__region;
}
return *field_rectangular__region;
}

const RectangularRegions& GeographicRegionContainer::rectangular__region() const
{
if (union_selection != ALT_rectangular__region) TTCN_error("Using non-selected field rectangular_region in a value of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
return *field_rectangular__region;
}

PolygonalRegion& GeographicRegionContainer::polygonal__region()
{
if (union_selection != ALT_polygonal__region) {
clean_up();
field_polygonal__region = new PolygonalRegion;
union_selection = ALT_polygonal__region;
}
return *field_polygonal__region;
}

const PolygonalRegion& GeographicRegionContainer::polygonal__region() const
{
if (union_selection != ALT_polygonal__region) TTCN_error("Using non-selected field polygonal_region in a value of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
return *field_polygonal__region;
}

IdentifiedRegion& GeographicRegionContainer::id__region()
{
if (union_selection != ALT_id__region) {
clean_up();
field_id__region = new IdentifiedRegion;
union_selection = ALT_id__region;
}
return *field_id__region;
}

const IdentifiedRegion& GeographicRegionContainer::id__region() const
{
if (union_selection != ALT_id__region) TTCN_error("Using non-selected field id_region in a value of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
return *field_id__region;
}

OCTETSTRING& GeographicRegionContainer::other__region()
{
if (union_selection != ALT_other__region) {
clean_up();
field_other__region = new OCTETSTRING;
union_selection = ALT_other__region;
}
return *field_other__region;
}

const OCTETSTRING& GeographicRegionContainer::other__region() const
{
if (union_selection != ALT_other__region) TTCN_error("Using non-selected field other_region in a value of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
return *field_other__region;
}

boolean GeographicRegionContainer::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
return union_selection == checked_selection;
}

boolean GeographicRegionContainer::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean GeographicRegionContainer::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_circular__region: return field_circular__region->is_value();
case ALT_rectangular__region: return field_rectangular__region->is_value();
case ALT_polygonal__region: return field_polygonal__region->is_value();
case ALT_id__region: return field_id__region->is_value();
case ALT_other__region: return field_other__region->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void GeographicRegionContainer::clean_up()
{
switch (union_selection) {
case ALT_circular__region:
  delete field_circular__region;
  break;
case ALT_rectangular__region:
  delete field_rectangular__region;
  break;
case ALT_polygonal__region:
  delete field_polygonal__region;
  break;
case ALT_id__region:
  delete field_id__region;
  break;
case ALT_other__region:
  delete field_other__region;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void GeographicRegionContainer::log() const
{
switch (union_selection) {
case ALT_circular__region:
TTCN_Logger::log_event_str("{ circular_region := ");
field_circular__region->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_rectangular__region:
TTCN_Logger::log_event_str("{ rectangular_region := ");
field_rectangular__region->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_polygonal__region:
TTCN_Logger::log_event_str("{ polygonal_region := ");
field_polygonal__region->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_id__region:
TTCN_Logger::log_event_str("{ id_region := ");
field_id__region->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_other__region:
TTCN_Logger::log_event_str("{ other_region := ");
field_other__region->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void GeographicRegionContainer::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsSecurity_TypesAndValues.GeographicRegionContainer'");
    }
    if (strcmp("circular_region", param_field) == 0) {
      circular__region().set_param(param);
      return;
    } else if (strcmp("rectangular_region", param_field) == 0) {
      rectangular__region().set_param(param);
      return;
    } else if (strcmp("polygonal_region", param_field) == 0) {
      polygonal__region().set_param(param);
      return;
    } else if (strcmp("id_region", param_field) == 0) {
      id__region().set_param(param);
      return;
    } else if (strcmp("other_region", param_field) == 0) {
      other__region().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsSecurity_TypesAndValues.GeographicRegionContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "circular_region")) {
    circular__region().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "rectangular_region")) {
    rectangular__region().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "polygonal_region")) {
    polygonal__region().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "id_region")) {
    id__region().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "other_region")) {
    other__region().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.", mp_last->get_id()->get_name());
}

Module_Param* GeographicRegionContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsSecurity_TypesAndValues.GeographicRegionContainer'");
    }
    if (strcmp("circular_region", param_field) == 0) {
      return circular__region().get_param(param_name);
    } else if (strcmp("rectangular_region", param_field) == 0) {
      return rectangular__region().get_param(param_name);
    } else if (strcmp("polygonal_region", param_field) == 0) {
      return polygonal__region().get_param(param_name);
    } else if (strcmp("id_region", param_field) == 0) {
      return id__region().get_param(param_name);
    } else if (strcmp("other_region", param_field) == 0) {
      return other__region().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `GeographicRegionContainer'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_circular__region:
    mp_field = field_circular__region->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("circular_region")));
    break;
  case ALT_rectangular__region:
    mp_field = field_rectangular__region->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("rectangular_region")));
    break;
  case ALT_polygonal__region:
    mp_field = field_polygonal__region->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("polygonal_region")));
    break;
  case ALT_id__region:
    mp_field = field_id__region->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("id_region")));
    break;
  case ALT_other__region:
    mp_field = field_other__region->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("other_region")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void GeographicRegionContainer::set_implicit_omit()
{
switch (union_selection) {
case ALT_circular__region:
field_circular__region->set_implicit_omit(); break;
case ALT_rectangular__region:
field_rectangular__region->set_implicit_omit(); break;
case ALT_polygonal__region:
field_polygonal__region->set_implicit_omit(); break;
case ALT_id__region:
field_id__region->set_implicit_omit(); break;
case ALT_other__region:
field_other__region->set_implicit_omit(); break;
default: break;
}
}

void GeographicRegionContainer::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_circular__region:
field_circular__region->encode_text(text_buf);
break;
case ALT_rectangular__region:
field_rectangular__region->encode_text(text_buf);
break;
case ALT_polygonal__region:
field_polygonal__region->encode_text(text_buf);
break;
case ALT_id__region:
field_id__region->encode_text(text_buf);
break;
case ALT_other__region:
field_other__region->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
}
}

void GeographicRegionContainer::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_circular__region:
circular__region().decode_text(text_buf);
break;
case ALT_rectangular__region:
rectangular__region().decode_text(text_buf);
break;
case ALT_polygonal__region:
polygonal__region().decode_text(text_buf);
break;
case ALT_id__region:
id__region().decode_text(text_buf);
break;
case ALT_other__region:
other__region().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
}
}

void GeographicRegionContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void GeographicRegionContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int GeographicRegionContainer::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = circular__region().RAW_decode(CircularRegion_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = rectangular__region().RAW_decode(RectangularRegions_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 2:
      decoded_length = polygonal__region().RAW_decode(PolygonalRegion_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 3:
      decoded_length = id__region().RAW_decode(IdentifiedRegion_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 4:
      decoded_length = other__region().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = circular__region().RAW_decode(CircularRegion_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = rectangular__region().RAW_decode(RectangularRegions_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = polygonal__region().RAW_decode(PolygonalRegion_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = id__region().RAW_decode(IdentifiedRegion_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = other__region().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int GeographicRegionContainer::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 5;  myleaf.body.node.nodes = init_nodes_of_enc_tree(5);
  memset(myleaf.body.node.nodes, 0, 5 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_circular__region:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, CircularRegion_descr_.raw);
    encoded_length = field_circular__region->RAW_encode(CircularRegion_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &CircularRegion_descr_;
    break;
  case ALT_rectangular__region:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, RectangularRegions_descr_.raw);
    encoded_length = field_rectangular__region->RAW_encode(RectangularRegions_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &RectangularRegions_descr_;
    break;
  case ALT_polygonal__region:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, PolygonalRegion_descr_.raw);
    encoded_length = field_polygonal__region->RAW_encode(PolygonalRegion_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &PolygonalRegion_descr_;
    break;
  case ALT_id__region:
    myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 3, IdentifiedRegion_descr_.raw);
    encoded_length = field_id__region->RAW_encode(IdentifiedRegion_descr_, *myleaf.body.node.nodes[3]);
    myleaf.body.node.nodes[3]->coding_descr = &IdentifiedRegion_descr_;
    break;
  case ALT_other__region:
    myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 4, OCTETSTRING_descr_.raw);
    encoded_length = field_other__region->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[4]);
    myleaf.body.node.nodes[4]->coding_descr = &OCTETSTRING_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int GeographicRegionContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_circular__region:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "circular_region");
    enc_len += field_circular__region->JSON_encode(CircularRegion_descr_, p_tok);
    break;
  case ALT_rectangular__region:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "rectangular_region");
    enc_len += field_rectangular__region->JSON_encode(RectangularRegions_descr_, p_tok);
    break;
  case ALT_polygonal__region:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "polygonal_region");
    enc_len += field_polygonal__region->JSON_encode(PolygonalRegion_descr_, p_tok);
    break;
  case ALT_id__region:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "id_region");
    enc_len += field_id__region->JSON_encode(IdentifiedRegion_descr_, p_tok);
    break;
  case ALT_other__region:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "other_region");
    enc_len += field_other__region->JSON_encode(OCTETSTRING_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int GeographicRegionContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "circular_region", name_len)) {
      int ret_val = circular__region().JSON_decode(CircularRegion_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "circular_region");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "rectangular_region", name_len)) {
      int ret_val = rectangular__region().JSON_decode(RectangularRegions_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "rectangular_region");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "polygonal_region", name_len)) {
      int ret_val = polygonal__region().JSON_decode(PolygonalRegion_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "polygonal_region");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "id_region", name_len)) {
      int ret_val = id__region().JSON_decode(IdentifiedRegion_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "id_region");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "other_region", name_len)) {
      int ret_val = other__region().JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "other_region");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void GeographicRegionContainer_template::copy_value(const GeographicRegionContainer& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case GeographicRegionContainer::ALT_circular__region:
single_value.field_circular__region = new CircularRegion_template(other_value.circular__region());
break;
case GeographicRegionContainer::ALT_rectangular__region:
single_value.field_rectangular__region = new RectangularRegions_template(other_value.rectangular__region());
break;
case GeographicRegionContainer::ALT_polygonal__region:
single_value.field_polygonal__region = new PolygonalRegion_template(other_value.polygonal__region());
break;
case GeographicRegionContainer::ALT_id__region:
single_value.field_id__region = new IdentifiedRegion_template(other_value.id__region());
break;
case GeographicRegionContainer::ALT_other__region:
single_value.field_other__region = new OCTETSTRING_template(other_value.other__region());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
}
set_selection(SPECIFIC_VALUE);
}

void GeographicRegionContainer_template::copy_template(const GeographicRegionContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case GeographicRegionContainer::ALT_circular__region:
single_value.field_circular__region = new CircularRegion_template(*other_value.single_value.field_circular__region);
break;
case GeographicRegionContainer::ALT_rectangular__region:
single_value.field_rectangular__region = new RectangularRegions_template(*other_value.single_value.field_rectangular__region);
break;
case GeographicRegionContainer::ALT_polygonal__region:
single_value.field_polygonal__region = new PolygonalRegion_template(*other_value.single_value.field_polygonal__region);
break;
case GeographicRegionContainer::ALT_id__region:
single_value.field_id__region = new IdentifiedRegion_template(*other_value.single_value.field_id__region);
break;
case GeographicRegionContainer::ALT_other__region:
single_value.field_other__region = new OCTETSTRING_template(*other_value.single_value.field_other__region);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new GeographicRegionContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
}
set_selection(other_value);
}

GeographicRegionContainer_template::GeographicRegionContainer_template()
{
}

GeographicRegionContainer_template::GeographicRegionContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

GeographicRegionContainer_template::GeographicRegionContainer_template(const GeographicRegionContainer& other_value)
{
copy_value(other_value);
}

GeographicRegionContainer_template::GeographicRegionContainer_template(const OPTIONAL<GeographicRegionContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeographicRegionContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer from an unbound optional field.");
}
}

GeographicRegionContainer_template::GeographicRegionContainer_template(const GeographicRegionContainer_template& other_value)
: Base_Template(){
copy_template(other_value);
}

GeographicRegionContainer_template::~GeographicRegionContainer_template()
{
clean_up();
}

void GeographicRegionContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case GeographicRegionContainer::ALT_circular__region:
delete single_value.field_circular__region;
break;
case GeographicRegionContainer::ALT_rectangular__region:
delete single_value.field_rectangular__region;
break;
case GeographicRegionContainer::ALT_polygonal__region:
delete single_value.field_polygonal__region;
break;
case GeographicRegionContainer::ALT_id__region:
delete single_value.field_id__region;
break;
case GeographicRegionContainer::ALT_other__region:
delete single_value.field_other__region;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

GeographicRegionContainer_template& GeographicRegionContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

GeographicRegionContainer_template& GeographicRegionContainer_template::operator=(const GeographicRegionContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

GeographicRegionContainer_template& GeographicRegionContainer_template::operator=(const OPTIONAL<GeographicRegionContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const GeographicRegionContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
}
return *this;
}

GeographicRegionContainer_template& GeographicRegionContainer_template::operator=(const GeographicRegionContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean GeographicRegionContainer_template::match(const GeographicRegionContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
GeographicRegionContainer::union_selection_type value_selection = other_value.get_selection();
if (value_selection == GeographicRegionContainer::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case GeographicRegionContainer::ALT_circular__region:
return single_value.field_circular__region->match(other_value.circular__region(), legacy);
case GeographicRegionContainer::ALT_rectangular__region:
return single_value.field_rectangular__region->match(other_value.rectangular__region(), legacy);
case GeographicRegionContainer::ALT_polygonal__region:
return single_value.field_polygonal__region->match(other_value.polygonal__region(), legacy);
case GeographicRegionContainer::ALT_id__region:
return single_value.field_id__region->match(other_value.id__region(), legacy);
case GeographicRegionContainer::ALT_other__region:
return single_value.field_other__region->match(other_value.other__region(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
}
return FALSE;
}

boolean GeographicRegionContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case GeographicRegionContainer::ALT_circular__region:
return single_value.field_circular__region->is_value();
case GeographicRegionContainer::ALT_rectangular__region:
return single_value.field_rectangular__region->is_value();
case GeographicRegionContainer::ALT_polygonal__region:
return single_value.field_polygonal__region->is_value();
case GeographicRegionContainer::ALT_id__region:
return single_value.field_id__region->is_value();
case GeographicRegionContainer::ALT_other__region:
return single_value.field_other__region->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
}
}

GeographicRegionContainer GeographicRegionContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
GeographicRegionContainer ret_val;
switch (single_value.union_selection) {
case GeographicRegionContainer::ALT_circular__region:
ret_val.circular__region() = single_value.field_circular__region->valueof();
break;
case GeographicRegionContainer::ALT_rectangular__region:
ret_val.rectangular__region() = single_value.field_rectangular__region->valueof();
break;
case GeographicRegionContainer::ALT_polygonal__region:
ret_val.polygonal__region() = single_value.field_polygonal__region->valueof();
break;
case GeographicRegionContainer::ALT_id__region:
ret_val.id__region() = single_value.field_id__region->valueof();
break;
case GeographicRegionContainer::ALT_other__region:
ret_val.other__region() = single_value.field_other__region->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
}
return ret_val;
}

GeographicRegionContainer_template& GeographicRegionContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
return value_list.list_value[list_index];
}
void GeographicRegionContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new GeographicRegionContainer_template[list_length];
}

CircularRegion_template& GeographicRegionContainer_template::circular__region()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != GeographicRegionContainer::ALT_circular__region) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_circular__region = new CircularRegion_template(ANY_VALUE);
else single_value.field_circular__region = new CircularRegion_template;
single_value.union_selection = GeographicRegionContainer::ALT_circular__region;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_circular__region;
}

const CircularRegion_template& GeographicRegionContainer_template::circular__region() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field circular_region in a non-specific template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
if (single_value.union_selection != GeographicRegionContainer::ALT_circular__region) TTCN_error("Accessing non-selected field circular_region in a template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
return *single_value.field_circular__region;
}

RectangularRegions_template& GeographicRegionContainer_template::rectangular__region()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != GeographicRegionContainer::ALT_rectangular__region) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_rectangular__region = new RectangularRegions_template(ANY_VALUE);
else single_value.field_rectangular__region = new RectangularRegions_template;
single_value.union_selection = GeographicRegionContainer::ALT_rectangular__region;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_rectangular__region;
}

const RectangularRegions_template& GeographicRegionContainer_template::rectangular__region() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field rectangular_region in a non-specific template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
if (single_value.union_selection != GeographicRegionContainer::ALT_rectangular__region) TTCN_error("Accessing non-selected field rectangular_region in a template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
return *single_value.field_rectangular__region;
}

PolygonalRegion_template& GeographicRegionContainer_template::polygonal__region()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != GeographicRegionContainer::ALT_polygonal__region) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_polygonal__region = new PolygonalRegion_template(ANY_VALUE);
else single_value.field_polygonal__region = new PolygonalRegion_template;
single_value.union_selection = GeographicRegionContainer::ALT_polygonal__region;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_polygonal__region;
}

const PolygonalRegion_template& GeographicRegionContainer_template::polygonal__region() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field polygonal_region in a non-specific template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
if (single_value.union_selection != GeographicRegionContainer::ALT_polygonal__region) TTCN_error("Accessing non-selected field polygonal_region in a template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
return *single_value.field_polygonal__region;
}

IdentifiedRegion_template& GeographicRegionContainer_template::id__region()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != GeographicRegionContainer::ALT_id__region) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_id__region = new IdentifiedRegion_template(ANY_VALUE);
else single_value.field_id__region = new IdentifiedRegion_template;
single_value.union_selection = GeographicRegionContainer::ALT_id__region;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_id__region;
}

const IdentifiedRegion_template& GeographicRegionContainer_template::id__region() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field id_region in a non-specific template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
if (single_value.union_selection != GeographicRegionContainer::ALT_id__region) TTCN_error("Accessing non-selected field id_region in a template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
return *single_value.field_id__region;
}

OCTETSTRING_template& GeographicRegionContainer_template::other__region()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != GeographicRegionContainer::ALT_other__region) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_other__region = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_other__region = new OCTETSTRING_template;
single_value.union_selection = GeographicRegionContainer::ALT_other__region;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_other__region;
}

const OCTETSTRING_template& GeographicRegionContainer_template::other__region() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field other_region in a non-specific template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
if (single_value.union_selection != GeographicRegionContainer::ALT_other__region) TTCN_error("Accessing non-selected field other_region in a template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
return *single_value.field_other__region;
}

boolean GeographicRegionContainer_template::ischosen(GeographicRegionContainer::union_selection_type checked_selection) const
{
if (checked_selection == GeographicRegionContainer::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == GeographicRegionContainer::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer");
}
return FALSE;
}

void GeographicRegionContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case GeographicRegionContainer::ALT_circular__region:
TTCN_Logger::log_event_str("{ circular_region := ");
single_value.field_circular__region->log();
TTCN_Logger::log_event_str(" }");
break;
case GeographicRegionContainer::ALT_rectangular__region:
TTCN_Logger::log_event_str("{ rectangular_region := ");
single_value.field_rectangular__region->log();
TTCN_Logger::log_event_str(" }");
break;
case GeographicRegionContainer::ALT_polygonal__region:
TTCN_Logger::log_event_str("{ polygonal_region := ");
single_value.field_polygonal__region->log();
TTCN_Logger::log_event_str(" }");
break;
case GeographicRegionContainer::ALT_id__region:
TTCN_Logger::log_event_str("{ id_region := ");
single_value.field_id__region->log();
TTCN_Logger::log_event_str(" }");
break;
case GeographicRegionContainer::ALT_other__region:
TTCN_Logger::log_event_str("{ other_region := ");
single_value.field_other__region->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void GeographicRegionContainer_template::log_match(const GeographicRegionContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case GeographicRegionContainer::ALT_circular__region:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".circular_region");
single_value.field_circular__region->log_match(match_value.circular__region(), legacy);
} else {
TTCN_Logger::log_event_str("{ circular_region := ");
single_value.field_circular__region->log_match(match_value.circular__region(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case GeographicRegionContainer::ALT_rectangular__region:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".rectangular_region");
single_value.field_rectangular__region->log_match(match_value.rectangular__region(), legacy);
} else {
TTCN_Logger::log_event_str("{ rectangular_region := ");
single_value.field_rectangular__region->log_match(match_value.rectangular__region(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case GeographicRegionContainer::ALT_polygonal__region:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".polygonal_region");
single_value.field_polygonal__region->log_match(match_value.polygonal__region(), legacy);
} else {
TTCN_Logger::log_event_str("{ polygonal_region := ");
single_value.field_polygonal__region->log_match(match_value.polygonal__region(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case GeographicRegionContainer::ALT_id__region:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".id_region");
single_value.field_id__region->log_match(match_value.id__region(), legacy);
} else {
TTCN_Logger::log_event_str("{ id_region := ");
single_value.field_id__region->log_match(match_value.id__region(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case GeographicRegionContainer::ALT_other__region:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".other_region");
single_value.field_other__region->log_match(match_value.other__region(), legacy);
} else {
TTCN_Logger::log_event_str("{ other_region := ");
single_value.field_other__region->log_match(match_value.other__region(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void GeographicRegionContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case GeographicRegionContainer::ALT_circular__region:
single_value.field_circular__region->encode_text(text_buf);
break;
case GeographicRegionContainer::ALT_rectangular__region:
single_value.field_rectangular__region->encode_text(text_buf);
break;
case GeographicRegionContainer::ALT_polygonal__region:
single_value.field_polygonal__region->encode_text(text_buf);
break;
case GeographicRegionContainer::ALT_id__region:
single_value.field_id__region->encode_text(text_buf);
break;
case GeographicRegionContainer::ALT_other__region:
single_value.field_other__region->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
}
}

void GeographicRegionContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = GeographicRegionContainer::UNBOUND_VALUE;
GeographicRegionContainer::union_selection_type new_selection = (GeographicRegionContainer::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case GeographicRegionContainer::ALT_circular__region:
single_value.field_circular__region = new CircularRegion_template;
single_value.field_circular__region->decode_text(text_buf);
break;
case GeographicRegionContainer::ALT_rectangular__region:
single_value.field_rectangular__region = new RectangularRegions_template;
single_value.field_rectangular__region->decode_text(text_buf);
break;
case GeographicRegionContainer::ALT_polygonal__region:
single_value.field_polygonal__region = new PolygonalRegion_template;
single_value.field_polygonal__region->decode_text(text_buf);
break;
case GeographicRegionContainer::ALT_id__region:
single_value.field_id__region = new IdentifiedRegion_template;
single_value.field_id__region->decode_text(text_buf);
break;
case GeographicRegionContainer::ALT_other__region:
single_value.field_other__region = new OCTETSTRING_template;
single_value.field_other__region->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new GeographicRegionContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
}
}

boolean GeographicRegionContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean GeographicRegionContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void GeographicRegionContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsSecurity_TypesAndValues.GeographicRegionContainer'");
    }
    if (strcmp("circular_region", param_field) == 0) {
      circular__region().set_param(param);
      return;
    } else if (strcmp("rectangular_region", param_field) == 0) {
      rectangular__region().set_param(param);
      return;
    } else if (strcmp("polygonal_region", param_field) == 0) {
      polygonal__region().set_param(param);
      return;
    } else if (strcmp("id_region", param_field) == 0) {
      id__region().set_param(param);
      return;
    } else if (strcmp("other_region", param_field) == 0) {
      other__region().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsSecurity_TypesAndValues.GeographicRegionContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    GeographicRegionContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.GeographicRegionContainer");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "circular_region")) {
      circular__region().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "rectangular_region")) {
      rectangular__region().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "polygonal_region")) {
      polygonal__region().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "id_region")) {
      id__region().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "other_region")) {
      other__region().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.GeographicRegionContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* GeographicRegionContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsSecurity_TypesAndValues.GeographicRegionContainer'");
    }
    if (strcmp("circular_region", param_field) == 0) {
      return circular__region().get_param(param_name);
    } else if (strcmp("rectangular_region", param_field) == 0) {
      return rectangular__region().get_param(param_name);
    } else if (strcmp("polygonal_region", param_field) == 0) {
      return polygonal__region().get_param(param_name);
    } else if (strcmp("id_region", param_field) == 0) {
      return id__region().get_param(param_name);
    } else if (strcmp("other_region", param_field) == 0) {
      return other__region().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `GeographicRegionContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case GeographicRegionContainer::ALT_circular__region:
      mp_field = single_value.field_circular__region->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("circular_region")));
      break;
    case GeographicRegionContainer::ALT_rectangular__region:
      mp_field = single_value.field_rectangular__region->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("rectangular_region")));
      break;
    case GeographicRegionContainer::ALT_polygonal__region:
      mp_field = single_value.field_polygonal__region->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("polygonal_region")));
      break;
    case GeographicRegionContainer::ALT_id__region:
      mp_field = single_value.field_id__region->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("id_region")));
      break;
    case GeographicRegionContainer::ALT_other__region:
      mp_field = single_value.field_other__region->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("other_region")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void GeographicRegionContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case GeographicRegionContainer::ALT_circular__region:
single_value.field_circular__region->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.GeographicRegionContainer");
return;
case GeographicRegionContainer::ALT_rectangular__region:
single_value.field_rectangular__region->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.GeographicRegionContainer");
return;
case GeographicRegionContainer::ALT_polygonal__region:
single_value.field_polygonal__region->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.GeographicRegionContainer");
return;
case GeographicRegionContainer::ALT_id__region:
single_value.field_id__region->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.GeographicRegionContainer");
return;
case GeographicRegionContainer::ALT_other__region:
single_value.field_other__region->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.GeographicRegionContainer");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsSecurity_TypesAndValues.GeographicRegionContainer.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.GeographicRegionContainer");
}

TwoDLocation::TwoDLocation()
{
  bound_flag = FALSE;
}

TwoDLocation::TwoDLocation(const INTEGER& par_latitude,
    const INTEGER& par_longitude)
  :   field_latitude(par_latitude),
  field_longitude(par_longitude)
{
  bound_flag = TRUE;
}

TwoDLocation::TwoDLocation(const TwoDLocation& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.TwoDLocation.");
bound_flag = TRUE;
if (other_value.latitude().is_bound()) field_latitude = other_value.latitude();
else field_latitude.clean_up();
if (other_value.longitude().is_bound()) field_longitude = other_value.longitude();
else field_longitude.clean_up();
}

void TwoDLocation::clean_up()
{
field_latitude.clean_up();
field_longitude.clean_up();
bound_flag = FALSE;
}

TwoDLocation& TwoDLocation::operator=(const TwoDLocation& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.TwoDLocation.");
  bound_flag = TRUE;
  if (other_value.latitude().is_bound()) field_latitude = other_value.latitude();
  else field_latitude.clean_up();
  if (other_value.longitude().is_bound()) field_longitude = other_value.longitude();
  else field_longitude.clean_up();
}
return *this;
}

boolean TwoDLocation::operator==(const TwoDLocation& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_latitude==other_value.field_latitude
  && field_longitude==other_value.field_longitude;
}

boolean TwoDLocation::is_bound() const
{
if (bound_flag) return TRUE;
if(field_latitude.is_bound()) return TRUE;
if(field_longitude.is_bound()) return TRUE;
return FALSE;
}
boolean TwoDLocation::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_latitude.is_value()) return FALSE;
if(!field_longitude.is_value()) return FALSE;
return TRUE;
}
int TwoDLocation::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.TwoDLocation");
  return 2;
}

void TwoDLocation::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ latitude := ");
field_latitude.log();
TTCN_Logger::log_event_str(", longitude := ");
field_longitude.log();
TTCN_Logger::log_event_str(" }");
}

void TwoDLocation::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.TwoDLocation'");
    }
    if (strcmp("latitude", param_field) == 0) {
      latitude().set_param(param);
      return;
    } else if (strcmp("longitude", param_field) == 0) {
      longitude().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.TwoDLocation'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.TwoDLocation has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) latitude().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) longitude().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "latitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          latitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "longitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          longitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.TwoDLocation: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.TwoDLocation");
  }
}

Module_Param* TwoDLocation::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.TwoDLocation'");
    }
    if (strcmp("latitude", param_field) == 0) {
      return latitude().get_param(param_name);
    } else if (strcmp("longitude", param_field) == 0) {
      return longitude().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.TwoDLocation'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_latitude = field_latitude.get_param(param_name);
  mp_field_latitude->set_id(new Module_Param_FieldName(mcopystr("latitude")));
  mp->add_elem(mp_field_latitude);
  Module_Param* mp_field_longitude = field_longitude.get_param(param_name);
  mp_field_longitude->set_id(new Module_Param_FieldName(mcopystr("longitude")));
  mp->add_elem(mp_field_longitude);
  return mp;
  }

void TwoDLocation::set_implicit_omit()
{
if (latitude().is_bound()) latitude().set_implicit_omit();
if (longitude().is_bound()) longitude().set_implicit_omit();
}

void TwoDLocation::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.TwoDLocation.");
field_latitude.encode_text(text_buf);
field_longitude.encode_text(text_buf);
}

void TwoDLocation::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_latitude.decode_text(text_buf);
field_longitude.decode_text(text_buf);
}

void TwoDLocation::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void TwoDLocation::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int TwoDLocation::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_latitude.RAW_decode(WGSLatitude_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_longitude.RAW_decode(WGSLongitude_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int TwoDLocation::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, WGSLatitude_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, WGSLongitude_descr_.raw);
  encoded_length += field_latitude.RAW_encode(WGSLatitude_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_longitude.RAW_encode(WGSLongitude_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int TwoDLocation::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.TwoDLocation.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "latitude");
    enc_len += field_latitude.JSON_encode(WGSLatitude_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "longitude");
    enc_len += field_longitude.JSON_encode(WGSLongitude_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int TwoDLocation::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (8 == name_len && 0 == strncmp(fld_name, "latitude", name_len)) {
         int ret_val = field_latitude.JSON_decode(WGSLatitude_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "latitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "longitude", name_len)) {
         int ret_val = field_longitude.JSON_decode(WGSLongitude_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "longitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_latitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "latitude");
    return JSON_ERROR_FATAL;
  }
if (!field_longitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "longitude");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct TwoDLocation_template::single_value_struct {
INTEGER_template field_latitude;
INTEGER_template field_longitude;
};

void TwoDLocation_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_latitude = ANY_VALUE;
single_value->field_longitude = ANY_VALUE;
}
}
}

void TwoDLocation_template::copy_value(const TwoDLocation& other_value)
{
single_value = new single_value_struct;
if (other_value.latitude().is_bound()) {
  single_value->field_latitude = other_value.latitude();
} else {
  single_value->field_latitude.clean_up();
}
if (other_value.longitude().is_bound()) {
  single_value->field_longitude = other_value.longitude();
} else {
  single_value->field_longitude.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void TwoDLocation_template::copy_template(const TwoDLocation_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.latitude().get_selection()) {
single_value->field_latitude = other_value.latitude();
} else {
single_value->field_latitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.longitude().get_selection()) {
single_value->field_longitude = other_value.longitude();
} else {
single_value->field_longitude.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TwoDLocation_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TwoDLocation.");
break;
}
set_selection(other_value);
}

TwoDLocation_template::TwoDLocation_template()
{
}

TwoDLocation_template::TwoDLocation_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

TwoDLocation_template::TwoDLocation_template(const TwoDLocation& other_value)
{
copy_value(other_value);
}

TwoDLocation_template::TwoDLocation_template(const OPTIONAL<TwoDLocation>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TwoDLocation&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.TwoDLocation from an unbound optional field.");
}
}

TwoDLocation_template::TwoDLocation_template(const TwoDLocation_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

TwoDLocation_template::~TwoDLocation_template()
{
clean_up();
}

TwoDLocation_template& TwoDLocation_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TwoDLocation_template& TwoDLocation_template::operator=(const TwoDLocation& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

TwoDLocation_template& TwoDLocation_template::operator=(const OPTIONAL<TwoDLocation>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TwoDLocation&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.TwoDLocation.");
}
return *this;
}

TwoDLocation_template& TwoDLocation_template::operator=(const TwoDLocation_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean TwoDLocation_template::match(const TwoDLocation& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.latitude().is_bound()) return FALSE;
if(!single_value->field_latitude.match(other_value.latitude(), legacy))return FALSE;
if(!other_value.longitude().is_bound()) return FALSE;
if(!single_value->field_longitude.match(other_value.longitude(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TwoDLocation.");
}
return FALSE;
}

boolean TwoDLocation_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_latitude.is_bound()) return TRUE;
if (single_value->field_longitude.is_bound()) return TRUE;
return FALSE;
}

boolean TwoDLocation_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_latitude.is_value()) return FALSE;
if (!single_value->field_longitude.is_value()) return FALSE;
return TRUE;
}

void TwoDLocation_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

TwoDLocation TwoDLocation_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.TwoDLocation.");
TwoDLocation ret_val;
if (single_value->field_latitude.is_bound()) {
ret_val.latitude() = single_value->field_latitude.valueof();
}
if (single_value->field_longitude.is_bound()) {
ret_val.longitude() = single_value->field_longitude.valueof();
}
return ret_val;
}

void TwoDLocation_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.TwoDLocation.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new TwoDLocation_template[list_length];
}

TwoDLocation_template& TwoDLocation_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.TwoDLocation.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.TwoDLocation.");
return value_list.list_value[list_index];
}

INTEGER_template& TwoDLocation_template::latitude()
{
set_specific();
return single_value->field_latitude;
}

const INTEGER_template& TwoDLocation_template::latitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field latitude of a non-specific template of type @LibItsSecurity_TypesAndValues.TwoDLocation.");
return single_value->field_latitude;
}

INTEGER_template& TwoDLocation_template::longitude()
{
set_specific();
return single_value->field_longitude;
}

const INTEGER_template& TwoDLocation_template::longitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field longitude of a non-specific template of type @LibItsSecurity_TypesAndValues.TwoDLocation.");
return single_value->field_longitude;
}

int TwoDLocation_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TwoDLocation which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TwoDLocation containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TwoDLocation containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TwoDLocation containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TwoDLocation containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TwoDLocation containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TwoDLocation.");
  }
  return 0;
}

void TwoDLocation_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ latitude := ");
single_value->field_latitude.log();
TTCN_Logger::log_event_str(", longitude := ");
single_value->field_longitude.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void TwoDLocation_template::log_match(const TwoDLocation& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_latitude.match(match_value.latitude(), legacy)){
TTCN_Logger::log_logmatch_info(".latitude");
single_value->field_latitude.log_match(match_value.latitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_longitude.match(match_value.longitude(), legacy)){
TTCN_Logger::log_logmatch_info(".longitude");
single_value->field_longitude.log_match(match_value.longitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ latitude := ");
single_value->field_latitude.log_match(match_value.latitude(), legacy);
TTCN_Logger::log_event_str(", longitude := ");
single_value->field_longitude.log_match(match_value.longitude(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void TwoDLocation_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_latitude.encode_text(text_buf);
single_value->field_longitude.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TwoDLocation.");
}
}

void TwoDLocation_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_latitude.decode_text(text_buf);
single_value->field_longitude.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TwoDLocation_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.TwoDLocation.");
}
}

void TwoDLocation_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.TwoDLocation'");
    }
    if (strcmp("latitude", param_field) == 0) {
      latitude().set_param(param);
      return;
    } else if (strcmp("longitude", param_field) == 0) {
      longitude().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.TwoDLocation'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TwoDLocation_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.TwoDLocation has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) latitude().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) longitude().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "latitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          latitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "longitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          longitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.TwoDLocation: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.TwoDLocation");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* TwoDLocation_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.TwoDLocation'");
    }
    if (strcmp("latitude", param_field) == 0) {
      return latitude().get_param(param_name);
    } else if (strcmp("longitude", param_field) == 0) {
      return longitude().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.TwoDLocation'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_latitude = single_value->field_latitude.get_param(param_name);
    mp_field_latitude->set_id(new Module_Param_FieldName(mcopystr("latitude")));
    mp->add_elem(mp_field_latitude);
    Module_Param* mp_field_longitude = single_value->field_longitude.get_param(param_name);
    mp_field_longitude->set_id(new Module_Param_FieldName(mcopystr("longitude")));
    mp->add_elem(mp_field_longitude);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void TwoDLocation_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_latitude.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TwoDLocation");
single_value->field_longitude.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TwoDLocation");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.TwoDLocation");
}

boolean TwoDLocation_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TwoDLocation_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

CircularRegion::CircularRegion()
{
  bound_flag = FALSE;
}

CircularRegion::CircularRegion(const TwoDLocation& par_center,
    const INTEGER& par_radius)
  :   field_center(par_center),
  field_radius(par_radius)
{
  bound_flag = TRUE;
}

CircularRegion::CircularRegion(const CircularRegion& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.CircularRegion.");
bound_flag = TRUE;
if (other_value.center().is_bound()) field_center = other_value.center();
else field_center.clean_up();
if (other_value.radius().is_bound()) field_radius = other_value.radius();
else field_radius.clean_up();
}

void CircularRegion::clean_up()
{
field_center.clean_up();
field_radius.clean_up();
bound_flag = FALSE;
}

CircularRegion& CircularRegion::operator=(const CircularRegion& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.CircularRegion.");
  bound_flag = TRUE;
  if (other_value.center().is_bound()) field_center = other_value.center();
  else field_center.clean_up();
  if (other_value.radius().is_bound()) field_radius = other_value.radius();
  else field_radius.clean_up();
}
return *this;
}

boolean CircularRegion::operator==(const CircularRegion& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_center==other_value.field_center
  && field_radius==other_value.field_radius;
}

boolean CircularRegion::is_bound() const
{
if (bound_flag) return TRUE;
if(field_center.is_bound()) return TRUE;
if(field_radius.is_bound()) return TRUE;
return FALSE;
}
boolean CircularRegion::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_center.is_value()) return FALSE;
if(!field_radius.is_value()) return FALSE;
return TRUE;
}
int CircularRegion::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.CircularRegion");
  return 2;
}

void CircularRegion::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ center := ");
field_center.log();
TTCN_Logger::log_event_str(", radius := ");
field_radius.log();
TTCN_Logger::log_event_str(" }");
}

void CircularRegion::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.CircularRegion'");
    }
    if (strcmp("center", param_field) == 0) {
      center().set_param(param);
      return;
    } else if (strcmp("radius", param_field) == 0) {
      radius().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.CircularRegion'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.CircularRegion has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) center().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) radius().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "center")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          center().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "radius")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          radius().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.CircularRegion: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.CircularRegion");
  }
}

Module_Param* CircularRegion::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.CircularRegion'");
    }
    if (strcmp("center", param_field) == 0) {
      return center().get_param(param_name);
    } else if (strcmp("radius", param_field) == 0) {
      return radius().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.CircularRegion'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_center = field_center.get_param(param_name);
  mp_field_center->set_id(new Module_Param_FieldName(mcopystr("center")));
  mp->add_elem(mp_field_center);
  Module_Param* mp_field_radius = field_radius.get_param(param_name);
  mp_field_radius->set_id(new Module_Param_FieldName(mcopystr("radius")));
  mp->add_elem(mp_field_radius);
  return mp;
  }

void CircularRegion::set_implicit_omit()
{
if (center().is_bound()) center().set_implicit_omit();
if (radius().is_bound()) radius().set_implicit_omit();
}

void CircularRegion::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.CircularRegion.");
field_center.encode_text(text_buf);
field_radius.encode_text(text_buf);
}

void CircularRegion::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_center.decode_text(text_buf);
field_radius.decode_text(text_buf);
}

void CircularRegion::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void CircularRegion::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int CircularRegion::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_center.RAW_decode(TwoDLocation_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_radius.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int CircularRegion::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, TwoDLocation_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  encoded_length += field_center.RAW_encode(TwoDLocation_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_radius.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int CircularRegion::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.CircularRegion.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "center");
    enc_len += field_center.JSON_encode(TwoDLocation_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "radius");
    enc_len += field_radius.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int CircularRegion::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (6 == name_len && 0 == strncmp(fld_name, "center", name_len)) {
         int ret_val = field_center.JSON_decode(TwoDLocation_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "center");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "radius", name_len)) {
         int ret_val = field_radius.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "radius");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_center.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "center");
    return JSON_ERROR_FATAL;
  }
if (!field_radius.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "radius");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct CircularRegion_template::single_value_struct {
TwoDLocation_template field_center;
INTEGER_template field_radius;
};

void CircularRegion_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_center = ANY_VALUE;
single_value->field_radius = ANY_VALUE;
}
}
}

void CircularRegion_template::copy_value(const CircularRegion& other_value)
{
single_value = new single_value_struct;
if (other_value.center().is_bound()) {
  single_value->field_center = other_value.center();
} else {
  single_value->field_center.clean_up();
}
if (other_value.radius().is_bound()) {
  single_value->field_radius = other_value.radius();
} else {
  single_value->field_radius.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void CircularRegion_template::copy_template(const CircularRegion_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.center().get_selection()) {
single_value->field_center = other_value.center();
} else {
single_value->field_center.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.radius().get_selection()) {
single_value->field_radius = other_value.radius();
} else {
single_value->field_radius.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CircularRegion_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.CircularRegion.");
break;
}
set_selection(other_value);
}

CircularRegion_template::CircularRegion_template()
{
}

CircularRegion_template::CircularRegion_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

CircularRegion_template::CircularRegion_template(const CircularRegion& other_value)
{
copy_value(other_value);
}

CircularRegion_template::CircularRegion_template(const OPTIONAL<CircularRegion>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CircularRegion&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.CircularRegion from an unbound optional field.");
}
}

CircularRegion_template::CircularRegion_template(const CircularRegion_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

CircularRegion_template::~CircularRegion_template()
{
clean_up();
}

CircularRegion_template& CircularRegion_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CircularRegion_template& CircularRegion_template::operator=(const CircularRegion& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

CircularRegion_template& CircularRegion_template::operator=(const OPTIONAL<CircularRegion>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CircularRegion&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.CircularRegion.");
}
return *this;
}

CircularRegion_template& CircularRegion_template::operator=(const CircularRegion_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean CircularRegion_template::match(const CircularRegion& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.center().is_bound()) return FALSE;
if(!single_value->field_center.match(other_value.center(), legacy))return FALSE;
if(!other_value.radius().is_bound()) return FALSE;
if(!single_value->field_radius.match(other_value.radius(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.CircularRegion.");
}
return FALSE;
}

boolean CircularRegion_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_center.is_bound()) return TRUE;
if (single_value->field_radius.is_bound()) return TRUE;
return FALSE;
}

boolean CircularRegion_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_center.is_value()) return FALSE;
if (!single_value->field_radius.is_value()) return FALSE;
return TRUE;
}

void CircularRegion_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

CircularRegion CircularRegion_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.CircularRegion.");
CircularRegion ret_val;
if (single_value->field_center.is_bound()) {
ret_val.center() = single_value->field_center.valueof();
}
if (single_value->field_radius.is_bound()) {
ret_val.radius() = single_value->field_radius.valueof();
}
return ret_val;
}

void CircularRegion_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.CircularRegion.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new CircularRegion_template[list_length];
}

CircularRegion_template& CircularRegion_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.CircularRegion.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.CircularRegion.");
return value_list.list_value[list_index];
}

TwoDLocation_template& CircularRegion_template::center()
{
set_specific();
return single_value->field_center;
}

const TwoDLocation_template& CircularRegion_template::center() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field center of a non-specific template of type @LibItsSecurity_TypesAndValues.CircularRegion.");
return single_value->field_center;
}

INTEGER_template& CircularRegion_template::radius()
{
set_specific();
return single_value->field_radius;
}

const INTEGER_template& CircularRegion_template::radius() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field radius of a non-specific template of type @LibItsSecurity_TypesAndValues.CircularRegion.");
return single_value->field_radius;
}

int CircularRegion_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.CircularRegion which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.CircularRegion containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.CircularRegion containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.CircularRegion containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.CircularRegion containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.CircularRegion containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.CircularRegion.");
  }
  return 0;
}

void CircularRegion_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ center := ");
single_value->field_center.log();
TTCN_Logger::log_event_str(", radius := ");
single_value->field_radius.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void CircularRegion_template::log_match(const CircularRegion& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_center.match(match_value.center(), legacy)){
TTCN_Logger::log_logmatch_info(".center");
single_value->field_center.log_match(match_value.center(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_radius.match(match_value.radius(), legacy)){
TTCN_Logger::log_logmatch_info(".radius");
single_value->field_radius.log_match(match_value.radius(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ center := ");
single_value->field_center.log_match(match_value.center(), legacy);
TTCN_Logger::log_event_str(", radius := ");
single_value->field_radius.log_match(match_value.radius(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void CircularRegion_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_center.encode_text(text_buf);
single_value->field_radius.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.CircularRegion.");
}
}

void CircularRegion_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_center.decode_text(text_buf);
single_value->field_radius.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CircularRegion_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.CircularRegion.");
}
}

void CircularRegion_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.CircularRegion'");
    }
    if (strcmp("center", param_field) == 0) {
      center().set_param(param);
      return;
    } else if (strcmp("radius", param_field) == 0) {
      radius().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.CircularRegion'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CircularRegion_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.CircularRegion has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) center().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) radius().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "center")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          center().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "radius")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          radius().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.CircularRegion: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.CircularRegion");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* CircularRegion_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.CircularRegion'");
    }
    if (strcmp("center", param_field) == 0) {
      return center().get_param(param_name);
    } else if (strcmp("radius", param_field) == 0) {
      return radius().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.CircularRegion'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_center = single_value->field_center.get_param(param_name);
    mp_field_center->set_id(new Module_Param_FieldName(mcopystr("center")));
    mp->add_elem(mp_field_center);
    Module_Param* mp_field_radius = single_value->field_radius.get_param(param_name);
    mp_field_radius->set_id(new Module_Param_FieldName(mcopystr("radius")));
    mp->add_elem(mp_field_radius);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void CircularRegion_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_center.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.CircularRegion");
single_value->field_radius.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.CircularRegion");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.CircularRegion");
}

boolean CircularRegion_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CircularRegion_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const RectangularRegion RectangularRegions::UNBOUND_ELEM;
boolean RectangularRegions::compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index)
{
if (((const RectangularRegions*)left_ptr)->val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
if (((const RectangularRegions*)right_ptr)->val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
if (((const RectangularRegions*)left_ptr)->val_ptr->value_elements[left_index] != NULL){
if (((const RectangularRegions*)right_ptr)->val_ptr->value_elements[right_index] != NULL){
return *((const RectangularRegions*)left_ptr)->val_ptr->value_elements[left_index] == *((const RectangularRegions*)right_ptr)->val_ptr->value_elements[right_index];
} else return FALSE;
} else {
return ((const RectangularRegions*)right_ptr)->val_ptr->value_elements[right_index] == NULL;
}
}

RectangularRegions::RectangularRegions()
{
val_ptr = NULL;
}

RectangularRegions::RectangularRegions(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

RectangularRegions::RectangularRegions(const RectangularRegions& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

RectangularRegions::~RectangularRegions()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void RectangularRegions::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

RectangularRegions& RectangularRegions::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

RectangularRegions& RectangularRegions::operator=(const RectangularRegions& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean RectangularRegions::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
return val_ptr->n_elements == 0 ;
}

boolean RectangularRegions::operator==(const RectangularRegions& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
if (val_ptr == other_value.val_ptr) return TRUE;
return compare_set_of(this, val_ptr->n_elements, &other_value, (other_value.val_ptr)->n_elements, compare_function);
}

RectangularRegion& RectangularRegions::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.RectangularRegions using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (RectangularRegion**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new RectangularRegion(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new RectangularRegion;
}
return *val_ptr->value_elements[index_value];
}

RectangularRegion& RectangularRegions::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
return (*this)[(int)index_value];
}

const RectangularRegion& RectangularRegions::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.RectangularRegions using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsSecurity_TypesAndValues.RectangularRegions: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const RectangularRegion& RectangularRegions::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
return (*this)[(int)index_value];
}

RectangularRegions RectangularRegions::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

RectangularRegions RectangularRegions::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

RectangularRegions RectangularRegions::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

RectangularRegions RectangularRegions::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
RectangularRegions ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new RectangularRegion(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

RectangularRegions RectangularRegions::operator+(const RectangularRegions& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsSecurity_TypesAndValues.RectangularRegions concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
RectangularRegions ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new RectangularRegion(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new RectangularRegion(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

RectangularRegions RectangularRegions::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsSecurity_TypesAndValues.RectangularRegions","element");
RectangularRegions ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new RectangularRegion(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

RectangularRegions RectangularRegions::replace(int index, int len, const RectangularRegions& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsSecurity_TypesAndValues.RectangularRegions","element");
RectangularRegions ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new RectangularRegion(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new RectangularRegion(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new RectangularRegion(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

RectangularRegions RectangularRegions::replace(int index, int len, const RectangularRegions_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void RectangularRegions::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (RectangularRegion**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new RectangularRegion(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (RectangularRegion**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsSecurity_TypesAndValues.RectangularRegions: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (RectangularRegion**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean RectangularRegions::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int RectangularRegions::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
return val_ptr->n_elements;
}

int RectangularRegions::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void RectangularRegions::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void RectangularRegions::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set of type `@LibItsSecurity_TypesAndValues.RectangularRegions'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "set of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.RectangularRegions");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.RectangularRegions");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* RectangularRegions::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of type `@LibItsSecurity_TypesAndValues.RectangularRegions'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void RectangularRegions::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void RectangularRegions::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void RectangularRegions::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
val_ptr->value_elements = (RectangularRegion**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new RectangularRegion;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void RectangularRegions::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RectangularRegions::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int RectangularRegions::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int RectangularRegions::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

int RectangularRegions::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int RectangularRegions::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    RectangularRegion* val = new RectangularRegion;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (RectangularRegion**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void RectangularRegions_template::copy_value(const RectangularRegions& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsSecurity_TypesAndValues.RectangularRegions with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (RectangularRegion_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new RectangularRegion_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new RectangularRegion_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void RectangularRegions_template::copy_template(const RectangularRegions_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (RectangularRegion_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new RectangularRegion_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new RectangularRegion_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RectangularRegions_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = other_value.value_set.n_items;
value_set.set_items = new RectangularRegion_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count] = other_value.value_set.set_items[set_count];
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
break;
}
set_selection(other_value);
}

boolean RectangularRegions_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const RectangularRegions_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const RectangularRegions*)value_ptr)[value_index], legacy);
else return ((const RectangularRegions_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

boolean RectangularRegions_template::match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const RectangularRegions_template*)template_ptr)->value_set.set_items[template_index].match((*(const RectangularRegions*)value_ptr)[value_index], legacy);
else return ((const RectangularRegions_template*)template_ptr)->value_set.set_items[template_index].is_any_or_omit();
}

void RectangularRegions_template::log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy)
{
if (value_ptr != NULL && template_ptr != NULL)((const RectangularRegions_template*)template_ptr)->single_value.value_elements[index_template]->log_match((*(const RectangularRegions*)value_ptr)[index_value], legacy);
else if (value_ptr != NULL) (*(const RectangularRegions*)value_ptr)[index_value].log();
else if (template_ptr != NULL) ((const RectangularRegions_template*)template_ptr)->single_value.value_elements[index_template]->log();
}

RectangularRegions_template::RectangularRegions_template()
{
}

RectangularRegions_template::RectangularRegions_template(template_sel other_value)
 : Restricted_Length_Template(other_value)
{
check_single_selection(other_value);
}

RectangularRegions_template::RectangularRegions_template(null_type)
 : Restricted_Length_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

RectangularRegions_template::RectangularRegions_template(const RectangularRegions& other_value)
{
copy_value(other_value);
}

RectangularRegions_template::RectangularRegions_template(const OPTIONAL<RectangularRegions>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RectangularRegions&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.RectangularRegions from an unbound optional field.");
}
}

RectangularRegions_template::RectangularRegions_template(const RectangularRegions_template& other_value)
 : Restricted_Length_Template()
{
copy_template(other_value);
}

RectangularRegions_template::~RectangularRegions_template()
{
clean_up();
}

void RectangularRegions_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
delete [] value_set.set_items;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RectangularRegions_template& RectangularRegions_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RectangularRegions_template& RectangularRegions_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

RectangularRegions_template& RectangularRegions_template::operator=(const RectangularRegions& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RectangularRegions_template& RectangularRegions_template::operator=(const OPTIONAL<RectangularRegions>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RectangularRegions&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
}
return *this;
}

RectangularRegions_template& RectangularRegions_template::operator=(const RectangularRegions_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

RectangularRegion_template& RectangularRegions_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.RectangularRegions using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.RectangularRegions.");
    break;
}
return *single_value.value_elements[index_value];
}

RectangularRegion_template& RectangularRegions_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
return (*this)[(int)index_value];
}

const RectangularRegion_template& RectangularRegions_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.RectangularRegions using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.RectangularRegions.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsSecurity_TypesAndValues.RectangularRegions: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const RectangularRegion_template& RectangularRegions_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
return (*this)[(int)index_value];
}

void RectangularRegions_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (RectangularRegion_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new RectangularRegion_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new RectangularRegion_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (RectangularRegion_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int RectangularRegions_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int RectangularRegions_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RectangularRegions which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RectangularRegions containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case SUPERSET_MATCH:
case SUBSET_MATCH: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = value_set.n_items;
  if (!is_size) { while (elem_count>0 && !value_set.set_items[elem_count-1].is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (value_set.set_items[i].get_selection())
    {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RectangularRegions containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
  if (template_selection==SUPERSET_MATCH) {
    has_any_or_none = TRUE;
   } else {
    int max_size = min_size;
    min_size = 0;
    if (!has_any_or_none) { // [0,max_size]
      switch (length_restriction_type) {
      case NO_LENGTH_RESTRICTION:
        if (max_size==0) return 0;
        TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RectangularRegions with no exact size.", op_name);
      case SINGLE_LENGTH_RESTRICTION:
        if (length_restriction.single_length<=max_size)
          return length_restriction.single_length;
        TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.RectangularRegions. The maximum size (%d) contradicts the length restriction (%d).", op_name, max_size, length_restriction.single_length);
      case RANGE_LENGTH_RESTRICTION:
        if (max_size==length_restriction.range_length.min_length) {
          return max_size;
        } else if (max_size>length_restriction.range_length.min_length){
          TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RectangularRegions with no exact size.", op_name);
        } else
          TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.RectangularRegions. Maximum size (%d) contradicts the length restriction (%d..%d).", op_name, max_size, length_restriction.range_length.min_length, length_restriction.range_length.max_length);
      default:
        TTCN_error("Internal error: Template has invalid length restriction type.");
      }
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RectangularRegions containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RectangularRegions containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RectangularRegions containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RectangularRegions containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.RectangularRegions.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsSecurity_TypesAndValues.RectangularRegions");
}

boolean RectangularRegions_template::match(const RectangularRegions& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_set_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case SUPERSET_MATCH:
case SUBSET_MATCH:
return match_set_of(&other_value, value_length, this, value_set.n_items, match_function_set, legacy);
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
}
return FALSE;
}

boolean RectangularRegions_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

RectangularRegions RectangularRegions_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
RectangularRegions ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

RectangularRegions RectangularRegions_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

RectangularRegions RectangularRegions_template::replace(int index, int len, const RectangularRegions_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

RectangularRegions RectangularRegions_template::replace(int index, int len, const RectangularRegions& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void RectangularRegions_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new RectangularRegions_template[list_length];
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = list_length;
value_set.set_items = new RectangularRegion_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
}
set_selection(template_type);
}

RectangularRegions_template& RectangularRegions_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
return value_list.list_value[list_index];
}

RectangularRegion_template& RectangularRegions_template::set_item(unsigned int set_index)
{
if (template_selection != SUPERSET_MATCH && template_selection != SUBSET_MATCH) TTCN_error("Internal error: Accessing a set element of a non-set template of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
if (set_index >= value_set.n_items) TTCN_error("Internal error: Index overflow in a set template of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
return value_set.set_items[set_index];
}

void RectangularRegions_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log();
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
TTCN_Logger::log_event("%s(", template_selection == SUPERSET_MATCH ? "superset" : "subset");
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++) {
if (set_count > 0) TTCN_Logger::log_event_str(", ");
value_set.set_items[set_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void RectangularRegions_template::log_match(const RectangularRegions& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (template_selection == SPECIFIC_VALUE)
  log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
else{
if(previous_size != 0){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::set_logmatch_buffer_len(previous_size);
TTCN_Logger::log_event_str(":=");
}
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
return;
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else {
TTCN_Logger::log_event_str(" unmatched");
if (template_selection == SPECIFIC_VALUE) log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
}
}

void RectangularRegions_template::encode_text(Text_Buf& text_buf) const
{
encode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
text_buf.push_int(value_set.n_items);
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
}
}

void RectangularRegions_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
single_value.value_elements = (RectangularRegion_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new RectangularRegion_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RectangularRegions_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = text_buf.pull_int().get_val();
value_set.set_items = new RectangularRegion_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
}
}

boolean RectangularRegions_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RectangularRegions_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void RectangularRegions_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set template type `@LibItsSecurity_TypesAndValues.RectangularRegions'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "set of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RectangularRegions_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    set_size(mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      if (mp->get_elem(p_i)->get_type()!=Module_Param::MP_NotUsed) {
        (*this)[p_i].set_param(*mp->get_elem(p_i));
      }
    }
    break;
  case Module_Param::MP_Superset_Template:
  case Module_Param::MP_Subset_Template:
    set_type(mp->get_type()==Module_Param::MP_Superset_Template ? SUPERSET_MATCH : SUBSET_MATCH, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      set_item(p_i).set_param(*mp->get_elem(p_i));
    }
    break;
  default:
    param.type_error("set of template", "@LibItsSecurity_TypesAndValues.RectangularRegions");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* RectangularRegions_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of template type `@LibItsSecurity_TypesAndValues.RectangularRegions'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void RectangularRegions_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.RectangularRegions");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.RectangularRegions");
}

RectangularRegion::RectangularRegion()
{
  bound_flag = FALSE;
}

RectangularRegion::RectangularRegion(const TwoDLocation& par_northwest,
    const TwoDLocation& par_southeast)
  :   field_northwest(par_northwest),
  field_southeast(par_southeast)
{
  bound_flag = TRUE;
}

RectangularRegion::RectangularRegion(const RectangularRegion& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegion.");
bound_flag = TRUE;
if (other_value.northwest().is_bound()) field_northwest = other_value.northwest();
else field_northwest.clean_up();
if (other_value.southeast().is_bound()) field_southeast = other_value.southeast();
else field_southeast.clean_up();
}

void RectangularRegion::clean_up()
{
field_northwest.clean_up();
field_southeast.clean_up();
bound_flag = FALSE;
}

RectangularRegion& RectangularRegion::operator=(const RectangularRegion& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegion.");
  bound_flag = TRUE;
  if (other_value.northwest().is_bound()) field_northwest = other_value.northwest();
  else field_northwest.clean_up();
  if (other_value.southeast().is_bound()) field_southeast = other_value.southeast();
  else field_southeast.clean_up();
}
return *this;
}

boolean RectangularRegion::operator==(const RectangularRegion& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_northwest==other_value.field_northwest
  && field_southeast==other_value.field_southeast;
}

boolean RectangularRegion::is_bound() const
{
if (bound_flag) return TRUE;
if(field_northwest.is_bound()) return TRUE;
if(field_southeast.is_bound()) return TRUE;
return FALSE;
}
boolean RectangularRegion::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_northwest.is_value()) return FALSE;
if(!field_southeast.is_value()) return FALSE;
return TRUE;
}
int RectangularRegion::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.RectangularRegion");
  return 2;
}

void RectangularRegion::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ northwest := ");
field_northwest.log();
TTCN_Logger::log_event_str(", southeast := ");
field_southeast.log();
TTCN_Logger::log_event_str(" }");
}

void RectangularRegion::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.RectangularRegion'");
    }
    if (strcmp("northwest", param_field) == 0) {
      northwest().set_param(param);
      return;
    } else if (strcmp("southeast", param_field) == 0) {
      southeast().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.RectangularRegion'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.RectangularRegion has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) northwest().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) southeast().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "northwest")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          northwest().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "southeast")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          southeast().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.RectangularRegion: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.RectangularRegion");
  }
}

Module_Param* RectangularRegion::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.RectangularRegion'");
    }
    if (strcmp("northwest", param_field) == 0) {
      return northwest().get_param(param_name);
    } else if (strcmp("southeast", param_field) == 0) {
      return southeast().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.RectangularRegion'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_northwest = field_northwest.get_param(param_name);
  mp_field_northwest->set_id(new Module_Param_FieldName(mcopystr("northwest")));
  mp->add_elem(mp_field_northwest);
  Module_Param* mp_field_southeast = field_southeast.get_param(param_name);
  mp_field_southeast->set_id(new Module_Param_FieldName(mcopystr("southeast")));
  mp->add_elem(mp_field_southeast);
  return mp;
  }

void RectangularRegion::set_implicit_omit()
{
if (northwest().is_bound()) northwest().set_implicit_omit();
if (southeast().is_bound()) southeast().set_implicit_omit();
}

void RectangularRegion::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.RectangularRegion.");
field_northwest.encode_text(text_buf);
field_southeast.encode_text(text_buf);
}

void RectangularRegion::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_northwest.decode_text(text_buf);
field_southeast.decode_text(text_buf);
}

void RectangularRegion::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RectangularRegion::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int RectangularRegion::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_northwest.RAW_decode(TwoDLocation_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_southeast.RAW_decode(TwoDLocation_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int RectangularRegion::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, TwoDLocation_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, TwoDLocation_descr_.raw);
  encoded_length += field_northwest.RAW_encode(TwoDLocation_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_southeast.RAW_encode(TwoDLocation_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int RectangularRegion::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegion.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "northwest");
    enc_len += field_northwest.JSON_encode(TwoDLocation_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "southeast");
    enc_len += field_southeast.JSON_encode(TwoDLocation_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int RectangularRegion::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (9 == name_len && 0 == strncmp(fld_name, "northwest", name_len)) {
         int ret_val = field_northwest.JSON_decode(TwoDLocation_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "northwest");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "southeast", name_len)) {
         int ret_val = field_southeast.JSON_decode(TwoDLocation_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "southeast");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_northwest.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "northwest");
    return JSON_ERROR_FATAL;
  }
if (!field_southeast.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "southeast");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct RectangularRegion_template::single_value_struct {
TwoDLocation_template field_northwest;
TwoDLocation_template field_southeast;
};

void RectangularRegion_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_northwest = ANY_VALUE;
single_value->field_southeast = ANY_VALUE;
}
}
}

void RectangularRegion_template::copy_value(const RectangularRegion& other_value)
{
single_value = new single_value_struct;
if (other_value.northwest().is_bound()) {
  single_value->field_northwest = other_value.northwest();
} else {
  single_value->field_northwest.clean_up();
}
if (other_value.southeast().is_bound()) {
  single_value->field_southeast = other_value.southeast();
} else {
  single_value->field_southeast.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void RectangularRegion_template::copy_template(const RectangularRegion_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.northwest().get_selection()) {
single_value->field_northwest = other_value.northwest();
} else {
single_value->field_northwest.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.southeast().get_selection()) {
single_value->field_southeast = other_value.southeast();
} else {
single_value->field_southeast.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RectangularRegion_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.RectangularRegion.");
break;
}
set_selection(other_value);
}

RectangularRegion_template::RectangularRegion_template()
{
}

RectangularRegion_template::RectangularRegion_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RectangularRegion_template::RectangularRegion_template(const RectangularRegion& other_value)
{
copy_value(other_value);
}

RectangularRegion_template::RectangularRegion_template(const OPTIONAL<RectangularRegion>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RectangularRegion&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.RectangularRegion from an unbound optional field.");
}
}

RectangularRegion_template::RectangularRegion_template(const RectangularRegion_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

RectangularRegion_template::~RectangularRegion_template()
{
clean_up();
}

RectangularRegion_template& RectangularRegion_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RectangularRegion_template& RectangularRegion_template::operator=(const RectangularRegion& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RectangularRegion_template& RectangularRegion_template::operator=(const OPTIONAL<RectangularRegion>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RectangularRegion&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.RectangularRegion.");
}
return *this;
}

RectangularRegion_template& RectangularRegion_template::operator=(const RectangularRegion_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RectangularRegion_template::match(const RectangularRegion& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.northwest().is_bound()) return FALSE;
if(!single_value->field_northwest.match(other_value.northwest(), legacy))return FALSE;
if(!other_value.southeast().is_bound()) return FALSE;
if(!single_value->field_southeast.match(other_value.southeast(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.RectangularRegion.");
}
return FALSE;
}

boolean RectangularRegion_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_northwest.is_bound()) return TRUE;
if (single_value->field_southeast.is_bound()) return TRUE;
return FALSE;
}

boolean RectangularRegion_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_northwest.is_value()) return FALSE;
if (!single_value->field_southeast.is_value()) return FALSE;
return TRUE;
}

void RectangularRegion_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RectangularRegion RectangularRegion_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.RectangularRegion.");
RectangularRegion ret_val;
if (single_value->field_northwest.is_bound()) {
ret_val.northwest() = single_value->field_northwest.valueof();
}
if (single_value->field_southeast.is_bound()) {
ret_val.southeast() = single_value->field_southeast.valueof();
}
return ret_val;
}

void RectangularRegion_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.RectangularRegion.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RectangularRegion_template[list_length];
}

RectangularRegion_template& RectangularRegion_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.RectangularRegion.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.RectangularRegion.");
return value_list.list_value[list_index];
}

TwoDLocation_template& RectangularRegion_template::northwest()
{
set_specific();
return single_value->field_northwest;
}

const TwoDLocation_template& RectangularRegion_template::northwest() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field northwest of a non-specific template of type @LibItsSecurity_TypesAndValues.RectangularRegion.");
return single_value->field_northwest;
}

TwoDLocation_template& RectangularRegion_template::southeast()
{
set_specific();
return single_value->field_southeast;
}

const TwoDLocation_template& RectangularRegion_template::southeast() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field southeast of a non-specific template of type @LibItsSecurity_TypesAndValues.RectangularRegion.");
return single_value->field_southeast;
}

int RectangularRegion_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.RectangularRegion which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.RectangularRegion containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.RectangularRegion containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.RectangularRegion containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.RectangularRegion containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.RectangularRegion containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.RectangularRegion.");
  }
  return 0;
}

void RectangularRegion_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ northwest := ");
single_value->field_northwest.log();
TTCN_Logger::log_event_str(", southeast := ");
single_value->field_southeast.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RectangularRegion_template::log_match(const RectangularRegion& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_northwest.match(match_value.northwest(), legacy)){
TTCN_Logger::log_logmatch_info(".northwest");
single_value->field_northwest.log_match(match_value.northwest(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_southeast.match(match_value.southeast(), legacy)){
TTCN_Logger::log_logmatch_info(".southeast");
single_value->field_southeast.log_match(match_value.southeast(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ northwest := ");
single_value->field_northwest.log_match(match_value.northwest(), legacy);
TTCN_Logger::log_event_str(", southeast := ");
single_value->field_southeast.log_match(match_value.southeast(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RectangularRegion_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_northwest.encode_text(text_buf);
single_value->field_southeast.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.RectangularRegion.");
}
}

void RectangularRegion_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_northwest.decode_text(text_buf);
single_value->field_southeast.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RectangularRegion_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.RectangularRegion.");
}
}

void RectangularRegion_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.RectangularRegion'");
    }
    if (strcmp("northwest", param_field) == 0) {
      northwest().set_param(param);
      return;
    } else if (strcmp("southeast", param_field) == 0) {
      southeast().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.RectangularRegion'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RectangularRegion_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.RectangularRegion has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) northwest().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) southeast().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "northwest")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          northwest().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "southeast")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          southeast().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.RectangularRegion: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.RectangularRegion");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RectangularRegion_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.RectangularRegion'");
    }
    if (strcmp("northwest", param_field) == 0) {
      return northwest().get_param(param_name);
    } else if (strcmp("southeast", param_field) == 0) {
      return southeast().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.RectangularRegion'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_northwest = single_value->field_northwest.get_param(param_name);
    mp_field_northwest->set_id(new Module_Param_FieldName(mcopystr("northwest")));
    mp->add_elem(mp_field_northwest);
    Module_Param* mp_field_southeast = single_value->field_southeast.get_param(param_name);
    mp_field_southeast->set_id(new Module_Param_FieldName(mcopystr("southeast")));
    mp->add_elem(mp_field_southeast);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RectangularRegion_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_northwest.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.RectangularRegion");
single_value->field_southeast.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.RectangularRegion");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.RectangularRegion");
}

boolean RectangularRegion_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RectangularRegion_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const TwoDLocation PolygonalRegion::UNBOUND_ELEM;
boolean PolygonalRegion::compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index)
{
if (((const PolygonalRegion*)left_ptr)->val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
if (((const PolygonalRegion*)right_ptr)->val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
if (((const PolygonalRegion*)left_ptr)->val_ptr->value_elements[left_index] != NULL){
if (((const PolygonalRegion*)right_ptr)->val_ptr->value_elements[right_index] != NULL){
return *((const PolygonalRegion*)left_ptr)->val_ptr->value_elements[left_index] == *((const PolygonalRegion*)right_ptr)->val_ptr->value_elements[right_index];
} else return FALSE;
} else {
return ((const PolygonalRegion*)right_ptr)->val_ptr->value_elements[right_index] == NULL;
}
}

PolygonalRegion::PolygonalRegion()
{
val_ptr = NULL;
}

PolygonalRegion::PolygonalRegion(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

PolygonalRegion::PolygonalRegion(const PolygonalRegion& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

PolygonalRegion::~PolygonalRegion()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void PolygonalRegion::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

PolygonalRegion& PolygonalRegion::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

PolygonalRegion& PolygonalRegion::operator=(const PolygonalRegion& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean PolygonalRegion::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
return val_ptr->n_elements == 0 ;
}

boolean PolygonalRegion::operator==(const PolygonalRegion& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
if (val_ptr == other_value.val_ptr) return TRUE;
return compare_set_of(this, val_ptr->n_elements, &other_value, (other_value.val_ptr)->n_elements, compare_function);
}

TwoDLocation& PolygonalRegion::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.PolygonalRegion using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (TwoDLocation**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new TwoDLocation(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new TwoDLocation;
}
return *val_ptr->value_elements[index_value];
}

TwoDLocation& PolygonalRegion::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
return (*this)[(int)index_value];
}

const TwoDLocation& PolygonalRegion::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.PolygonalRegion using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsSecurity_TypesAndValues.PolygonalRegion: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const TwoDLocation& PolygonalRegion::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
return (*this)[(int)index_value];
}

PolygonalRegion PolygonalRegion::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

PolygonalRegion PolygonalRegion::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

PolygonalRegion PolygonalRegion::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

PolygonalRegion PolygonalRegion::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
PolygonalRegion ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new TwoDLocation(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

PolygonalRegion PolygonalRegion::operator+(const PolygonalRegion& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsSecurity_TypesAndValues.PolygonalRegion concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
PolygonalRegion ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new TwoDLocation(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new TwoDLocation(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

PolygonalRegion PolygonalRegion::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsSecurity_TypesAndValues.PolygonalRegion","element");
PolygonalRegion ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new TwoDLocation(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

PolygonalRegion PolygonalRegion::replace(int index, int len, const PolygonalRegion& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsSecurity_TypesAndValues.PolygonalRegion","element");
PolygonalRegion ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new TwoDLocation(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new TwoDLocation(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new TwoDLocation(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

PolygonalRegion PolygonalRegion::replace(int index, int len, const PolygonalRegion_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void PolygonalRegion::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (TwoDLocation**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new TwoDLocation(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (TwoDLocation**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsSecurity_TypesAndValues.PolygonalRegion: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (TwoDLocation**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean PolygonalRegion::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int PolygonalRegion::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
return val_ptr->n_elements;
}

int PolygonalRegion::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void PolygonalRegion::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void PolygonalRegion::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set of type `@LibItsSecurity_TypesAndValues.PolygonalRegion'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "set of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.PolygonalRegion");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.PolygonalRegion");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* PolygonalRegion::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of type `@LibItsSecurity_TypesAndValues.PolygonalRegion'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void PolygonalRegion::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void PolygonalRegion::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void PolygonalRegion::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
val_ptr->value_elements = (TwoDLocation**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new TwoDLocation;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void PolygonalRegion::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void PolygonalRegion::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int PolygonalRegion::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int PolygonalRegion::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

int PolygonalRegion::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int PolygonalRegion::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    TwoDLocation* val = new TwoDLocation;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (TwoDLocation**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void PolygonalRegion_template::copy_value(const PolygonalRegion& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (TwoDLocation_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new TwoDLocation_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new TwoDLocation_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void PolygonalRegion_template::copy_template(const PolygonalRegion_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (TwoDLocation_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new TwoDLocation_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new TwoDLocation_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new PolygonalRegion_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = other_value.value_set.n_items;
value_set.set_items = new TwoDLocation_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count] = other_value.value_set.set_items[set_count];
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
break;
}
set_selection(other_value);
}

boolean PolygonalRegion_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const PolygonalRegion_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const PolygonalRegion*)value_ptr)[value_index], legacy);
else return ((const PolygonalRegion_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

boolean PolygonalRegion_template::match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const PolygonalRegion_template*)template_ptr)->value_set.set_items[template_index].match((*(const PolygonalRegion*)value_ptr)[value_index], legacy);
else return ((const PolygonalRegion_template*)template_ptr)->value_set.set_items[template_index].is_any_or_omit();
}

void PolygonalRegion_template::log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy)
{
if (value_ptr != NULL && template_ptr != NULL)((const PolygonalRegion_template*)template_ptr)->single_value.value_elements[index_template]->log_match((*(const PolygonalRegion*)value_ptr)[index_value], legacy);
else if (value_ptr != NULL) (*(const PolygonalRegion*)value_ptr)[index_value].log();
else if (template_ptr != NULL) ((const PolygonalRegion_template*)template_ptr)->single_value.value_elements[index_template]->log();
}

PolygonalRegion_template::PolygonalRegion_template()
{
}

PolygonalRegion_template::PolygonalRegion_template(template_sel other_value)
 : Restricted_Length_Template(other_value)
{
check_single_selection(other_value);
}

PolygonalRegion_template::PolygonalRegion_template(null_type)
 : Restricted_Length_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

PolygonalRegion_template::PolygonalRegion_template(const PolygonalRegion& other_value)
{
copy_value(other_value);
}

PolygonalRegion_template::PolygonalRegion_template(const OPTIONAL<PolygonalRegion>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PolygonalRegion&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion from an unbound optional field.");
}
}

PolygonalRegion_template::PolygonalRegion_template(const PolygonalRegion_template& other_value)
 : Restricted_Length_Template()
{
copy_template(other_value);
}

PolygonalRegion_template::~PolygonalRegion_template()
{
clean_up();
}

void PolygonalRegion_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
delete [] value_set.set_items;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

PolygonalRegion_template& PolygonalRegion_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

PolygonalRegion_template& PolygonalRegion_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

PolygonalRegion_template& PolygonalRegion_template::operator=(const PolygonalRegion& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

PolygonalRegion_template& PolygonalRegion_template::operator=(const OPTIONAL<PolygonalRegion>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const PolygonalRegion&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
}
return *this;
}

PolygonalRegion_template& PolygonalRegion_template::operator=(const PolygonalRegion_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

TwoDLocation_template& PolygonalRegion_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.PolygonalRegion using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
    break;
}
return *single_value.value_elements[index_value];
}

TwoDLocation_template& PolygonalRegion_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
return (*this)[(int)index_value];
}

const TwoDLocation_template& PolygonalRegion_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.PolygonalRegion using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const TwoDLocation_template& PolygonalRegion_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
return (*this)[(int)index_value];
}

void PolygonalRegion_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (TwoDLocation_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new TwoDLocation_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new TwoDLocation_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (TwoDLocation_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int PolygonalRegion_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int PolygonalRegion_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case SUPERSET_MATCH:
case SUBSET_MATCH: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = value_set.n_items;
  if (!is_size) { while (elem_count>0 && !value_set.set_items[elem_count-1].is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (value_set.set_items[i].get_selection())
    {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
  if (template_selection==SUPERSET_MATCH) {
    has_any_or_none = TRUE;
   } else {
    int max_size = min_size;
    min_size = 0;
    if (!has_any_or_none) { // [0,max_size]
      switch (length_restriction_type) {
      case NO_LENGTH_RESTRICTION:
        if (max_size==0) return 0;
        TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion with no exact size.", op_name);
      case SINGLE_LENGTH_RESTRICTION:
        if (length_restriction.single_length<=max_size)
          return length_restriction.single_length;
        TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.PolygonalRegion. The maximum size (%d) contradicts the length restriction (%d).", op_name, max_size, length_restriction.single_length);
      case RANGE_LENGTH_RESTRICTION:
        if (max_size==length_restriction.range_length.min_length) {
          return max_size;
        } else if (max_size>length_restriction.range_length.min_length){
          TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion with no exact size.", op_name);
        } else
          TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.PolygonalRegion. Maximum size (%d) contradicts the length restriction (%d..%d).", op_name, max_size, length_restriction.range_length.min_length, length_restriction.range_length.max_length);
      default:
        TTCN_error("Internal error: Template has invalid length restriction type.");
      }
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.PolygonalRegion.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsSecurity_TypesAndValues.PolygonalRegion");
}

boolean PolygonalRegion_template::match(const PolygonalRegion& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_set_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case SUPERSET_MATCH:
case SUBSET_MATCH:
return match_set_of(&other_value, value_length, this, value_set.n_items, match_function_set, legacy);
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
}
return FALSE;
}

boolean PolygonalRegion_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

PolygonalRegion PolygonalRegion_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
PolygonalRegion ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

PolygonalRegion PolygonalRegion_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

PolygonalRegion PolygonalRegion_template::replace(int index, int len, const PolygonalRegion_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

PolygonalRegion PolygonalRegion_template::replace(int index, int len, const PolygonalRegion& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void PolygonalRegion_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new PolygonalRegion_template[list_length];
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = list_length;
value_set.set_items = new TwoDLocation_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
}
set_selection(template_type);
}

PolygonalRegion_template& PolygonalRegion_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
return value_list.list_value[list_index];
}

TwoDLocation_template& PolygonalRegion_template::set_item(unsigned int set_index)
{
if (template_selection != SUPERSET_MATCH && template_selection != SUBSET_MATCH) TTCN_error("Internal error: Accessing a set element of a non-set template of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
if (set_index >= value_set.n_items) TTCN_error("Internal error: Index overflow in a set template of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
return value_set.set_items[set_index];
}

void PolygonalRegion_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log();
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
TTCN_Logger::log_event("%s(", template_selection == SUPERSET_MATCH ? "superset" : "subset");
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++) {
if (set_count > 0) TTCN_Logger::log_event_str(", ");
value_set.set_items[set_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void PolygonalRegion_template::log_match(const PolygonalRegion& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (template_selection == SPECIFIC_VALUE)
  log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
else{
if(previous_size != 0){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::set_logmatch_buffer_len(previous_size);
TTCN_Logger::log_event_str(":=");
}
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
return;
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else {
TTCN_Logger::log_event_str(" unmatched");
if (template_selection == SPECIFIC_VALUE) log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
}
}

void PolygonalRegion_template::encode_text(Text_Buf& text_buf) const
{
encode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
text_buf.push_int(value_set.n_items);
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
}
}

void PolygonalRegion_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
single_value.value_elements = (TwoDLocation_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new TwoDLocation_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new PolygonalRegion_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = text_buf.pull_int().get_val();
value_set.set_items = new TwoDLocation_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
}
}

boolean PolygonalRegion_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean PolygonalRegion_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void PolygonalRegion_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set template type `@LibItsSecurity_TypesAndValues.PolygonalRegion'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "set of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    PolygonalRegion_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    set_size(mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      if (mp->get_elem(p_i)->get_type()!=Module_Param::MP_NotUsed) {
        (*this)[p_i].set_param(*mp->get_elem(p_i));
      }
    }
    break;
  case Module_Param::MP_Superset_Template:
  case Module_Param::MP_Subset_Template:
    set_type(mp->get_type()==Module_Param::MP_Superset_Template ? SUPERSET_MATCH : SUBSET_MATCH, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      set_item(p_i).set_param(*mp->get_elem(p_i));
    }
    break;
  default:
    param.type_error("set of template", "@LibItsSecurity_TypesAndValues.PolygonalRegion");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* PolygonalRegion_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of template type `@LibItsSecurity_TypesAndValues.PolygonalRegion'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void PolygonalRegion_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.PolygonalRegion");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.PolygonalRegion");
}

RegionDictionary::RegionDictionary()
{
enum_value = UNBOUND_VALUE;
}

RegionDictionary::RegionDictionary(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

RegionDictionary::RegionDictionary(enum_type other_value)
{
enum_value = other_value;
}

RegionDictionary::RegionDictionary(const RegionDictionary& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
enum_value = other_value.enum_value;
}

RegionDictionary& RegionDictionary::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

RegionDictionary& RegionDictionary::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

RegionDictionary& RegionDictionary::operator=(const RegionDictionary& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
enum_value = other_value.enum_value;
return *this;
}

boolean RegionDictionary::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
return enum_value == other_value;
}

boolean RegionDictionary::operator==(const RegionDictionary& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
return enum_value == other_value.enum_value;
}

boolean RegionDictionary::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
return enum_value < other_value;
}

boolean RegionDictionary::operator<(const RegionDictionary& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
return enum_value < other_value.enum_value;
}

boolean RegionDictionary::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
return enum_value > other_value;
}

boolean RegionDictionary::operator>(const RegionDictionary& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
return enum_value > other_value.enum_value;
}

const char *RegionDictionary::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__iso__3166__1: return "e_iso_3166_1";
case e__un__stats: return "e_un_stats";
default: return "<unknown>";
}
}

RegionDictionary::enum_type RegionDictionary::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_iso_3166_1")) return e__iso__3166__1;
else if (!strcmp(str_par, "e_un_stats")) return e__un__stats;
else return UNKNOWN_VALUE;
}

boolean RegionDictionary::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
return TRUE;
default:
return FALSE;
}
}

int RegionDictionary::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int RegionDictionary::enum2int(const RegionDictionary& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void RegionDictionary::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.", int_val);
enum_value = (enum_type)int_val;
}

RegionDictionary::operator RegionDictionary::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
return enum_value;
}

void RegionDictionary::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void RegionDictionary::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsSecurity_TypesAndValues.RegionDictionary");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.RegionDictionary.");
  }
}

Module_Param* RegionDictionary::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void RegionDictionary::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
text_buf.push_int(enum_value);
}

void RegionDictionary::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.", enum_value);
}

void RegionDictionary::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RegionDictionary::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int RegionDictionary::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 2, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int RegionDictionary::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 2);
}

int RegionDictionary::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int RegionDictionary::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void RegionDictionary_template::copy_template(const RegionDictionary_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RegionDictionary_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
}
}

RegionDictionary_template::RegionDictionary_template()
{
}

RegionDictionary_template::RegionDictionary_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RegionDictionary_template::RegionDictionary_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!RegionDictionary::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary with unknown numeric value %d.", other_value);
single_value = (RegionDictionary::enum_type)other_value;
}

RegionDictionary_template::RegionDictionary_template(RegionDictionary::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

RegionDictionary_template::RegionDictionary_template(const RegionDictionary& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == RegionDictionary::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
single_value = other_value.enum_value;
}

RegionDictionary_template::RegionDictionary_template(const OPTIONAL<RegionDictionary>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (RegionDictionary::enum_type)(const RegionDictionary&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary from an unbound optional field.");
}
}

RegionDictionary_template::RegionDictionary_template(const RegionDictionary_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

RegionDictionary_template::~RegionDictionary_template()
{
clean_up();
}

boolean RegionDictionary_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean RegionDictionary_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != RegionDictionary::UNBOUND_VALUE;
}

void RegionDictionary_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

RegionDictionary_template& RegionDictionary_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RegionDictionary_template& RegionDictionary_template::operator=(int other_value)
{
if (!RegionDictionary::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (RegionDictionary::enum_type)other_value;
return *this;
}

RegionDictionary_template& RegionDictionary_template::operator=(RegionDictionary::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

RegionDictionary_template& RegionDictionary_template::operator=(const RegionDictionary& other_value)
{
if (other_value.enum_value == RegionDictionary::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

RegionDictionary_template& RegionDictionary_template::operator=(const OPTIONAL<RegionDictionary>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (RegionDictionary::enum_type)(const RegionDictionary&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
}
return *this;
}

RegionDictionary_template& RegionDictionary_template::operator=(const RegionDictionary_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RegionDictionary_template::match(RegionDictionary::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
}
return FALSE;
}

boolean RegionDictionary_template::match(const RegionDictionary& other_value, boolean) const
{
if (other_value.enum_value == RegionDictionary::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary with an unbound value.");
return match(other_value.enum_value);
}

RegionDictionary::enum_type RegionDictionary_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
return single_value;
}

void RegionDictionary_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RegionDictionary_template[list_length];
}

RegionDictionary_template& RegionDictionary_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
return value_list.list_value[list_index];
}

void RegionDictionary_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(RegionDictionary::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RegionDictionary_template::log_match(const RegionDictionary& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void RegionDictionary_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
}
}

void RegionDictionary_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (RegionDictionary::enum_type)text_buf.pull_int().get_val();
if (!RegionDictionary::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RegionDictionary_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsSecurity_TypesAndValues.RegionDictionary.");
}
}

boolean RegionDictionary_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RegionDictionary_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void RegionDictionary_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    RegionDictionary::enum_type enum_val = (enum_name != NULL) ? RegionDictionary::str_to_enum(enum_name) : RegionDictionary::UNKNOWN_VALUE;
    if (RegionDictionary::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RegionDictionary_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    RegionDictionary::enum_type enum_val = RegionDictionary::str_to_enum(mp->get_enumerated());
    if (!RegionDictionary::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.RegionDictionary.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsSecurity_TypesAndValues.RegionDictionary");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RegionDictionary_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(RegionDictionary::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RegionDictionary_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.RegionDictionary");
}

IdentifiedRegion::IdentifiedRegion()
{
  bound_flag = FALSE;
}

IdentifiedRegion::IdentifiedRegion(const RegionDictionary& par_region__dictionary,
    const INTEGER& par_region__identifier,
    const INTEGER& par_local__region)
  :   field_region__dictionary(par_region__dictionary),
  field_region__identifier(par_region__identifier),
  field_local__region(par_local__region)
{
  bound_flag = TRUE;
}

IdentifiedRegion::IdentifiedRegion(const IdentifiedRegion& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.IdentifiedRegion.");
bound_flag = TRUE;
if (other_value.region__dictionary().is_bound()) field_region__dictionary = other_value.region__dictionary();
else field_region__dictionary.clean_up();
if (other_value.region__identifier().is_bound()) field_region__identifier = other_value.region__identifier();
else field_region__identifier.clean_up();
if (other_value.local__region().is_bound()) field_local__region = other_value.local__region();
else field_local__region.clean_up();
}

void IdentifiedRegion::clean_up()
{
field_region__dictionary.clean_up();
field_region__identifier.clean_up();
field_local__region.clean_up();
bound_flag = FALSE;
}

IdentifiedRegion& IdentifiedRegion::operator=(const IdentifiedRegion& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.IdentifiedRegion.");
  bound_flag = TRUE;
  if (other_value.region__dictionary().is_bound()) field_region__dictionary = other_value.region__dictionary();
  else field_region__dictionary.clean_up();
  if (other_value.region__identifier().is_bound()) field_region__identifier = other_value.region__identifier();
  else field_region__identifier.clean_up();
  if (other_value.local__region().is_bound()) field_local__region = other_value.local__region();
  else field_local__region.clean_up();
}
return *this;
}

boolean IdentifiedRegion::operator==(const IdentifiedRegion& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_region__dictionary==other_value.field_region__dictionary
  && field_region__identifier==other_value.field_region__identifier
  && field_local__region==other_value.field_local__region;
}

boolean IdentifiedRegion::is_bound() const
{
if (bound_flag) return TRUE;
if(field_region__dictionary.is_bound()) return TRUE;
if(field_region__identifier.is_bound()) return TRUE;
if(field_local__region.is_bound()) return TRUE;
return FALSE;
}
boolean IdentifiedRegion::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_region__dictionary.is_value()) return FALSE;
if(!field_region__identifier.is_value()) return FALSE;
if(!field_local__region.is_value()) return FALSE;
return TRUE;
}
int IdentifiedRegion::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.IdentifiedRegion");
  return 3;
}

void IdentifiedRegion::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ region_dictionary := ");
field_region__dictionary.log();
TTCN_Logger::log_event_str(", region_identifier := ");
field_region__identifier.log();
TTCN_Logger::log_event_str(", local_region := ");
field_local__region.log();
TTCN_Logger::log_event_str(" }");
}

void IdentifiedRegion::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.IdentifiedRegion'");
    }
    if (strcmp("region_dictionary", param_field) == 0) {
      region__dictionary().set_param(param);
      return;
    } else if (strcmp("region_identifier", param_field) == 0) {
      region__identifier().set_param(param);
      return;
    } else if (strcmp("local_region", param_field) == 0) {
      local__region().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.IdentifiedRegion'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.IdentifiedRegion has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) region__dictionary().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) region__identifier().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) local__region().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "region_dictionary")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          region__dictionary().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "region_identifier")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          region__identifier().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "local_region")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          local__region().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.IdentifiedRegion: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.IdentifiedRegion");
  }
}

Module_Param* IdentifiedRegion::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.IdentifiedRegion'");
    }
    if (strcmp("region_dictionary", param_field) == 0) {
      return region__dictionary().get_param(param_name);
    } else if (strcmp("region_identifier", param_field) == 0) {
      return region__identifier().get_param(param_name);
    } else if (strcmp("local_region", param_field) == 0) {
      return local__region().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.IdentifiedRegion'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_region__dictionary = field_region__dictionary.get_param(param_name);
  mp_field_region__dictionary->set_id(new Module_Param_FieldName(mcopystr("region_dictionary")));
  mp->add_elem(mp_field_region__dictionary);
  Module_Param* mp_field_region__identifier = field_region__identifier.get_param(param_name);
  mp_field_region__identifier->set_id(new Module_Param_FieldName(mcopystr("region_identifier")));
  mp->add_elem(mp_field_region__identifier);
  Module_Param* mp_field_local__region = field_local__region.get_param(param_name);
  mp_field_local__region->set_id(new Module_Param_FieldName(mcopystr("local_region")));
  mp->add_elem(mp_field_local__region);
  return mp;
  }

void IdentifiedRegion::set_implicit_omit()
{
if (region__dictionary().is_bound()) region__dictionary().set_implicit_omit();
if (region__identifier().is_bound()) region__identifier().set_implicit_omit();
if (local__region().is_bound()) local__region().set_implicit_omit();
}

void IdentifiedRegion::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.IdentifiedRegion.");
field_region__dictionary.encode_text(text_buf);
field_region__identifier.encode_text(text_buf);
field_local__region.encode_text(text_buf);
}

void IdentifiedRegion::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_region__dictionary.decode_text(text_buf);
field_region__identifier.decode_text(text_buf);
field_local__region.decode_text(text_buf);
}

void IdentifiedRegion::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void IdentifiedRegion::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int IdentifiedRegion::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_region__dictionary.RAW_decode(RegionDictionary_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_region__identifier.RAW_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_local__region.RAW_decode(IntX_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int IdentifiedRegion::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, RegionDictionary_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt16_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, IntX_descr_.raw);
  encoded_length += field_region__dictionary.RAW_encode(RegionDictionary_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_region__identifier.RAW_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_local__region.RAW_encode(IntX_descr_, *myleaf.body.node.nodes[2]);
  return myleaf.length = encoded_length;
}

int IdentifiedRegion::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.IdentifiedRegion.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "region_dictionary");
    enc_len += field_region__dictionary.JSON_encode(RegionDictionary_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "region_identifier");
    enc_len += field_region__identifier.JSON_encode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "local_region");
    enc_len += field_local__region.JSON_encode(IntX_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int IdentifiedRegion::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (17 == name_len && 0 == strncmp(fld_name, "region_dictionary", name_len)) {
         int ret_val = field_region__dictionary.JSON_decode(RegionDictionary_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "region_dictionary");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "region_identifier", name_len)) {
         int ret_val = field_region__identifier.JSON_decode(LibCommon__BasicTypesAndValues::UInt16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "region_identifier");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "local_region", name_len)) {
         int ret_val = field_local__region.JSON_decode(IntX_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "local_region");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_region__dictionary.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "region_dictionary");
    return JSON_ERROR_FATAL;
  }
if (!field_region__identifier.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "region_identifier");
    return JSON_ERROR_FATAL;
  }
if (!field_local__region.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "local_region");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct IdentifiedRegion_template::single_value_struct {
RegionDictionary_template field_region__dictionary;
INTEGER_template field_region__identifier;
INTEGER_template field_local__region;
};

void IdentifiedRegion_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_region__dictionary = ANY_VALUE;
single_value->field_region__identifier = ANY_VALUE;
single_value->field_local__region = ANY_VALUE;
}
}
}

void IdentifiedRegion_template::copy_value(const IdentifiedRegion& other_value)
{
single_value = new single_value_struct;
if (other_value.region__dictionary().is_bound()) {
  single_value->field_region__dictionary = other_value.region__dictionary();
} else {
  single_value->field_region__dictionary.clean_up();
}
if (other_value.region__identifier().is_bound()) {
  single_value->field_region__identifier = other_value.region__identifier();
} else {
  single_value->field_region__identifier.clean_up();
}
if (other_value.local__region().is_bound()) {
  single_value->field_local__region = other_value.local__region();
} else {
  single_value->field_local__region.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void IdentifiedRegion_template::copy_template(const IdentifiedRegion_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.region__dictionary().get_selection()) {
single_value->field_region__dictionary = other_value.region__dictionary();
} else {
single_value->field_region__dictionary.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.region__identifier().get_selection()) {
single_value->field_region__identifier = other_value.region__identifier();
} else {
single_value->field_region__identifier.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.local__region().get_selection()) {
single_value->field_local__region = other_value.local__region();
} else {
single_value->field_local__region.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new IdentifiedRegion_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion.");
break;
}
set_selection(other_value);
}

IdentifiedRegion_template::IdentifiedRegion_template()
{
}

IdentifiedRegion_template::IdentifiedRegion_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

IdentifiedRegion_template::IdentifiedRegion_template(const IdentifiedRegion& other_value)
{
copy_value(other_value);
}

IdentifiedRegion_template::IdentifiedRegion_template(const OPTIONAL<IdentifiedRegion>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IdentifiedRegion&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion from an unbound optional field.");
}
}

IdentifiedRegion_template::IdentifiedRegion_template(const IdentifiedRegion_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

IdentifiedRegion_template::~IdentifiedRegion_template()
{
clean_up();
}

IdentifiedRegion_template& IdentifiedRegion_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

IdentifiedRegion_template& IdentifiedRegion_template::operator=(const IdentifiedRegion& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

IdentifiedRegion_template& IdentifiedRegion_template::operator=(const OPTIONAL<IdentifiedRegion>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const IdentifiedRegion&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion.");
}
return *this;
}

IdentifiedRegion_template& IdentifiedRegion_template::operator=(const IdentifiedRegion_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean IdentifiedRegion_template::match(const IdentifiedRegion& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.region__dictionary().is_bound()) return FALSE;
if(!single_value->field_region__dictionary.match(other_value.region__dictionary(), legacy))return FALSE;
if(!other_value.region__identifier().is_bound()) return FALSE;
if(!single_value->field_region__identifier.match(other_value.region__identifier(), legacy))return FALSE;
if(!other_value.local__region().is_bound()) return FALSE;
if(!single_value->field_local__region.match(other_value.local__region(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion.");
}
return FALSE;
}

boolean IdentifiedRegion_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_region__dictionary.is_bound()) return TRUE;
if (single_value->field_region__identifier.is_bound()) return TRUE;
if (single_value->field_local__region.is_bound()) return TRUE;
return FALSE;
}

boolean IdentifiedRegion_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_region__dictionary.is_value()) return FALSE;
if (!single_value->field_region__identifier.is_value()) return FALSE;
if (!single_value->field_local__region.is_value()) return FALSE;
return TRUE;
}

void IdentifiedRegion_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

IdentifiedRegion IdentifiedRegion_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion.");
IdentifiedRegion ret_val;
if (single_value->field_region__dictionary.is_bound()) {
ret_val.region__dictionary() = single_value->field_region__dictionary.valueof();
}
if (single_value->field_region__identifier.is_bound()) {
ret_val.region__identifier() = single_value->field_region__identifier.valueof();
}
if (single_value->field_local__region.is_bound()) {
ret_val.local__region() = single_value->field_local__region.valueof();
}
return ret_val;
}

void IdentifiedRegion_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new IdentifiedRegion_template[list_length];
}

IdentifiedRegion_template& IdentifiedRegion_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion.");
return value_list.list_value[list_index];
}

RegionDictionary_template& IdentifiedRegion_template::region__dictionary()
{
set_specific();
return single_value->field_region__dictionary;
}

const RegionDictionary_template& IdentifiedRegion_template::region__dictionary() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field region_dictionary of a non-specific template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion.");
return single_value->field_region__dictionary;
}

INTEGER_template& IdentifiedRegion_template::region__identifier()
{
set_specific();
return single_value->field_region__identifier;
}

const INTEGER_template& IdentifiedRegion_template::region__identifier() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field region_identifier of a non-specific template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion.");
return single_value->field_region__identifier;
}

INTEGER_template& IdentifiedRegion_template::local__region()
{
set_specific();
return single_value->field_local__region;
}

const INTEGER_template& IdentifiedRegion_template::local__region() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field local_region of a non-specific template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion.");
return single_value->field_local__region;
}

int IdentifiedRegion_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion.");
  }
  return 0;
}

void IdentifiedRegion_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ region_dictionary := ");
single_value->field_region__dictionary.log();
TTCN_Logger::log_event_str(", region_identifier := ");
single_value->field_region__identifier.log();
TTCN_Logger::log_event_str(", local_region := ");
single_value->field_local__region.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void IdentifiedRegion_template::log_match(const IdentifiedRegion& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_region__dictionary.match(match_value.region__dictionary(), legacy)){
TTCN_Logger::log_logmatch_info(".region_dictionary");
single_value->field_region__dictionary.log_match(match_value.region__dictionary(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_region__identifier.match(match_value.region__identifier(), legacy)){
TTCN_Logger::log_logmatch_info(".region_identifier");
single_value->field_region__identifier.log_match(match_value.region__identifier(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_local__region.match(match_value.local__region(), legacy)){
TTCN_Logger::log_logmatch_info(".local_region");
single_value->field_local__region.log_match(match_value.local__region(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ region_dictionary := ");
single_value->field_region__dictionary.log_match(match_value.region__dictionary(), legacy);
TTCN_Logger::log_event_str(", region_identifier := ");
single_value->field_region__identifier.log_match(match_value.region__identifier(), legacy);
TTCN_Logger::log_event_str(", local_region := ");
single_value->field_local__region.log_match(match_value.local__region(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void IdentifiedRegion_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_region__dictionary.encode_text(text_buf);
single_value->field_region__identifier.encode_text(text_buf);
single_value->field_local__region.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion.");
}
}

void IdentifiedRegion_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_region__dictionary.decode_text(text_buf);
single_value->field_region__identifier.decode_text(text_buf);
single_value->field_local__region.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new IdentifiedRegion_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion.");
}
}

void IdentifiedRegion_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.IdentifiedRegion'");
    }
    if (strcmp("region_dictionary", param_field) == 0) {
      region__dictionary().set_param(param);
      return;
    } else if (strcmp("region_identifier", param_field) == 0) {
      region__identifier().set_param(param);
      return;
    } else if (strcmp("local_region", param_field) == 0) {
      local__region().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.IdentifiedRegion'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    IdentifiedRegion_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.IdentifiedRegion has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) region__dictionary().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) region__identifier().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) local__region().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "region_dictionary")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          region__dictionary().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "region_identifier")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          region__identifier().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "local_region")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          local__region().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.IdentifiedRegion: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.IdentifiedRegion");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* IdentifiedRegion_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.IdentifiedRegion'");
    }
    if (strcmp("region_dictionary", param_field) == 0) {
      return region__dictionary().get_param(param_name);
    } else if (strcmp("region_identifier", param_field) == 0) {
      return region__identifier().get_param(param_name);
    } else if (strcmp("local_region", param_field) == 0) {
      return local__region().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.IdentifiedRegion'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_region__dictionary = single_value->field_region__dictionary.get_param(param_name);
    mp_field_region__dictionary->set_id(new Module_Param_FieldName(mcopystr("region_dictionary")));
    mp->add_elem(mp_field_region__dictionary);
    Module_Param* mp_field_region__identifier = single_value->field_region__identifier.get_param(param_name);
    mp_field_region__identifier->set_id(new Module_Param_FieldName(mcopystr("region_identifier")));
    mp->add_elem(mp_field_region__identifier);
    Module_Param* mp_field_local__region = single_value->field_local__region.get_param(param_name);
    mp_field_local__region->set_id(new Module_Param_FieldName(mcopystr("local_region")));
    mp->add_elem(mp_field_local__region);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void IdentifiedRegion_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_region__dictionary.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.IdentifiedRegion");
single_value->field_region__identifier.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.IdentifiedRegion");
single_value->field_local__region.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.IdentifiedRegion");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.IdentifiedRegion");
}

boolean IdentifiedRegion_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean IdentifiedRegion_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ValidityRestriction::ValidityRestriction()
{
  bound_flag = FALSE;
}

ValidityRestriction::ValidityRestriction(const ValidityRestrictionType& par_type__,
    const ValidityRestrictionContainer& par_validity)
  :   field_type__(par_type__),
  field_validity(par_validity)
{
  bound_flag = TRUE;
}

ValidityRestriction::ValidityRestriction(const ValidityRestriction& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestriction.");
bound_flag = TRUE;
if (other_value.type__().is_bound()) field_type__ = other_value.type__();
else field_type__.clean_up();
if (other_value.validity().is_bound()) field_validity = other_value.validity();
else field_validity.clean_up();
}

void ValidityRestriction::clean_up()
{
field_type__.clean_up();
field_validity.clean_up();
bound_flag = FALSE;
}

ValidityRestriction& ValidityRestriction::operator=(const ValidityRestriction& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestriction.");
  bound_flag = TRUE;
  if (other_value.type__().is_bound()) field_type__ = other_value.type__();
  else field_type__.clean_up();
  if (other_value.validity().is_bound()) field_validity = other_value.validity();
  else field_validity.clean_up();
}
return *this;
}

boolean ValidityRestriction::operator==(const ValidityRestriction& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_type__==other_value.field_type__
  && field_validity==other_value.field_validity;
}

boolean ValidityRestriction::is_bound() const
{
if (bound_flag) return TRUE;
if(field_type__.is_bound()) return TRUE;
if(field_validity.is_bound()) return TRUE;
return FALSE;
}
boolean ValidityRestriction::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_type__.is_value()) return FALSE;
if(!field_validity.is_value()) return FALSE;
return TRUE;
}
int ValidityRestriction::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.ValidityRestriction");
  return 2;
}

void ValidityRestriction::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ type_ := ");
field_type__.log();
TTCN_Logger::log_event_str(", validity := ");
field_validity.log();
TTCN_Logger::log_event_str(" }");
}

void ValidityRestriction::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.ValidityRestriction'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("validity", param_field) == 0) {
      validity().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ValidityRestriction'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.ValidityRestriction has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) validity().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "validity")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          validity().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.ValidityRestriction: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.ValidityRestriction");
  }
}

Module_Param* ValidityRestriction::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.ValidityRestriction'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("validity", param_field) == 0) {
      return validity().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ValidityRestriction'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_type__ = field_type__.get_param(param_name);
  mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
  mp->add_elem(mp_field_type__);
  Module_Param* mp_field_validity = field_validity.get_param(param_name);
  mp_field_validity->set_id(new Module_Param_FieldName(mcopystr("validity")));
  mp->add_elem(mp_field_validity);
  return mp;
  }

void ValidityRestriction::set_implicit_omit()
{
if (type__().is_bound()) type__().set_implicit_omit();
if (validity().is_bound()) validity().set_implicit_omit();
}

void ValidityRestriction::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.ValidityRestriction.");
field_type__.encode_text(text_buf);
field_validity.encode_text(text_buf);
}

void ValidityRestriction::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_type__.decode_text(text_buf);
field_validity.decode_text(text_buf);
}

void ValidityRestriction::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ValidityRestriction::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ValidityRestriction::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_type__.RAW_decode(ValidityRestrictionType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_validity.RAW_decode(ValidityRestrictionContainer_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ValidityRestriction::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, ValidityRestrictionType_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, ValidityRestrictionContainer_descr_.raw);
  encoded_length += field_type__.RAW_encode(ValidityRestrictionType_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_validity.RAW_encode(ValidityRestrictionContainer_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int ValidityRestriction::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestriction.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "type_");
    enc_len += field_type__.JSON_encode(ValidityRestrictionType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "validity");
    enc_len += field_validity.JSON_encode(ValidityRestrictionContainer_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ValidityRestriction::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (5 == name_len && 0 == strncmp(fld_name, "type_", name_len)) {
         int ret_val = field_type__.JSON_decode(ValidityRestrictionType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "type_");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "validity", name_len)) {
         int ret_val = field_validity.JSON_decode(ValidityRestrictionContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "validity");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_type__.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "type_");
    return JSON_ERROR_FATAL;
  }
if (!field_validity.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "validity");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ValidityRestriction_template::single_value_struct {
ValidityRestrictionType_template field_type__;
ValidityRestrictionContainer_template field_validity;
};

void ValidityRestriction_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_type__ = ANY_VALUE;
single_value->field_validity = ANY_VALUE;
}
}
}

void ValidityRestriction_template::copy_value(const ValidityRestriction& other_value)
{
single_value = new single_value_struct;
if (other_value.type__().is_bound()) {
  single_value->field_type__ = other_value.type__();
} else {
  single_value->field_type__.clean_up();
}
if (other_value.validity().is_bound()) {
  single_value->field_validity = other_value.validity();
} else {
  single_value->field_validity.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ValidityRestriction_template::copy_template(const ValidityRestriction_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.type__().get_selection()) {
single_value->field_type__ = other_value.type__();
} else {
single_value->field_type__.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.validity().get_selection()) {
single_value->field_validity = other_value.validity();
} else {
single_value->field_validity.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ValidityRestriction_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ValidityRestriction.");
break;
}
set_selection(other_value);
}

ValidityRestriction_template::ValidityRestriction_template()
{
}

ValidityRestriction_template::ValidityRestriction_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ValidityRestriction_template::ValidityRestriction_template(const ValidityRestriction& other_value)
{
copy_value(other_value);
}

ValidityRestriction_template::ValidityRestriction_template(const OPTIONAL<ValidityRestriction>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ValidityRestriction&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.ValidityRestriction from an unbound optional field.");
}
}

ValidityRestriction_template::ValidityRestriction_template(const ValidityRestriction_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ValidityRestriction_template::~ValidityRestriction_template()
{
clean_up();
}

ValidityRestriction_template& ValidityRestriction_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ValidityRestriction_template& ValidityRestriction_template::operator=(const ValidityRestriction& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ValidityRestriction_template& ValidityRestriction_template::operator=(const OPTIONAL<ValidityRestriction>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ValidityRestriction&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.ValidityRestriction.");
}
return *this;
}

ValidityRestriction_template& ValidityRestriction_template::operator=(const ValidityRestriction_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ValidityRestriction_template::match(const ValidityRestriction& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.type__().is_bound()) return FALSE;
if(!single_value->field_type__.match(other_value.type__(), legacy))return FALSE;
if(!other_value.validity().is_bound()) return FALSE;
if(!single_value->field_validity.match(other_value.validity(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ValidityRestriction.");
}
return FALSE;
}

boolean ValidityRestriction_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_type__.is_bound()) return TRUE;
if (single_value->field_validity.is_bound()) return TRUE;
return FALSE;
}

boolean ValidityRestriction_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_type__.is_value()) return FALSE;
if (!single_value->field_validity.is_value()) return FALSE;
return TRUE;
}

void ValidityRestriction_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ValidityRestriction ValidityRestriction_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.ValidityRestriction.");
ValidityRestriction ret_val;
if (single_value->field_type__.is_bound()) {
ret_val.type__() = single_value->field_type__.valueof();
}
if (single_value->field_validity.is_bound()) {
ret_val.validity() = single_value->field_validity.valueof();
}
return ret_val;
}

void ValidityRestriction_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.ValidityRestriction.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ValidityRestriction_template[list_length];
}

ValidityRestriction_template& ValidityRestriction_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.ValidityRestriction.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.ValidityRestriction.");
return value_list.list_value[list_index];
}

ValidityRestrictionType_template& ValidityRestriction_template::type__()
{
set_specific();
return single_value->field_type__;
}

const ValidityRestrictionType_template& ValidityRestriction_template::type__() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field type_ of a non-specific template of type @LibItsSecurity_TypesAndValues.ValidityRestriction.");
return single_value->field_type__;
}

ValidityRestrictionContainer_template& ValidityRestriction_template::validity()
{
set_specific();
return single_value->field_validity;
}

const ValidityRestrictionContainer_template& ValidityRestriction_template::validity() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field validity of a non-specific template of type @LibItsSecurity_TypesAndValues.ValidityRestriction.");
return single_value->field_validity;
}

int ValidityRestriction_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ValidityRestriction which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ValidityRestriction containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ValidityRestriction containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ValidityRestriction containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ValidityRestriction containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ValidityRestriction containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ValidityRestriction.");
  }
  return 0;
}

void ValidityRestriction_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log();
TTCN_Logger::log_event_str(", validity := ");
single_value->field_validity.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ValidityRestriction_template::log_match(const ValidityRestriction& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_type__.match(match_value.type__(), legacy)){
TTCN_Logger::log_logmatch_info(".type_");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_validity.match(match_value.validity(), legacy)){
TTCN_Logger::log_logmatch_info(".validity");
single_value->field_validity.log_match(match_value.validity(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::log_event_str(", validity := ");
single_value->field_validity.log_match(match_value.validity(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ValidityRestriction_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_type__.encode_text(text_buf);
single_value->field_validity.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ValidityRestriction.");
}
}

void ValidityRestriction_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_type__.decode_text(text_buf);
single_value->field_validity.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ValidityRestriction_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.ValidityRestriction.");
}
}

void ValidityRestriction_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.ValidityRestriction'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("validity", param_field) == 0) {
      validity().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.ValidityRestriction'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ValidityRestriction_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.ValidityRestriction has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) validity().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "validity")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          validity().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.ValidityRestriction: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.ValidityRestriction");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ValidityRestriction_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.ValidityRestriction'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("validity", param_field) == 0) {
      return validity().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ValidityRestriction'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_type__ = single_value->field_type__.get_param(param_name);
    mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
    mp->add_elem(mp_field_type__);
    Module_Param* mp_field_validity = single_value->field_validity.get_param(param_name);
    mp_field_validity->set_id(new Module_Param_FieldName(mcopystr("validity")));
    mp->add_elem(mp_field_validity);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ValidityRestriction_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_type__.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ValidityRestriction");
single_value->field_validity.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ValidityRestriction");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.ValidityRestriction");
}

boolean ValidityRestriction_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ValidityRestriction_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

Certificate::Certificate()
{
  bound_flag = FALSE;
}

Certificate::Certificate(const INTEGER& par_version,
    const SignerInfo& par_signer__info,
    const SubjectInfo& par_subject__info,
    const SubjectAttributes& par_subject__attributes,
    const ValidityRestrictions& par_validity__restrictions,
    const Signature& par_signature__)
  :   field_version(par_version),
  field_signer__info(par_signer__info),
  field_subject__info(par_subject__info),
  field_subject__attributes(par_subject__attributes),
  field_validity__restrictions(par_validity__restrictions),
  field_signature__(par_signature__)
{
  bound_flag = TRUE;
}

Certificate::Certificate(const Certificate& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.Certificate.");
bound_flag = TRUE;
if (other_value.version().is_bound()) field_version = other_value.version();
else field_version.clean_up();
if (other_value.signer__info().is_bound()) field_signer__info = other_value.signer__info();
else field_signer__info.clean_up();
if (other_value.subject__info().is_bound()) field_subject__info = other_value.subject__info();
else field_subject__info.clean_up();
if (other_value.subject__attributes().is_bound()) field_subject__attributes = other_value.subject__attributes();
else field_subject__attributes.clean_up();
if (other_value.validity__restrictions().is_bound()) field_validity__restrictions = other_value.validity__restrictions();
else field_validity__restrictions.clean_up();
if (other_value.signature__().is_bound()) field_signature__ = other_value.signature__();
else field_signature__.clean_up();
}

void Certificate::clean_up()
{
field_version.clean_up();
field_signer__info.clean_up();
field_subject__info.clean_up();
field_subject__attributes.clean_up();
field_validity__restrictions.clean_up();
field_signature__.clean_up();
bound_flag = FALSE;
}

Certificate& Certificate::operator=(const Certificate& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.Certificate.");
  bound_flag = TRUE;
  if (other_value.version().is_bound()) field_version = other_value.version();
  else field_version.clean_up();
  if (other_value.signer__info().is_bound()) field_signer__info = other_value.signer__info();
  else field_signer__info.clean_up();
  if (other_value.subject__info().is_bound()) field_subject__info = other_value.subject__info();
  else field_subject__info.clean_up();
  if (other_value.subject__attributes().is_bound()) field_subject__attributes = other_value.subject__attributes();
  else field_subject__attributes.clean_up();
  if (other_value.validity__restrictions().is_bound()) field_validity__restrictions = other_value.validity__restrictions();
  else field_validity__restrictions.clean_up();
  if (other_value.signature__().is_bound()) field_signature__ = other_value.signature__();
  else field_signature__.clean_up();
}
return *this;
}

boolean Certificate::operator==(const Certificate& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_version==other_value.field_version
  && field_signer__info==other_value.field_signer__info
  && field_subject__info==other_value.field_subject__info
  && field_subject__attributes==other_value.field_subject__attributes
  && field_validity__restrictions==other_value.field_validity__restrictions
  && field_signature__==other_value.field_signature__;
}

boolean Certificate::is_bound() const
{
if (bound_flag) return TRUE;
if(field_version.is_bound()) return TRUE;
if(field_signer__info.is_bound()) return TRUE;
if(field_subject__info.is_bound()) return TRUE;
if(field_subject__attributes.is_bound()) return TRUE;
if(field_validity__restrictions.is_bound()) return TRUE;
if(field_signature__.is_bound()) return TRUE;
return FALSE;
}
boolean Certificate::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_version.is_value()) return FALSE;
if(!field_signer__info.is_value()) return FALSE;
if(!field_subject__info.is_value()) return FALSE;
if(!field_subject__attributes.is_value()) return FALSE;
if(!field_validity__restrictions.is_value()) return FALSE;
if(!field_signature__.is_value()) return FALSE;
return TRUE;
}
int Certificate::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.Certificate");
  return 6;
}

void Certificate::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ version := ");
field_version.log();
TTCN_Logger::log_event_str(", signer_info := ");
field_signer__info.log();
TTCN_Logger::log_event_str(", subject_info := ");
field_subject__info.log();
TTCN_Logger::log_event_str(", subject_attributes := ");
field_subject__attributes.log();
TTCN_Logger::log_event_str(", validity_restrictions := ");
field_validity__restrictions.log();
TTCN_Logger::log_event_str(", signature_ := ");
field_signature__.log();
TTCN_Logger::log_event_str(" }");
}

void Certificate::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.Certificate'");
    }
    if (strcmp("version", param_field) == 0) {
      version().set_param(param);
      return;
    } else if (strcmp("signer_info", param_field) == 0) {
      signer__info().set_param(param);
      return;
    } else if (strcmp("subject_info", param_field) == 0) {
      subject__info().set_param(param);
      return;
    } else if (strcmp("subject_attributes", param_field) == 0) {
      subject__attributes().set_param(param);
      return;
    } else if (strcmp("validity_restrictions", param_field) == 0) {
      validity__restrictions().set_param(param);
      return;
    } else if (strcmp("signature_", param_field) == 0) {
      signature__().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.Certificate'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.Certificate has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) signer__info().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) subject__info().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) subject__attributes().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) validity__restrictions().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) signature__().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signer_info")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signer__info().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "subject_info")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          subject__info().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "subject_attributes")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          subject__attributes().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "validity_restrictions")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          validity__restrictions().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signature_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signature__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.Certificate: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.Certificate");
  }
}

Module_Param* Certificate::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.Certificate'");
    }
    if (strcmp("version", param_field) == 0) {
      return version().get_param(param_name);
    } else if (strcmp("signer_info", param_field) == 0) {
      return signer__info().get_param(param_name);
    } else if (strcmp("subject_info", param_field) == 0) {
      return subject__info().get_param(param_name);
    } else if (strcmp("subject_attributes", param_field) == 0) {
      return subject__attributes().get_param(param_name);
    } else if (strcmp("validity_restrictions", param_field) == 0) {
      return validity__restrictions().get_param(param_name);
    } else if (strcmp("signature_", param_field) == 0) {
      return signature__().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.Certificate'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_version = field_version.get_param(param_name);
  mp_field_version->set_id(new Module_Param_FieldName(mcopystr("version")));
  mp->add_elem(mp_field_version);
  Module_Param* mp_field_signer__info = field_signer__info.get_param(param_name);
  mp_field_signer__info->set_id(new Module_Param_FieldName(mcopystr("signer_info")));
  mp->add_elem(mp_field_signer__info);
  Module_Param* mp_field_subject__info = field_subject__info.get_param(param_name);
  mp_field_subject__info->set_id(new Module_Param_FieldName(mcopystr("subject_info")));
  mp->add_elem(mp_field_subject__info);
  Module_Param* mp_field_subject__attributes = field_subject__attributes.get_param(param_name);
  mp_field_subject__attributes->set_id(new Module_Param_FieldName(mcopystr("subject_attributes")));
  mp->add_elem(mp_field_subject__attributes);
  Module_Param* mp_field_validity__restrictions = field_validity__restrictions.get_param(param_name);
  mp_field_validity__restrictions->set_id(new Module_Param_FieldName(mcopystr("validity_restrictions")));
  mp->add_elem(mp_field_validity__restrictions);
  Module_Param* mp_field_signature__ = field_signature__.get_param(param_name);
  mp_field_signature__->set_id(new Module_Param_FieldName(mcopystr("signature_")));
  mp->add_elem(mp_field_signature__);
  return mp;
  }

void Certificate::set_implicit_omit()
{
if (version().is_bound()) version().set_implicit_omit();
if (signer__info().is_bound()) signer__info().set_implicit_omit();
if (subject__info().is_bound()) subject__info().set_implicit_omit();
if (subject__attributes().is_bound()) subject__attributes().set_implicit_omit();
if (validity__restrictions().is_bound()) validity__restrictions().set_implicit_omit();
if (signature__().is_bound()) signature__().set_implicit_omit();
}

void Certificate::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.Certificate.");
field_version.encode_text(text_buf);
field_signer__info.encode_text(text_buf);
field_subject__info.encode_text(text_buf);
field_subject__attributes.encode_text(text_buf);
field_validity__restrictions.encode_text(text_buf);
field_signature__.encode_text(text_buf);
}

void Certificate::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_version.decode_text(text_buf);
field_signer__info.decode_text(text_buf);
field_subject__info.decode_text(text_buf);
field_subject__attributes.decode_text(text_buf);
field_validity__restrictions.decode_text(text_buf);
field_signature__.decode_text(text_buf);
}

void Certificate::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Certificate::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int Certificate::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_version.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_signer__info.RAW_decode(SignerInfo_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_subject__info.RAW_decode(SubjectInfo_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_subject__attributes.RAW_decode(SubjectAttributes_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_validity__restrictions.RAW_decode(ValidityRestrictions_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_signature__.RAW_decode(Signature_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int Certificate::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 6;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(6);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, SignerInfo_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, SubjectInfo_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, SubjectAttributes_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, ValidityRestrictions_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, Signature_descr_.raw);
  encoded_length += field_version.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_signer__info.RAW_encode(SignerInfo_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_subject__info.RAW_encode(SubjectInfo_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_subject__attributes.RAW_encode(SubjectAttributes_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_validity__restrictions.RAW_encode(ValidityRestrictions_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_signature__.RAW_encode(Signature_descr_, *myleaf.body.node.nodes[5]);
  return myleaf.length = encoded_length;
}

int Certificate::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.Certificate.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "version");
    enc_len += field_version.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "signer_info");
    enc_len += field_signer__info.JSON_encode(SignerInfo_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "subject_info");
    enc_len += field_subject__info.JSON_encode(SubjectInfo_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "subject_attributes");
    enc_len += field_subject__attributes.JSON_encode(SubjectAttributes_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "validity_restrictions");
    enc_len += field_validity__restrictions.JSON_encode(ValidityRestrictions_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "signature_");
    enc_len += field_signature__.JSON_encode(Signature_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Certificate::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (7 == name_len && 0 == strncmp(fld_name, "version", name_len)) {
         int ret_val = field_version.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "version");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "signer_info", name_len)) {
         int ret_val = field_signer__info.JSON_decode(SignerInfo_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "signer_info");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "subject_info", name_len)) {
         int ret_val = field_subject__info.JSON_decode(SubjectInfo_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "subject_info");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "subject_attributes", name_len)) {
         int ret_val = field_subject__attributes.JSON_decode(SubjectAttributes_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "subject_attributes");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (21 == name_len && 0 == strncmp(fld_name, "validity_restrictions", name_len)) {
         int ret_val = field_validity__restrictions.JSON_decode(ValidityRestrictions_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "validity_restrictions");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (10 == name_len && 0 == strncmp(fld_name, "signature_", name_len)) {
         int ret_val = field_signature__.JSON_decode(Signature_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "signature_");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_version.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "version");
    return JSON_ERROR_FATAL;
  }
if (!field_signer__info.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "signer_info");
    return JSON_ERROR_FATAL;
  }
if (!field_subject__info.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "subject_info");
    return JSON_ERROR_FATAL;
  }
if (!field_subject__attributes.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "subject_attributes");
    return JSON_ERROR_FATAL;
  }
if (!field_validity__restrictions.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "validity_restrictions");
    return JSON_ERROR_FATAL;
  }
if (!field_signature__.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "signature_");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct Certificate_template::single_value_struct {
INTEGER_template field_version;
SignerInfo_template field_signer__info;
SubjectInfo_template field_subject__info;
SubjectAttributes_template field_subject__attributes;
ValidityRestrictions_template field_validity__restrictions;
Signature_template field_signature__;
};

void Certificate_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_version = ANY_VALUE;
single_value->field_signer__info = ANY_VALUE;
single_value->field_subject__info = ANY_VALUE;
single_value->field_subject__attributes = ANY_VALUE;
single_value->field_validity__restrictions = ANY_VALUE;
single_value->field_signature__ = ANY_VALUE;
}
}
}

void Certificate_template::copy_value(const Certificate& other_value)
{
single_value = new single_value_struct;
if (other_value.version().is_bound()) {
  single_value->field_version = other_value.version();
} else {
  single_value->field_version.clean_up();
}
if (other_value.signer__info().is_bound()) {
  single_value->field_signer__info = other_value.signer__info();
} else {
  single_value->field_signer__info.clean_up();
}
if (other_value.subject__info().is_bound()) {
  single_value->field_subject__info = other_value.subject__info();
} else {
  single_value->field_subject__info.clean_up();
}
if (other_value.subject__attributes().is_bound()) {
  single_value->field_subject__attributes = other_value.subject__attributes();
} else {
  single_value->field_subject__attributes.clean_up();
}
if (other_value.validity__restrictions().is_bound()) {
  single_value->field_validity__restrictions = other_value.validity__restrictions();
} else {
  single_value->field_validity__restrictions.clean_up();
}
if (other_value.signature__().is_bound()) {
  single_value->field_signature__ = other_value.signature__();
} else {
  single_value->field_signature__.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Certificate_template::copy_template(const Certificate_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.version().get_selection()) {
single_value->field_version = other_value.version();
} else {
single_value->field_version.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.signer__info().get_selection()) {
single_value->field_signer__info = other_value.signer__info();
} else {
single_value->field_signer__info.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.subject__info().get_selection()) {
single_value->field_subject__info = other_value.subject__info();
} else {
single_value->field_subject__info.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.subject__attributes().get_selection()) {
single_value->field_subject__attributes = other_value.subject__attributes();
} else {
single_value->field_subject__attributes.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.validity__restrictions().get_selection()) {
single_value->field_validity__restrictions = other_value.validity__restrictions();
} else {
single_value->field_validity__restrictions.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.signature__().get_selection()) {
single_value->field_signature__ = other_value.signature__();
} else {
single_value->field_signature__.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Certificate_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.Certificate.");
break;
}
set_selection(other_value);
}

Certificate_template::Certificate_template()
{
}

Certificate_template::Certificate_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Certificate_template::Certificate_template(const Certificate& other_value)
{
copy_value(other_value);
}

Certificate_template::Certificate_template(const OPTIONAL<Certificate>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Certificate&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.Certificate from an unbound optional field.");
}
}

Certificate_template::Certificate_template(const Certificate_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Certificate_template::~Certificate_template()
{
clean_up();
}

Certificate_template& Certificate_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Certificate_template& Certificate_template::operator=(const Certificate& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Certificate_template& Certificate_template::operator=(const OPTIONAL<Certificate>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Certificate&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.Certificate.");
}
return *this;
}

Certificate_template& Certificate_template::operator=(const Certificate_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Certificate_template::match(const Certificate& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.version().is_bound()) return FALSE;
if(!single_value->field_version.match(other_value.version(), legacy))return FALSE;
if(!other_value.signer__info().is_bound()) return FALSE;
if(!single_value->field_signer__info.match(other_value.signer__info(), legacy))return FALSE;
if(!other_value.subject__info().is_bound()) return FALSE;
if(!single_value->field_subject__info.match(other_value.subject__info(), legacy))return FALSE;
if(!other_value.subject__attributes().is_bound()) return FALSE;
if(!single_value->field_subject__attributes.match(other_value.subject__attributes(), legacy))return FALSE;
if(!other_value.validity__restrictions().is_bound()) return FALSE;
if(!single_value->field_validity__restrictions.match(other_value.validity__restrictions(), legacy))return FALSE;
if(!other_value.signature__().is_bound()) return FALSE;
if(!single_value->field_signature__.match(other_value.signature__(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.Certificate.");
}
return FALSE;
}

boolean Certificate_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_version.is_bound()) return TRUE;
if (single_value->field_signer__info.is_bound()) return TRUE;
if (single_value->field_subject__info.is_bound()) return TRUE;
if (single_value->field_subject__attributes.is_bound()) return TRUE;
if (single_value->field_validity__restrictions.is_bound()) return TRUE;
if (single_value->field_signature__.is_bound()) return TRUE;
return FALSE;
}

boolean Certificate_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_version.is_value()) return FALSE;
if (!single_value->field_signer__info.is_value()) return FALSE;
if (!single_value->field_subject__info.is_value()) return FALSE;
if (!single_value->field_subject__attributes.is_value()) return FALSE;
if (!single_value->field_validity__restrictions.is_value()) return FALSE;
if (!single_value->field_signature__.is_value()) return FALSE;
return TRUE;
}

void Certificate_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Certificate Certificate_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.Certificate.");
Certificate ret_val;
if (single_value->field_version.is_bound()) {
ret_val.version() = single_value->field_version.valueof();
}
if (single_value->field_signer__info.is_bound()) {
ret_val.signer__info() = single_value->field_signer__info.valueof();
}
if (single_value->field_subject__info.is_bound()) {
ret_val.subject__info() = single_value->field_subject__info.valueof();
}
if (single_value->field_subject__attributes.is_bound()) {
ret_val.subject__attributes() = single_value->field_subject__attributes.valueof();
}
if (single_value->field_validity__restrictions.is_bound()) {
ret_val.validity__restrictions() = single_value->field_validity__restrictions.valueof();
}
if (single_value->field_signature__.is_bound()) {
ret_val.signature__() = single_value->field_signature__.valueof();
}
return ret_val;
}

void Certificate_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.Certificate.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Certificate_template[list_length];
}

Certificate_template& Certificate_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.Certificate.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.Certificate.");
return value_list.list_value[list_index];
}

INTEGER_template& Certificate_template::version()
{
set_specific();
return single_value->field_version;
}

const INTEGER_template& Certificate_template::version() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field version of a non-specific template of type @LibItsSecurity_TypesAndValues.Certificate.");
return single_value->field_version;
}

SignerInfo_template& Certificate_template::signer__info()
{
set_specific();
return single_value->field_signer__info;
}

const SignerInfo_template& Certificate_template::signer__info() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field signer_info of a non-specific template of type @LibItsSecurity_TypesAndValues.Certificate.");
return single_value->field_signer__info;
}

SubjectInfo_template& Certificate_template::subject__info()
{
set_specific();
return single_value->field_subject__info;
}

const SubjectInfo_template& Certificate_template::subject__info() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field subject_info of a non-specific template of type @LibItsSecurity_TypesAndValues.Certificate.");
return single_value->field_subject__info;
}

SubjectAttributes_template& Certificate_template::subject__attributes()
{
set_specific();
return single_value->field_subject__attributes;
}

const SubjectAttributes_template& Certificate_template::subject__attributes() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field subject_attributes of a non-specific template of type @LibItsSecurity_TypesAndValues.Certificate.");
return single_value->field_subject__attributes;
}

ValidityRestrictions_template& Certificate_template::validity__restrictions()
{
set_specific();
return single_value->field_validity__restrictions;
}

const ValidityRestrictions_template& Certificate_template::validity__restrictions() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field validity_restrictions of a non-specific template of type @LibItsSecurity_TypesAndValues.Certificate.");
return single_value->field_validity__restrictions;
}

Signature_template& Certificate_template::signature__()
{
set_specific();
return single_value->field_signature__;
}

const Signature_template& Certificate_template::signature__() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field signature_ of a non-specific template of type @LibItsSecurity_TypesAndValues.Certificate.");
return single_value->field_signature__;
}

int Certificate_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Certificate which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 6;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Certificate containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Certificate containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Certificate containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Certificate containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Certificate containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.Certificate.");
  }
  return 0;
}

void Certificate_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log();
TTCN_Logger::log_event_str(", signer_info := ");
single_value->field_signer__info.log();
TTCN_Logger::log_event_str(", subject_info := ");
single_value->field_subject__info.log();
TTCN_Logger::log_event_str(", subject_attributes := ");
single_value->field_subject__attributes.log();
TTCN_Logger::log_event_str(", validity_restrictions := ");
single_value->field_validity__restrictions.log();
TTCN_Logger::log_event_str(", signature_ := ");
single_value->field_signature__.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Certificate_template::log_match(const Certificate& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_version.match(match_value.version(), legacy)){
TTCN_Logger::log_logmatch_info(".version");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_signer__info.match(match_value.signer__info(), legacy)){
TTCN_Logger::log_logmatch_info(".signer_info");
single_value->field_signer__info.log_match(match_value.signer__info(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_subject__info.match(match_value.subject__info(), legacy)){
TTCN_Logger::log_logmatch_info(".subject_info");
single_value->field_subject__info.log_match(match_value.subject__info(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_subject__attributes.match(match_value.subject__attributes(), legacy)){
TTCN_Logger::log_logmatch_info(".subject_attributes");
single_value->field_subject__attributes.log_match(match_value.subject__attributes(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_validity__restrictions.match(match_value.validity__restrictions(), legacy)){
TTCN_Logger::log_logmatch_info(".validity_restrictions");
single_value->field_validity__restrictions.log_match(match_value.validity__restrictions(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_signature__.match(match_value.signature__(), legacy)){
TTCN_Logger::log_logmatch_info(".signature_");
single_value->field_signature__.log_match(match_value.signature__(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::log_event_str(", signer_info := ");
single_value->field_signer__info.log_match(match_value.signer__info(), legacy);
TTCN_Logger::log_event_str(", subject_info := ");
single_value->field_subject__info.log_match(match_value.subject__info(), legacy);
TTCN_Logger::log_event_str(", subject_attributes := ");
single_value->field_subject__attributes.log_match(match_value.subject__attributes(), legacy);
TTCN_Logger::log_event_str(", validity_restrictions := ");
single_value->field_validity__restrictions.log_match(match_value.validity__restrictions(), legacy);
TTCN_Logger::log_event_str(", signature_ := ");
single_value->field_signature__.log_match(match_value.signature__(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Certificate_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_version.encode_text(text_buf);
single_value->field_signer__info.encode_text(text_buf);
single_value->field_subject__info.encode_text(text_buf);
single_value->field_subject__attributes.encode_text(text_buf);
single_value->field_validity__restrictions.encode_text(text_buf);
single_value->field_signature__.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.Certificate.");
}
}

void Certificate_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_version.decode_text(text_buf);
single_value->field_signer__info.decode_text(text_buf);
single_value->field_subject__info.decode_text(text_buf);
single_value->field_subject__attributes.decode_text(text_buf);
single_value->field_validity__restrictions.decode_text(text_buf);
single_value->field_signature__.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Certificate_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.Certificate.");
}
}

void Certificate_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.Certificate'");
    }
    if (strcmp("version", param_field) == 0) {
      version().set_param(param);
      return;
    } else if (strcmp("signer_info", param_field) == 0) {
      signer__info().set_param(param);
      return;
    } else if (strcmp("subject_info", param_field) == 0) {
      subject__info().set_param(param);
      return;
    } else if (strcmp("subject_attributes", param_field) == 0) {
      subject__attributes().set_param(param);
      return;
    } else if (strcmp("validity_restrictions", param_field) == 0) {
      validity__restrictions().set_param(param);
      return;
    } else if (strcmp("signature_", param_field) == 0) {
      signature__().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.Certificate'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Certificate_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.Certificate has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) signer__info().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) subject__info().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) subject__attributes().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) validity__restrictions().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) signature__().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signer_info")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signer__info().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "subject_info")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          subject__info().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "subject_attributes")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          subject__attributes().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "validity_restrictions")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          validity__restrictions().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signature_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signature__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.Certificate: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.Certificate");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Certificate_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.Certificate'");
    }
    if (strcmp("version", param_field) == 0) {
      return version().get_param(param_name);
    } else if (strcmp("signer_info", param_field) == 0) {
      return signer__info().get_param(param_name);
    } else if (strcmp("subject_info", param_field) == 0) {
      return subject__info().get_param(param_name);
    } else if (strcmp("subject_attributes", param_field) == 0) {
      return subject__attributes().get_param(param_name);
    } else if (strcmp("validity_restrictions", param_field) == 0) {
      return validity__restrictions().get_param(param_name);
    } else if (strcmp("signature_", param_field) == 0) {
      return signature__().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.Certificate'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_version = single_value->field_version.get_param(param_name);
    mp_field_version->set_id(new Module_Param_FieldName(mcopystr("version")));
    mp->add_elem(mp_field_version);
    Module_Param* mp_field_signer__info = single_value->field_signer__info.get_param(param_name);
    mp_field_signer__info->set_id(new Module_Param_FieldName(mcopystr("signer_info")));
    mp->add_elem(mp_field_signer__info);
    Module_Param* mp_field_subject__info = single_value->field_subject__info.get_param(param_name);
    mp_field_subject__info->set_id(new Module_Param_FieldName(mcopystr("subject_info")));
    mp->add_elem(mp_field_subject__info);
    Module_Param* mp_field_subject__attributes = single_value->field_subject__attributes.get_param(param_name);
    mp_field_subject__attributes->set_id(new Module_Param_FieldName(mcopystr("subject_attributes")));
    mp->add_elem(mp_field_subject__attributes);
    Module_Param* mp_field_validity__restrictions = single_value->field_validity__restrictions.get_param(param_name);
    mp_field_validity__restrictions->set_id(new Module_Param_FieldName(mcopystr("validity_restrictions")));
    mp->add_elem(mp_field_validity__restrictions);
    Module_Param* mp_field_signature__ = single_value->field_signature__.get_param(param_name);
    mp_field_signature__->set_id(new Module_Param_FieldName(mcopystr("signature_")));
    mp->add_elem(mp_field_signature__);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Certificate_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_version.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.Certificate");
single_value->field_signer__info.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.Certificate");
single_value->field_subject__info.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.Certificate");
single_value->field_subject__attributes.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.Certificate");
single_value->field_validity__restrictions.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.Certificate");
single_value->field_signature__.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.Certificate");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.Certificate");
}

boolean Certificate_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Certificate_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const Certificate CertificateChain::UNBOUND_ELEM;
boolean CertificateChain::compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index)
{
if (((const CertificateChain*)left_ptr)->val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
if (((const CertificateChain*)right_ptr)->val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
if (((const CertificateChain*)left_ptr)->val_ptr->value_elements[left_index] != NULL){
if (((const CertificateChain*)right_ptr)->val_ptr->value_elements[right_index] != NULL){
return *((const CertificateChain*)left_ptr)->val_ptr->value_elements[left_index] == *((const CertificateChain*)right_ptr)->val_ptr->value_elements[right_index];
} else return FALSE;
} else {
return ((const CertificateChain*)right_ptr)->val_ptr->value_elements[right_index] == NULL;
}
}

CertificateChain::CertificateChain()
{
val_ptr = NULL;
}

CertificateChain::CertificateChain(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

CertificateChain::CertificateChain(const CertificateChain& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

CertificateChain::~CertificateChain()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void CertificateChain::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

CertificateChain& CertificateChain::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

CertificateChain& CertificateChain::operator=(const CertificateChain& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean CertificateChain::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
return val_ptr->n_elements == 0 ;
}

boolean CertificateChain::operator==(const CertificateChain& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
if (val_ptr == other_value.val_ptr) return TRUE;
return compare_set_of(this, val_ptr->n_elements, &other_value, (other_value.val_ptr)->n_elements, compare_function);
}

Certificate& CertificateChain::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.CertificateChain using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (Certificate**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new Certificate(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new Certificate;
}
return *val_ptr->value_elements[index_value];
}

Certificate& CertificateChain::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
return (*this)[(int)index_value];
}

const Certificate& CertificateChain::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.CertificateChain using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsSecurity_TypesAndValues.CertificateChain: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const Certificate& CertificateChain::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
return (*this)[(int)index_value];
}

CertificateChain CertificateChain::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

CertificateChain CertificateChain::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

CertificateChain CertificateChain::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

CertificateChain CertificateChain::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
CertificateChain ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new Certificate(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

CertificateChain CertificateChain::operator+(const CertificateChain& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsSecurity_TypesAndValues.CertificateChain concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
CertificateChain ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new Certificate(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new Certificate(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

CertificateChain CertificateChain::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsSecurity_TypesAndValues.CertificateChain","element");
CertificateChain ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new Certificate(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

CertificateChain CertificateChain::replace(int index, int len, const CertificateChain& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsSecurity_TypesAndValues.CertificateChain","element");
CertificateChain ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new Certificate(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new Certificate(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new Certificate(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

CertificateChain CertificateChain::replace(int index, int len, const CertificateChain_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void CertificateChain::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (Certificate**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new Certificate(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (Certificate**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsSecurity_TypesAndValues.CertificateChain: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (Certificate**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean CertificateChain::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int CertificateChain::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
return val_ptr->n_elements;
}

int CertificateChain::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void CertificateChain::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void CertificateChain::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set of type `@LibItsSecurity_TypesAndValues.CertificateChain'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "set of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.CertificateChain");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.CertificateChain");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* CertificateChain::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of type `@LibItsSecurity_TypesAndValues.CertificateChain'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void CertificateChain::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void CertificateChain::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void CertificateChain::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
val_ptr->value_elements = (Certificate**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new Certificate;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void CertificateChain::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void CertificateChain::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int CertificateChain::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int CertificateChain::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

int CertificateChain::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int CertificateChain::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    Certificate* val = new Certificate;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (Certificate**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void CertificateChain_template::copy_value(const CertificateChain& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsSecurity_TypesAndValues.CertificateChain with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (Certificate_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new Certificate_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new Certificate_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void CertificateChain_template::copy_template(const CertificateChain_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (Certificate_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new Certificate_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new Certificate_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CertificateChain_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = other_value.value_set.n_items;
value_set.set_items = new Certificate_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count] = other_value.value_set.set_items[set_count];
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.CertificateChain.");
break;
}
set_selection(other_value);
}

boolean CertificateChain_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const CertificateChain_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const CertificateChain*)value_ptr)[value_index], legacy);
else return ((const CertificateChain_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

boolean CertificateChain_template::match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const CertificateChain_template*)template_ptr)->value_set.set_items[template_index].match((*(const CertificateChain*)value_ptr)[value_index], legacy);
else return ((const CertificateChain_template*)template_ptr)->value_set.set_items[template_index].is_any_or_omit();
}

void CertificateChain_template::log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy)
{
if (value_ptr != NULL && template_ptr != NULL)((const CertificateChain_template*)template_ptr)->single_value.value_elements[index_template]->log_match((*(const CertificateChain*)value_ptr)[index_value], legacy);
else if (value_ptr != NULL) (*(const CertificateChain*)value_ptr)[index_value].log();
else if (template_ptr != NULL) ((const CertificateChain_template*)template_ptr)->single_value.value_elements[index_template]->log();
}

CertificateChain_template::CertificateChain_template()
{
}

CertificateChain_template::CertificateChain_template(template_sel other_value)
 : Restricted_Length_Template(other_value)
{
check_single_selection(other_value);
}

CertificateChain_template::CertificateChain_template(null_type)
 : Restricted_Length_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

CertificateChain_template::CertificateChain_template(const CertificateChain& other_value)
{
copy_value(other_value);
}

CertificateChain_template::CertificateChain_template(const OPTIONAL<CertificateChain>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CertificateChain&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.CertificateChain from an unbound optional field.");
}
}

CertificateChain_template::CertificateChain_template(const CertificateChain_template& other_value)
 : Restricted_Length_Template()
{
copy_template(other_value);
}

CertificateChain_template::~CertificateChain_template()
{
clean_up();
}

void CertificateChain_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
delete [] value_set.set_items;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

CertificateChain_template& CertificateChain_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CertificateChain_template& CertificateChain_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

CertificateChain_template& CertificateChain_template::operator=(const CertificateChain& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

CertificateChain_template& CertificateChain_template::operator=(const OPTIONAL<CertificateChain>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CertificateChain&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.CertificateChain.");
}
return *this;
}

CertificateChain_template& CertificateChain_template::operator=(const CertificateChain_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

Certificate_template& CertificateChain_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.CertificateChain using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.CertificateChain.");
    break;
}
return *single_value.value_elements[index_value];
}

Certificate_template& CertificateChain_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.CertificateChain.");
return (*this)[(int)index_value];
}

const Certificate_template& CertificateChain_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.CertificateChain using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.CertificateChain.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsSecurity_TypesAndValues.CertificateChain: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const Certificate_template& CertificateChain_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.CertificateChain.");
return (*this)[(int)index_value];
}

void CertificateChain_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsSecurity_TypesAndValues.CertificateChain.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (Certificate_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new Certificate_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new Certificate_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (Certificate_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int CertificateChain_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int CertificateChain_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.CertificateChain which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.CertificateChain containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case SUPERSET_MATCH:
case SUBSET_MATCH: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = value_set.n_items;
  if (!is_size) { while (elem_count>0 && !value_set.set_items[elem_count-1].is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (value_set.set_items[i].get_selection())
    {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.CertificateChain containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
  if (template_selection==SUPERSET_MATCH) {
    has_any_or_none = TRUE;
   } else {
    int max_size = min_size;
    min_size = 0;
    if (!has_any_or_none) { // [0,max_size]
      switch (length_restriction_type) {
      case NO_LENGTH_RESTRICTION:
        if (max_size==0) return 0;
        TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.CertificateChain with no exact size.", op_name);
      case SINGLE_LENGTH_RESTRICTION:
        if (length_restriction.single_length<=max_size)
          return length_restriction.single_length;
        TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.CertificateChain. The maximum size (%d) contradicts the length restriction (%d).", op_name, max_size, length_restriction.single_length);
      case RANGE_LENGTH_RESTRICTION:
        if (max_size==length_restriction.range_length.min_length) {
          return max_size;
        } else if (max_size>length_restriction.range_length.min_length){
          TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.CertificateChain with no exact size.", op_name);
        } else
          TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.CertificateChain. Maximum size (%d) contradicts the length restriction (%d..%d).", op_name, max_size, length_restriction.range_length.min_length, length_restriction.range_length.max_length);
      default:
        TTCN_error("Internal error: Template has invalid length restriction type.");
      }
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.CertificateChain containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.CertificateChain containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.CertificateChain containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.CertificateChain containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.CertificateChain.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsSecurity_TypesAndValues.CertificateChain");
}

boolean CertificateChain_template::match(const CertificateChain& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_set_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case SUPERSET_MATCH:
case SUBSET_MATCH:
return match_set_of(&other_value, value_length, this, value_set.n_items, match_function_set, legacy);
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.CertificateChain.");
}
return FALSE;
}

boolean CertificateChain_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

CertificateChain CertificateChain_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.CertificateChain.");
CertificateChain ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

CertificateChain CertificateChain_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

CertificateChain CertificateChain_template::replace(int index, int len, const CertificateChain_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

CertificateChain CertificateChain_template::replace(int index, int len, const CertificateChain& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void CertificateChain_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new CertificateChain_template[list_length];
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = list_length;
value_set.set_items = new Certificate_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsSecurity_TypesAndValues.CertificateChain.");
}
set_selection(template_type);
}

CertificateChain_template& CertificateChain_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.CertificateChain.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.CertificateChain.");
return value_list.list_value[list_index];
}

Certificate_template& CertificateChain_template::set_item(unsigned int set_index)
{
if (template_selection != SUPERSET_MATCH && template_selection != SUBSET_MATCH) TTCN_error("Internal error: Accessing a set element of a non-set template of type @LibItsSecurity_TypesAndValues.CertificateChain.");
if (set_index >= value_set.n_items) TTCN_error("Internal error: Index overflow in a set template of type @LibItsSecurity_TypesAndValues.CertificateChain.");
return value_set.set_items[set_index];
}

void CertificateChain_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log();
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
TTCN_Logger::log_event("%s(", template_selection == SUPERSET_MATCH ? "superset" : "subset");
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++) {
if (set_count > 0) TTCN_Logger::log_event_str(", ");
value_set.set_items[set_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void CertificateChain_template::log_match(const CertificateChain& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (template_selection == SPECIFIC_VALUE)
  log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
else{
if(previous_size != 0){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::set_logmatch_buffer_len(previous_size);
TTCN_Logger::log_event_str(":=");
}
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
return;
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else {
TTCN_Logger::log_event_str(" unmatched");
if (template_selection == SPECIFIC_VALUE) log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
}
}

void CertificateChain_template::encode_text(Text_Buf& text_buf) const
{
encode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
text_buf.push_int(value_set.n_items);
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.CertificateChain.");
}
}

void CertificateChain_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsSecurity_TypesAndValues.CertificateChain.");
single_value.value_elements = (Certificate_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new Certificate_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CertificateChain_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = text_buf.pull_int().get_val();
value_set.set_items = new Certificate_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsSecurity_TypesAndValues.CertificateChain.");
}
}

boolean CertificateChain_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CertificateChain_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void CertificateChain_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set template type `@LibItsSecurity_TypesAndValues.CertificateChain'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "set of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CertificateChain_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    set_size(mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      if (mp->get_elem(p_i)->get_type()!=Module_Param::MP_NotUsed) {
        (*this)[p_i].set_param(*mp->get_elem(p_i));
      }
    }
    break;
  case Module_Param::MP_Superset_Template:
  case Module_Param::MP_Subset_Template:
    set_type(mp->get_type()==Module_Param::MP_Superset_Template ? SUPERSET_MATCH : SUBSET_MATCH, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      set_item(p_i).set_param(*mp->get_elem(p_i));
    }
    break;
  default:
    param.type_error("set of template", "@LibItsSecurity_TypesAndValues.CertificateChain");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* CertificateChain_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of template type `@LibItsSecurity_TypesAndValues.CertificateChain'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void CertificateChain_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.CertificateChain");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.CertificateChain");
}

CertificateWithAlgo::CertificateWithAlgo()
{
  bound_flag = FALSE;
}

CertificateWithAlgo::CertificateWithAlgo(const PublicKeyAlgorithm& par_algorithm,
    const OCTETSTRING& par_digest)
  :   field_algorithm(par_algorithm),
  field_digest(par_digest)
{
  bound_flag = TRUE;
}

CertificateWithAlgo::CertificateWithAlgo(const CertificateWithAlgo& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo.");
bound_flag = TRUE;
if (other_value.algorithm().is_bound()) field_algorithm = other_value.algorithm();
else field_algorithm.clean_up();
if (other_value.digest().is_bound()) field_digest = other_value.digest();
else field_digest.clean_up();
}

void CertificateWithAlgo::clean_up()
{
field_algorithm.clean_up();
field_digest.clean_up();
bound_flag = FALSE;
}

CertificateWithAlgo& CertificateWithAlgo::operator=(const CertificateWithAlgo& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo.");
  bound_flag = TRUE;
  if (other_value.algorithm().is_bound()) field_algorithm = other_value.algorithm();
  else field_algorithm.clean_up();
  if (other_value.digest().is_bound()) field_digest = other_value.digest();
  else field_digest.clean_up();
}
return *this;
}

boolean CertificateWithAlgo::operator==(const CertificateWithAlgo& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_algorithm==other_value.field_algorithm
  && field_digest==other_value.field_digest;
}

boolean CertificateWithAlgo::is_bound() const
{
if (bound_flag) return TRUE;
if(field_algorithm.is_bound()) return TRUE;
if(field_digest.is_bound()) return TRUE;
return FALSE;
}
boolean CertificateWithAlgo::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_algorithm.is_value()) return FALSE;
if(!field_digest.is_value()) return FALSE;
return TRUE;
}
int CertificateWithAlgo::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo");
  return 2;
}

void CertificateWithAlgo::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ algorithm := ");
field_algorithm.log();
TTCN_Logger::log_event_str(", digest := ");
field_digest.log();
TTCN_Logger::log_event_str(" }");
}

void CertificateWithAlgo::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.CertificateWithAlgo'");
    }
    if (strcmp("algorithm", param_field) == 0) {
      algorithm().set_param(param);
      return;
    } else if (strcmp("digest", param_field) == 0) {
      digest().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.CertificateWithAlgo'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) algorithm().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) digest().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "algorithm")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          algorithm().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "digest")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          digest().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.CertificateWithAlgo: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.CertificateWithAlgo");
  }
}

Module_Param* CertificateWithAlgo::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.CertificateWithAlgo'");
    }
    if (strcmp("algorithm", param_field) == 0) {
      return algorithm().get_param(param_name);
    } else if (strcmp("digest", param_field) == 0) {
      return digest().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.CertificateWithAlgo'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_algorithm = field_algorithm.get_param(param_name);
  mp_field_algorithm->set_id(new Module_Param_FieldName(mcopystr("algorithm")));
  mp->add_elem(mp_field_algorithm);
  Module_Param* mp_field_digest = field_digest.get_param(param_name);
  mp_field_digest->set_id(new Module_Param_FieldName(mcopystr("digest")));
  mp->add_elem(mp_field_digest);
  return mp;
  }

void CertificateWithAlgo::set_implicit_omit()
{
if (algorithm().is_bound()) algorithm().set_implicit_omit();
if (digest().is_bound()) digest().set_implicit_omit();
}

void CertificateWithAlgo::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo.");
field_algorithm.encode_text(text_buf);
field_digest.encode_text(text_buf);
}

void CertificateWithAlgo::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_algorithm.decode_text(text_buf);
field_digest.decode_text(text_buf);
}

void CertificateWithAlgo::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void CertificateWithAlgo::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int CertificateWithAlgo::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_algorithm.RAW_decode(PublicKeyAlgorithm_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_digest.RAW_decode(HashedId8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int CertificateWithAlgo::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, PublicKeyAlgorithm_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, HashedId8_descr_.raw);
  encoded_length += field_algorithm.RAW_encode(PublicKeyAlgorithm_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_digest.RAW_encode(HashedId8_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int CertificateWithAlgo::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "algorithm");
    enc_len += field_algorithm.JSON_encode(PublicKeyAlgorithm_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "digest");
    enc_len += field_digest.JSON_encode(HashedId8_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int CertificateWithAlgo::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (9 == name_len && 0 == strncmp(fld_name, "algorithm", name_len)) {
         int ret_val = field_algorithm.JSON_decode(PublicKeyAlgorithm_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "algorithm");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (6 == name_len && 0 == strncmp(fld_name, "digest", name_len)) {
         int ret_val = field_digest.JSON_decode(HashedId8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "digest");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_algorithm.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "algorithm");
    return JSON_ERROR_FATAL;
  }
if (!field_digest.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "digest");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct CertificateWithAlgo_template::single_value_struct {
PublicKeyAlgorithm_template field_algorithm;
OCTETSTRING_template field_digest;
};

void CertificateWithAlgo_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_algorithm = ANY_VALUE;
single_value->field_digest = ANY_VALUE;
}
}
}

void CertificateWithAlgo_template::copy_value(const CertificateWithAlgo& other_value)
{
single_value = new single_value_struct;
if (other_value.algorithm().is_bound()) {
  single_value->field_algorithm = other_value.algorithm();
} else {
  single_value->field_algorithm.clean_up();
}
if (other_value.digest().is_bound()) {
  single_value->field_digest = other_value.digest();
} else {
  single_value->field_digest.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void CertificateWithAlgo_template::copy_template(const CertificateWithAlgo_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.algorithm().get_selection()) {
single_value->field_algorithm = other_value.algorithm();
} else {
single_value->field_algorithm.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.digest().get_selection()) {
single_value->field_digest = other_value.digest();
} else {
single_value->field_digest.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CertificateWithAlgo_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo.");
break;
}
set_selection(other_value);
}

CertificateWithAlgo_template::CertificateWithAlgo_template()
{
}

CertificateWithAlgo_template::CertificateWithAlgo_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

CertificateWithAlgo_template::CertificateWithAlgo_template(const CertificateWithAlgo& other_value)
{
copy_value(other_value);
}

CertificateWithAlgo_template::CertificateWithAlgo_template(const OPTIONAL<CertificateWithAlgo>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CertificateWithAlgo&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo from an unbound optional field.");
}
}

CertificateWithAlgo_template::CertificateWithAlgo_template(const CertificateWithAlgo_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

CertificateWithAlgo_template::~CertificateWithAlgo_template()
{
clean_up();
}

CertificateWithAlgo_template& CertificateWithAlgo_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CertificateWithAlgo_template& CertificateWithAlgo_template::operator=(const CertificateWithAlgo& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

CertificateWithAlgo_template& CertificateWithAlgo_template::operator=(const OPTIONAL<CertificateWithAlgo>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const CertificateWithAlgo&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo.");
}
return *this;
}

CertificateWithAlgo_template& CertificateWithAlgo_template::operator=(const CertificateWithAlgo_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean CertificateWithAlgo_template::match(const CertificateWithAlgo& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.algorithm().is_bound()) return FALSE;
if(!single_value->field_algorithm.match(other_value.algorithm(), legacy))return FALSE;
if(!other_value.digest().is_bound()) return FALSE;
if(!single_value->field_digest.match(other_value.digest(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo.");
}
return FALSE;
}

boolean CertificateWithAlgo_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_algorithm.is_bound()) return TRUE;
if (single_value->field_digest.is_bound()) return TRUE;
return FALSE;
}

boolean CertificateWithAlgo_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_algorithm.is_value()) return FALSE;
if (!single_value->field_digest.is_value()) return FALSE;
return TRUE;
}

void CertificateWithAlgo_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

CertificateWithAlgo CertificateWithAlgo_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo.");
CertificateWithAlgo ret_val;
if (single_value->field_algorithm.is_bound()) {
ret_val.algorithm() = single_value->field_algorithm.valueof();
}
if (single_value->field_digest.is_bound()) {
ret_val.digest() = single_value->field_digest.valueof();
}
return ret_val;
}

void CertificateWithAlgo_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new CertificateWithAlgo_template[list_length];
}

CertificateWithAlgo_template& CertificateWithAlgo_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo.");
return value_list.list_value[list_index];
}

PublicKeyAlgorithm_template& CertificateWithAlgo_template::algorithm()
{
set_specific();
return single_value->field_algorithm;
}

const PublicKeyAlgorithm_template& CertificateWithAlgo_template::algorithm() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field algorithm of a non-specific template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo.");
return single_value->field_algorithm;
}

OCTETSTRING_template& CertificateWithAlgo_template::digest()
{
set_specific();
return single_value->field_digest;
}

const OCTETSTRING_template& CertificateWithAlgo_template::digest() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field digest of a non-specific template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo.");
return single_value->field_digest;
}

int CertificateWithAlgo_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo.");
  }
  return 0;
}

void CertificateWithAlgo_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ algorithm := ");
single_value->field_algorithm.log();
TTCN_Logger::log_event_str(", digest := ");
single_value->field_digest.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void CertificateWithAlgo_template::log_match(const CertificateWithAlgo& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_algorithm.match(match_value.algorithm(), legacy)){
TTCN_Logger::log_logmatch_info(".algorithm");
single_value->field_algorithm.log_match(match_value.algorithm(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_digest.match(match_value.digest(), legacy)){
TTCN_Logger::log_logmatch_info(".digest");
single_value->field_digest.log_match(match_value.digest(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ algorithm := ");
single_value->field_algorithm.log_match(match_value.algorithm(), legacy);
TTCN_Logger::log_event_str(", digest := ");
single_value->field_digest.log_match(match_value.digest(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void CertificateWithAlgo_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_algorithm.encode_text(text_buf);
single_value->field_digest.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo.");
}
}

void CertificateWithAlgo_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_algorithm.decode_text(text_buf);
single_value->field_digest.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CertificateWithAlgo_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo.");
}
}

void CertificateWithAlgo_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.CertificateWithAlgo'");
    }
    if (strcmp("algorithm", param_field) == 0) {
      algorithm().set_param(param);
      return;
    } else if (strcmp("digest", param_field) == 0) {
      digest().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.CertificateWithAlgo'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CertificateWithAlgo_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.CertificateWithAlgo has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) algorithm().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) digest().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "algorithm")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          algorithm().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "digest")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          digest().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.CertificateWithAlgo: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.CertificateWithAlgo");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* CertificateWithAlgo_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.CertificateWithAlgo'");
    }
    if (strcmp("algorithm", param_field) == 0) {
      return algorithm().get_param(param_name);
    } else if (strcmp("digest", param_field) == 0) {
      return digest().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.CertificateWithAlgo'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_algorithm = single_value->field_algorithm.get_param(param_name);
    mp_field_algorithm->set_id(new Module_Param_FieldName(mcopystr("algorithm")));
    mp->add_elem(mp_field_algorithm);
    Module_Param* mp_field_digest = single_value->field_digest.get_param(param_name);
    mp_field_digest->set_id(new Module_Param_FieldName(mcopystr("digest")));
    mp->add_elem(mp_field_digest);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void CertificateWithAlgo_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_algorithm.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.CertificateWithAlgo");
single_value->field_digest.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.CertificateWithAlgo");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.CertificateWithAlgo");
}

boolean CertificateWithAlgo_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CertificateWithAlgo_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

Time64WithStandardDeviation::Time64WithStandardDeviation()
{
  bound_flag = FALSE;
}

Time64WithStandardDeviation::Time64WithStandardDeviation(const INTEGER& par_time,
    const INTEGER& par_log__std__dev)
  :   field_time(par_time),
  field_log__std__dev(par_log__std__dev)
{
  bound_flag = TRUE;
}

Time64WithStandardDeviation::Time64WithStandardDeviation(const Time64WithStandardDeviation& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.");
bound_flag = TRUE;
if (other_value.time().is_bound()) field_time = other_value.time();
else field_time.clean_up();
if (other_value.log__std__dev().is_bound()) field_log__std__dev = other_value.log__std__dev();
else field_log__std__dev.clean_up();
}

void Time64WithStandardDeviation::clean_up()
{
field_time.clean_up();
field_log__std__dev.clean_up();
bound_flag = FALSE;
}

Time64WithStandardDeviation& Time64WithStandardDeviation::operator=(const Time64WithStandardDeviation& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.");
  bound_flag = TRUE;
  if (other_value.time().is_bound()) field_time = other_value.time();
  else field_time.clean_up();
  if (other_value.log__std__dev().is_bound()) field_log__std__dev = other_value.log__std__dev();
  else field_log__std__dev.clean_up();
}
return *this;
}

boolean Time64WithStandardDeviation::operator==(const Time64WithStandardDeviation& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_time==other_value.field_time
  && field_log__std__dev==other_value.field_log__std__dev;
}

boolean Time64WithStandardDeviation::is_bound() const
{
if (bound_flag) return TRUE;
if(field_time.is_bound()) return TRUE;
if(field_log__std__dev.is_bound()) return TRUE;
return FALSE;
}
boolean Time64WithStandardDeviation::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_time.is_value()) return FALSE;
if(!field_log__std__dev.is_value()) return FALSE;
return TRUE;
}
int Time64WithStandardDeviation::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation");
  return 2;
}

void Time64WithStandardDeviation::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ time := ");
field_time.log();
TTCN_Logger::log_event_str(", log_std_dev := ");
field_log__std__dev.log();
TTCN_Logger::log_event_str(" }");
}

void Time64WithStandardDeviation::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.Time64WithStandardDeviation'");
    }
    if (strcmp("time", param_field) == 0) {
      time().set_param(param);
      return;
    } else if (strcmp("log_std_dev", param_field) == 0) {
      log__std__dev().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.Time64WithStandardDeviation'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) time().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) log__std__dev().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "time")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          time().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "log_std_dev")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          log__std__dev().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.Time64WithStandardDeviation");
  }
}

Module_Param* Time64WithStandardDeviation::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.Time64WithStandardDeviation'");
    }
    if (strcmp("time", param_field) == 0) {
      return time().get_param(param_name);
    } else if (strcmp("log_std_dev", param_field) == 0) {
      return log__std__dev().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.Time64WithStandardDeviation'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_time = field_time.get_param(param_name);
  mp_field_time->set_id(new Module_Param_FieldName(mcopystr("time")));
  mp->add_elem(mp_field_time);
  Module_Param* mp_field_log__std__dev = field_log__std__dev.get_param(param_name);
  mp_field_log__std__dev->set_id(new Module_Param_FieldName(mcopystr("log_std_dev")));
  mp->add_elem(mp_field_log__std__dev);
  return mp;
  }

void Time64WithStandardDeviation::set_implicit_omit()
{
if (time().is_bound()) time().set_implicit_omit();
if (log__std__dev().is_bound()) log__std__dev().set_implicit_omit();
}

void Time64WithStandardDeviation::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.");
field_time.encode_text(text_buf);
field_log__std__dev.encode_text(text_buf);
}

void Time64WithStandardDeviation::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_time.decode_text(text_buf);
field_log__std__dev.decode_text(text_buf);
}

void Time64WithStandardDeviation::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void Time64WithStandardDeviation::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int Time64WithStandardDeviation::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_time.RAW_decode(Time64_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_log__std__dev.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int Time64WithStandardDeviation::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, Time64_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  encoded_length += field_time.RAW_encode(Time64_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_log__std__dev.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int Time64WithStandardDeviation::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "time");
    enc_len += field_time.JSON_encode(Time64_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "log_std_dev");
    enc_len += field_log__std__dev.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int Time64WithStandardDeviation::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (4 == name_len && 0 == strncmp(fld_name, "time", name_len)) {
         int ret_val = field_time.JSON_decode(Time64_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "time");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "log_std_dev", name_len)) {
         int ret_val = field_log__std__dev.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "log_std_dev");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_time.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "time");
    return JSON_ERROR_FATAL;
  }
if (!field_log__std__dev.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "log_std_dev");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct Time64WithStandardDeviation_template::single_value_struct {
INTEGER_template field_time;
INTEGER_template field_log__std__dev;
};

void Time64WithStandardDeviation_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_time = ANY_VALUE;
single_value->field_log__std__dev = ANY_VALUE;
}
}
}

void Time64WithStandardDeviation_template::copy_value(const Time64WithStandardDeviation& other_value)
{
single_value = new single_value_struct;
if (other_value.time().is_bound()) {
  single_value->field_time = other_value.time();
} else {
  single_value->field_time.clean_up();
}
if (other_value.log__std__dev().is_bound()) {
  single_value->field_log__std__dev = other_value.log__std__dev();
} else {
  single_value->field_log__std__dev.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void Time64WithStandardDeviation_template::copy_template(const Time64WithStandardDeviation_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.time().get_selection()) {
single_value->field_time = other_value.time();
} else {
single_value->field_time.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.log__std__dev().get_selection()) {
single_value->field_log__std__dev = other_value.log__std__dev();
} else {
single_value->field_log__std__dev.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new Time64WithStandardDeviation_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.");
break;
}
set_selection(other_value);
}

Time64WithStandardDeviation_template::Time64WithStandardDeviation_template()
{
}

Time64WithStandardDeviation_template::Time64WithStandardDeviation_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

Time64WithStandardDeviation_template::Time64WithStandardDeviation_template(const Time64WithStandardDeviation& other_value)
{
copy_value(other_value);
}

Time64WithStandardDeviation_template::Time64WithStandardDeviation_template(const OPTIONAL<Time64WithStandardDeviation>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Time64WithStandardDeviation&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation from an unbound optional field.");
}
}

Time64WithStandardDeviation_template::Time64WithStandardDeviation_template(const Time64WithStandardDeviation_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

Time64WithStandardDeviation_template::~Time64WithStandardDeviation_template()
{
clean_up();
}

Time64WithStandardDeviation_template& Time64WithStandardDeviation_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

Time64WithStandardDeviation_template& Time64WithStandardDeviation_template::operator=(const Time64WithStandardDeviation& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

Time64WithStandardDeviation_template& Time64WithStandardDeviation_template::operator=(const OPTIONAL<Time64WithStandardDeviation>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const Time64WithStandardDeviation&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.");
}
return *this;
}

Time64WithStandardDeviation_template& Time64WithStandardDeviation_template::operator=(const Time64WithStandardDeviation_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean Time64WithStandardDeviation_template::match(const Time64WithStandardDeviation& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.time().is_bound()) return FALSE;
if(!single_value->field_time.match(other_value.time(), legacy))return FALSE;
if(!other_value.log__std__dev().is_bound()) return FALSE;
if(!single_value->field_log__std__dev.match(other_value.log__std__dev(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.");
}
return FALSE;
}

boolean Time64WithStandardDeviation_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_time.is_bound()) return TRUE;
if (single_value->field_log__std__dev.is_bound()) return TRUE;
return FALSE;
}

boolean Time64WithStandardDeviation_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_time.is_value()) return FALSE;
if (!single_value->field_log__std__dev.is_value()) return FALSE;
return TRUE;
}

void Time64WithStandardDeviation_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

Time64WithStandardDeviation Time64WithStandardDeviation_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.");
Time64WithStandardDeviation ret_val;
if (single_value->field_time.is_bound()) {
ret_val.time() = single_value->field_time.valueof();
}
if (single_value->field_log__std__dev.is_bound()) {
ret_val.log__std__dev() = single_value->field_log__std__dev.valueof();
}
return ret_val;
}

void Time64WithStandardDeviation_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new Time64WithStandardDeviation_template[list_length];
}

Time64WithStandardDeviation_template& Time64WithStandardDeviation_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.");
return value_list.list_value[list_index];
}

INTEGER_template& Time64WithStandardDeviation_template::time()
{
set_specific();
return single_value->field_time;
}

const INTEGER_template& Time64WithStandardDeviation_template::time() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field time of a non-specific template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.");
return single_value->field_time;
}

INTEGER_template& Time64WithStandardDeviation_template::log__std__dev()
{
set_specific();
return single_value->field_log__std__dev;
}

const INTEGER_template& Time64WithStandardDeviation_template::log__std__dev() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field log_std_dev of a non-specific template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.");
return single_value->field_log__std__dev;
}

int Time64WithStandardDeviation_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.");
  }
  return 0;
}

void Time64WithStandardDeviation_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ time := ");
single_value->field_time.log();
TTCN_Logger::log_event_str(", log_std_dev := ");
single_value->field_log__std__dev.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void Time64WithStandardDeviation_template::log_match(const Time64WithStandardDeviation& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_time.match(match_value.time(), legacy)){
TTCN_Logger::log_logmatch_info(".time");
single_value->field_time.log_match(match_value.time(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_log__std__dev.match(match_value.log__std__dev(), legacy)){
TTCN_Logger::log_logmatch_info(".log_std_dev");
single_value->field_log__std__dev.log_match(match_value.log__std__dev(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ time := ");
single_value->field_time.log_match(match_value.time(), legacy);
TTCN_Logger::log_event_str(", log_std_dev := ");
single_value->field_log__std__dev.log_match(match_value.log__std__dev(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void Time64WithStandardDeviation_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_time.encode_text(text_buf);
single_value->field_log__std__dev.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.");
}
}

void Time64WithStandardDeviation_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_time.decode_text(text_buf);
single_value->field_log__std__dev.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new Time64WithStandardDeviation_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation.");
}
}

void Time64WithStandardDeviation_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.Time64WithStandardDeviation'");
    }
    if (strcmp("time", param_field) == 0) {
      time().set_param(param);
      return;
    } else if (strcmp("log_std_dev", param_field) == 0) {
      log__std__dev().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.Time64WithStandardDeviation'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    Time64WithStandardDeviation_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) time().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) log__std__dev().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "time")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          time().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "log_std_dev")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          log__std__dev().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.Time64WithStandardDeviation: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.Time64WithStandardDeviation");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* Time64WithStandardDeviation_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.Time64WithStandardDeviation'");
    }
    if (strcmp("time", param_field) == 0) {
      return time().get_param(param_name);
    } else if (strcmp("log_std_dev", param_field) == 0) {
      return log__std__dev().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.Time64WithStandardDeviation'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_time = single_value->field_time.get_param(param_name);
    mp_field_time->set_id(new Module_Param_FieldName(mcopystr("time")));
    mp->add_elem(mp_field_time);
    Module_Param* mp_field_log__std__dev = single_value->field_log__std__dev.get_param(param_name);
    mp_field_log__std__dev->set_id(new Module_Param_FieldName(mcopystr("log_std_dev")));
    mp->add_elem(mp_field_log__std__dev);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void Time64WithStandardDeviation_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_time.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.Time64WithStandardDeviation");
single_value->field_log__std__dev.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.Time64WithStandardDeviation");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.Time64WithStandardDeviation");
}

boolean Time64WithStandardDeviation_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean Time64WithStandardDeviation_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ThreeDLocation::ThreeDLocation()
{
  bound_flag = FALSE;
}

ThreeDLocation::ThreeDLocation(const INTEGER& par_latitude,
    const INTEGER& par_longitude,
    const OCTETSTRING& par_elevation)
  :   field_latitude(par_latitude),
  field_longitude(par_longitude),
  field_elevation(par_elevation)
{
  bound_flag = TRUE;
}

ThreeDLocation::ThreeDLocation(const ThreeDLocation& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocation.");
bound_flag = TRUE;
if (other_value.latitude().is_bound()) field_latitude = other_value.latitude();
else field_latitude.clean_up();
if (other_value.longitude().is_bound()) field_longitude = other_value.longitude();
else field_longitude.clean_up();
if (other_value.elevation().is_bound()) field_elevation = other_value.elevation();
else field_elevation.clean_up();
}

void ThreeDLocation::clean_up()
{
field_latitude.clean_up();
field_longitude.clean_up();
field_elevation.clean_up();
bound_flag = FALSE;
}

ThreeDLocation& ThreeDLocation::operator=(const ThreeDLocation& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocation.");
  bound_flag = TRUE;
  if (other_value.latitude().is_bound()) field_latitude = other_value.latitude();
  else field_latitude.clean_up();
  if (other_value.longitude().is_bound()) field_longitude = other_value.longitude();
  else field_longitude.clean_up();
  if (other_value.elevation().is_bound()) field_elevation = other_value.elevation();
  else field_elevation.clean_up();
}
return *this;
}

boolean ThreeDLocation::operator==(const ThreeDLocation& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_latitude==other_value.field_latitude
  && field_longitude==other_value.field_longitude
  && field_elevation==other_value.field_elevation;
}

boolean ThreeDLocation::is_bound() const
{
if (bound_flag) return TRUE;
if(field_latitude.is_bound()) return TRUE;
if(field_longitude.is_bound()) return TRUE;
if(field_elevation.is_bound()) return TRUE;
return FALSE;
}
boolean ThreeDLocation::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_latitude.is_value()) return FALSE;
if(!field_longitude.is_value()) return FALSE;
if(!field_elevation.is_value()) return FALSE;
return TRUE;
}
int ThreeDLocation::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.ThreeDLocation");
  return 3;
}

void ThreeDLocation::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ latitude := ");
field_latitude.log();
TTCN_Logger::log_event_str(", longitude := ");
field_longitude.log();
TTCN_Logger::log_event_str(", elevation := ");
field_elevation.log();
TTCN_Logger::log_event_str(" }");
}

void ThreeDLocation::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.ThreeDLocation'");
    }
    if (strcmp("latitude", param_field) == 0) {
      latitude().set_param(param);
      return;
    } else if (strcmp("longitude", param_field) == 0) {
      longitude().set_param(param);
      return;
    } else if (strcmp("elevation", param_field) == 0) {
      elevation().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ThreeDLocation'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.ThreeDLocation has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) latitude().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) longitude().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) elevation().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "latitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          latitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "longitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          longitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "elevation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          elevation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.ThreeDLocation: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.ThreeDLocation");
  }
}

Module_Param* ThreeDLocation::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.ThreeDLocation'");
    }
    if (strcmp("latitude", param_field) == 0) {
      return latitude().get_param(param_name);
    } else if (strcmp("longitude", param_field) == 0) {
      return longitude().get_param(param_name);
    } else if (strcmp("elevation", param_field) == 0) {
      return elevation().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ThreeDLocation'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_latitude = field_latitude.get_param(param_name);
  mp_field_latitude->set_id(new Module_Param_FieldName(mcopystr("latitude")));
  mp->add_elem(mp_field_latitude);
  Module_Param* mp_field_longitude = field_longitude.get_param(param_name);
  mp_field_longitude->set_id(new Module_Param_FieldName(mcopystr("longitude")));
  mp->add_elem(mp_field_longitude);
  Module_Param* mp_field_elevation = field_elevation.get_param(param_name);
  mp_field_elevation->set_id(new Module_Param_FieldName(mcopystr("elevation")));
  mp->add_elem(mp_field_elevation);
  return mp;
  }

void ThreeDLocation::set_implicit_omit()
{
if (latitude().is_bound()) latitude().set_implicit_omit();
if (longitude().is_bound()) longitude().set_implicit_omit();
if (elevation().is_bound()) elevation().set_implicit_omit();
}

void ThreeDLocation::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.ThreeDLocation.");
field_latitude.encode_text(text_buf);
field_longitude.encode_text(text_buf);
field_elevation.encode_text(text_buf);
}

void ThreeDLocation::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_latitude.decode_text(text_buf);
field_longitude.decode_text(text_buf);
field_elevation.decode_text(text_buf);
}

void ThreeDLocation::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ThreeDLocation::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ThreeDLocation::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_latitude.RAW_decode(WGSLatitude_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_longitude.RAW_decode(WGSLongitude_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_elevation.RAW_decode(LibCommon__DataStrings::Oct2_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ThreeDLocation::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, WGSLatitude_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, WGSLongitude_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__DataStrings::Oct2_descr_.raw);
  encoded_length += field_latitude.RAW_encode(WGSLatitude_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_longitude.RAW_encode(WGSLongitude_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_elevation.RAW_encode(LibCommon__DataStrings::Oct2_descr_, *myleaf.body.node.nodes[2]);
  return myleaf.length = encoded_length;
}

int ThreeDLocation::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocation.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "latitude");
    enc_len += field_latitude.JSON_encode(WGSLatitude_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "longitude");
    enc_len += field_longitude.JSON_encode(WGSLongitude_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "elevation");
    enc_len += field_elevation.JSON_encode(LibCommon__DataStrings::Oct2_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ThreeDLocation::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (8 == name_len && 0 == strncmp(fld_name, "latitude", name_len)) {
         int ret_val = field_latitude.JSON_decode(WGSLatitude_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "latitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "longitude", name_len)) {
         int ret_val = field_longitude.JSON_decode(WGSLongitude_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "longitude");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (9 == name_len && 0 == strncmp(fld_name, "elevation", name_len)) {
         int ret_val = field_elevation.JSON_decode(LibCommon__DataStrings::Oct2_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "elevation");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_latitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "latitude");
    return JSON_ERROR_FATAL;
  }
if (!field_longitude.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "longitude");
    return JSON_ERROR_FATAL;
  }
if (!field_elevation.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "elevation");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ThreeDLocation_template::single_value_struct {
INTEGER_template field_latitude;
INTEGER_template field_longitude;
OCTETSTRING_template field_elevation;
};

void ThreeDLocation_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_latitude = ANY_VALUE;
single_value->field_longitude = ANY_VALUE;
single_value->field_elevation = ANY_VALUE;
}
}
}

void ThreeDLocation_template::copy_value(const ThreeDLocation& other_value)
{
single_value = new single_value_struct;
if (other_value.latitude().is_bound()) {
  single_value->field_latitude = other_value.latitude();
} else {
  single_value->field_latitude.clean_up();
}
if (other_value.longitude().is_bound()) {
  single_value->field_longitude = other_value.longitude();
} else {
  single_value->field_longitude.clean_up();
}
if (other_value.elevation().is_bound()) {
  single_value->field_elevation = other_value.elevation();
} else {
  single_value->field_elevation.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ThreeDLocation_template::copy_template(const ThreeDLocation_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.latitude().get_selection()) {
single_value->field_latitude = other_value.latitude();
} else {
single_value->field_latitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.longitude().get_selection()) {
single_value->field_longitude = other_value.longitude();
} else {
single_value->field_longitude.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.elevation().get_selection()) {
single_value->field_elevation = other_value.elevation();
} else {
single_value->field_elevation.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ThreeDLocation_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ThreeDLocation.");
break;
}
set_selection(other_value);
}

ThreeDLocation_template::ThreeDLocation_template()
{
}

ThreeDLocation_template::ThreeDLocation_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ThreeDLocation_template::ThreeDLocation_template(const ThreeDLocation& other_value)
{
copy_value(other_value);
}

ThreeDLocation_template::ThreeDLocation_template(const OPTIONAL<ThreeDLocation>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ThreeDLocation&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.ThreeDLocation from an unbound optional field.");
}
}

ThreeDLocation_template::ThreeDLocation_template(const ThreeDLocation_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ThreeDLocation_template::~ThreeDLocation_template()
{
clean_up();
}

ThreeDLocation_template& ThreeDLocation_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ThreeDLocation_template& ThreeDLocation_template::operator=(const ThreeDLocation& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ThreeDLocation_template& ThreeDLocation_template::operator=(const OPTIONAL<ThreeDLocation>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ThreeDLocation&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.ThreeDLocation.");
}
return *this;
}

ThreeDLocation_template& ThreeDLocation_template::operator=(const ThreeDLocation_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ThreeDLocation_template::match(const ThreeDLocation& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.latitude().is_bound()) return FALSE;
if(!single_value->field_latitude.match(other_value.latitude(), legacy))return FALSE;
if(!other_value.longitude().is_bound()) return FALSE;
if(!single_value->field_longitude.match(other_value.longitude(), legacy))return FALSE;
if(!other_value.elevation().is_bound()) return FALSE;
if(!single_value->field_elevation.match(other_value.elevation(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ThreeDLocation.");
}
return FALSE;
}

boolean ThreeDLocation_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_latitude.is_bound()) return TRUE;
if (single_value->field_longitude.is_bound()) return TRUE;
if (single_value->field_elevation.is_bound()) return TRUE;
return FALSE;
}

boolean ThreeDLocation_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_latitude.is_value()) return FALSE;
if (!single_value->field_longitude.is_value()) return FALSE;
if (!single_value->field_elevation.is_value()) return FALSE;
return TRUE;
}

void ThreeDLocation_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ThreeDLocation ThreeDLocation_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.ThreeDLocation.");
ThreeDLocation ret_val;
if (single_value->field_latitude.is_bound()) {
ret_val.latitude() = single_value->field_latitude.valueof();
}
if (single_value->field_longitude.is_bound()) {
ret_val.longitude() = single_value->field_longitude.valueof();
}
if (single_value->field_elevation.is_bound()) {
ret_val.elevation() = single_value->field_elevation.valueof();
}
return ret_val;
}

void ThreeDLocation_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.ThreeDLocation.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ThreeDLocation_template[list_length];
}

ThreeDLocation_template& ThreeDLocation_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.ThreeDLocation.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.ThreeDLocation.");
return value_list.list_value[list_index];
}

INTEGER_template& ThreeDLocation_template::latitude()
{
set_specific();
return single_value->field_latitude;
}

const INTEGER_template& ThreeDLocation_template::latitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field latitude of a non-specific template of type @LibItsSecurity_TypesAndValues.ThreeDLocation.");
return single_value->field_latitude;
}

INTEGER_template& ThreeDLocation_template::longitude()
{
set_specific();
return single_value->field_longitude;
}

const INTEGER_template& ThreeDLocation_template::longitude() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field longitude of a non-specific template of type @LibItsSecurity_TypesAndValues.ThreeDLocation.");
return single_value->field_longitude;
}

OCTETSTRING_template& ThreeDLocation_template::elevation()
{
set_specific();
return single_value->field_elevation;
}

const OCTETSTRING_template& ThreeDLocation_template::elevation() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field elevation of a non-specific template of type @LibItsSecurity_TypesAndValues.ThreeDLocation.");
return single_value->field_elevation;
}

int ThreeDLocation_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ThreeDLocation which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ThreeDLocation containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ThreeDLocation containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ThreeDLocation containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ThreeDLocation containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ThreeDLocation containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ThreeDLocation.");
  }
  return 0;
}

void ThreeDLocation_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ latitude := ");
single_value->field_latitude.log();
TTCN_Logger::log_event_str(", longitude := ");
single_value->field_longitude.log();
TTCN_Logger::log_event_str(", elevation := ");
single_value->field_elevation.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ThreeDLocation_template::log_match(const ThreeDLocation& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_latitude.match(match_value.latitude(), legacy)){
TTCN_Logger::log_logmatch_info(".latitude");
single_value->field_latitude.log_match(match_value.latitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_longitude.match(match_value.longitude(), legacy)){
TTCN_Logger::log_logmatch_info(".longitude");
single_value->field_longitude.log_match(match_value.longitude(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_elevation.match(match_value.elevation(), legacy)){
TTCN_Logger::log_logmatch_info(".elevation");
single_value->field_elevation.log_match(match_value.elevation(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ latitude := ");
single_value->field_latitude.log_match(match_value.latitude(), legacy);
TTCN_Logger::log_event_str(", longitude := ");
single_value->field_longitude.log_match(match_value.longitude(), legacy);
TTCN_Logger::log_event_str(", elevation := ");
single_value->field_elevation.log_match(match_value.elevation(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ThreeDLocation_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_latitude.encode_text(text_buf);
single_value->field_longitude.encode_text(text_buf);
single_value->field_elevation.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ThreeDLocation.");
}
}

void ThreeDLocation_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_latitude.decode_text(text_buf);
single_value->field_longitude.decode_text(text_buf);
single_value->field_elevation.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ThreeDLocation_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.ThreeDLocation.");
}
}

void ThreeDLocation_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.ThreeDLocation'");
    }
    if (strcmp("latitude", param_field) == 0) {
      latitude().set_param(param);
      return;
    } else if (strcmp("longitude", param_field) == 0) {
      longitude().set_param(param);
      return;
    } else if (strcmp("elevation", param_field) == 0) {
      elevation().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.ThreeDLocation'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ThreeDLocation_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.ThreeDLocation has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) latitude().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) longitude().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) elevation().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "latitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          latitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "longitude")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          longitude().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "elevation")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          elevation().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.ThreeDLocation: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.ThreeDLocation");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ThreeDLocation_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.ThreeDLocation'");
    }
    if (strcmp("latitude", param_field) == 0) {
      return latitude().get_param(param_name);
    } else if (strcmp("longitude", param_field) == 0) {
      return longitude().get_param(param_name);
    } else if (strcmp("elevation", param_field) == 0) {
      return elevation().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ThreeDLocation'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_latitude = single_value->field_latitude.get_param(param_name);
    mp_field_latitude->set_id(new Module_Param_FieldName(mcopystr("latitude")));
    mp->add_elem(mp_field_latitude);
    Module_Param* mp_field_longitude = single_value->field_longitude.get_param(param_name);
    mp_field_longitude->set_id(new Module_Param_FieldName(mcopystr("longitude")));
    mp->add_elem(mp_field_longitude);
    Module_Param* mp_field_elevation = single_value->field_elevation.get_param(param_name);
    mp_field_elevation->set_id(new Module_Param_FieldName(mcopystr("elevation")));
    mp->add_elem(mp_field_elevation);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ThreeDLocation_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_latitude.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ThreeDLocation");
single_value->field_longitude.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ThreeDLocation");
single_value->field_elevation.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ThreeDLocation");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.ThreeDLocation");
}

boolean ThreeDLocation_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ThreeDLocation_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const ThreeDLocation ThreeDLocations::UNBOUND_ELEM;
boolean ThreeDLocations::compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index)
{
if (((const ThreeDLocations*)left_ptr)->val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
if (((const ThreeDLocations*)right_ptr)->val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
if (((const ThreeDLocations*)left_ptr)->val_ptr->value_elements[left_index] != NULL){
if (((const ThreeDLocations*)right_ptr)->val_ptr->value_elements[right_index] != NULL){
return *((const ThreeDLocations*)left_ptr)->val_ptr->value_elements[left_index] == *((const ThreeDLocations*)right_ptr)->val_ptr->value_elements[right_index];
} else return FALSE;
} else {
return ((const ThreeDLocations*)right_ptr)->val_ptr->value_elements[right_index] == NULL;
}
}

ThreeDLocations::ThreeDLocations()
{
val_ptr = NULL;
}

ThreeDLocations::ThreeDLocations(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

ThreeDLocations::ThreeDLocations(const ThreeDLocations& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

ThreeDLocations::~ThreeDLocations()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void ThreeDLocations::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

ThreeDLocations& ThreeDLocations::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

ThreeDLocations& ThreeDLocations::operator=(const ThreeDLocations& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean ThreeDLocations::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
return val_ptr->n_elements == 0 ;
}

boolean ThreeDLocations::operator==(const ThreeDLocations& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
if (val_ptr == other_value.val_ptr) return TRUE;
return compare_set_of(this, val_ptr->n_elements, &other_value, (other_value.val_ptr)->n_elements, compare_function);
}

ThreeDLocation& ThreeDLocations::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.ThreeDLocations using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (ThreeDLocation**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new ThreeDLocation(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new ThreeDLocation;
}
return *val_ptr->value_elements[index_value];
}

ThreeDLocation& ThreeDLocations::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
return (*this)[(int)index_value];
}

const ThreeDLocation& ThreeDLocations::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.ThreeDLocations using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsSecurity_TypesAndValues.ThreeDLocations: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const ThreeDLocation& ThreeDLocations::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
return (*this)[(int)index_value];
}

ThreeDLocations ThreeDLocations::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

ThreeDLocations ThreeDLocations::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

ThreeDLocations ThreeDLocations::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

ThreeDLocations ThreeDLocations::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
ThreeDLocations ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new ThreeDLocation(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

ThreeDLocations ThreeDLocations::operator+(const ThreeDLocations& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsSecurity_TypesAndValues.ThreeDLocations concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
ThreeDLocations ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new ThreeDLocation(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new ThreeDLocation(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

ThreeDLocations ThreeDLocations::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsSecurity_TypesAndValues.ThreeDLocations","element");
ThreeDLocations ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new ThreeDLocation(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

ThreeDLocations ThreeDLocations::replace(int index, int len, const ThreeDLocations& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsSecurity_TypesAndValues.ThreeDLocations","element");
ThreeDLocations ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new ThreeDLocation(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new ThreeDLocation(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new ThreeDLocation(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

ThreeDLocations ThreeDLocations::replace(int index, int len, const ThreeDLocations_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void ThreeDLocations::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (ThreeDLocation**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new ThreeDLocation(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (ThreeDLocation**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsSecurity_TypesAndValues.ThreeDLocations: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (ThreeDLocation**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean ThreeDLocations::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int ThreeDLocations::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
return val_ptr->n_elements;
}

int ThreeDLocations::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void ThreeDLocations::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void ThreeDLocations::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set of type `@LibItsSecurity_TypesAndValues.ThreeDLocations'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "set of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.ThreeDLocations");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.ThreeDLocations");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* ThreeDLocations::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of type `@LibItsSecurity_TypesAndValues.ThreeDLocations'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void ThreeDLocations::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void ThreeDLocations::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void ThreeDLocations::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
val_ptr->value_elements = (ThreeDLocation**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new ThreeDLocation;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void ThreeDLocations::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ThreeDLocations::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ThreeDLocations::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int ThreeDLocations::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

void ThreeDLocations_template::copy_value(const ThreeDLocations& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (ThreeDLocation_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new ThreeDLocation_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new ThreeDLocation_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void ThreeDLocations_template::copy_template(const ThreeDLocations_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (ThreeDLocation_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new ThreeDLocation_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new ThreeDLocation_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ThreeDLocations_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = other_value.value_set.n_items;
value_set.set_items = new ThreeDLocation_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count] = other_value.value_set.set_items[set_count];
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
break;
}
set_selection(other_value);
}

boolean ThreeDLocations_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const ThreeDLocations_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const ThreeDLocations*)value_ptr)[value_index], legacy);
else return ((const ThreeDLocations_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

boolean ThreeDLocations_template::match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const ThreeDLocations_template*)template_ptr)->value_set.set_items[template_index].match((*(const ThreeDLocations*)value_ptr)[value_index], legacy);
else return ((const ThreeDLocations_template*)template_ptr)->value_set.set_items[template_index].is_any_or_omit();
}

void ThreeDLocations_template::log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy)
{
if (value_ptr != NULL && template_ptr != NULL)((const ThreeDLocations_template*)template_ptr)->single_value.value_elements[index_template]->log_match((*(const ThreeDLocations*)value_ptr)[index_value], legacy);
else if (value_ptr != NULL) (*(const ThreeDLocations*)value_ptr)[index_value].log();
else if (template_ptr != NULL) ((const ThreeDLocations_template*)template_ptr)->single_value.value_elements[index_template]->log();
}

ThreeDLocations_template::ThreeDLocations_template()
{
}

ThreeDLocations_template::ThreeDLocations_template(template_sel other_value)
 : Restricted_Length_Template(other_value)
{
check_single_selection(other_value);
}

ThreeDLocations_template::ThreeDLocations_template(null_type)
 : Restricted_Length_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

ThreeDLocations_template::ThreeDLocations_template(const ThreeDLocations& other_value)
{
copy_value(other_value);
}

ThreeDLocations_template::ThreeDLocations_template(const OPTIONAL<ThreeDLocations>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ThreeDLocations&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations from an unbound optional field.");
}
}

ThreeDLocations_template::ThreeDLocations_template(const ThreeDLocations_template& other_value)
 : Restricted_Length_Template()
{
copy_template(other_value);
}

ThreeDLocations_template::~ThreeDLocations_template()
{
clean_up();
}

void ThreeDLocations_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
delete [] value_set.set_items;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ThreeDLocations_template& ThreeDLocations_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ThreeDLocations_template& ThreeDLocations_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

ThreeDLocations_template& ThreeDLocations_template::operator=(const ThreeDLocations& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ThreeDLocations_template& ThreeDLocations_template::operator=(const OPTIONAL<ThreeDLocations>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ThreeDLocations&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
}
return *this;
}

ThreeDLocations_template& ThreeDLocations_template::operator=(const ThreeDLocations_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

ThreeDLocation_template& ThreeDLocations_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.ThreeDLocations using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
    break;
}
return *single_value.value_elements[index_value];
}

ThreeDLocation_template& ThreeDLocations_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
return (*this)[(int)index_value];
}

const ThreeDLocation_template& ThreeDLocations_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.ThreeDLocations using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const ThreeDLocation_template& ThreeDLocations_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
return (*this)[(int)index_value];
}

void ThreeDLocations_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (ThreeDLocation_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new ThreeDLocation_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new ThreeDLocation_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (ThreeDLocation_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int ThreeDLocations_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int ThreeDLocations_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case SUPERSET_MATCH:
case SUBSET_MATCH: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = value_set.n_items;
  if (!is_size) { while (elem_count>0 && !value_set.set_items[elem_count-1].is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (value_set.set_items[i].get_selection())
    {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
  if (template_selection==SUPERSET_MATCH) {
    has_any_or_none = TRUE;
   } else {
    int max_size = min_size;
    min_size = 0;
    if (!has_any_or_none) { // [0,max_size]
      switch (length_restriction_type) {
      case NO_LENGTH_RESTRICTION:
        if (max_size==0) return 0;
        TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations with no exact size.", op_name);
      case SINGLE_LENGTH_RESTRICTION:
        if (length_restriction.single_length<=max_size)
          return length_restriction.single_length;
        TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.ThreeDLocations. The maximum size (%d) contradicts the length restriction (%d).", op_name, max_size, length_restriction.single_length);
      case RANGE_LENGTH_RESTRICTION:
        if (max_size==length_restriction.range_length.min_length) {
          return max_size;
        } else if (max_size>length_restriction.range_length.min_length){
          TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations with no exact size.", op_name);
        } else
          TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.ThreeDLocations. Maximum size (%d) contradicts the length restriction (%d..%d).", op_name, max_size, length_restriction.range_length.min_length, length_restriction.range_length.max_length);
      default:
        TTCN_error("Internal error: Template has invalid length restriction type.");
      }
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ThreeDLocations.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsSecurity_TypesAndValues.ThreeDLocations");
}

boolean ThreeDLocations_template::match(const ThreeDLocations& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_set_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case SUPERSET_MATCH:
case SUBSET_MATCH:
return match_set_of(&other_value, value_length, this, value_set.n_items, match_function_set, legacy);
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
}
return FALSE;
}

boolean ThreeDLocations_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

ThreeDLocations ThreeDLocations_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
ThreeDLocations ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

ThreeDLocations ThreeDLocations_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

ThreeDLocations ThreeDLocations_template::replace(int index, int len, const ThreeDLocations_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

ThreeDLocations ThreeDLocations_template::replace(int index, int len, const ThreeDLocations& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void ThreeDLocations_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new ThreeDLocations_template[list_length];
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = list_length;
value_set.set_items = new ThreeDLocation_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
}
set_selection(template_type);
}

ThreeDLocations_template& ThreeDLocations_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
return value_list.list_value[list_index];
}

ThreeDLocation_template& ThreeDLocations_template::set_item(unsigned int set_index)
{
if (template_selection != SUPERSET_MATCH && template_selection != SUBSET_MATCH) TTCN_error("Internal error: Accessing a set element of a non-set template of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
if (set_index >= value_set.n_items) TTCN_error("Internal error: Index overflow in a set template of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
return value_set.set_items[set_index];
}

void ThreeDLocations_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log();
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
TTCN_Logger::log_event("%s(", template_selection == SUPERSET_MATCH ? "superset" : "subset");
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++) {
if (set_count > 0) TTCN_Logger::log_event_str(", ");
value_set.set_items[set_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void ThreeDLocations_template::log_match(const ThreeDLocations& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (template_selection == SPECIFIC_VALUE)
  log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
else{
if(previous_size != 0){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::set_logmatch_buffer_len(previous_size);
TTCN_Logger::log_event_str(":=");
}
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
return;
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else {
TTCN_Logger::log_event_str(" unmatched");
if (template_selection == SPECIFIC_VALUE) log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
}
}

void ThreeDLocations_template::encode_text(Text_Buf& text_buf) const
{
encode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
text_buf.push_int(value_set.n_items);
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
}
}

void ThreeDLocations_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
single_value.value_elements = (ThreeDLocation_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new ThreeDLocation_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ThreeDLocations_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = text_buf.pull_int().get_val();
value_set.set_items = new ThreeDLocation_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
}
}

boolean ThreeDLocations_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ThreeDLocations_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void ThreeDLocations_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set template type `@LibItsSecurity_TypesAndValues.ThreeDLocations'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "set of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ThreeDLocations_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    set_size(mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      if (mp->get_elem(p_i)->get_type()!=Module_Param::MP_NotUsed) {
        (*this)[p_i].set_param(*mp->get_elem(p_i));
      }
    }
    break;
  case Module_Param::MP_Superset_Template:
  case Module_Param::MP_Subset_Template:
    set_type(mp->get_type()==Module_Param::MP_Superset_Template ? SUPERSET_MATCH : SUBSET_MATCH, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      set_item(p_i).set_param(*mp->get_elem(p_i));
    }
    break;
  default:
    param.type_error("set of template", "@LibItsSecurity_TypesAndValues.ThreeDLocations");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* ThreeDLocations_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of template type `@LibItsSecurity_TypesAndValues.ThreeDLocations'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void ThreeDLocations_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ThreeDLocations");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.ThreeDLocations");
}


const HeaderField HeaderFields::UNBOUND_ELEM;
boolean HeaderFields::compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index)
{
if (((const HeaderFields*)left_ptr)->val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
if (((const HeaderFields*)right_ptr)->val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
if (((const HeaderFields*)left_ptr)->val_ptr->value_elements[left_index] != NULL){
if (((const HeaderFields*)right_ptr)->val_ptr->value_elements[right_index] != NULL){
return *((const HeaderFields*)left_ptr)->val_ptr->value_elements[left_index] == *((const HeaderFields*)right_ptr)->val_ptr->value_elements[right_index];
} else return FALSE;
} else {
return ((const HeaderFields*)right_ptr)->val_ptr->value_elements[right_index] == NULL;
}
}

HeaderFields::HeaderFields()
{
val_ptr = NULL;
}

HeaderFields::HeaderFields(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

HeaderFields::HeaderFields(const HeaderFields& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

HeaderFields::~HeaderFields()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void HeaderFields::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

HeaderFields& HeaderFields::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

HeaderFields& HeaderFields::operator=(const HeaderFields& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean HeaderFields::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
return val_ptr->n_elements == 0 ;
}

boolean HeaderFields::operator==(const HeaderFields& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
if (val_ptr == other_value.val_ptr) return TRUE;
return compare_set_of(this, val_ptr->n_elements, &other_value, (other_value.val_ptr)->n_elements, compare_function);
}

HeaderField& HeaderFields::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.HeaderFields using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (HeaderField**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new HeaderField(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new HeaderField;
}
return *val_ptr->value_elements[index_value];
}

HeaderField& HeaderFields::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
return (*this)[(int)index_value];
}

const HeaderField& HeaderFields::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.HeaderFields using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsSecurity_TypesAndValues.HeaderFields: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const HeaderField& HeaderFields::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
return (*this)[(int)index_value];
}

HeaderFields HeaderFields::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

HeaderFields HeaderFields::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

HeaderFields HeaderFields::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

HeaderFields HeaderFields::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
HeaderFields ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new HeaderField(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

HeaderFields HeaderFields::operator+(const HeaderFields& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsSecurity_TypesAndValues.HeaderFields concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
HeaderFields ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new HeaderField(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new HeaderField(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

HeaderFields HeaderFields::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsSecurity_TypesAndValues.HeaderFields","element");
HeaderFields ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new HeaderField(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

HeaderFields HeaderFields::replace(int index, int len, const HeaderFields& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsSecurity_TypesAndValues.HeaderFields","element");
HeaderFields ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new HeaderField(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new HeaderField(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new HeaderField(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

HeaderFields HeaderFields::replace(int index, int len, const HeaderFields_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void HeaderFields::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (HeaderField**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new HeaderField(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (HeaderField**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsSecurity_TypesAndValues.HeaderFields: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (HeaderField**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean HeaderFields::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int HeaderFields::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
return val_ptr->n_elements;
}

int HeaderFields::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void HeaderFields::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void HeaderFields::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set of type `@LibItsSecurity_TypesAndValues.HeaderFields'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "set of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.HeaderFields");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.HeaderFields");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* HeaderFields::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of type `@LibItsSecurity_TypesAndValues.HeaderFields'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void HeaderFields::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void HeaderFields::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void HeaderFields::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
val_ptr->value_elements = (HeaderField**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new HeaderField;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void HeaderFields::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void HeaderFields::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int HeaderFields::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int HeaderFields::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

int HeaderFields::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int HeaderFields::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    HeaderField* val = new HeaderField;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (HeaderField**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void HeaderFields_template::copy_value(const HeaderFields& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsSecurity_TypesAndValues.HeaderFields with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (HeaderField_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new HeaderField_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new HeaderField_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void HeaderFields_template::copy_template(const HeaderFields_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (HeaderField_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new HeaderField_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new HeaderField_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new HeaderFields_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = other_value.value_set.n_items;
value_set.set_items = new HeaderField_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count] = other_value.value_set.set_items[set_count];
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.HeaderFields.");
break;
}
set_selection(other_value);
}

boolean HeaderFields_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const HeaderFields_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const HeaderFields*)value_ptr)[value_index], legacy);
else return ((const HeaderFields_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

boolean HeaderFields_template::match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const HeaderFields_template*)template_ptr)->value_set.set_items[template_index].match((*(const HeaderFields*)value_ptr)[value_index], legacy);
else return ((const HeaderFields_template*)template_ptr)->value_set.set_items[template_index].is_any_or_omit();
}

void HeaderFields_template::log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy)
{
if (value_ptr != NULL && template_ptr != NULL)((const HeaderFields_template*)template_ptr)->single_value.value_elements[index_template]->log_match((*(const HeaderFields*)value_ptr)[index_value], legacy);
else if (value_ptr != NULL) (*(const HeaderFields*)value_ptr)[index_value].log();
else if (template_ptr != NULL) ((const HeaderFields_template*)template_ptr)->single_value.value_elements[index_template]->log();
}

HeaderFields_template::HeaderFields_template()
{
}

HeaderFields_template::HeaderFields_template(template_sel other_value)
 : Restricted_Length_Template(other_value)
{
check_single_selection(other_value);
}

HeaderFields_template::HeaderFields_template(null_type)
 : Restricted_Length_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

HeaderFields_template::HeaderFields_template(const HeaderFields& other_value)
{
copy_value(other_value);
}

HeaderFields_template::HeaderFields_template(const OPTIONAL<HeaderFields>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const HeaderFields&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.HeaderFields from an unbound optional field.");
}
}

HeaderFields_template::HeaderFields_template(const HeaderFields_template& other_value)
 : Restricted_Length_Template()
{
copy_template(other_value);
}

HeaderFields_template::~HeaderFields_template()
{
clean_up();
}

void HeaderFields_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
delete [] value_set.set_items;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

HeaderFields_template& HeaderFields_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

HeaderFields_template& HeaderFields_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

HeaderFields_template& HeaderFields_template::operator=(const HeaderFields& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

HeaderFields_template& HeaderFields_template::operator=(const OPTIONAL<HeaderFields>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const HeaderFields&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.HeaderFields.");
}
return *this;
}

HeaderFields_template& HeaderFields_template::operator=(const HeaderFields_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

HeaderField_template& HeaderFields_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.HeaderFields using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.HeaderFields.");
    break;
}
return *single_value.value_elements[index_value];
}

HeaderField_template& HeaderFields_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.HeaderFields.");
return (*this)[(int)index_value];
}

const HeaderField_template& HeaderFields_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.HeaderFields using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.HeaderFields.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsSecurity_TypesAndValues.HeaderFields: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const HeaderField_template& HeaderFields_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.HeaderFields.");
return (*this)[(int)index_value];
}

void HeaderFields_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsSecurity_TypesAndValues.HeaderFields.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (HeaderField_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new HeaderField_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new HeaderField_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (HeaderField_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int HeaderFields_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int HeaderFields_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.HeaderFields which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.HeaderFields containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case SUPERSET_MATCH:
case SUBSET_MATCH: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = value_set.n_items;
  if (!is_size) { while (elem_count>0 && !value_set.set_items[elem_count-1].is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (value_set.set_items[i].get_selection())
    {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.HeaderFields containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
  if (template_selection==SUPERSET_MATCH) {
    has_any_or_none = TRUE;
   } else {
    int max_size = min_size;
    min_size = 0;
    if (!has_any_or_none) { // [0,max_size]
      switch (length_restriction_type) {
      case NO_LENGTH_RESTRICTION:
        if (max_size==0) return 0;
        TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.HeaderFields with no exact size.", op_name);
      case SINGLE_LENGTH_RESTRICTION:
        if (length_restriction.single_length<=max_size)
          return length_restriction.single_length;
        TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.HeaderFields. The maximum size (%d) contradicts the length restriction (%d).", op_name, max_size, length_restriction.single_length);
      case RANGE_LENGTH_RESTRICTION:
        if (max_size==length_restriction.range_length.min_length) {
          return max_size;
        } else if (max_size>length_restriction.range_length.min_length){
          TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.HeaderFields with no exact size.", op_name);
        } else
          TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.HeaderFields. Maximum size (%d) contradicts the length restriction (%d..%d).", op_name, max_size, length_restriction.range_length.min_length, length_restriction.range_length.max_length);
      default:
        TTCN_error("Internal error: Template has invalid length restriction type.");
      }
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.HeaderFields containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.HeaderFields containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.HeaderFields containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.HeaderFields containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.HeaderFields.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsSecurity_TypesAndValues.HeaderFields");
}

boolean HeaderFields_template::match(const HeaderFields& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_set_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case SUPERSET_MATCH:
case SUBSET_MATCH:
return match_set_of(&other_value, value_length, this, value_set.n_items, match_function_set, legacy);
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.HeaderFields.");
}
return FALSE;
}

boolean HeaderFields_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

HeaderFields HeaderFields_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.HeaderFields.");
HeaderFields ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

HeaderFields HeaderFields_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

HeaderFields HeaderFields_template::replace(int index, int len, const HeaderFields_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

HeaderFields HeaderFields_template::replace(int index, int len, const HeaderFields& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void HeaderFields_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new HeaderFields_template[list_length];
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = list_length;
value_set.set_items = new HeaderField_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsSecurity_TypesAndValues.HeaderFields.");
}
set_selection(template_type);
}

HeaderFields_template& HeaderFields_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.HeaderFields.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.HeaderFields.");
return value_list.list_value[list_index];
}

HeaderField_template& HeaderFields_template::set_item(unsigned int set_index)
{
if (template_selection != SUPERSET_MATCH && template_selection != SUBSET_MATCH) TTCN_error("Internal error: Accessing a set element of a non-set template of type @LibItsSecurity_TypesAndValues.HeaderFields.");
if (set_index >= value_set.n_items) TTCN_error("Internal error: Index overflow in a set template of type @LibItsSecurity_TypesAndValues.HeaderFields.");
return value_set.set_items[set_index];
}

void HeaderFields_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log();
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
TTCN_Logger::log_event("%s(", template_selection == SUPERSET_MATCH ? "superset" : "subset");
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++) {
if (set_count > 0) TTCN_Logger::log_event_str(", ");
value_set.set_items[set_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void HeaderFields_template::log_match(const HeaderFields& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (template_selection == SPECIFIC_VALUE)
  log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
else{
if(previous_size != 0){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::set_logmatch_buffer_len(previous_size);
TTCN_Logger::log_event_str(":=");
}
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
return;
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else {
TTCN_Logger::log_event_str(" unmatched");
if (template_selection == SPECIFIC_VALUE) log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
}
}

void HeaderFields_template::encode_text(Text_Buf& text_buf) const
{
encode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
text_buf.push_int(value_set.n_items);
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.HeaderFields.");
}
}

void HeaderFields_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsSecurity_TypesAndValues.HeaderFields.");
single_value.value_elements = (HeaderField_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new HeaderField_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new HeaderFields_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = text_buf.pull_int().get_val();
value_set.set_items = new HeaderField_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsSecurity_TypesAndValues.HeaderFields.");
}
}

boolean HeaderFields_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean HeaderFields_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void HeaderFields_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set template type `@LibItsSecurity_TypesAndValues.HeaderFields'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "set of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    HeaderFields_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    set_size(mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      if (mp->get_elem(p_i)->get_type()!=Module_Param::MP_NotUsed) {
        (*this)[p_i].set_param(*mp->get_elem(p_i));
      }
    }
    break;
  case Module_Param::MP_Superset_Template:
  case Module_Param::MP_Subset_Template:
    set_type(mp->get_type()==Module_Param::MP_Superset_Template ? SUPERSET_MATCH : SUBSET_MATCH, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      set_item(p_i).set_param(*mp->get_elem(p_i));
    }
    break;
  default:
    param.type_error("set of template", "@LibItsSecurity_TypesAndValues.HeaderFields");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* HeaderFields_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of template type `@LibItsSecurity_TypesAndValues.HeaderFields'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void HeaderFields_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.HeaderFields");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.HeaderFields");
}

HeaderFieldType::HeaderFieldType()
{
enum_value = UNBOUND_VALUE;
}

HeaderFieldType::HeaderFieldType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

HeaderFieldType::HeaderFieldType(enum_type other_value)
{
enum_value = other_value;
}

HeaderFieldType::HeaderFieldType(const HeaderFieldType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
enum_value = other_value.enum_value;
}

HeaderFieldType& HeaderFieldType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

HeaderFieldType& HeaderFieldType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

HeaderFieldType& HeaderFieldType::operator=(const HeaderFieldType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
enum_value = other_value.enum_value;
return *this;
}

boolean HeaderFieldType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
return enum_value == other_value;
}

boolean HeaderFieldType::operator==(const HeaderFieldType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
return enum_value == other_value.enum_value;
}

boolean HeaderFieldType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
return enum_value < other_value;
}

boolean HeaderFieldType::operator<(const HeaderFieldType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
return enum_value < other_value.enum_value;
}

boolean HeaderFieldType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
return enum_value > other_value;
}

boolean HeaderFieldType::operator>(const HeaderFieldType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
return enum_value > other_value.enum_value;
}

const char *HeaderFieldType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__generation__time: return "e_generation_time";
case e__generation__time__standard__deviation: return "e_generation_time_standard_deviation";
case e__expiration: return "e_expiration";
case e__generation__location: return "e_generation_location";
case e__request__unrecognized__certificate: return "e_request_unrecognized_certificate";
case e__its__aid: return "e_its_aid";
case e__signer__info: return "e_signer_info";
case e__encryption__parameters: return "e_encryption_parameters";
case e__recipient__info: return "e_recipient_info";
default: return "<unknown>";
}
}

HeaderFieldType::enum_type HeaderFieldType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_generation_time")) return e__generation__time;
else if (!strcmp(str_par, "e_generation_time_standard_deviation")) return e__generation__time__standard__deviation;
else if (!strcmp(str_par, "e_expiration")) return e__expiration;
else if (!strcmp(str_par, "e_generation_location")) return e__generation__location;
else if (!strcmp(str_par, "e_request_unrecognized_certificate")) return e__request__unrecognized__certificate;
else if (!strcmp(str_par, "e_its_aid")) return e__its__aid;
else if (!strcmp(str_par, "e_signer_info")) return e__signer__info;
else if (!strcmp(str_par, "e_encryption_parameters")) return e__encryption__parameters;
else if (!strcmp(str_par, "e_recipient_info")) return e__recipient__info;
else return UNKNOWN_VALUE;
}

boolean HeaderFieldType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 128:
case 129:
case 130:
return TRUE;
default:
return FALSE;
}
}

int HeaderFieldType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int HeaderFieldType::enum2int(const HeaderFieldType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void HeaderFieldType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.", int_val);
enum_value = (enum_type)int_val;
}

HeaderFieldType::operator HeaderFieldType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
return enum_value;
}

void HeaderFieldType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void HeaderFieldType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsSecurity_TypesAndValues.HeaderFieldType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
  }
}

Module_Param* HeaderFieldType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void HeaderFieldType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
text_buf.push_int(enum_value);
}

void HeaderFieldType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.", enum_value);
}

void HeaderFieldType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void HeaderFieldType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int HeaderFieldType::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 8, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int HeaderFieldType::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 8);
}

int HeaderFieldType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int HeaderFieldType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void HeaderFieldType_template::copy_template(const HeaderFieldType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new HeaderFieldType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
}
}

HeaderFieldType_template::HeaderFieldType_template()
{
}

HeaderFieldType_template::HeaderFieldType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

HeaderFieldType_template::HeaderFieldType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!HeaderFieldType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType with unknown numeric value %d.", other_value);
single_value = (HeaderFieldType::enum_type)other_value;
}

HeaderFieldType_template::HeaderFieldType_template(HeaderFieldType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

HeaderFieldType_template::HeaderFieldType_template(const HeaderFieldType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == HeaderFieldType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
single_value = other_value.enum_value;
}

HeaderFieldType_template::HeaderFieldType_template(const OPTIONAL<HeaderFieldType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (HeaderFieldType::enum_type)(const HeaderFieldType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType from an unbound optional field.");
}
}

HeaderFieldType_template::HeaderFieldType_template(const HeaderFieldType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

HeaderFieldType_template::~HeaderFieldType_template()
{
clean_up();
}

boolean HeaderFieldType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean HeaderFieldType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != HeaderFieldType::UNBOUND_VALUE;
}

void HeaderFieldType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

HeaderFieldType_template& HeaderFieldType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

HeaderFieldType_template& HeaderFieldType_template::operator=(int other_value)
{
if (!HeaderFieldType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (HeaderFieldType::enum_type)other_value;
return *this;
}

HeaderFieldType_template& HeaderFieldType_template::operator=(HeaderFieldType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

HeaderFieldType_template& HeaderFieldType_template::operator=(const HeaderFieldType& other_value)
{
if (other_value.enum_value == HeaderFieldType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

HeaderFieldType_template& HeaderFieldType_template::operator=(const OPTIONAL<HeaderFieldType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (HeaderFieldType::enum_type)(const HeaderFieldType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
}
return *this;
}

HeaderFieldType_template& HeaderFieldType_template::operator=(const HeaderFieldType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean HeaderFieldType_template::match(HeaderFieldType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
}
return FALSE;
}

boolean HeaderFieldType_template::match(const HeaderFieldType& other_value, boolean) const
{
if (other_value.enum_value == HeaderFieldType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType with an unbound value.");
return match(other_value.enum_value);
}

HeaderFieldType::enum_type HeaderFieldType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
return single_value;
}

void HeaderFieldType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new HeaderFieldType_template[list_length];
}

HeaderFieldType_template& HeaderFieldType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
return value_list.list_value[list_index];
}

void HeaderFieldType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(HeaderFieldType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void HeaderFieldType_template::log_match(const HeaderFieldType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void HeaderFieldType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
}
}

void HeaderFieldType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (HeaderFieldType::enum_type)text_buf.pull_int().get_val();
if (!HeaderFieldType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new HeaderFieldType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
}
}

boolean HeaderFieldType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean HeaderFieldType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void HeaderFieldType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    HeaderFieldType::enum_type enum_val = (enum_name != NULL) ? HeaderFieldType::str_to_enum(enum_name) : HeaderFieldType::UNKNOWN_VALUE;
    if (HeaderFieldType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    HeaderFieldType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    HeaderFieldType::enum_type enum_val = HeaderFieldType::str_to_enum(mp->get_enumerated());
    if (!HeaderFieldType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.HeaderFieldType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsSecurity_TypesAndValues.HeaderFieldType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* HeaderFieldType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(HeaderFieldType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void HeaderFieldType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.HeaderFieldType");
}

void HeaderFieldContainer::copy_value(const HeaderFieldContainer& other_value)
{
switch (other_value.union_selection) {
case ALT_generation__time:
field_generation__time = new INTEGER(*other_value.field_generation__time);
break;
case ALT_generation__time__with__standard__deviation:
field_generation__time__with__standard__deviation = new Time64WithStandardDeviation(*other_value.field_generation__time__with__standard__deviation);
break;
case ALT_expiry__time:
field_expiry__time = new INTEGER(*other_value.field_expiry__time);
break;
case ALT_generation__location:
field_generation__location = new ThreeDLocation(*other_value.field_generation__location);
break;
case ALT_digests:
field_digests = new HashedId3s(*other_value.field_digests);
break;
case ALT_its__aid:
field_its__aid = new INTEGER(*other_value.field_its__aid);
break;
case ALT_signer:
field_signer = new SignerInfo(*other_value.field_signer);
break;
case ALT_enc__params:
field_enc__params = new EncryptionParameters(*other_value.field_enc__params);
break;
case ALT_recipients:
field_recipients = new RecipientInfos(*other_value.field_recipients);
break;
case ALT_other__header:
field_other__header = new OCTETSTRING(*other_value.field_other__header);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
}
union_selection = other_value.union_selection;
}

HeaderFieldContainer::HeaderFieldContainer()
{
union_selection = UNBOUND_VALUE;
}

HeaderFieldContainer::HeaderFieldContainer(const HeaderFieldContainer& other_value)
: Base_Type(){
copy_value(other_value);
}

HeaderFieldContainer::~HeaderFieldContainer()
{
clean_up();
}

HeaderFieldContainer& HeaderFieldContainer::operator=(const HeaderFieldContainer& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean HeaderFieldContainer::operator==(const HeaderFieldContainer& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_generation__time:
return *field_generation__time == *other_value.field_generation__time;
case ALT_generation__time__with__standard__deviation:
return *field_generation__time__with__standard__deviation == *other_value.field_generation__time__with__standard__deviation;
case ALT_expiry__time:
return *field_expiry__time == *other_value.field_expiry__time;
case ALT_generation__location:
return *field_generation__location == *other_value.field_generation__location;
case ALT_digests:
return *field_digests == *other_value.field_digests;
case ALT_its__aid:
return *field_its__aid == *other_value.field_its__aid;
case ALT_signer:
return *field_signer == *other_value.field_signer;
case ALT_enc__params:
return *field_enc__params == *other_value.field_enc__params;
case ALT_recipients:
return *field_recipients == *other_value.field_recipients;
case ALT_other__header:
return *field_other__header == *other_value.field_other__header;
default:
return FALSE;
}
}

INTEGER& HeaderFieldContainer::generation__time()
{
if (union_selection != ALT_generation__time) {
clean_up();
field_generation__time = new INTEGER;
union_selection = ALT_generation__time;
}
return *field_generation__time;
}

const INTEGER& HeaderFieldContainer::generation__time() const
{
if (union_selection != ALT_generation__time) TTCN_error("Using non-selected field generation_time in a value of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *field_generation__time;
}

Time64WithStandardDeviation& HeaderFieldContainer::generation__time__with__standard__deviation()
{
if (union_selection != ALT_generation__time__with__standard__deviation) {
clean_up();
field_generation__time__with__standard__deviation = new Time64WithStandardDeviation;
union_selection = ALT_generation__time__with__standard__deviation;
}
return *field_generation__time__with__standard__deviation;
}

const Time64WithStandardDeviation& HeaderFieldContainer::generation__time__with__standard__deviation() const
{
if (union_selection != ALT_generation__time__with__standard__deviation) TTCN_error("Using non-selected field generation_time_with_standard_deviation in a value of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *field_generation__time__with__standard__deviation;
}

INTEGER& HeaderFieldContainer::expiry__time()
{
if (union_selection != ALT_expiry__time) {
clean_up();
field_expiry__time = new INTEGER;
union_selection = ALT_expiry__time;
}
return *field_expiry__time;
}

const INTEGER& HeaderFieldContainer::expiry__time() const
{
if (union_selection != ALT_expiry__time) TTCN_error("Using non-selected field expiry_time in a value of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *field_expiry__time;
}

ThreeDLocation& HeaderFieldContainer::generation__location()
{
if (union_selection != ALT_generation__location) {
clean_up();
field_generation__location = new ThreeDLocation;
union_selection = ALT_generation__location;
}
return *field_generation__location;
}

const ThreeDLocation& HeaderFieldContainer::generation__location() const
{
if (union_selection != ALT_generation__location) TTCN_error("Using non-selected field generation_location in a value of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *field_generation__location;
}

HashedId3s& HeaderFieldContainer::digests()
{
if (union_selection != ALT_digests) {
clean_up();
field_digests = new HashedId3s;
union_selection = ALT_digests;
}
return *field_digests;
}

const HashedId3s& HeaderFieldContainer::digests() const
{
if (union_selection != ALT_digests) TTCN_error("Using non-selected field digests in a value of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *field_digests;
}

INTEGER& HeaderFieldContainer::its__aid()
{
if (union_selection != ALT_its__aid) {
clean_up();
field_its__aid = new INTEGER;
union_selection = ALT_its__aid;
}
return *field_its__aid;
}

const INTEGER& HeaderFieldContainer::its__aid() const
{
if (union_selection != ALT_its__aid) TTCN_error("Using non-selected field its_aid in a value of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *field_its__aid;
}

SignerInfo& HeaderFieldContainer::signer()
{
if (union_selection != ALT_signer) {
clean_up();
field_signer = new SignerInfo;
union_selection = ALT_signer;
}
return *field_signer;
}

const SignerInfo& HeaderFieldContainer::signer() const
{
if (union_selection != ALT_signer) TTCN_error("Using non-selected field signer in a value of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *field_signer;
}

EncryptionParameters& HeaderFieldContainer::enc__params()
{
if (union_selection != ALT_enc__params) {
clean_up();
field_enc__params = new EncryptionParameters;
union_selection = ALT_enc__params;
}
return *field_enc__params;
}

const EncryptionParameters& HeaderFieldContainer::enc__params() const
{
if (union_selection != ALT_enc__params) TTCN_error("Using non-selected field enc_params in a value of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *field_enc__params;
}

RecipientInfos& HeaderFieldContainer::recipients()
{
if (union_selection != ALT_recipients) {
clean_up();
field_recipients = new RecipientInfos;
union_selection = ALT_recipients;
}
return *field_recipients;
}

const RecipientInfos& HeaderFieldContainer::recipients() const
{
if (union_selection != ALT_recipients) TTCN_error("Using non-selected field recipients in a value of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *field_recipients;
}

OCTETSTRING& HeaderFieldContainer::other__header()
{
if (union_selection != ALT_other__header) {
clean_up();
field_other__header = new OCTETSTRING;
union_selection = ALT_other__header;
}
return *field_other__header;
}

const OCTETSTRING& HeaderFieldContainer::other__header() const
{
if (union_selection != ALT_other__header) TTCN_error("Using non-selected field other_header in a value of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *field_other__header;
}

boolean HeaderFieldContainer::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return union_selection == checked_selection;
}

boolean HeaderFieldContainer::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean HeaderFieldContainer::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_generation__time: return field_generation__time->is_value();
case ALT_generation__time__with__standard__deviation: return field_generation__time__with__standard__deviation->is_value();
case ALT_expiry__time: return field_expiry__time->is_value();
case ALT_generation__location: return field_generation__location->is_value();
case ALT_digests: return field_digests->is_value();
case ALT_its__aid: return field_its__aid->is_value();
case ALT_signer: return field_signer->is_value();
case ALT_enc__params: return field_enc__params->is_value();
case ALT_recipients: return field_recipients->is_value();
case ALT_other__header: return field_other__header->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void HeaderFieldContainer::clean_up()
{
switch (union_selection) {
case ALT_generation__time:
  delete field_generation__time;
  break;
case ALT_generation__time__with__standard__deviation:
  delete field_generation__time__with__standard__deviation;
  break;
case ALT_expiry__time:
  delete field_expiry__time;
  break;
case ALT_generation__location:
  delete field_generation__location;
  break;
case ALT_digests:
  delete field_digests;
  break;
case ALT_its__aid:
  delete field_its__aid;
  break;
case ALT_signer:
  delete field_signer;
  break;
case ALT_enc__params:
  delete field_enc__params;
  break;
case ALT_recipients:
  delete field_recipients;
  break;
case ALT_other__header:
  delete field_other__header;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void HeaderFieldContainer::log() const
{
switch (union_selection) {
case ALT_generation__time:
TTCN_Logger::log_event_str("{ generation_time := ");
field_generation__time->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_generation__time__with__standard__deviation:
TTCN_Logger::log_event_str("{ generation_time_with_standard_deviation := ");
field_generation__time__with__standard__deviation->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_expiry__time:
TTCN_Logger::log_event_str("{ expiry_time := ");
field_expiry__time->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_generation__location:
TTCN_Logger::log_event_str("{ generation_location := ");
field_generation__location->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_digests:
TTCN_Logger::log_event_str("{ digests := ");
field_digests->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_its__aid:
TTCN_Logger::log_event_str("{ its_aid := ");
field_its__aid->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_signer:
TTCN_Logger::log_event_str("{ signer := ");
field_signer->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_enc__params:
TTCN_Logger::log_event_str("{ enc_params := ");
field_enc__params->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_recipients:
TTCN_Logger::log_event_str("{ recipients := ");
field_recipients->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_other__header:
TTCN_Logger::log_event_str("{ other_header := ");
field_other__header->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void HeaderFieldContainer::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsSecurity_TypesAndValues.HeaderFieldContainer'");
    }
    if (strcmp("generation_time", param_field) == 0) {
      generation__time().set_param(param);
      return;
    } else if (strcmp("generation_time_with_standard_deviation", param_field) == 0) {
      generation__time__with__standard__deviation().set_param(param);
      return;
    } else if (strcmp("expiry_time", param_field) == 0) {
      expiry__time().set_param(param);
      return;
    } else if (strcmp("generation_location", param_field) == 0) {
      generation__location().set_param(param);
      return;
    } else if (strcmp("digests", param_field) == 0) {
      digests().set_param(param);
      return;
    } else if (strcmp("its_aid", param_field) == 0) {
      its__aid().set_param(param);
      return;
    } else if (strcmp("signer", param_field) == 0) {
      signer().set_param(param);
      return;
    } else if (strcmp("enc_params", param_field) == 0) {
      enc__params().set_param(param);
      return;
    } else if (strcmp("recipients", param_field) == 0) {
      recipients().set_param(param);
      return;
    } else if (strcmp("other_header", param_field) == 0) {
      other__header().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsSecurity_TypesAndValues.HeaderFieldContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "generation_time")) {
    generation__time().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "generation_time_with_standard_deviation")) {
    generation__time__with__standard__deviation().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "expiry_time")) {
    expiry__time().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "generation_location")) {
    generation__location().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "digests")) {
    digests().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "its_aid")) {
    its__aid().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "signer")) {
    signer().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "enc_params")) {
    enc__params().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "recipients")) {
    recipients().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "other_header")) {
    other__header().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.", mp_last->get_id()->get_name());
}

Module_Param* HeaderFieldContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsSecurity_TypesAndValues.HeaderFieldContainer'");
    }
    if (strcmp("generation_time", param_field) == 0) {
      return generation__time().get_param(param_name);
    } else if (strcmp("generation_time_with_standard_deviation", param_field) == 0) {
      return generation__time__with__standard__deviation().get_param(param_name);
    } else if (strcmp("expiry_time", param_field) == 0) {
      return expiry__time().get_param(param_name);
    } else if (strcmp("generation_location", param_field) == 0) {
      return generation__location().get_param(param_name);
    } else if (strcmp("digests", param_field) == 0) {
      return digests().get_param(param_name);
    } else if (strcmp("its_aid", param_field) == 0) {
      return its__aid().get_param(param_name);
    } else if (strcmp("signer", param_field) == 0) {
      return signer().get_param(param_name);
    } else if (strcmp("enc_params", param_field) == 0) {
      return enc__params().get_param(param_name);
    } else if (strcmp("recipients", param_field) == 0) {
      return recipients().get_param(param_name);
    } else if (strcmp("other_header", param_field) == 0) {
      return other__header().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `HeaderFieldContainer'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_generation__time:
    mp_field = field_generation__time->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("generation_time")));
    break;
  case ALT_generation__time__with__standard__deviation:
    mp_field = field_generation__time__with__standard__deviation->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("generation_time_with_standard_deviation")));
    break;
  case ALT_expiry__time:
    mp_field = field_expiry__time->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("expiry_time")));
    break;
  case ALT_generation__location:
    mp_field = field_generation__location->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("generation_location")));
    break;
  case ALT_digests:
    mp_field = field_digests->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("digests")));
    break;
  case ALT_its__aid:
    mp_field = field_its__aid->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("its_aid")));
    break;
  case ALT_signer:
    mp_field = field_signer->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("signer")));
    break;
  case ALT_enc__params:
    mp_field = field_enc__params->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("enc_params")));
    break;
  case ALT_recipients:
    mp_field = field_recipients->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("recipients")));
    break;
  case ALT_other__header:
    mp_field = field_other__header->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("other_header")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void HeaderFieldContainer::set_implicit_omit()
{
switch (union_selection) {
case ALT_generation__time:
field_generation__time->set_implicit_omit(); break;
case ALT_generation__time__with__standard__deviation:
field_generation__time__with__standard__deviation->set_implicit_omit(); break;
case ALT_expiry__time:
field_expiry__time->set_implicit_omit(); break;
case ALT_generation__location:
field_generation__location->set_implicit_omit(); break;
case ALT_digests:
field_digests->set_implicit_omit(); break;
case ALT_its__aid:
field_its__aid->set_implicit_omit(); break;
case ALT_signer:
field_signer->set_implicit_omit(); break;
case ALT_enc__params:
field_enc__params->set_implicit_omit(); break;
case ALT_recipients:
field_recipients->set_implicit_omit(); break;
case ALT_other__header:
field_other__header->set_implicit_omit(); break;
default: break;
}
}

void HeaderFieldContainer::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_generation__time:
field_generation__time->encode_text(text_buf);
break;
case ALT_generation__time__with__standard__deviation:
field_generation__time__with__standard__deviation->encode_text(text_buf);
break;
case ALT_expiry__time:
field_expiry__time->encode_text(text_buf);
break;
case ALT_generation__location:
field_generation__location->encode_text(text_buf);
break;
case ALT_digests:
field_digests->encode_text(text_buf);
break;
case ALT_its__aid:
field_its__aid->encode_text(text_buf);
break;
case ALT_signer:
field_signer->encode_text(text_buf);
break;
case ALT_enc__params:
field_enc__params->encode_text(text_buf);
break;
case ALT_recipients:
field_recipients->encode_text(text_buf);
break;
case ALT_other__header:
field_other__header->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
}
}

void HeaderFieldContainer::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_generation__time:
generation__time().decode_text(text_buf);
break;
case ALT_generation__time__with__standard__deviation:
generation__time__with__standard__deviation().decode_text(text_buf);
break;
case ALT_expiry__time:
expiry__time().decode_text(text_buf);
break;
case ALT_generation__location:
generation__location().decode_text(text_buf);
break;
case ALT_digests:
digests().decode_text(text_buf);
break;
case ALT_its__aid:
its__aid().decode_text(text_buf);
break;
case ALT_signer:
signer().decode_text(text_buf);
break;
case ALT_enc__params:
enc__params().decode_text(text_buf);
break;
case ALT_recipients:
recipients().decode_text(text_buf);
break;
case ALT_other__header:
other__header().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
}
}

void HeaderFieldContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void HeaderFieldContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int HeaderFieldContainer::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = generation__time().RAW_decode(Time64_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = generation__time__with__standard__deviation().RAW_decode(Time64WithStandardDeviation_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 2:
      decoded_length = expiry__time().RAW_decode(Time32_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 3:
      decoded_length = generation__location().RAW_decode(ThreeDLocation_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 4:
      decoded_length = digests().RAW_decode(HashedId3s_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 5:
      decoded_length = its__aid().RAW_decode(IntX_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 6:
      decoded_length = signer().RAW_decode(SignerInfo_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 7:
      decoded_length = enc__params().RAW_decode(EncryptionParameters_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 8:
      decoded_length = recipients().RAW_decode(RecipientInfos_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 9:
      decoded_length = other__header().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = generation__time().RAW_decode(Time64_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = generation__time__with__standard__deviation().RAW_decode(Time64WithStandardDeviation_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = expiry__time().RAW_decode(Time32_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = generation__location().RAW_decode(ThreeDLocation_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = digests().RAW_decode(HashedId3s_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = its__aid().RAW_decode(IntX_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = signer().RAW_decode(SignerInfo_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = enc__params().RAW_decode(EncryptionParameters_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = recipients().RAW_decode(RecipientInfos_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = other__header().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int HeaderFieldContainer::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 10;  myleaf.body.node.nodes = init_nodes_of_enc_tree(10);
  memset(myleaf.body.node.nodes, 0, 10 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_generation__time:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, Time64_descr_.raw);
    encoded_length = field_generation__time->RAW_encode(Time64_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &Time64_descr_;
    break;
  case ALT_generation__time__with__standard__deviation:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, Time64WithStandardDeviation_descr_.raw);
    encoded_length = field_generation__time__with__standard__deviation->RAW_encode(Time64WithStandardDeviation_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &Time64WithStandardDeviation_descr_;
    break;
  case ALT_expiry__time:
    myleaf.body.node.nodes[2] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 2, Time32_descr_.raw);
    encoded_length = field_expiry__time->RAW_encode(Time32_descr_, *myleaf.body.node.nodes[2]);
    myleaf.body.node.nodes[2]->coding_descr = &Time32_descr_;
    break;
  case ALT_generation__location:
    myleaf.body.node.nodes[3] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 3, ThreeDLocation_descr_.raw);
    encoded_length = field_generation__location->RAW_encode(ThreeDLocation_descr_, *myleaf.body.node.nodes[3]);
    myleaf.body.node.nodes[3]->coding_descr = &ThreeDLocation_descr_;
    break;
  case ALT_digests:
    myleaf.body.node.nodes[4] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 4, HashedId3s_descr_.raw);
    encoded_length = field_digests->RAW_encode(HashedId3s_descr_, *myleaf.body.node.nodes[4]);
    myleaf.body.node.nodes[4]->coding_descr = &HashedId3s_descr_;
    break;
  case ALT_its__aid:
    myleaf.body.node.nodes[5] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 5, IntX_descr_.raw);
    encoded_length = field_its__aid->RAW_encode(IntX_descr_, *myleaf.body.node.nodes[5]);
    myleaf.body.node.nodes[5]->coding_descr = &IntX_descr_;
    break;
  case ALT_signer:
    myleaf.body.node.nodes[6] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 6, SignerInfo_descr_.raw);
    encoded_length = field_signer->RAW_encode(SignerInfo_descr_, *myleaf.body.node.nodes[6]);
    myleaf.body.node.nodes[6]->coding_descr = &SignerInfo_descr_;
    break;
  case ALT_enc__params:
    myleaf.body.node.nodes[7] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 7, EncryptionParameters_descr_.raw);
    encoded_length = field_enc__params->RAW_encode(EncryptionParameters_descr_, *myleaf.body.node.nodes[7]);
    myleaf.body.node.nodes[7]->coding_descr = &EncryptionParameters_descr_;
    break;
  case ALT_recipients:
    myleaf.body.node.nodes[8] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 8, RecipientInfos_descr_.raw);
    encoded_length = field_recipients->RAW_encode(RecipientInfos_descr_, *myleaf.body.node.nodes[8]);
    myleaf.body.node.nodes[8]->coding_descr = &RecipientInfos_descr_;
    break;
  case ALT_other__header:
    myleaf.body.node.nodes[9] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 9, OCTETSTRING_descr_.raw);
    encoded_length = field_other__header->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[9]);
    myleaf.body.node.nodes[9]->coding_descr = &OCTETSTRING_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int HeaderFieldContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_generation__time:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "generation_time");
    enc_len += field_generation__time->JSON_encode(Time64_descr_, p_tok);
    break;
  case ALT_generation__time__with__standard__deviation:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "generation_time_with_standard_deviation");
    enc_len += field_generation__time__with__standard__deviation->JSON_encode(Time64WithStandardDeviation_descr_, p_tok);
    break;
  case ALT_expiry__time:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "expiry_time");
    enc_len += field_expiry__time->JSON_encode(Time32_descr_, p_tok);
    break;
  case ALT_generation__location:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "generation_location");
    enc_len += field_generation__location->JSON_encode(ThreeDLocation_descr_, p_tok);
    break;
  case ALT_digests:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "digests");
    enc_len += field_digests->JSON_encode(HashedId3s_descr_, p_tok);
    break;
  case ALT_its__aid:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "its_aid");
    enc_len += field_its__aid->JSON_encode(IntX_descr_, p_tok);
    break;
  case ALT_signer:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "signer");
    enc_len += field_signer->JSON_encode(SignerInfo_descr_, p_tok);
    break;
  case ALT_enc__params:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "enc_params");
    enc_len += field_enc__params->JSON_encode(EncryptionParameters_descr_, p_tok);
    break;
  case ALT_recipients:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "recipients");
    enc_len += field_recipients->JSON_encode(RecipientInfos_descr_, p_tok);
    break;
  case ALT_other__header:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "other_header");
    enc_len += field_other__header->JSON_encode(OCTETSTRING_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int HeaderFieldContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "generation_time", name_len)) {
      int ret_val = generation__time().JSON_decode(Time64_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "generation_time");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "generation_time_with_standard_deviation", name_len)) {
      int ret_val = generation__time__with__standard__deviation().JSON_decode(Time64WithStandardDeviation_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "generation_time_with_standard_deviation");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "expiry_time", name_len)) {
      int ret_val = expiry__time().JSON_decode(Time32_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "expiry_time");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "generation_location", name_len)) {
      int ret_val = generation__location().JSON_decode(ThreeDLocation_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "generation_location");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "digests", name_len)) {
      int ret_val = digests().JSON_decode(HashedId3s_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "digests");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "its_aid", name_len)) {
      int ret_val = its__aid().JSON_decode(IntX_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "its_aid");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "signer", name_len)) {
      int ret_val = signer().JSON_decode(SignerInfo_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "signer");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "enc_params", name_len)) {
      int ret_val = enc__params().JSON_decode(EncryptionParameters_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "enc_params");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "recipients", name_len)) {
      int ret_val = recipients().JSON_decode(RecipientInfos_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "recipients");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "other_header", name_len)) {
      int ret_val = other__header().JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "other_header");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void HeaderFieldContainer_template::copy_value(const HeaderFieldContainer& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case HeaderFieldContainer::ALT_generation__time:
single_value.field_generation__time = new INTEGER_template(other_value.generation__time());
break;
case HeaderFieldContainer::ALT_generation__time__with__standard__deviation:
single_value.field_generation__time__with__standard__deviation = new Time64WithStandardDeviation_template(other_value.generation__time__with__standard__deviation());
break;
case HeaderFieldContainer::ALT_expiry__time:
single_value.field_expiry__time = new INTEGER_template(other_value.expiry__time());
break;
case HeaderFieldContainer::ALT_generation__location:
single_value.field_generation__location = new ThreeDLocation_template(other_value.generation__location());
break;
case HeaderFieldContainer::ALT_digests:
single_value.field_digests = new HashedId3s_template(other_value.digests());
break;
case HeaderFieldContainer::ALT_its__aid:
single_value.field_its__aid = new INTEGER_template(other_value.its__aid());
break;
case HeaderFieldContainer::ALT_signer:
single_value.field_signer = new SignerInfo_template(other_value.signer());
break;
case HeaderFieldContainer::ALT_enc__params:
single_value.field_enc__params = new EncryptionParameters_template(other_value.enc__params());
break;
case HeaderFieldContainer::ALT_recipients:
single_value.field_recipients = new RecipientInfos_template(other_value.recipients());
break;
case HeaderFieldContainer::ALT_other__header:
single_value.field_other__header = new OCTETSTRING_template(other_value.other__header());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
}
set_selection(SPECIFIC_VALUE);
}

void HeaderFieldContainer_template::copy_template(const HeaderFieldContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case HeaderFieldContainer::ALT_generation__time:
single_value.field_generation__time = new INTEGER_template(*other_value.single_value.field_generation__time);
break;
case HeaderFieldContainer::ALT_generation__time__with__standard__deviation:
single_value.field_generation__time__with__standard__deviation = new Time64WithStandardDeviation_template(*other_value.single_value.field_generation__time__with__standard__deviation);
break;
case HeaderFieldContainer::ALT_expiry__time:
single_value.field_expiry__time = new INTEGER_template(*other_value.single_value.field_expiry__time);
break;
case HeaderFieldContainer::ALT_generation__location:
single_value.field_generation__location = new ThreeDLocation_template(*other_value.single_value.field_generation__location);
break;
case HeaderFieldContainer::ALT_digests:
single_value.field_digests = new HashedId3s_template(*other_value.single_value.field_digests);
break;
case HeaderFieldContainer::ALT_its__aid:
single_value.field_its__aid = new INTEGER_template(*other_value.single_value.field_its__aid);
break;
case HeaderFieldContainer::ALT_signer:
single_value.field_signer = new SignerInfo_template(*other_value.single_value.field_signer);
break;
case HeaderFieldContainer::ALT_enc__params:
single_value.field_enc__params = new EncryptionParameters_template(*other_value.single_value.field_enc__params);
break;
case HeaderFieldContainer::ALT_recipients:
single_value.field_recipients = new RecipientInfos_template(*other_value.single_value.field_recipients);
break;
case HeaderFieldContainer::ALT_other__header:
single_value.field_other__header = new OCTETSTRING_template(*other_value.single_value.field_other__header);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new HeaderFieldContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
}
set_selection(other_value);
}

HeaderFieldContainer_template::HeaderFieldContainer_template()
{
}

HeaderFieldContainer_template::HeaderFieldContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

HeaderFieldContainer_template::HeaderFieldContainer_template(const HeaderFieldContainer& other_value)
{
copy_value(other_value);
}

HeaderFieldContainer_template::HeaderFieldContainer_template(const OPTIONAL<HeaderFieldContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const HeaderFieldContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer from an unbound optional field.");
}
}

HeaderFieldContainer_template::HeaderFieldContainer_template(const HeaderFieldContainer_template& other_value)
: Base_Template(){
copy_template(other_value);
}

HeaderFieldContainer_template::~HeaderFieldContainer_template()
{
clean_up();
}

void HeaderFieldContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case HeaderFieldContainer::ALT_generation__time:
delete single_value.field_generation__time;
break;
case HeaderFieldContainer::ALT_generation__time__with__standard__deviation:
delete single_value.field_generation__time__with__standard__deviation;
break;
case HeaderFieldContainer::ALT_expiry__time:
delete single_value.field_expiry__time;
break;
case HeaderFieldContainer::ALT_generation__location:
delete single_value.field_generation__location;
break;
case HeaderFieldContainer::ALT_digests:
delete single_value.field_digests;
break;
case HeaderFieldContainer::ALT_its__aid:
delete single_value.field_its__aid;
break;
case HeaderFieldContainer::ALT_signer:
delete single_value.field_signer;
break;
case HeaderFieldContainer::ALT_enc__params:
delete single_value.field_enc__params;
break;
case HeaderFieldContainer::ALT_recipients:
delete single_value.field_recipients;
break;
case HeaderFieldContainer::ALT_other__header:
delete single_value.field_other__header;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

HeaderFieldContainer_template& HeaderFieldContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

HeaderFieldContainer_template& HeaderFieldContainer_template::operator=(const HeaderFieldContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

HeaderFieldContainer_template& HeaderFieldContainer_template::operator=(const OPTIONAL<HeaderFieldContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const HeaderFieldContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
}
return *this;
}

HeaderFieldContainer_template& HeaderFieldContainer_template::operator=(const HeaderFieldContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean HeaderFieldContainer_template::match(const HeaderFieldContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
HeaderFieldContainer::union_selection_type value_selection = other_value.get_selection();
if (value_selection == HeaderFieldContainer::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case HeaderFieldContainer::ALT_generation__time:
return single_value.field_generation__time->match(other_value.generation__time(), legacy);
case HeaderFieldContainer::ALT_generation__time__with__standard__deviation:
return single_value.field_generation__time__with__standard__deviation->match(other_value.generation__time__with__standard__deviation(), legacy);
case HeaderFieldContainer::ALT_expiry__time:
return single_value.field_expiry__time->match(other_value.expiry__time(), legacy);
case HeaderFieldContainer::ALT_generation__location:
return single_value.field_generation__location->match(other_value.generation__location(), legacy);
case HeaderFieldContainer::ALT_digests:
return single_value.field_digests->match(other_value.digests(), legacy);
case HeaderFieldContainer::ALT_its__aid:
return single_value.field_its__aid->match(other_value.its__aid(), legacy);
case HeaderFieldContainer::ALT_signer:
return single_value.field_signer->match(other_value.signer(), legacy);
case HeaderFieldContainer::ALT_enc__params:
return single_value.field_enc__params->match(other_value.enc__params(), legacy);
case HeaderFieldContainer::ALT_recipients:
return single_value.field_recipients->match(other_value.recipients(), legacy);
case HeaderFieldContainer::ALT_other__header:
return single_value.field_other__header->match(other_value.other__header(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
}
return FALSE;
}

boolean HeaderFieldContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case HeaderFieldContainer::ALT_generation__time:
return single_value.field_generation__time->is_value();
case HeaderFieldContainer::ALT_generation__time__with__standard__deviation:
return single_value.field_generation__time__with__standard__deviation->is_value();
case HeaderFieldContainer::ALT_expiry__time:
return single_value.field_expiry__time->is_value();
case HeaderFieldContainer::ALT_generation__location:
return single_value.field_generation__location->is_value();
case HeaderFieldContainer::ALT_digests:
return single_value.field_digests->is_value();
case HeaderFieldContainer::ALT_its__aid:
return single_value.field_its__aid->is_value();
case HeaderFieldContainer::ALT_signer:
return single_value.field_signer->is_value();
case HeaderFieldContainer::ALT_enc__params:
return single_value.field_enc__params->is_value();
case HeaderFieldContainer::ALT_recipients:
return single_value.field_recipients->is_value();
case HeaderFieldContainer::ALT_other__header:
return single_value.field_other__header->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
}
}

HeaderFieldContainer HeaderFieldContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
HeaderFieldContainer ret_val;
switch (single_value.union_selection) {
case HeaderFieldContainer::ALT_generation__time:
ret_val.generation__time() = single_value.field_generation__time->valueof();
break;
case HeaderFieldContainer::ALT_generation__time__with__standard__deviation:
ret_val.generation__time__with__standard__deviation() = single_value.field_generation__time__with__standard__deviation->valueof();
break;
case HeaderFieldContainer::ALT_expiry__time:
ret_val.expiry__time() = single_value.field_expiry__time->valueof();
break;
case HeaderFieldContainer::ALT_generation__location:
ret_val.generation__location() = single_value.field_generation__location->valueof();
break;
case HeaderFieldContainer::ALT_digests:
ret_val.digests() = single_value.field_digests->valueof();
break;
case HeaderFieldContainer::ALT_its__aid:
ret_val.its__aid() = single_value.field_its__aid->valueof();
break;
case HeaderFieldContainer::ALT_signer:
ret_val.signer() = single_value.field_signer->valueof();
break;
case HeaderFieldContainer::ALT_enc__params:
ret_val.enc__params() = single_value.field_enc__params->valueof();
break;
case HeaderFieldContainer::ALT_recipients:
ret_val.recipients() = single_value.field_recipients->valueof();
break;
case HeaderFieldContainer::ALT_other__header:
ret_val.other__header() = single_value.field_other__header->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
}
return ret_val;
}

HeaderFieldContainer_template& HeaderFieldContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return value_list.list_value[list_index];
}
void HeaderFieldContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new HeaderFieldContainer_template[list_length];
}

INTEGER_template& HeaderFieldContainer_template::generation__time()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderFieldContainer::ALT_generation__time) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_generation__time = new INTEGER_template(ANY_VALUE);
else single_value.field_generation__time = new INTEGER_template;
single_value.union_selection = HeaderFieldContainer::ALT_generation__time;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_generation__time;
}

const INTEGER_template& HeaderFieldContainer_template::generation__time() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field generation_time in a non-specific template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
if (single_value.union_selection != HeaderFieldContainer::ALT_generation__time) TTCN_error("Accessing non-selected field generation_time in a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *single_value.field_generation__time;
}

Time64WithStandardDeviation_template& HeaderFieldContainer_template::generation__time__with__standard__deviation()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderFieldContainer::ALT_generation__time__with__standard__deviation) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_generation__time__with__standard__deviation = new Time64WithStandardDeviation_template(ANY_VALUE);
else single_value.field_generation__time__with__standard__deviation = new Time64WithStandardDeviation_template;
single_value.union_selection = HeaderFieldContainer::ALT_generation__time__with__standard__deviation;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_generation__time__with__standard__deviation;
}

const Time64WithStandardDeviation_template& HeaderFieldContainer_template::generation__time__with__standard__deviation() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field generation_time_with_standard_deviation in a non-specific template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
if (single_value.union_selection != HeaderFieldContainer::ALT_generation__time__with__standard__deviation) TTCN_error("Accessing non-selected field generation_time_with_standard_deviation in a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *single_value.field_generation__time__with__standard__deviation;
}

INTEGER_template& HeaderFieldContainer_template::expiry__time()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderFieldContainer::ALT_expiry__time) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_expiry__time = new INTEGER_template(ANY_VALUE);
else single_value.field_expiry__time = new INTEGER_template;
single_value.union_selection = HeaderFieldContainer::ALT_expiry__time;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_expiry__time;
}

const INTEGER_template& HeaderFieldContainer_template::expiry__time() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field expiry_time in a non-specific template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
if (single_value.union_selection != HeaderFieldContainer::ALT_expiry__time) TTCN_error("Accessing non-selected field expiry_time in a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *single_value.field_expiry__time;
}

ThreeDLocation_template& HeaderFieldContainer_template::generation__location()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderFieldContainer::ALT_generation__location) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_generation__location = new ThreeDLocation_template(ANY_VALUE);
else single_value.field_generation__location = new ThreeDLocation_template;
single_value.union_selection = HeaderFieldContainer::ALT_generation__location;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_generation__location;
}

const ThreeDLocation_template& HeaderFieldContainer_template::generation__location() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field generation_location in a non-specific template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
if (single_value.union_selection != HeaderFieldContainer::ALT_generation__location) TTCN_error("Accessing non-selected field generation_location in a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *single_value.field_generation__location;
}

HashedId3s_template& HeaderFieldContainer_template::digests()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderFieldContainer::ALT_digests) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_digests = new HashedId3s_template(ANY_VALUE);
else single_value.field_digests = new HashedId3s_template;
single_value.union_selection = HeaderFieldContainer::ALT_digests;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_digests;
}

const HashedId3s_template& HeaderFieldContainer_template::digests() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field digests in a non-specific template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
if (single_value.union_selection != HeaderFieldContainer::ALT_digests) TTCN_error("Accessing non-selected field digests in a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *single_value.field_digests;
}

INTEGER_template& HeaderFieldContainer_template::its__aid()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderFieldContainer::ALT_its__aid) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_its__aid = new INTEGER_template(ANY_VALUE);
else single_value.field_its__aid = new INTEGER_template;
single_value.union_selection = HeaderFieldContainer::ALT_its__aid;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_its__aid;
}

const INTEGER_template& HeaderFieldContainer_template::its__aid() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field its_aid in a non-specific template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
if (single_value.union_selection != HeaderFieldContainer::ALT_its__aid) TTCN_error("Accessing non-selected field its_aid in a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *single_value.field_its__aid;
}

SignerInfo_template& HeaderFieldContainer_template::signer()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderFieldContainer::ALT_signer) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_signer = new SignerInfo_template(ANY_VALUE);
else single_value.field_signer = new SignerInfo_template;
single_value.union_selection = HeaderFieldContainer::ALT_signer;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_signer;
}

const SignerInfo_template& HeaderFieldContainer_template::signer() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field signer in a non-specific template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
if (single_value.union_selection != HeaderFieldContainer::ALT_signer) TTCN_error("Accessing non-selected field signer in a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *single_value.field_signer;
}

EncryptionParameters_template& HeaderFieldContainer_template::enc__params()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderFieldContainer::ALT_enc__params) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_enc__params = new EncryptionParameters_template(ANY_VALUE);
else single_value.field_enc__params = new EncryptionParameters_template;
single_value.union_selection = HeaderFieldContainer::ALT_enc__params;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_enc__params;
}

const EncryptionParameters_template& HeaderFieldContainer_template::enc__params() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field enc_params in a non-specific template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
if (single_value.union_selection != HeaderFieldContainer::ALT_enc__params) TTCN_error("Accessing non-selected field enc_params in a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *single_value.field_enc__params;
}

RecipientInfos_template& HeaderFieldContainer_template::recipients()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderFieldContainer::ALT_recipients) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_recipients = new RecipientInfos_template(ANY_VALUE);
else single_value.field_recipients = new RecipientInfos_template;
single_value.union_selection = HeaderFieldContainer::ALT_recipients;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_recipients;
}

const RecipientInfos_template& HeaderFieldContainer_template::recipients() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field recipients in a non-specific template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
if (single_value.union_selection != HeaderFieldContainer::ALT_recipients) TTCN_error("Accessing non-selected field recipients in a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *single_value.field_recipients;
}

OCTETSTRING_template& HeaderFieldContainer_template::other__header()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != HeaderFieldContainer::ALT_other__header) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_other__header = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_other__header = new OCTETSTRING_template;
single_value.union_selection = HeaderFieldContainer::ALT_other__header;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_other__header;
}

const OCTETSTRING_template& HeaderFieldContainer_template::other__header() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field other_header in a non-specific template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
if (single_value.union_selection != HeaderFieldContainer::ALT_other__header) TTCN_error("Accessing non-selected field other_header in a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return *single_value.field_other__header;
}

boolean HeaderFieldContainer_template::ischosen(HeaderFieldContainer::union_selection_type checked_selection) const
{
if (checked_selection == HeaderFieldContainer::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == HeaderFieldContainer::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer");
}
return FALSE;
}

void HeaderFieldContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case HeaderFieldContainer::ALT_generation__time:
TTCN_Logger::log_event_str("{ generation_time := ");
single_value.field_generation__time->log();
TTCN_Logger::log_event_str(" }");
break;
case HeaderFieldContainer::ALT_generation__time__with__standard__deviation:
TTCN_Logger::log_event_str("{ generation_time_with_standard_deviation := ");
single_value.field_generation__time__with__standard__deviation->log();
TTCN_Logger::log_event_str(" }");
break;
case HeaderFieldContainer::ALT_expiry__time:
TTCN_Logger::log_event_str("{ expiry_time := ");
single_value.field_expiry__time->log();
TTCN_Logger::log_event_str(" }");
break;
case HeaderFieldContainer::ALT_generation__location:
TTCN_Logger::log_event_str("{ generation_location := ");
single_value.field_generation__location->log();
TTCN_Logger::log_event_str(" }");
break;
case HeaderFieldContainer::ALT_digests:
TTCN_Logger::log_event_str("{ digests := ");
single_value.field_digests->log();
TTCN_Logger::log_event_str(" }");
break;
case HeaderFieldContainer::ALT_its__aid:
TTCN_Logger::log_event_str("{ its_aid := ");
single_value.field_its__aid->log();
TTCN_Logger::log_event_str(" }");
break;
case HeaderFieldContainer::ALT_signer:
TTCN_Logger::log_event_str("{ signer := ");
single_value.field_signer->log();
TTCN_Logger::log_event_str(" }");
break;
case HeaderFieldContainer::ALT_enc__params:
TTCN_Logger::log_event_str("{ enc_params := ");
single_value.field_enc__params->log();
TTCN_Logger::log_event_str(" }");
break;
case HeaderFieldContainer::ALT_recipients:
TTCN_Logger::log_event_str("{ recipients := ");
single_value.field_recipients->log();
TTCN_Logger::log_event_str(" }");
break;
case HeaderFieldContainer::ALT_other__header:
TTCN_Logger::log_event_str("{ other_header := ");
single_value.field_other__header->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void HeaderFieldContainer_template::log_match(const HeaderFieldContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case HeaderFieldContainer::ALT_generation__time:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".generation_time");
single_value.field_generation__time->log_match(match_value.generation__time(), legacy);
} else {
TTCN_Logger::log_event_str("{ generation_time := ");
single_value.field_generation__time->log_match(match_value.generation__time(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HeaderFieldContainer::ALT_generation__time__with__standard__deviation:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".generation_time_with_standard_deviation");
single_value.field_generation__time__with__standard__deviation->log_match(match_value.generation__time__with__standard__deviation(), legacy);
} else {
TTCN_Logger::log_event_str("{ generation_time_with_standard_deviation := ");
single_value.field_generation__time__with__standard__deviation->log_match(match_value.generation__time__with__standard__deviation(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HeaderFieldContainer::ALT_expiry__time:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".expiry_time");
single_value.field_expiry__time->log_match(match_value.expiry__time(), legacy);
} else {
TTCN_Logger::log_event_str("{ expiry_time := ");
single_value.field_expiry__time->log_match(match_value.expiry__time(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HeaderFieldContainer::ALT_generation__location:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".generation_location");
single_value.field_generation__location->log_match(match_value.generation__location(), legacy);
} else {
TTCN_Logger::log_event_str("{ generation_location := ");
single_value.field_generation__location->log_match(match_value.generation__location(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HeaderFieldContainer::ALT_digests:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".digests");
single_value.field_digests->log_match(match_value.digests(), legacy);
} else {
TTCN_Logger::log_event_str("{ digests := ");
single_value.field_digests->log_match(match_value.digests(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HeaderFieldContainer::ALT_its__aid:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".its_aid");
single_value.field_its__aid->log_match(match_value.its__aid(), legacy);
} else {
TTCN_Logger::log_event_str("{ its_aid := ");
single_value.field_its__aid->log_match(match_value.its__aid(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HeaderFieldContainer::ALT_signer:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".signer");
single_value.field_signer->log_match(match_value.signer(), legacy);
} else {
TTCN_Logger::log_event_str("{ signer := ");
single_value.field_signer->log_match(match_value.signer(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HeaderFieldContainer::ALT_enc__params:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".enc_params");
single_value.field_enc__params->log_match(match_value.enc__params(), legacy);
} else {
TTCN_Logger::log_event_str("{ enc_params := ");
single_value.field_enc__params->log_match(match_value.enc__params(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HeaderFieldContainer::ALT_recipients:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".recipients");
single_value.field_recipients->log_match(match_value.recipients(), legacy);
} else {
TTCN_Logger::log_event_str("{ recipients := ");
single_value.field_recipients->log_match(match_value.recipients(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case HeaderFieldContainer::ALT_other__header:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".other_header");
single_value.field_other__header->log_match(match_value.other__header(), legacy);
} else {
TTCN_Logger::log_event_str("{ other_header := ");
single_value.field_other__header->log_match(match_value.other__header(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void HeaderFieldContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case HeaderFieldContainer::ALT_generation__time:
single_value.field_generation__time->encode_text(text_buf);
break;
case HeaderFieldContainer::ALT_generation__time__with__standard__deviation:
single_value.field_generation__time__with__standard__deviation->encode_text(text_buf);
break;
case HeaderFieldContainer::ALT_expiry__time:
single_value.field_expiry__time->encode_text(text_buf);
break;
case HeaderFieldContainer::ALT_generation__location:
single_value.field_generation__location->encode_text(text_buf);
break;
case HeaderFieldContainer::ALT_digests:
single_value.field_digests->encode_text(text_buf);
break;
case HeaderFieldContainer::ALT_its__aid:
single_value.field_its__aid->encode_text(text_buf);
break;
case HeaderFieldContainer::ALT_signer:
single_value.field_signer->encode_text(text_buf);
break;
case HeaderFieldContainer::ALT_enc__params:
single_value.field_enc__params->encode_text(text_buf);
break;
case HeaderFieldContainer::ALT_recipients:
single_value.field_recipients->encode_text(text_buf);
break;
case HeaderFieldContainer::ALT_other__header:
single_value.field_other__header->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
}
}

void HeaderFieldContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = HeaderFieldContainer::UNBOUND_VALUE;
HeaderFieldContainer::union_selection_type new_selection = (HeaderFieldContainer::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case HeaderFieldContainer::ALT_generation__time:
single_value.field_generation__time = new INTEGER_template;
single_value.field_generation__time->decode_text(text_buf);
break;
case HeaderFieldContainer::ALT_generation__time__with__standard__deviation:
single_value.field_generation__time__with__standard__deviation = new Time64WithStandardDeviation_template;
single_value.field_generation__time__with__standard__deviation->decode_text(text_buf);
break;
case HeaderFieldContainer::ALT_expiry__time:
single_value.field_expiry__time = new INTEGER_template;
single_value.field_expiry__time->decode_text(text_buf);
break;
case HeaderFieldContainer::ALT_generation__location:
single_value.field_generation__location = new ThreeDLocation_template;
single_value.field_generation__location->decode_text(text_buf);
break;
case HeaderFieldContainer::ALT_digests:
single_value.field_digests = new HashedId3s_template;
single_value.field_digests->decode_text(text_buf);
break;
case HeaderFieldContainer::ALT_its__aid:
single_value.field_its__aid = new INTEGER_template;
single_value.field_its__aid->decode_text(text_buf);
break;
case HeaderFieldContainer::ALT_signer:
single_value.field_signer = new SignerInfo_template;
single_value.field_signer->decode_text(text_buf);
break;
case HeaderFieldContainer::ALT_enc__params:
single_value.field_enc__params = new EncryptionParameters_template;
single_value.field_enc__params->decode_text(text_buf);
break;
case HeaderFieldContainer::ALT_recipients:
single_value.field_recipients = new RecipientInfos_template;
single_value.field_recipients->decode_text(text_buf);
break;
case HeaderFieldContainer::ALT_other__header:
single_value.field_other__header = new OCTETSTRING_template;
single_value.field_other__header->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new HeaderFieldContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
}
}

boolean HeaderFieldContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean HeaderFieldContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void HeaderFieldContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsSecurity_TypesAndValues.HeaderFieldContainer'");
    }
    if (strcmp("generation_time", param_field) == 0) {
      generation__time().set_param(param);
      return;
    } else if (strcmp("generation_time_with_standard_deviation", param_field) == 0) {
      generation__time__with__standard__deviation().set_param(param);
      return;
    } else if (strcmp("expiry_time", param_field) == 0) {
      expiry__time().set_param(param);
      return;
    } else if (strcmp("generation_location", param_field) == 0) {
      generation__location().set_param(param);
      return;
    } else if (strcmp("digests", param_field) == 0) {
      digests().set_param(param);
      return;
    } else if (strcmp("its_aid", param_field) == 0) {
      its__aid().set_param(param);
      return;
    } else if (strcmp("signer", param_field) == 0) {
      signer().set_param(param);
      return;
    } else if (strcmp("enc_params", param_field) == 0) {
      enc__params().set_param(param);
      return;
    } else if (strcmp("recipients", param_field) == 0) {
      recipients().set_param(param);
      return;
    } else if (strcmp("other_header", param_field) == 0) {
      other__header().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsSecurity_TypesAndValues.HeaderFieldContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    HeaderFieldContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.HeaderFieldContainer");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "generation_time")) {
      generation__time().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "generation_time_with_standard_deviation")) {
      generation__time__with__standard__deviation().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "expiry_time")) {
      expiry__time().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "generation_location")) {
      generation__location().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "digests")) {
      digests().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "its_aid")) {
      its__aid().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "signer")) {
      signer().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "enc_params")) {
      enc__params().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "recipients")) {
      recipients().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "other_header")) {
      other__header().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.HeaderFieldContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* HeaderFieldContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsSecurity_TypesAndValues.HeaderFieldContainer'");
    }
    if (strcmp("generation_time", param_field) == 0) {
      return generation__time().get_param(param_name);
    } else if (strcmp("generation_time_with_standard_deviation", param_field) == 0) {
      return generation__time__with__standard__deviation().get_param(param_name);
    } else if (strcmp("expiry_time", param_field) == 0) {
      return expiry__time().get_param(param_name);
    } else if (strcmp("generation_location", param_field) == 0) {
      return generation__location().get_param(param_name);
    } else if (strcmp("digests", param_field) == 0) {
      return digests().get_param(param_name);
    } else if (strcmp("its_aid", param_field) == 0) {
      return its__aid().get_param(param_name);
    } else if (strcmp("signer", param_field) == 0) {
      return signer().get_param(param_name);
    } else if (strcmp("enc_params", param_field) == 0) {
      return enc__params().get_param(param_name);
    } else if (strcmp("recipients", param_field) == 0) {
      return recipients().get_param(param_name);
    } else if (strcmp("other_header", param_field) == 0) {
      return other__header().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `HeaderFieldContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case HeaderFieldContainer::ALT_generation__time:
      mp_field = single_value.field_generation__time->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("generation_time")));
      break;
    case HeaderFieldContainer::ALT_generation__time__with__standard__deviation:
      mp_field = single_value.field_generation__time__with__standard__deviation->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("generation_time_with_standard_deviation")));
      break;
    case HeaderFieldContainer::ALT_expiry__time:
      mp_field = single_value.field_expiry__time->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("expiry_time")));
      break;
    case HeaderFieldContainer::ALT_generation__location:
      mp_field = single_value.field_generation__location->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("generation_location")));
      break;
    case HeaderFieldContainer::ALT_digests:
      mp_field = single_value.field_digests->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("digests")));
      break;
    case HeaderFieldContainer::ALT_its__aid:
      mp_field = single_value.field_its__aid->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("its_aid")));
      break;
    case HeaderFieldContainer::ALT_signer:
      mp_field = single_value.field_signer->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("signer")));
      break;
    case HeaderFieldContainer::ALT_enc__params:
      mp_field = single_value.field_enc__params->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("enc_params")));
      break;
    case HeaderFieldContainer::ALT_recipients:
      mp_field = single_value.field_recipients->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("recipients")));
      break;
    case HeaderFieldContainer::ALT_other__header:
      mp_field = single_value.field_other__header->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("other_header")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void HeaderFieldContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case HeaderFieldContainer::ALT_generation__time:
single_value.field_generation__time->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.HeaderFieldContainer");
return;
case HeaderFieldContainer::ALT_generation__time__with__standard__deviation:
single_value.field_generation__time__with__standard__deviation->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.HeaderFieldContainer");
return;
case HeaderFieldContainer::ALT_expiry__time:
single_value.field_expiry__time->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.HeaderFieldContainer");
return;
case HeaderFieldContainer::ALT_generation__location:
single_value.field_generation__location->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.HeaderFieldContainer");
return;
case HeaderFieldContainer::ALT_digests:
single_value.field_digests->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.HeaderFieldContainer");
return;
case HeaderFieldContainer::ALT_its__aid:
single_value.field_its__aid->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.HeaderFieldContainer");
return;
case HeaderFieldContainer::ALT_signer:
single_value.field_signer->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.HeaderFieldContainer");
return;
case HeaderFieldContainer::ALT_enc__params:
single_value.field_enc__params->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.HeaderFieldContainer");
return;
case HeaderFieldContainer::ALT_recipients:
single_value.field_recipients->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.HeaderFieldContainer");
return;
case HeaderFieldContainer::ALT_other__header:
single_value.field_other__header->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.HeaderFieldContainer");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsSecurity_TypesAndValues.HeaderFieldContainer.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.HeaderFieldContainer");
}


const RecipientInfo RecipientInfos::UNBOUND_ELEM;
boolean RecipientInfos::compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index)
{
if (((const RecipientInfos*)left_ptr)->val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
if (((const RecipientInfos*)right_ptr)->val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
if (((const RecipientInfos*)left_ptr)->val_ptr->value_elements[left_index] != NULL){
if (((const RecipientInfos*)right_ptr)->val_ptr->value_elements[right_index] != NULL){
return *((const RecipientInfos*)left_ptr)->val_ptr->value_elements[left_index] == *((const RecipientInfos*)right_ptr)->val_ptr->value_elements[right_index];
} else return FALSE;
} else {
return ((const RecipientInfos*)right_ptr)->val_ptr->value_elements[right_index] == NULL;
}
}

RecipientInfos::RecipientInfos()
{
val_ptr = NULL;
}

RecipientInfos::RecipientInfos(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

RecipientInfos::RecipientInfos(const RecipientInfos& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

RecipientInfos::~RecipientInfos()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void RecipientInfos::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

RecipientInfos& RecipientInfos::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

RecipientInfos& RecipientInfos::operator=(const RecipientInfos& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean RecipientInfos::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
return val_ptr->n_elements == 0 ;
}

boolean RecipientInfos::operator==(const RecipientInfos& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
if (val_ptr == other_value.val_ptr) return TRUE;
return compare_set_of(this, val_ptr->n_elements, &other_value, (other_value.val_ptr)->n_elements, compare_function);
}

RecipientInfo& RecipientInfos::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.RecipientInfos using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (RecipientInfo**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new RecipientInfo(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new RecipientInfo;
}
return *val_ptr->value_elements[index_value];
}

RecipientInfo& RecipientInfos::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
return (*this)[(int)index_value];
}

const RecipientInfo& RecipientInfos::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.RecipientInfos using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsSecurity_TypesAndValues.RecipientInfos: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const RecipientInfo& RecipientInfos::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
return (*this)[(int)index_value];
}

RecipientInfos RecipientInfos::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

RecipientInfos RecipientInfos::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

RecipientInfos RecipientInfos::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

RecipientInfos RecipientInfos::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
RecipientInfos ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new RecipientInfo(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

RecipientInfos RecipientInfos::operator+(const RecipientInfos& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsSecurity_TypesAndValues.RecipientInfos concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
RecipientInfos ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new RecipientInfo(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new RecipientInfo(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

RecipientInfos RecipientInfos::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsSecurity_TypesAndValues.RecipientInfos","element");
RecipientInfos ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new RecipientInfo(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

RecipientInfos RecipientInfos::replace(int index, int len, const RecipientInfos& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsSecurity_TypesAndValues.RecipientInfos","element");
RecipientInfos ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new RecipientInfo(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new RecipientInfo(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new RecipientInfo(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

RecipientInfos RecipientInfos::replace(int index, int len, const RecipientInfos_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void RecipientInfos::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (RecipientInfo**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new RecipientInfo(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (RecipientInfo**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsSecurity_TypesAndValues.RecipientInfos: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (RecipientInfo**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean RecipientInfos::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int RecipientInfos::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
return val_ptr->n_elements;
}

int RecipientInfos::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void RecipientInfos::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void RecipientInfos::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set of type `@LibItsSecurity_TypesAndValues.RecipientInfos'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "set of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.RecipientInfos");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.RecipientInfos");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* RecipientInfos::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of type `@LibItsSecurity_TypesAndValues.RecipientInfos'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void RecipientInfos::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void RecipientInfos::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void RecipientInfos::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
val_ptr->value_elements = (RecipientInfo**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new RecipientInfo;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void RecipientInfos::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RecipientInfos::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int RecipientInfos::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int RecipientInfos::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

int RecipientInfos::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int RecipientInfos::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    RecipientInfo* val = new RecipientInfo;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (RecipientInfo**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void RecipientInfos_template::copy_value(const RecipientInfos& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsSecurity_TypesAndValues.RecipientInfos with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (RecipientInfo_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new RecipientInfo_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new RecipientInfo_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void RecipientInfos_template::copy_template(const RecipientInfos_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (RecipientInfo_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new RecipientInfo_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new RecipientInfo_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RecipientInfos_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = other_value.value_set.n_items;
value_set.set_items = new RecipientInfo_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count] = other_value.value_set.set_items[set_count];
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
break;
}
set_selection(other_value);
}

boolean RecipientInfos_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const RecipientInfos_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const RecipientInfos*)value_ptr)[value_index], legacy);
else return ((const RecipientInfos_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

boolean RecipientInfos_template::match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const RecipientInfos_template*)template_ptr)->value_set.set_items[template_index].match((*(const RecipientInfos*)value_ptr)[value_index], legacy);
else return ((const RecipientInfos_template*)template_ptr)->value_set.set_items[template_index].is_any_or_omit();
}

void RecipientInfos_template::log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy)
{
if (value_ptr != NULL && template_ptr != NULL)((const RecipientInfos_template*)template_ptr)->single_value.value_elements[index_template]->log_match((*(const RecipientInfos*)value_ptr)[index_value], legacy);
else if (value_ptr != NULL) (*(const RecipientInfos*)value_ptr)[index_value].log();
else if (template_ptr != NULL) ((const RecipientInfos_template*)template_ptr)->single_value.value_elements[index_template]->log();
}

RecipientInfos_template::RecipientInfos_template()
{
}

RecipientInfos_template::RecipientInfos_template(template_sel other_value)
 : Restricted_Length_Template(other_value)
{
check_single_selection(other_value);
}

RecipientInfos_template::RecipientInfos_template(null_type)
 : Restricted_Length_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

RecipientInfos_template::RecipientInfos_template(const RecipientInfos& other_value)
{
copy_value(other_value);
}

RecipientInfos_template::RecipientInfos_template(const OPTIONAL<RecipientInfos>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RecipientInfos&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.RecipientInfos from an unbound optional field.");
}
}

RecipientInfos_template::RecipientInfos_template(const RecipientInfos_template& other_value)
 : Restricted_Length_Template()
{
copy_template(other_value);
}

RecipientInfos_template::~RecipientInfos_template()
{
clean_up();
}

void RecipientInfos_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
delete [] value_set.set_items;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RecipientInfos_template& RecipientInfos_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RecipientInfos_template& RecipientInfos_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

RecipientInfos_template& RecipientInfos_template::operator=(const RecipientInfos& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RecipientInfos_template& RecipientInfos_template::operator=(const OPTIONAL<RecipientInfos>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RecipientInfos&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
}
return *this;
}

RecipientInfos_template& RecipientInfos_template::operator=(const RecipientInfos_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

RecipientInfo_template& RecipientInfos_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.RecipientInfos using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.RecipientInfos.");
    break;
}
return *single_value.value_elements[index_value];
}

RecipientInfo_template& RecipientInfos_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
return (*this)[(int)index_value];
}

const RecipientInfo_template& RecipientInfos_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.RecipientInfos using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.RecipientInfos.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsSecurity_TypesAndValues.RecipientInfos: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const RecipientInfo_template& RecipientInfos_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
return (*this)[(int)index_value];
}

void RecipientInfos_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (RecipientInfo_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new RecipientInfo_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new RecipientInfo_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (RecipientInfo_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int RecipientInfos_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int RecipientInfos_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RecipientInfos which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RecipientInfos containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case SUPERSET_MATCH:
case SUBSET_MATCH: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = value_set.n_items;
  if (!is_size) { while (elem_count>0 && !value_set.set_items[elem_count-1].is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (value_set.set_items[i].get_selection())
    {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RecipientInfos containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
  if (template_selection==SUPERSET_MATCH) {
    has_any_or_none = TRUE;
   } else {
    int max_size = min_size;
    min_size = 0;
    if (!has_any_or_none) { // [0,max_size]
      switch (length_restriction_type) {
      case NO_LENGTH_RESTRICTION:
        if (max_size==0) return 0;
        TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RecipientInfos with no exact size.", op_name);
      case SINGLE_LENGTH_RESTRICTION:
        if (length_restriction.single_length<=max_size)
          return length_restriction.single_length;
        TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.RecipientInfos. The maximum size (%d) contradicts the length restriction (%d).", op_name, max_size, length_restriction.single_length);
      case RANGE_LENGTH_RESTRICTION:
        if (max_size==length_restriction.range_length.min_length) {
          return max_size;
        } else if (max_size>length_restriction.range_length.min_length){
          TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RecipientInfos with no exact size.", op_name);
        } else
          TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.RecipientInfos. Maximum size (%d) contradicts the length restriction (%d..%d).", op_name, max_size, length_restriction.range_length.min_length, length_restriction.range_length.max_length);
      default:
        TTCN_error("Internal error: Template has invalid length restriction type.");
      }
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RecipientInfos containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RecipientInfos containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RecipientInfos containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.RecipientInfos containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.RecipientInfos.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsSecurity_TypesAndValues.RecipientInfos");
}

boolean RecipientInfos_template::match(const RecipientInfos& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_set_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case SUPERSET_MATCH:
case SUBSET_MATCH:
return match_set_of(&other_value, value_length, this, value_set.n_items, match_function_set, legacy);
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
}
return FALSE;
}

boolean RecipientInfos_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

RecipientInfos RecipientInfos_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
RecipientInfos ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

RecipientInfos RecipientInfos_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

RecipientInfos RecipientInfos_template::replace(int index, int len, const RecipientInfos_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

RecipientInfos RecipientInfos_template::replace(int index, int len, const RecipientInfos& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void RecipientInfos_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new RecipientInfos_template[list_length];
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = list_length;
value_set.set_items = new RecipientInfo_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
}
set_selection(template_type);
}

RecipientInfos_template& RecipientInfos_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
return value_list.list_value[list_index];
}

RecipientInfo_template& RecipientInfos_template::set_item(unsigned int set_index)
{
if (template_selection != SUPERSET_MATCH && template_selection != SUBSET_MATCH) TTCN_error("Internal error: Accessing a set element of a non-set template of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
if (set_index >= value_set.n_items) TTCN_error("Internal error: Index overflow in a set template of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
return value_set.set_items[set_index];
}

void RecipientInfos_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log();
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
TTCN_Logger::log_event("%s(", template_selection == SUPERSET_MATCH ? "superset" : "subset");
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++) {
if (set_count > 0) TTCN_Logger::log_event_str(", ");
value_set.set_items[set_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void RecipientInfos_template::log_match(const RecipientInfos& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (template_selection == SPECIFIC_VALUE)
  log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
else{
if(previous_size != 0){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::set_logmatch_buffer_len(previous_size);
TTCN_Logger::log_event_str(":=");
}
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
return;
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else {
TTCN_Logger::log_event_str(" unmatched");
if (template_selection == SPECIFIC_VALUE) log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
}
}

void RecipientInfos_template::encode_text(Text_Buf& text_buf) const
{
encode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
text_buf.push_int(value_set.n_items);
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
}
}

void RecipientInfos_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
single_value.value_elements = (RecipientInfo_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new RecipientInfo_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RecipientInfos_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = text_buf.pull_int().get_val();
value_set.set_items = new RecipientInfo_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
}
}

boolean RecipientInfos_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RecipientInfos_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void RecipientInfos_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set template type `@LibItsSecurity_TypesAndValues.RecipientInfos'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "set of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RecipientInfos_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    set_size(mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      if (mp->get_elem(p_i)->get_type()!=Module_Param::MP_NotUsed) {
        (*this)[p_i].set_param(*mp->get_elem(p_i));
      }
    }
    break;
  case Module_Param::MP_Superset_Template:
  case Module_Param::MP_Subset_Template:
    set_type(mp->get_type()==Module_Param::MP_Superset_Template ? SUPERSET_MATCH : SUBSET_MATCH, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      set_item(p_i).set_param(*mp->get_elem(p_i));
    }
    break;
  default:
    param.type_error("set of template", "@LibItsSecurity_TypesAndValues.RecipientInfos");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* RecipientInfos_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of template type `@LibItsSecurity_TypesAndValues.RecipientInfos'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void RecipientInfos_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.RecipientInfos");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.RecipientInfos");
}

void RecipientInfoContainer::copy_value(const RecipientInfoContainer& other_value)
{
switch (other_value.union_selection) {
case ALT_enc__key:
field_enc__key = new EciesEncryptedKey(*other_value.field_enc__key);
break;
case ALT_enc__key__other:
field_enc__key__other = new OCTETSTRING(*other_value.field_enc__key__other);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
}
union_selection = other_value.union_selection;
}

RecipientInfoContainer::RecipientInfoContainer()
{
union_selection = UNBOUND_VALUE;
}

RecipientInfoContainer::RecipientInfoContainer(const RecipientInfoContainer& other_value)
: Base_Type(){
copy_value(other_value);
}

RecipientInfoContainer::~RecipientInfoContainer()
{
clean_up();
}

RecipientInfoContainer& RecipientInfoContainer::operator=(const RecipientInfoContainer& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean RecipientInfoContainer::operator==(const RecipientInfoContainer& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_enc__key:
return *field_enc__key == *other_value.field_enc__key;
case ALT_enc__key__other:
return *field_enc__key__other == *other_value.field_enc__key__other;
default:
return FALSE;
}
}

EciesEncryptedKey& RecipientInfoContainer::enc__key()
{
if (union_selection != ALT_enc__key) {
clean_up();
field_enc__key = new EciesEncryptedKey;
union_selection = ALT_enc__key;
}
return *field_enc__key;
}

const EciesEncryptedKey& RecipientInfoContainer::enc__key() const
{
if (union_selection != ALT_enc__key) TTCN_error("Using non-selected field enc_key in a value of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
return *field_enc__key;
}

OCTETSTRING& RecipientInfoContainer::enc__key__other()
{
if (union_selection != ALT_enc__key__other) {
clean_up();
field_enc__key__other = new OCTETSTRING;
union_selection = ALT_enc__key__other;
}
return *field_enc__key__other;
}

const OCTETSTRING& RecipientInfoContainer::enc__key__other() const
{
if (union_selection != ALT_enc__key__other) TTCN_error("Using non-selected field enc_key_other in a value of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
return *field_enc__key__other;
}

boolean RecipientInfoContainer::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
return union_selection == checked_selection;
}

boolean RecipientInfoContainer::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean RecipientInfoContainer::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_enc__key: return field_enc__key->is_value();
case ALT_enc__key__other: return field_enc__key__other->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void RecipientInfoContainer::clean_up()
{
switch (union_selection) {
case ALT_enc__key:
  delete field_enc__key;
  break;
case ALT_enc__key__other:
  delete field_enc__key__other;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void RecipientInfoContainer::log() const
{
switch (union_selection) {
case ALT_enc__key:
TTCN_Logger::log_event_str("{ enc_key := ");
field_enc__key->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_enc__key__other:
TTCN_Logger::log_event_str("{ enc_key_other := ");
field_enc__key__other->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void RecipientInfoContainer::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsSecurity_TypesAndValues.RecipientInfoContainer'");
    }
    if (strcmp("enc_key", param_field) == 0) {
      enc__key().set_param(param);
      return;
    } else if (strcmp("enc_key_other", param_field) == 0) {
      enc__key__other().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsSecurity_TypesAndValues.RecipientInfoContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "enc_key")) {
    enc__key().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "enc_key_other")) {
    enc__key__other().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.", mp_last->get_id()->get_name());
}

Module_Param* RecipientInfoContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsSecurity_TypesAndValues.RecipientInfoContainer'");
    }
    if (strcmp("enc_key", param_field) == 0) {
      return enc__key().get_param(param_name);
    } else if (strcmp("enc_key_other", param_field) == 0) {
      return enc__key__other().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `RecipientInfoContainer'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_enc__key:
    mp_field = field_enc__key->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("enc_key")));
    break;
  case ALT_enc__key__other:
    mp_field = field_enc__key__other->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("enc_key_other")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void RecipientInfoContainer::set_implicit_omit()
{
switch (union_selection) {
case ALT_enc__key:
field_enc__key->set_implicit_omit(); break;
case ALT_enc__key__other:
field_enc__key__other->set_implicit_omit(); break;
default: break;
}
}

void RecipientInfoContainer::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_enc__key:
field_enc__key->encode_text(text_buf);
break;
case ALT_enc__key__other:
field_enc__key__other->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
}
}

void RecipientInfoContainer::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_enc__key:
enc__key().decode_text(text_buf);
break;
case ALT_enc__key__other:
enc__key__other().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
}
}

void RecipientInfoContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RecipientInfoContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int RecipientInfoContainer::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = enc__key().RAW_decode(EciesEncryptedKey_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = enc__key__other().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = enc__key().RAW_decode(EciesEncryptedKey_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = enc__key__other().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int RecipientInfoContainer::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  memset(myleaf.body.node.nodes, 0, 2 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_enc__key:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, EciesEncryptedKey_descr_.raw);
    encoded_length = field_enc__key->RAW_encode(EciesEncryptedKey_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &EciesEncryptedKey_descr_;
    break;
  case ALT_enc__key__other:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, OCTETSTRING_descr_.raw);
    encoded_length = field_enc__key__other->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &OCTETSTRING_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int RecipientInfoContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_enc__key:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "enc_key");
    enc_len += field_enc__key->JSON_encode(EciesEncryptedKey_descr_, p_tok);
    break;
  case ALT_enc__key__other:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "enc_key_other");
    enc_len += field_enc__key__other->JSON_encode(OCTETSTRING_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int RecipientInfoContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "enc_key", name_len)) {
      int ret_val = enc__key().JSON_decode(EciesEncryptedKey_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "enc_key");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "enc_key_other", name_len)) {
      int ret_val = enc__key__other().JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "enc_key_other");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void RecipientInfoContainer_template::copy_value(const RecipientInfoContainer& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case RecipientInfoContainer::ALT_enc__key:
single_value.field_enc__key = new EciesEncryptedKey_template(other_value.enc__key());
break;
case RecipientInfoContainer::ALT_enc__key__other:
single_value.field_enc__key__other = new OCTETSTRING_template(other_value.enc__key__other());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
}
set_selection(SPECIFIC_VALUE);
}

void RecipientInfoContainer_template::copy_template(const RecipientInfoContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case RecipientInfoContainer::ALT_enc__key:
single_value.field_enc__key = new EciesEncryptedKey_template(*other_value.single_value.field_enc__key);
break;
case RecipientInfoContainer::ALT_enc__key__other:
single_value.field_enc__key__other = new OCTETSTRING_template(*other_value.single_value.field_enc__key__other);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RecipientInfoContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
}
set_selection(other_value);
}

RecipientInfoContainer_template::RecipientInfoContainer_template()
{
}

RecipientInfoContainer_template::RecipientInfoContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RecipientInfoContainer_template::RecipientInfoContainer_template(const RecipientInfoContainer& other_value)
{
copy_value(other_value);
}

RecipientInfoContainer_template::RecipientInfoContainer_template(const OPTIONAL<RecipientInfoContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RecipientInfoContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer from an unbound optional field.");
}
}

RecipientInfoContainer_template::RecipientInfoContainer_template(const RecipientInfoContainer_template& other_value)
: Base_Template(){
copy_template(other_value);
}

RecipientInfoContainer_template::~RecipientInfoContainer_template()
{
clean_up();
}

void RecipientInfoContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case RecipientInfoContainer::ALT_enc__key:
delete single_value.field_enc__key;
break;
case RecipientInfoContainer::ALT_enc__key__other:
delete single_value.field_enc__key__other;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RecipientInfoContainer_template& RecipientInfoContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RecipientInfoContainer_template& RecipientInfoContainer_template::operator=(const RecipientInfoContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RecipientInfoContainer_template& RecipientInfoContainer_template::operator=(const OPTIONAL<RecipientInfoContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RecipientInfoContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
}
return *this;
}

RecipientInfoContainer_template& RecipientInfoContainer_template::operator=(const RecipientInfoContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RecipientInfoContainer_template::match(const RecipientInfoContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
RecipientInfoContainer::union_selection_type value_selection = other_value.get_selection();
if (value_selection == RecipientInfoContainer::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case RecipientInfoContainer::ALT_enc__key:
return single_value.field_enc__key->match(other_value.enc__key(), legacy);
case RecipientInfoContainer::ALT_enc__key__other:
return single_value.field_enc__key__other->match(other_value.enc__key__other(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
}
return FALSE;
}

boolean RecipientInfoContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case RecipientInfoContainer::ALT_enc__key:
return single_value.field_enc__key->is_value();
case RecipientInfoContainer::ALT_enc__key__other:
return single_value.field_enc__key__other->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
}
}

RecipientInfoContainer RecipientInfoContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
RecipientInfoContainer ret_val;
switch (single_value.union_selection) {
case RecipientInfoContainer::ALT_enc__key:
ret_val.enc__key() = single_value.field_enc__key->valueof();
break;
case RecipientInfoContainer::ALT_enc__key__other:
ret_val.enc__key__other() = single_value.field_enc__key__other->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
}
return ret_val;
}

RecipientInfoContainer_template& RecipientInfoContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
return value_list.list_value[list_index];
}
void RecipientInfoContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RecipientInfoContainer_template[list_length];
}

EciesEncryptedKey_template& RecipientInfoContainer_template::enc__key()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != RecipientInfoContainer::ALT_enc__key) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_enc__key = new EciesEncryptedKey_template(ANY_VALUE);
else single_value.field_enc__key = new EciesEncryptedKey_template;
single_value.union_selection = RecipientInfoContainer::ALT_enc__key;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_enc__key;
}

const EciesEncryptedKey_template& RecipientInfoContainer_template::enc__key() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field enc_key in a non-specific template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
if (single_value.union_selection != RecipientInfoContainer::ALT_enc__key) TTCN_error("Accessing non-selected field enc_key in a template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
return *single_value.field_enc__key;
}

OCTETSTRING_template& RecipientInfoContainer_template::enc__key__other()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != RecipientInfoContainer::ALT_enc__key__other) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_enc__key__other = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_enc__key__other = new OCTETSTRING_template;
single_value.union_selection = RecipientInfoContainer::ALT_enc__key__other;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_enc__key__other;
}

const OCTETSTRING_template& RecipientInfoContainer_template::enc__key__other() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field enc_key_other in a non-specific template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
if (single_value.union_selection != RecipientInfoContainer::ALT_enc__key__other) TTCN_error("Accessing non-selected field enc_key_other in a template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
return *single_value.field_enc__key__other;
}

boolean RecipientInfoContainer_template::ischosen(RecipientInfoContainer::union_selection_type checked_selection) const
{
if (checked_selection == RecipientInfoContainer::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == RecipientInfoContainer::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer");
}
return FALSE;
}

void RecipientInfoContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case RecipientInfoContainer::ALT_enc__key:
TTCN_Logger::log_event_str("{ enc_key := ");
single_value.field_enc__key->log();
TTCN_Logger::log_event_str(" }");
break;
case RecipientInfoContainer::ALT_enc__key__other:
TTCN_Logger::log_event_str("{ enc_key_other := ");
single_value.field_enc__key__other->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RecipientInfoContainer_template::log_match(const RecipientInfoContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case RecipientInfoContainer::ALT_enc__key:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".enc_key");
single_value.field_enc__key->log_match(match_value.enc__key(), legacy);
} else {
TTCN_Logger::log_event_str("{ enc_key := ");
single_value.field_enc__key->log_match(match_value.enc__key(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case RecipientInfoContainer::ALT_enc__key__other:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".enc_key_other");
single_value.field_enc__key__other->log_match(match_value.enc__key__other(), legacy);
} else {
TTCN_Logger::log_event_str("{ enc_key_other := ");
single_value.field_enc__key__other->log_match(match_value.enc__key__other(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RecipientInfoContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case RecipientInfoContainer::ALT_enc__key:
single_value.field_enc__key->encode_text(text_buf);
break;
case RecipientInfoContainer::ALT_enc__key__other:
single_value.field_enc__key__other->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
}
}

void RecipientInfoContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = RecipientInfoContainer::UNBOUND_VALUE;
RecipientInfoContainer::union_selection_type new_selection = (RecipientInfoContainer::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case RecipientInfoContainer::ALT_enc__key:
single_value.field_enc__key = new EciesEncryptedKey_template;
single_value.field_enc__key->decode_text(text_buf);
break;
case RecipientInfoContainer::ALT_enc__key__other:
single_value.field_enc__key__other = new OCTETSTRING_template;
single_value.field_enc__key__other->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RecipientInfoContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
}
}

boolean RecipientInfoContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RecipientInfoContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void RecipientInfoContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsSecurity_TypesAndValues.RecipientInfoContainer'");
    }
    if (strcmp("enc_key", param_field) == 0) {
      enc__key().set_param(param);
      return;
    } else if (strcmp("enc_key_other", param_field) == 0) {
      enc__key__other().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsSecurity_TypesAndValues.RecipientInfoContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RecipientInfoContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.RecipientInfoContainer");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "enc_key")) {
      enc__key().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "enc_key_other")) {
      enc__key__other().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.RecipientInfoContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RecipientInfoContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsSecurity_TypesAndValues.RecipientInfoContainer'");
    }
    if (strcmp("enc_key", param_field) == 0) {
      return enc__key().get_param(param_name);
    } else if (strcmp("enc_key_other", param_field) == 0) {
      return enc__key__other().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `RecipientInfoContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case RecipientInfoContainer::ALT_enc__key:
      mp_field = single_value.field_enc__key->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("enc_key")));
      break;
    case RecipientInfoContainer::ALT_enc__key__other:
      mp_field = single_value.field_enc__key__other->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("enc_key_other")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RecipientInfoContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case RecipientInfoContainer::ALT_enc__key:
single_value.field_enc__key->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.RecipientInfoContainer");
return;
case RecipientInfoContainer::ALT_enc__key__other:
single_value.field_enc__key__other->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.RecipientInfoContainer");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsSecurity_TypesAndValues.RecipientInfoContainer.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.RecipientInfoContainer");
}

EciesEncryptedKey::EciesEncryptedKey()
{
  bound_flag = FALSE;
}

EciesEncryptedKey::EciesEncryptedKey(const EccPoint& par_v,
    const OCTETSTRING& par_c,
    const OCTETSTRING& par_t)
  :   field_v(par_v),
  field_c(par_c),
  field_t(par_t)
{
  bound_flag = TRUE;
}

EciesEncryptedKey::EciesEncryptedKey(const EciesEncryptedKey& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey.");
bound_flag = TRUE;
if (other_value.v().is_bound()) field_v = other_value.v();
else field_v.clean_up();
if (other_value.c().is_bound()) field_c = other_value.c();
else field_c.clean_up();
if (other_value.t().is_bound()) field_t = other_value.t();
else field_t.clean_up();
}

void EciesEncryptedKey::clean_up()
{
field_v.clean_up();
field_c.clean_up();
field_t.clean_up();
bound_flag = FALSE;
}

EciesEncryptedKey& EciesEncryptedKey::operator=(const EciesEncryptedKey& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey.");
  bound_flag = TRUE;
  if (other_value.v().is_bound()) field_v = other_value.v();
  else field_v.clean_up();
  if (other_value.c().is_bound()) field_c = other_value.c();
  else field_c.clean_up();
  if (other_value.t().is_bound()) field_t = other_value.t();
  else field_t.clean_up();
}
return *this;
}

boolean EciesEncryptedKey::operator==(const EciesEncryptedKey& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_v==other_value.field_v
  && field_c==other_value.field_c
  && field_t==other_value.field_t;
}

boolean EciesEncryptedKey::is_bound() const
{
if (bound_flag) return TRUE;
if(field_v.is_bound()) return TRUE;
if(field_c.is_bound()) return TRUE;
if(field_t.is_bound()) return TRUE;
return FALSE;
}
boolean EciesEncryptedKey::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_v.is_value()) return FALSE;
if(!field_c.is_value()) return FALSE;
if(!field_t.is_value()) return FALSE;
return TRUE;
}
int EciesEncryptedKey::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey");
  return 3;
}

void EciesEncryptedKey::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ v := ");
field_v.log();
TTCN_Logger::log_event_str(", c := ");
field_c.log();
TTCN_Logger::log_event_str(", t := ");
field_t.log();
TTCN_Logger::log_event_str(" }");
}

void EciesEncryptedKey::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.EciesEncryptedKey'");
    }
    if (strcmp("v", param_field) == 0) {
      v().set_param(param);
      return;
    } else if (strcmp("c", param_field) == 0) {
      c().set_param(param);
      return;
    } else if (strcmp("t", param_field) == 0) {
      t().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.EciesEncryptedKey'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) v().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) c().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) t().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "v")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          v().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "c")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          c().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.EciesEncryptedKey: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.EciesEncryptedKey");
  }
}

Module_Param* EciesEncryptedKey::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.EciesEncryptedKey'");
    }
    if (strcmp("v", param_field) == 0) {
      return v().get_param(param_name);
    } else if (strcmp("c", param_field) == 0) {
      return c().get_param(param_name);
    } else if (strcmp("t", param_field) == 0) {
      return t().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.EciesEncryptedKey'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_v = field_v.get_param(param_name);
  mp_field_v->set_id(new Module_Param_FieldName(mcopystr("v")));
  mp->add_elem(mp_field_v);
  Module_Param* mp_field_c = field_c.get_param(param_name);
  mp_field_c->set_id(new Module_Param_FieldName(mcopystr("c")));
  mp->add_elem(mp_field_c);
  Module_Param* mp_field_t = field_t.get_param(param_name);
  mp_field_t->set_id(new Module_Param_FieldName(mcopystr("t")));
  mp->add_elem(mp_field_t);
  return mp;
  }

void EciesEncryptedKey::set_implicit_omit()
{
if (v().is_bound()) v().set_implicit_omit();
if (c().is_bound()) c().set_implicit_omit();
if (t().is_bound()) t().set_implicit_omit();
}

void EciesEncryptedKey::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey.");
field_v.encode_text(text_buf);
field_c.encode_text(text_buf);
field_t.encode_text(text_buf);
}

void EciesEncryptedKey::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_v.decode_text(text_buf);
field_c.decode_text(text_buf);
field_t.decode_text(text_buf);
}

void EciesEncryptedKey::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void EciesEncryptedKey::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int EciesEncryptedKey::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_v.RAW_decode(EccPoint_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_c.RAW_decode(OCTETSTRING_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_t.RAW_decode(LibCommon__DataStrings::Oct16_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int EciesEncryptedKey::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, EccPoint_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, OCTETSTRING_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, LibCommon__DataStrings::Oct16_descr_.raw);
  encoded_length += field_v.RAW_encode(EccPoint_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_c.RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_t.RAW_encode(LibCommon__DataStrings::Oct16_descr_, *myleaf.body.node.nodes[2]);
  return myleaf.length = encoded_length;
}

int EciesEncryptedKey::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "v");
    enc_len += field_v.JSON_encode(EccPoint_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "c");
    enc_len += field_c.JSON_encode(OCTETSTRING_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "t");
    enc_len += field_t.JSON_encode(LibCommon__DataStrings::Oct16_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int EciesEncryptedKey::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (1 == name_len && 0 == strncmp(fld_name, "v", name_len)) {
         int ret_val = field_v.JSON_decode(EccPoint_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "v");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (1 == name_len && 0 == strncmp(fld_name, "c", name_len)) {
         int ret_val = field_c.JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "c");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (1 == name_len && 0 == strncmp(fld_name, "t", name_len)) {
         int ret_val = field_t.JSON_decode(LibCommon__DataStrings::Oct16_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "t");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_v.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "v");
    return JSON_ERROR_FATAL;
  }
if (!field_c.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "c");
    return JSON_ERROR_FATAL;
  }
if (!field_t.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "t");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct EciesEncryptedKey_template::single_value_struct {
EccPoint_template field_v;
OCTETSTRING_template field_c;
OCTETSTRING_template field_t;
};

void EciesEncryptedKey_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_v = ANY_VALUE;
single_value->field_c = ANY_VALUE;
single_value->field_t = ANY_VALUE;
}
}
}

void EciesEncryptedKey_template::copy_value(const EciesEncryptedKey& other_value)
{
single_value = new single_value_struct;
if (other_value.v().is_bound()) {
  single_value->field_v = other_value.v();
} else {
  single_value->field_v.clean_up();
}
if (other_value.c().is_bound()) {
  single_value->field_c = other_value.c();
} else {
  single_value->field_c.clean_up();
}
if (other_value.t().is_bound()) {
  single_value->field_t = other_value.t();
} else {
  single_value->field_t.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void EciesEncryptedKey_template::copy_template(const EciesEncryptedKey_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.v().get_selection()) {
single_value->field_v = other_value.v();
} else {
single_value->field_v.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.c().get_selection()) {
single_value->field_c = other_value.c();
} else {
single_value->field_c.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.t().get_selection()) {
single_value->field_t = other_value.t();
} else {
single_value->field_t.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new EciesEncryptedKey_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey.");
break;
}
set_selection(other_value);
}

EciesEncryptedKey_template::EciesEncryptedKey_template()
{
}

EciesEncryptedKey_template::EciesEncryptedKey_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

EciesEncryptedKey_template::EciesEncryptedKey_template(const EciesEncryptedKey& other_value)
{
copy_value(other_value);
}

EciesEncryptedKey_template::EciesEncryptedKey_template(const OPTIONAL<EciesEncryptedKey>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EciesEncryptedKey&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey from an unbound optional field.");
}
}

EciesEncryptedKey_template::EciesEncryptedKey_template(const EciesEncryptedKey_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

EciesEncryptedKey_template::~EciesEncryptedKey_template()
{
clean_up();
}

EciesEncryptedKey_template& EciesEncryptedKey_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

EciesEncryptedKey_template& EciesEncryptedKey_template::operator=(const EciesEncryptedKey& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

EciesEncryptedKey_template& EciesEncryptedKey_template::operator=(const OPTIONAL<EciesEncryptedKey>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const EciesEncryptedKey&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey.");
}
return *this;
}

EciesEncryptedKey_template& EciesEncryptedKey_template::operator=(const EciesEncryptedKey_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean EciesEncryptedKey_template::match(const EciesEncryptedKey& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.v().is_bound()) return FALSE;
if(!single_value->field_v.match(other_value.v(), legacy))return FALSE;
if(!other_value.c().is_bound()) return FALSE;
if(!single_value->field_c.match(other_value.c(), legacy))return FALSE;
if(!other_value.t().is_bound()) return FALSE;
if(!single_value->field_t.match(other_value.t(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey.");
}
return FALSE;
}

boolean EciesEncryptedKey_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_v.is_bound()) return TRUE;
if (single_value->field_c.is_bound()) return TRUE;
if (single_value->field_t.is_bound()) return TRUE;
return FALSE;
}

boolean EciesEncryptedKey_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_v.is_value()) return FALSE;
if (!single_value->field_c.is_value()) return FALSE;
if (!single_value->field_t.is_value()) return FALSE;
return TRUE;
}

void EciesEncryptedKey_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

EciesEncryptedKey EciesEncryptedKey_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey.");
EciesEncryptedKey ret_val;
if (single_value->field_v.is_bound()) {
ret_val.v() = single_value->field_v.valueof();
}
if (single_value->field_c.is_bound()) {
ret_val.c() = single_value->field_c.valueof();
}
if (single_value->field_t.is_bound()) {
ret_val.t() = single_value->field_t.valueof();
}
return ret_val;
}

void EciesEncryptedKey_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new EciesEncryptedKey_template[list_length];
}

EciesEncryptedKey_template& EciesEncryptedKey_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey.");
return value_list.list_value[list_index];
}

EccPoint_template& EciesEncryptedKey_template::v()
{
set_specific();
return single_value->field_v;
}

const EccPoint_template& EciesEncryptedKey_template::v() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field v of a non-specific template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey.");
return single_value->field_v;
}

OCTETSTRING_template& EciesEncryptedKey_template::c()
{
set_specific();
return single_value->field_c;
}

const OCTETSTRING_template& EciesEncryptedKey_template::c() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field c of a non-specific template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey.");
return single_value->field_c;
}

OCTETSTRING_template& EciesEncryptedKey_template::t()
{
set_specific();
return single_value->field_t;
}

const OCTETSTRING_template& EciesEncryptedKey_template::t() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field t of a non-specific template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey.");
return single_value->field_t;
}

int EciesEncryptedKey_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey.");
  }
  return 0;
}

void EciesEncryptedKey_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ v := ");
single_value->field_v.log();
TTCN_Logger::log_event_str(", c := ");
single_value->field_c.log();
TTCN_Logger::log_event_str(", t := ");
single_value->field_t.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void EciesEncryptedKey_template::log_match(const EciesEncryptedKey& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_v.match(match_value.v(), legacy)){
TTCN_Logger::log_logmatch_info(".v");
single_value->field_v.log_match(match_value.v(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_c.match(match_value.c(), legacy)){
TTCN_Logger::log_logmatch_info(".c");
single_value->field_c.log_match(match_value.c(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_t.match(match_value.t(), legacy)){
TTCN_Logger::log_logmatch_info(".t");
single_value->field_t.log_match(match_value.t(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ v := ");
single_value->field_v.log_match(match_value.v(), legacy);
TTCN_Logger::log_event_str(", c := ");
single_value->field_c.log_match(match_value.c(), legacy);
TTCN_Logger::log_event_str(", t := ");
single_value->field_t.log_match(match_value.t(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void EciesEncryptedKey_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_v.encode_text(text_buf);
single_value->field_c.encode_text(text_buf);
single_value->field_t.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey.");
}
}

void EciesEncryptedKey_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_v.decode_text(text_buf);
single_value->field_c.decode_text(text_buf);
single_value->field_t.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new EciesEncryptedKey_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey.");
}
}

void EciesEncryptedKey_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.EciesEncryptedKey'");
    }
    if (strcmp("v", param_field) == 0) {
      v().set_param(param);
      return;
    } else if (strcmp("c", param_field) == 0) {
      c().set_param(param);
      return;
    } else if (strcmp("t", param_field) == 0) {
      t().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.EciesEncryptedKey'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    EciesEncryptedKey_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.EciesEncryptedKey has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) v().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) c().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) t().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "v")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          v().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "c")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          c().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "t")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          t().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.EciesEncryptedKey: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.EciesEncryptedKey");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* EciesEncryptedKey_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.EciesEncryptedKey'");
    }
    if (strcmp("v", param_field) == 0) {
      return v().get_param(param_name);
    } else if (strcmp("c", param_field) == 0) {
      return c().get_param(param_name);
    } else if (strcmp("t", param_field) == 0) {
      return t().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.EciesEncryptedKey'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_v = single_value->field_v.get_param(param_name);
    mp_field_v->set_id(new Module_Param_FieldName(mcopystr("v")));
    mp->add_elem(mp_field_v);
    Module_Param* mp_field_c = single_value->field_c.get_param(param_name);
    mp_field_c->set_id(new Module_Param_FieldName(mcopystr("c")));
    mp->add_elem(mp_field_c);
    Module_Param* mp_field_t = single_value->field_t.get_param(param_name);
    mp_field_t->set_id(new Module_Param_FieldName(mcopystr("t")));
    mp->add_elem(mp_field_t);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void EciesEncryptedKey_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_v.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.EciesEncryptedKey");
single_value->field_c.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.EciesEncryptedKey");
single_value->field_t.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.EciesEncryptedKey");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.EciesEncryptedKey");
}

boolean EciesEncryptedKey_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean EciesEncryptedKey_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

RecipientInfo::RecipientInfo()
{
  bound_flag = FALSE;
}

RecipientInfo::RecipientInfo(const OCTETSTRING& par_cert__id,
    const PublicKeyAlgorithm& par_pk__encryption,
    const RecipientInfoContainer& par_enc__key)
  :   field_cert__id(par_cert__id),
  field_pk__encryption(par_pk__encryption),
  field_enc__key(par_enc__key)
{
  bound_flag = TRUE;
}

RecipientInfo::RecipientInfo(const RecipientInfo& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfo.");
bound_flag = TRUE;
if (other_value.cert__id().is_bound()) field_cert__id = other_value.cert__id();
else field_cert__id.clean_up();
if (other_value.pk__encryption().is_bound()) field_pk__encryption = other_value.pk__encryption();
else field_pk__encryption.clean_up();
if (other_value.enc__key().is_bound()) field_enc__key = other_value.enc__key();
else field_enc__key.clean_up();
}

void RecipientInfo::clean_up()
{
field_cert__id.clean_up();
field_pk__encryption.clean_up();
field_enc__key.clean_up();
bound_flag = FALSE;
}

RecipientInfo& RecipientInfo::operator=(const RecipientInfo& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfo.");
  bound_flag = TRUE;
  if (other_value.cert__id().is_bound()) field_cert__id = other_value.cert__id();
  else field_cert__id.clean_up();
  if (other_value.pk__encryption().is_bound()) field_pk__encryption = other_value.pk__encryption();
  else field_pk__encryption.clean_up();
  if (other_value.enc__key().is_bound()) field_enc__key = other_value.enc__key();
  else field_enc__key.clean_up();
}
return *this;
}

boolean RecipientInfo::operator==(const RecipientInfo& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_cert__id==other_value.field_cert__id
  && field_pk__encryption==other_value.field_pk__encryption
  && field_enc__key==other_value.field_enc__key;
}

boolean RecipientInfo::is_bound() const
{
if (bound_flag) return TRUE;
if(field_cert__id.is_bound()) return TRUE;
if(field_pk__encryption.is_bound()) return TRUE;
if(field_enc__key.is_bound()) return TRUE;
return FALSE;
}
boolean RecipientInfo::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_cert__id.is_value()) return FALSE;
if(!field_pk__encryption.is_value()) return FALSE;
if(!field_enc__key.is_value()) return FALSE;
return TRUE;
}
int RecipientInfo::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.RecipientInfo");
  return 3;
}

void RecipientInfo::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ cert_id := ");
field_cert__id.log();
TTCN_Logger::log_event_str(", pk_encryption := ");
field_pk__encryption.log();
TTCN_Logger::log_event_str(", enc_key := ");
field_enc__key.log();
TTCN_Logger::log_event_str(" }");
}

void RecipientInfo::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.RecipientInfo'");
    }
    if (strcmp("cert_id", param_field) == 0) {
      cert__id().set_param(param);
      return;
    } else if (strcmp("pk_encryption", param_field) == 0) {
      pk__encryption().set_param(param);
      return;
    } else if (strcmp("enc_key", param_field) == 0) {
      enc__key().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.RecipientInfo'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.RecipientInfo has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) cert__id().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) pk__encryption().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) enc__key().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cert_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cert__id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pk_encryption")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pk__encryption().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "enc_key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          enc__key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.RecipientInfo: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.RecipientInfo");
  }
}

Module_Param* RecipientInfo::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.RecipientInfo'");
    }
    if (strcmp("cert_id", param_field) == 0) {
      return cert__id().get_param(param_name);
    } else if (strcmp("pk_encryption", param_field) == 0) {
      return pk__encryption().get_param(param_name);
    } else if (strcmp("enc_key", param_field) == 0) {
      return enc__key().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.RecipientInfo'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_cert__id = field_cert__id.get_param(param_name);
  mp_field_cert__id->set_id(new Module_Param_FieldName(mcopystr("cert_id")));
  mp->add_elem(mp_field_cert__id);
  Module_Param* mp_field_pk__encryption = field_pk__encryption.get_param(param_name);
  mp_field_pk__encryption->set_id(new Module_Param_FieldName(mcopystr("pk_encryption")));
  mp->add_elem(mp_field_pk__encryption);
  Module_Param* mp_field_enc__key = field_enc__key.get_param(param_name);
  mp_field_enc__key->set_id(new Module_Param_FieldName(mcopystr("enc_key")));
  mp->add_elem(mp_field_enc__key);
  return mp;
  }

void RecipientInfo::set_implicit_omit()
{
if (cert__id().is_bound()) cert__id().set_implicit_omit();
if (pk__encryption().is_bound()) pk__encryption().set_implicit_omit();
if (enc__key().is_bound()) enc__key().set_implicit_omit();
}

void RecipientInfo::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.RecipientInfo.");
field_cert__id.encode_text(text_buf);
field_pk__encryption.encode_text(text_buf);
field_enc__key.encode_text(text_buf);
}

void RecipientInfo::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_cert__id.decode_text(text_buf);
field_pk__encryption.decode_text(text_buf);
field_enc__key.decode_text(text_buf);
}

void RecipientInfo::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void RecipientInfo::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int RecipientInfo::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_cert__id.RAW_decode(HashedId8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_pk__encryption.RAW_decode(PublicKeyAlgorithm_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_enc__key.RAW_decode(RecipientInfoContainer_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int RecipientInfo::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 3;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(3);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, HashedId8_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, PublicKeyAlgorithm_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, RecipientInfoContainer_descr_.raw);
  encoded_length += field_cert__id.RAW_encode(HashedId8_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_pk__encryption.RAW_encode(PublicKeyAlgorithm_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_enc__key.RAW_encode(RecipientInfoContainer_descr_, *myleaf.body.node.nodes[2]);
  return myleaf.length = encoded_length;
}

int RecipientInfo::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfo.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "cert_id");
    enc_len += field_cert__id.JSON_encode(HashedId8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "pk_encryption");
    enc_len += field_pk__encryption.JSON_encode(PublicKeyAlgorithm_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "enc_key");
    enc_len += field_enc__key.JSON_encode(RecipientInfoContainer_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int RecipientInfo::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (7 == name_len && 0 == strncmp(fld_name, "cert_id", name_len)) {
         int ret_val = field_cert__id.JSON_decode(HashedId8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "cert_id");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "pk_encryption", name_len)) {
         int ret_val = field_pk__encryption.JSON_decode(PublicKeyAlgorithm_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "pk_encryption");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (7 == name_len && 0 == strncmp(fld_name, "enc_key", name_len)) {
         int ret_val = field_enc__key.JSON_decode(RecipientInfoContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "enc_key");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_cert__id.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "cert_id");
    return JSON_ERROR_FATAL;
  }
if (!field_pk__encryption.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "pk_encryption");
    return JSON_ERROR_FATAL;
  }
if (!field_enc__key.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "enc_key");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct RecipientInfo_template::single_value_struct {
OCTETSTRING_template field_cert__id;
PublicKeyAlgorithm_template field_pk__encryption;
RecipientInfoContainer_template field_enc__key;
};

void RecipientInfo_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_cert__id = ANY_VALUE;
single_value->field_pk__encryption = ANY_VALUE;
single_value->field_enc__key = ANY_VALUE;
}
}
}

void RecipientInfo_template::copy_value(const RecipientInfo& other_value)
{
single_value = new single_value_struct;
if (other_value.cert__id().is_bound()) {
  single_value->field_cert__id = other_value.cert__id();
} else {
  single_value->field_cert__id.clean_up();
}
if (other_value.pk__encryption().is_bound()) {
  single_value->field_pk__encryption = other_value.pk__encryption();
} else {
  single_value->field_pk__encryption.clean_up();
}
if (other_value.enc__key().is_bound()) {
  single_value->field_enc__key = other_value.enc__key();
} else {
  single_value->field_enc__key.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void RecipientInfo_template::copy_template(const RecipientInfo_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.cert__id().get_selection()) {
single_value->field_cert__id = other_value.cert__id();
} else {
single_value->field_cert__id.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.pk__encryption().get_selection()) {
single_value->field_pk__encryption = other_value.pk__encryption();
} else {
single_value->field_pk__encryption.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.enc__key().get_selection()) {
single_value->field_enc__key = other_value.enc__key();
} else {
single_value->field_enc__key.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new RecipientInfo_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.RecipientInfo.");
break;
}
set_selection(other_value);
}

RecipientInfo_template::RecipientInfo_template()
{
}

RecipientInfo_template::RecipientInfo_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

RecipientInfo_template::RecipientInfo_template(const RecipientInfo& other_value)
{
copy_value(other_value);
}

RecipientInfo_template::RecipientInfo_template(const OPTIONAL<RecipientInfo>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RecipientInfo&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.RecipientInfo from an unbound optional field.");
}
}

RecipientInfo_template::RecipientInfo_template(const RecipientInfo_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

RecipientInfo_template::~RecipientInfo_template()
{
clean_up();
}

RecipientInfo_template& RecipientInfo_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

RecipientInfo_template& RecipientInfo_template::operator=(const RecipientInfo& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

RecipientInfo_template& RecipientInfo_template::operator=(const OPTIONAL<RecipientInfo>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const RecipientInfo&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.RecipientInfo.");
}
return *this;
}

RecipientInfo_template& RecipientInfo_template::operator=(const RecipientInfo_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean RecipientInfo_template::match(const RecipientInfo& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.cert__id().is_bound()) return FALSE;
if(!single_value->field_cert__id.match(other_value.cert__id(), legacy))return FALSE;
if(!other_value.pk__encryption().is_bound()) return FALSE;
if(!single_value->field_pk__encryption.match(other_value.pk__encryption(), legacy))return FALSE;
if(!other_value.enc__key().is_bound()) return FALSE;
if(!single_value->field_enc__key.match(other_value.enc__key(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.RecipientInfo.");
}
return FALSE;
}

boolean RecipientInfo_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_cert__id.is_bound()) return TRUE;
if (single_value->field_pk__encryption.is_bound()) return TRUE;
if (single_value->field_enc__key.is_bound()) return TRUE;
return FALSE;
}

boolean RecipientInfo_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_cert__id.is_value()) return FALSE;
if (!single_value->field_pk__encryption.is_value()) return FALSE;
if (!single_value->field_enc__key.is_value()) return FALSE;
return TRUE;
}

void RecipientInfo_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

RecipientInfo RecipientInfo_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.RecipientInfo.");
RecipientInfo ret_val;
if (single_value->field_cert__id.is_bound()) {
ret_val.cert__id() = single_value->field_cert__id.valueof();
}
if (single_value->field_pk__encryption.is_bound()) {
ret_val.pk__encryption() = single_value->field_pk__encryption.valueof();
}
if (single_value->field_enc__key.is_bound()) {
ret_val.enc__key() = single_value->field_enc__key.valueof();
}
return ret_val;
}

void RecipientInfo_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.RecipientInfo.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new RecipientInfo_template[list_length];
}

RecipientInfo_template& RecipientInfo_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.RecipientInfo.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.RecipientInfo.");
return value_list.list_value[list_index];
}

OCTETSTRING_template& RecipientInfo_template::cert__id()
{
set_specific();
return single_value->field_cert__id;
}

const OCTETSTRING_template& RecipientInfo_template::cert__id() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field cert_id of a non-specific template of type @LibItsSecurity_TypesAndValues.RecipientInfo.");
return single_value->field_cert__id;
}

PublicKeyAlgorithm_template& RecipientInfo_template::pk__encryption()
{
set_specific();
return single_value->field_pk__encryption;
}

const PublicKeyAlgorithm_template& RecipientInfo_template::pk__encryption() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field pk_encryption of a non-specific template of type @LibItsSecurity_TypesAndValues.RecipientInfo.");
return single_value->field_pk__encryption;
}

RecipientInfoContainer_template& RecipientInfo_template::enc__key()
{
set_specific();
return single_value->field_enc__key;
}

const RecipientInfoContainer_template& RecipientInfo_template::enc__key() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field enc_key of a non-specific template of type @LibItsSecurity_TypesAndValues.RecipientInfo.");
return single_value->field_enc__key;
}

int RecipientInfo_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.RecipientInfo which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 3;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.RecipientInfo containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.RecipientInfo containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.RecipientInfo containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.RecipientInfo containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.RecipientInfo containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.RecipientInfo.");
  }
  return 0;
}

void RecipientInfo_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ cert_id := ");
single_value->field_cert__id.log();
TTCN_Logger::log_event_str(", pk_encryption := ");
single_value->field_pk__encryption.log();
TTCN_Logger::log_event_str(", enc_key := ");
single_value->field_enc__key.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void RecipientInfo_template::log_match(const RecipientInfo& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_cert__id.match(match_value.cert__id(), legacy)){
TTCN_Logger::log_logmatch_info(".cert_id");
single_value->field_cert__id.log_match(match_value.cert__id(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_pk__encryption.match(match_value.pk__encryption(), legacy)){
TTCN_Logger::log_logmatch_info(".pk_encryption");
single_value->field_pk__encryption.log_match(match_value.pk__encryption(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_enc__key.match(match_value.enc__key(), legacy)){
TTCN_Logger::log_logmatch_info(".enc_key");
single_value->field_enc__key.log_match(match_value.enc__key(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ cert_id := ");
single_value->field_cert__id.log_match(match_value.cert__id(), legacy);
TTCN_Logger::log_event_str(", pk_encryption := ");
single_value->field_pk__encryption.log_match(match_value.pk__encryption(), legacy);
TTCN_Logger::log_event_str(", enc_key := ");
single_value->field_enc__key.log_match(match_value.enc__key(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void RecipientInfo_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_cert__id.encode_text(text_buf);
single_value->field_pk__encryption.encode_text(text_buf);
single_value->field_enc__key.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.RecipientInfo.");
}
}

void RecipientInfo_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_cert__id.decode_text(text_buf);
single_value->field_pk__encryption.decode_text(text_buf);
single_value->field_enc__key.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new RecipientInfo_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.RecipientInfo.");
}
}

void RecipientInfo_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.RecipientInfo'");
    }
    if (strcmp("cert_id", param_field) == 0) {
      cert__id().set_param(param);
      return;
    } else if (strcmp("pk_encryption", param_field) == 0) {
      pk__encryption().set_param(param);
      return;
    } else if (strcmp("enc_key", param_field) == 0) {
      enc__key().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.RecipientInfo'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    RecipientInfo_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (3<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.RecipientInfo has 3 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) cert__id().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) pk__encryption().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) enc__key().set_param(*mp->get_elem(2));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "cert_id")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          cert__id().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "pk_encryption")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          pk__encryption().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "enc_key")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          enc__key().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.RecipientInfo: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.RecipientInfo");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* RecipientInfo_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.RecipientInfo'");
    }
    if (strcmp("cert_id", param_field) == 0) {
      return cert__id().get_param(param_name);
    } else if (strcmp("pk_encryption", param_field) == 0) {
      return pk__encryption().get_param(param_name);
    } else if (strcmp("enc_key", param_field) == 0) {
      return enc__key().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.RecipientInfo'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_cert__id = single_value->field_cert__id.get_param(param_name);
    mp_field_cert__id->set_id(new Module_Param_FieldName(mcopystr("cert_id")));
    mp->add_elem(mp_field_cert__id);
    Module_Param* mp_field_pk__encryption = single_value->field_pk__encryption.get_param(param_name);
    mp_field_pk__encryption->set_id(new Module_Param_FieldName(mcopystr("pk_encryption")));
    mp->add_elem(mp_field_pk__encryption);
    Module_Param* mp_field_enc__key = single_value->field_enc__key.get_param(param_name);
    mp_field_enc__key->set_id(new Module_Param_FieldName(mcopystr("enc_key")));
    mp->add_elem(mp_field_enc__key);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void RecipientInfo_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_cert__id.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.RecipientInfo");
single_value->field_pk__encryption.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.RecipientInfo");
single_value->field_enc__key.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.RecipientInfo");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.RecipientInfo");
}

boolean RecipientInfo_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean RecipientInfo_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

HeaderField::HeaderField()
{
  bound_flag = FALSE;
}

HeaderField::HeaderField(const HeaderFieldType& par_type__,
    const HeaderFieldContainer& par_headerField)
  :   field_type__(par_type__),
  field_headerField(par_headerField)
{
  bound_flag = TRUE;
}

HeaderField::HeaderField(const HeaderField& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.HeaderField.");
bound_flag = TRUE;
if (other_value.type__().is_bound()) field_type__ = other_value.type__();
else field_type__.clean_up();
if (other_value.headerField().is_bound()) field_headerField = other_value.headerField();
else field_headerField.clean_up();
}

void HeaderField::clean_up()
{
field_type__.clean_up();
field_headerField.clean_up();
bound_flag = FALSE;
}

HeaderField& HeaderField::operator=(const HeaderField& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.HeaderField.");
  bound_flag = TRUE;
  if (other_value.type__().is_bound()) field_type__ = other_value.type__();
  else field_type__.clean_up();
  if (other_value.headerField().is_bound()) field_headerField = other_value.headerField();
  else field_headerField.clean_up();
}
return *this;
}

boolean HeaderField::operator==(const HeaderField& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_type__==other_value.field_type__
  && field_headerField==other_value.field_headerField;
}

boolean HeaderField::is_bound() const
{
if (bound_flag) return TRUE;
if(field_type__.is_bound()) return TRUE;
if(field_headerField.is_bound()) return TRUE;
return FALSE;
}
boolean HeaderField::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_type__.is_value()) return FALSE;
if(!field_headerField.is_value()) return FALSE;
return TRUE;
}
int HeaderField::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.HeaderField");
  return 2;
}

void HeaderField::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ type_ := ");
field_type__.log();
TTCN_Logger::log_event_str(", headerField := ");
field_headerField.log();
TTCN_Logger::log_event_str(" }");
}

void HeaderField::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.HeaderField'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("headerField", param_field) == 0) {
      headerField().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.HeaderField'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.HeaderField has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerField().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerField")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerField().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.HeaderField: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.HeaderField");
  }
}

Module_Param* HeaderField::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.HeaderField'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("headerField", param_field) == 0) {
      return headerField().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.HeaderField'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_type__ = field_type__.get_param(param_name);
  mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
  mp->add_elem(mp_field_type__);
  Module_Param* mp_field_headerField = field_headerField.get_param(param_name);
  mp_field_headerField->set_id(new Module_Param_FieldName(mcopystr("headerField")));
  mp->add_elem(mp_field_headerField);
  return mp;
  }

void HeaderField::set_implicit_omit()
{
if (type__().is_bound()) type__().set_implicit_omit();
if (headerField().is_bound()) headerField().set_implicit_omit();
}

void HeaderField::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.HeaderField.");
field_type__.encode_text(text_buf);
field_headerField.encode_text(text_buf);
}

void HeaderField::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_type__.decode_text(text_buf);
field_headerField.decode_text(text_buf);
}

void HeaderField::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void HeaderField::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int HeaderField::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_type__.RAW_decode(HeaderFieldType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_headerField.RAW_decode(HeaderFieldContainer_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int HeaderField::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, HeaderFieldType_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, HeaderFieldContainer_descr_.raw);
  encoded_length += field_type__.RAW_encode(HeaderFieldType_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_headerField.RAW_encode(HeaderFieldContainer_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int HeaderField::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.HeaderField.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "type_");
    enc_len += field_type__.JSON_encode(HeaderFieldType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "headerField");
    enc_len += field_headerField.JSON_encode(HeaderFieldContainer_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int HeaderField::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (5 == name_len && 0 == strncmp(fld_name, "type_", name_len)) {
         int ret_val = field_type__.JSON_decode(HeaderFieldType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "type_");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "headerField", name_len)) {
         int ret_val = field_headerField.JSON_decode(HeaderFieldContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "headerField");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_type__.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "type_");
    return JSON_ERROR_FATAL;
  }
if (!field_headerField.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "headerField");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct HeaderField_template::single_value_struct {
HeaderFieldType_template field_type__;
HeaderFieldContainer_template field_headerField;
};

void HeaderField_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_type__ = ANY_VALUE;
single_value->field_headerField = ANY_VALUE;
}
}
}

void HeaderField_template::copy_value(const HeaderField& other_value)
{
single_value = new single_value_struct;
if (other_value.type__().is_bound()) {
  single_value->field_type__ = other_value.type__();
} else {
  single_value->field_type__.clean_up();
}
if (other_value.headerField().is_bound()) {
  single_value->field_headerField = other_value.headerField();
} else {
  single_value->field_headerField.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void HeaderField_template::copy_template(const HeaderField_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.type__().get_selection()) {
single_value->field_type__ = other_value.type__();
} else {
single_value->field_type__.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.headerField().get_selection()) {
single_value->field_headerField = other_value.headerField();
} else {
single_value->field_headerField.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new HeaderField_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.HeaderField.");
break;
}
set_selection(other_value);
}

HeaderField_template::HeaderField_template()
{
}

HeaderField_template::HeaderField_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

HeaderField_template::HeaderField_template(const HeaderField& other_value)
{
copy_value(other_value);
}

HeaderField_template::HeaderField_template(const OPTIONAL<HeaderField>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const HeaderField&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.HeaderField from an unbound optional field.");
}
}

HeaderField_template::HeaderField_template(const HeaderField_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

HeaderField_template::~HeaderField_template()
{
clean_up();
}

HeaderField_template& HeaderField_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

HeaderField_template& HeaderField_template::operator=(const HeaderField& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

HeaderField_template& HeaderField_template::operator=(const OPTIONAL<HeaderField>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const HeaderField&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.HeaderField.");
}
return *this;
}

HeaderField_template& HeaderField_template::operator=(const HeaderField_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean HeaderField_template::match(const HeaderField& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.type__().is_bound()) return FALSE;
if(!single_value->field_type__.match(other_value.type__(), legacy))return FALSE;
if(!other_value.headerField().is_bound()) return FALSE;
if(!single_value->field_headerField.match(other_value.headerField(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.HeaderField.");
}
return FALSE;
}

boolean HeaderField_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_type__.is_bound()) return TRUE;
if (single_value->field_headerField.is_bound()) return TRUE;
return FALSE;
}

boolean HeaderField_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_type__.is_value()) return FALSE;
if (!single_value->field_headerField.is_value()) return FALSE;
return TRUE;
}

void HeaderField_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

HeaderField HeaderField_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.HeaderField.");
HeaderField ret_val;
if (single_value->field_type__.is_bound()) {
ret_val.type__() = single_value->field_type__.valueof();
}
if (single_value->field_headerField.is_bound()) {
ret_val.headerField() = single_value->field_headerField.valueof();
}
return ret_val;
}

void HeaderField_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.HeaderField.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new HeaderField_template[list_length];
}

HeaderField_template& HeaderField_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.HeaderField.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.HeaderField.");
return value_list.list_value[list_index];
}

HeaderFieldType_template& HeaderField_template::type__()
{
set_specific();
return single_value->field_type__;
}

const HeaderFieldType_template& HeaderField_template::type__() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field type_ of a non-specific template of type @LibItsSecurity_TypesAndValues.HeaderField.");
return single_value->field_type__;
}

HeaderFieldContainer_template& HeaderField_template::headerField()
{
set_specific();
return single_value->field_headerField;
}

const HeaderFieldContainer_template& HeaderField_template::headerField() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field headerField of a non-specific template of type @LibItsSecurity_TypesAndValues.HeaderField.");
return single_value->field_headerField;
}

int HeaderField_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.HeaderField which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.HeaderField containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.HeaderField containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.HeaderField containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.HeaderField containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.HeaderField containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.HeaderField.");
  }
  return 0;
}

void HeaderField_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log();
TTCN_Logger::log_event_str(", headerField := ");
single_value->field_headerField.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void HeaderField_template::log_match(const HeaderField& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_type__.match(match_value.type__(), legacy)){
TTCN_Logger::log_logmatch_info(".type_");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_headerField.match(match_value.headerField(), legacy)){
TTCN_Logger::log_logmatch_info(".headerField");
single_value->field_headerField.log_match(match_value.headerField(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::log_event_str(", headerField := ");
single_value->field_headerField.log_match(match_value.headerField(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void HeaderField_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_type__.encode_text(text_buf);
single_value->field_headerField.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.HeaderField.");
}
}

void HeaderField_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_type__.decode_text(text_buf);
single_value->field_headerField.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new HeaderField_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.HeaderField.");
}
}

void HeaderField_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.HeaderField'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("headerField", param_field) == 0) {
      headerField().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.HeaderField'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    HeaderField_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.HeaderField has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) headerField().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "headerField")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          headerField().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.HeaderField: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.HeaderField");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* HeaderField_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.HeaderField'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("headerField", param_field) == 0) {
      return headerField().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.HeaderField'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_type__ = single_value->field_type__.get_param(param_name);
    mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
    mp->add_elem(mp_field_type__);
    Module_Param* mp_field_headerField = single_value->field_headerField.get_param(param_name);
    mp_field_headerField->set_id(new Module_Param_FieldName(mcopystr("headerField")));
    mp->add_elem(mp_field_headerField);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void HeaderField_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_type__.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.HeaderField");
single_value->field_headerField.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.HeaderField");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.HeaderField");
}

boolean HeaderField_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean HeaderField_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SecPayloadType::SecPayloadType()
{
enum_value = UNBOUND_VALUE;
}

SecPayloadType::SecPayloadType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

SecPayloadType::SecPayloadType(enum_type other_value)
{
enum_value = other_value;
}

SecPayloadType::SecPayloadType(const SecPayloadType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
enum_value = other_value.enum_value;
}

SecPayloadType& SecPayloadType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

SecPayloadType& SecPayloadType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

SecPayloadType& SecPayloadType::operator=(const SecPayloadType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
enum_value = other_value.enum_value;
return *this;
}

boolean SecPayloadType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
return enum_value == other_value;
}

boolean SecPayloadType::operator==(const SecPayloadType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
return enum_value == other_value.enum_value;
}

boolean SecPayloadType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
return enum_value < other_value;
}

boolean SecPayloadType::operator<(const SecPayloadType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
return enum_value < other_value.enum_value;
}

boolean SecPayloadType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
return enum_value > other_value;
}

boolean SecPayloadType::operator>(const SecPayloadType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
return enum_value > other_value.enum_value;
}

const char *SecPayloadType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__unsecured: return "e_unsecured";
case e__signed: return "e_signed";
case e__encrypted: return "e_encrypted";
case e__signed__external: return "e_signed_external";
case e__signed__and__encrypted: return "e_signed_and_encrypted";
default: return "<unknown>";
}
}

SecPayloadType::enum_type SecPayloadType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_unsecured")) return e__unsecured;
else if (!strcmp(str_par, "e_signed")) return e__signed;
else if (!strcmp(str_par, "e_encrypted")) return e__encrypted;
else if (!strcmp(str_par, "e_signed_external")) return e__signed__external;
else if (!strcmp(str_par, "e_signed_and_encrypted")) return e__signed__and__encrypted;
else return UNKNOWN_VALUE;
}

boolean SecPayloadType::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
return TRUE;
default:
return FALSE;
}
}

int SecPayloadType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int SecPayloadType::enum2int(const SecPayloadType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void SecPayloadType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.", int_val);
enum_value = (enum_type)int_val;
}

SecPayloadType::operator SecPayloadType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
return enum_value;
}

void SecPayloadType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void SecPayloadType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsSecurity_TypesAndValues.SecPayloadType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.SecPayloadType.");
  }
}

Module_Param* SecPayloadType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void SecPayloadType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
text_buf.push_int(enum_value);
}

void SecPayloadType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.", enum_value);
}

void SecPayloadType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SecPayloadType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SecPayloadType::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 3, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int SecPayloadType::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 3);
}

int SecPayloadType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int SecPayloadType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void SecPayloadType_template::copy_template(const SecPayloadType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SecPayloadType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
}
}

SecPayloadType_template::SecPayloadType_template()
{
}

SecPayloadType_template::SecPayloadType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SecPayloadType_template::SecPayloadType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!SecPayloadType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType with unknown numeric value %d.", other_value);
single_value = (SecPayloadType::enum_type)other_value;
}

SecPayloadType_template::SecPayloadType_template(SecPayloadType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

SecPayloadType_template::SecPayloadType_template(const SecPayloadType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == SecPayloadType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
single_value = other_value.enum_value;
}

SecPayloadType_template::SecPayloadType_template(const OPTIONAL<SecPayloadType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SecPayloadType::enum_type)(const SecPayloadType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType from an unbound optional field.");
}
}

SecPayloadType_template::SecPayloadType_template(const SecPayloadType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

SecPayloadType_template::~SecPayloadType_template()
{
clean_up();
}

boolean SecPayloadType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean SecPayloadType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != SecPayloadType::UNBOUND_VALUE;
}

void SecPayloadType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

SecPayloadType_template& SecPayloadType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SecPayloadType_template& SecPayloadType_template::operator=(int other_value)
{
if (!SecPayloadType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (SecPayloadType::enum_type)other_value;
return *this;
}

SecPayloadType_template& SecPayloadType_template::operator=(SecPayloadType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

SecPayloadType_template& SecPayloadType_template::operator=(const SecPayloadType& other_value)
{
if (other_value.enum_value == SecPayloadType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

SecPayloadType_template& SecPayloadType_template::operator=(const OPTIONAL<SecPayloadType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (SecPayloadType::enum_type)(const SecPayloadType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
}
return *this;
}

SecPayloadType_template& SecPayloadType_template::operator=(const SecPayloadType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SecPayloadType_template::match(SecPayloadType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
}
return FALSE;
}

boolean SecPayloadType_template::match(const SecPayloadType& other_value, boolean) const
{
if (other_value.enum_value == SecPayloadType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType with an unbound value.");
return match(other_value.enum_value);
}

SecPayloadType::enum_type SecPayloadType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
return single_value;
}

void SecPayloadType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SecPayloadType_template[list_length];
}

SecPayloadType_template& SecPayloadType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
return value_list.list_value[list_index];
}

void SecPayloadType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(SecPayloadType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SecPayloadType_template::log_match(const SecPayloadType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void SecPayloadType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
}
}

void SecPayloadType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (SecPayloadType::enum_type)text_buf.pull_int().get_val();
if (!SecPayloadType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SecPayloadType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsSecurity_TypesAndValues.SecPayloadType.");
}
}

boolean SecPayloadType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SecPayloadType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void SecPayloadType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    SecPayloadType::enum_type enum_val = (enum_name != NULL) ? SecPayloadType::str_to_enum(enum_name) : SecPayloadType::UNKNOWN_VALUE;
    if (SecPayloadType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SecPayloadType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    SecPayloadType::enum_type enum_val = SecPayloadType::str_to_enum(mp->get_enumerated());
    if (!SecPayloadType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.SecPayloadType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsSecurity_TypesAndValues.SecPayloadType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SecPayloadType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(SecPayloadType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SecPayloadType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.SecPayloadType");
}

SecPayload::SecPayload()
{
  bound_flag = FALSE;
}

SecPayload::SecPayload(const SecPayloadType& par_type__,
    const OPTIONAL<OCTETSTRING>& par_data)
  :   field_type__(par_type__),
  field_data(par_data)
{
  bound_flag = TRUE;
}

SecPayload::SecPayload(const SecPayload& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.SecPayload.");
bound_flag = TRUE;
if (other_value.type__().is_bound()) field_type__ = other_value.type__();
else field_type__.clean_up();
if (other_value.data().is_bound()) field_data = other_value.data();
else field_data.clean_up();
}

void SecPayload::clean_up()
{
field_type__.clean_up();
field_data.clean_up();
bound_flag = FALSE;
}

SecPayload& SecPayload::operator=(const SecPayload& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.SecPayload.");
  bound_flag = TRUE;
  if (other_value.type__().is_bound()) field_type__ = other_value.type__();
  else field_type__.clean_up();
  if (other_value.data().is_bound()) field_data = other_value.data();
  else field_data.clean_up();
}
return *this;
}

boolean SecPayload::operator==(const SecPayload& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_type__==other_value.field_type__
  && field_data==other_value.field_data;
}

boolean SecPayload::is_bound() const
{
if (bound_flag) return TRUE;
if(field_type__.is_bound()) return TRUE;
if(OPTIONAL_OMIT == field_data.get_selection() || field_data.is_bound()) return TRUE;
return FALSE;
}
boolean SecPayload::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_type__.is_value()) return FALSE;
if(OPTIONAL_OMIT != field_data.get_selection() && !field_data.is_value()) return FALSE;
return TRUE;
}
int SecPayload::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.SecPayload");
  int ret_val = 1;
  if (field_data.ispresent()) ret_val++;
  return ret_val;
}

void SecPayload::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ type_ := ");
field_type__.log();
TTCN_Logger::log_event_str(", data := ");
field_data.log();
TTCN_Logger::log_event_str(" }");
}

void SecPayload::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.SecPayload'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SecPayload'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.SecPayload has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.SecPayload: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.SecPayload");
  }
}

Module_Param* SecPayload::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.SecPayload'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("data", param_field) == 0) {
      return data().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SecPayload'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_type__ = field_type__.get_param(param_name);
  mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
  mp->add_elem(mp_field_type__);
  Module_Param* mp_field_data = field_data.get_param(param_name);
  mp_field_data->set_id(new Module_Param_FieldName(mcopystr("data")));
  mp->add_elem(mp_field_data);
  return mp;
  }

void SecPayload::set_implicit_omit()
{
if (type__().is_bound()) type__().set_implicit_omit();
if (!data().is_bound()) data() = OMIT_VALUE;
else data().set_implicit_omit();
}

void SecPayload::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.SecPayload.");
field_type__.encode_text(text_buf);
field_data.encode_text(text_buf);
}

void SecPayload::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_type__.decode_text(text_buf);
field_data.decode_text(text_buf);
}

void SecPayload::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SecPayload::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SecPayload::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_type__.RAW_decode(SecPayloadType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  if (limit > 0){
  size_t fl_start_pos = p_buf.get_pos_bit();
  decoded_field_length = field_data().RAW_decode(OCTETSTRING_descr_, p_buf, limit, local_top_order, TRUE);
  if (decoded_field_length < 1) {
  field_data = OMIT_VALUE;
  p_buf.set_pos_bit(fl_start_pos);
  } else {
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  }
  }
  else field_data=OMIT_VALUE;
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int SecPayload::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, SecPayloadType_descr_.raw);
  if (field_data.ispresent()) {
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, OCTETSTRING_descr_.raw);
  }
  else myleaf.body.node.nodes[1] = NULL;
  encoded_length += field_type__.RAW_encode(SecPayloadType_descr_, *myleaf.body.node.nodes[0]);
  if (field_data.ispresent()) {
  encoded_length += field_data().RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[1]);
  }
  return myleaf.length = encoded_length;
}

int SecPayload::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.SecPayload.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "type_");
    enc_len += field_type__.JSON_encode(SecPayloadType_descr_, p_tok);
  }

  if (field_data.is_present())
  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "data");
    enc_len += field_data.JSON_encode(OCTETSTRING_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SecPayload::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (5 == name_len && 0 == strncmp(fld_name, "type_", name_len)) {
         int ret_val = field_type__.JSON_decode(SecPayloadType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "type_");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (4 == name_len && 0 == strncmp(fld_name, "data", name_len)) {
         int ret_val = field_data.JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "data");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_type__.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "type_");
    return JSON_ERROR_FATAL;
  }
if (!field_data.is_bound()) {
    field_data = OMIT_VALUE;
  }

  return dec_len;
}

struct SecPayload_template::single_value_struct {
SecPayloadType_template field_type__;
OCTETSTRING_template field_data;
};

void SecPayload_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_type__ = ANY_VALUE;
single_value->field_data = ANY_OR_OMIT;
}
}
}

void SecPayload_template::copy_value(const SecPayload& other_value)
{
single_value = new single_value_struct;
if (other_value.type__().is_bound()) {
  single_value->field_type__ = other_value.type__();
} else {
  single_value->field_type__.clean_up();
}
if (other_value.data().is_bound()) {
  if (other_value.data().ispresent()) single_value->field_data = other_value.data()();
  else single_value->field_data = OMIT_VALUE;
} else {
  single_value->field_data.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SecPayload_template::copy_template(const SecPayload_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.type__().get_selection()) {
single_value->field_type__ = other_value.type__();
} else {
single_value->field_type__.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.data().get_selection()) {
single_value->field_data = other_value.data();
} else {
single_value->field_data.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SecPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SecPayload.");
break;
}
set_selection(other_value);
}

SecPayload_template::SecPayload_template()
{
}

SecPayload_template::SecPayload_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SecPayload_template::SecPayload_template(const SecPayload& other_value)
{
copy_value(other_value);
}

SecPayload_template::SecPayload_template(const OPTIONAL<SecPayload>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SecPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.SecPayload from an unbound optional field.");
}
}

SecPayload_template::SecPayload_template(const SecPayload_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SecPayload_template::~SecPayload_template()
{
clean_up();
}

SecPayload_template& SecPayload_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SecPayload_template& SecPayload_template::operator=(const SecPayload& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SecPayload_template& SecPayload_template::operator=(const OPTIONAL<SecPayload>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SecPayload&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.SecPayload.");
}
return *this;
}

SecPayload_template& SecPayload_template::operator=(const SecPayload_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SecPayload_template::match(const SecPayload& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.type__().is_bound()) return FALSE;
if(!single_value->field_type__.match(other_value.type__(), legacy))return FALSE;
if(!other_value.data().is_bound()) return FALSE;
if((other_value.data().ispresent() ? !single_value->field_data.match((const OCTETSTRING&)other_value.data(), legacy) : !single_value->field_data.match_omit(legacy)))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SecPayload.");
}
return FALSE;
}

boolean SecPayload_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_type__.is_bound()) return TRUE;
if (single_value->field_data.is_omit() || single_value->field_data.is_bound()) return TRUE;
return FALSE;
}

boolean SecPayload_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_type__.is_value()) return FALSE;
if (!single_value->field_data.is_omit() && !single_value->field_data.is_value()) return FALSE;
return TRUE;
}

void SecPayload_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SecPayload SecPayload_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.SecPayload.");
SecPayload ret_val;
if (single_value->field_type__.is_bound()) {
ret_val.type__() = single_value->field_type__.valueof();
}
if (single_value->field_data.is_omit()) ret_val.data() = OMIT_VALUE;
else if (single_value->field_data.is_bound()) {
ret_val.data() = single_value->field_data.valueof();
}
return ret_val;
}

void SecPayload_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.SecPayload.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SecPayload_template[list_length];
}

SecPayload_template& SecPayload_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.SecPayload.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.SecPayload.");
return value_list.list_value[list_index];
}

SecPayloadType_template& SecPayload_template::type__()
{
set_specific();
return single_value->field_type__;
}

const SecPayloadType_template& SecPayload_template::type__() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field type_ of a non-specific template of type @LibItsSecurity_TypesAndValues.SecPayload.");
return single_value->field_type__;
}

OCTETSTRING_template& SecPayload_template::data()
{
set_specific();
return single_value->field_data;
}

const OCTETSTRING_template& SecPayload_template::data() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field data of a non-specific template of type @LibItsSecurity_TypesAndValues.SecPayload.");
return single_value->field_data;
}

int SecPayload_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SecPayload which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
  {    int ret_val = 1;
      if (single_value->field_data.is_present()) ret_val++;
      return ret_val;
    }
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SecPayload containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SecPayload containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SecPayload containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SecPayload containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SecPayload containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SecPayload.");
  }
  return 0;
}

void SecPayload_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log();
TTCN_Logger::log_event_str(", data := ");
single_value->field_data.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SecPayload_template::log_match(const SecPayload& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_type__.match(match_value.type__(), legacy)){
TTCN_Logger::log_logmatch_info(".type_");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if (match_value.data().ispresent()){
if(!single_value->field_data.match(match_value.data(), legacy)){
TTCN_Logger::log_logmatch_info(".data");
single_value->field_data.log_match(match_value.data(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
} else {
if (!single_value->field_data.match_omit(legacy)){
 TTCN_Logger::log_logmatch_info(".data := omit with ");
TTCN_Logger::print_logmatch_buffer();
single_value->field_data.log();
TTCN_Logger::log_event_str(" unmatched");
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::log_event_str(", data := ");
if (match_value.data().ispresent()) single_value->field_data.log_match(match_value.data(), legacy);
else {
TTCN_Logger::log_event_str("omit with ");
single_value->field_data.log();
if (single_value->field_data.match_omit(legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SecPayload_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_type__.encode_text(text_buf);
single_value->field_data.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SecPayload.");
}
}

void SecPayload_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_type__.decode_text(text_buf);
single_value->field_data.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SecPayload_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.SecPayload.");
}
}

void SecPayload_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.SecPayload'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("data", param_field) == 0) {
      data().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.SecPayload'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SecPayload_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.SecPayload has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) data().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "data")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          data().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.SecPayload: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.SecPayload");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SecPayload_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.SecPayload'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("data", param_field) == 0) {
      return data().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SecPayload'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_type__ = single_value->field_type__.get_param(param_name);
    mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
    mp->add_elem(mp_field_type__);
    Module_Param* mp_field_data = single_value->field_data.get_param(param_name);
    mp_field_data->set_id(new Module_Param_FieldName(mcopystr("data")));
    mp->add_elem(mp_field_data);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SecPayload_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_type__.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SecPayload");
single_value->field_data.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SecPayload");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.SecPayload");
}

boolean SecPayload_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SecPayload_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

TrailerFieldType::TrailerFieldType()
{
enum_value = UNBOUND_VALUE;
}

TrailerFieldType::TrailerFieldType(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

TrailerFieldType::TrailerFieldType(enum_type other_value)
{
enum_value = other_value;
}

TrailerFieldType::TrailerFieldType(const TrailerFieldType& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
enum_value = other_value.enum_value;
}

TrailerFieldType& TrailerFieldType::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

TrailerFieldType& TrailerFieldType::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

TrailerFieldType& TrailerFieldType::operator=(const TrailerFieldType& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
enum_value = other_value.enum_value;
return *this;
}

boolean TrailerFieldType::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
return enum_value == other_value;
}

boolean TrailerFieldType::operator==(const TrailerFieldType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
return enum_value == other_value.enum_value;
}

boolean TrailerFieldType::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
return enum_value < other_value;
}

boolean TrailerFieldType::operator<(const TrailerFieldType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
return enum_value < other_value.enum_value;
}

boolean TrailerFieldType::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
return enum_value > other_value;
}

boolean TrailerFieldType::operator>(const TrailerFieldType& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
return enum_value > other_value.enum_value;
}

const char *TrailerFieldType::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case e__signature: return "e_signature";
default: return "<unknown>";
}
}

TrailerFieldType::enum_type TrailerFieldType::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "e_signature")) return e__signature;
else return UNKNOWN_VALUE;
}

boolean TrailerFieldType::is_valid_enum(int int_par)
{
switch (int_par) {
case 1:
return TRUE;
default:
return FALSE;
}
}

int TrailerFieldType::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int TrailerFieldType::enum2int(const TrailerFieldType& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void TrailerFieldType::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.", int_val);
enum_value = (enum_type)int_val;
}

TrailerFieldType::operator TrailerFieldType::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
return enum_value;
}

void TrailerFieldType::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void TrailerFieldType::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    enum_value = (enum_name != NULL) ? str_to_enum(enum_name) : UNKNOWN_VALUE;
    if (is_valid_enum(enum_value)) {
      return;
    }
    mp = param.get_referenced_param();
  }
  if (mp->get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@LibItsSecurity_TypesAndValues.TrailerFieldType");
  enum_value = str_to_enum(mp->get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
  }
}

Module_Param* TrailerFieldType::get_param(Module_Param_Name& /* param_name */) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  return new Module_Param_Enumerated(mcopystr(enum_to_str(enum_value)));
}

void TrailerFieldType::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
text_buf.push_int(enum_value);
}

void TrailerFieldType::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.", enum_value);
}

void TrailerFieldType::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void TrailerFieldType::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int TrailerFieldType::RAW_decode(const TTCN_Typedescriptor_t& p_td,TTCN_Buffer& p_buf,int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{
  int decoded_value = 0;
  int decoded_length = RAW_decode_enum_type(p_td, p_buf, limit, top_bit_ord, decoded_value, 1, no_err);
  if (decoded_length < 0) return decoded_length;
  if (is_valid_enum(decoded_value)) enum_value = (enum_type)decoded_value;
  else {
    if(no_err){
     return -1;
    } else {
    TTCN_EncDec_ErrorContext::error
      (TTCN_EncDec::ET_ENC_ENUM, "Invalid enum value '%d' for '%s': ",decoded_value, p_td.name);
    enum_value = UNKNOWN_VALUE;
    }
  }
  return decoded_length;
}

int TrailerFieldType::RAW_encode(const TTCN_Typedescriptor_t& p_td, RAW_enc_tree& myleaf) const
{
  return RAW_encode_enum_type(p_td, myleaf, (int)enum_value, 1);
}

int TrailerFieldType::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (enum_value == UNBOUND_VALUE) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
    return -1;
  }

  char* tmp_str = mprintf("\"%s\"", enum_to_str(enum_value));
  int enc_len = p_tok.put_next_token(JSON_TOKEN_STRING, tmp_str);
  Free(tmp_str);
  return enc_len;
}

int TrailerFieldType::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  char* value = 0;
  size_t value_len = 0;
  boolean error = false;
  int dec_len = 0;
  boolean use_default = p_td.json->default_value && 0 == p_tok.get_buffer_length();
  if (use_default) {
    value = (char*)p_td.json->default_value;
    value_len = strlen(value);
  } else {
    dec_len = p_tok.get_next_token(&token, &value, &value_len);
  }
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_STRING == token || use_default) {
    if (use_default || (value_len > 2 && value[0] == '\"' && value[value_len - 1] == '\"')) {
      if (!use_default) value[value_len - 1] = 0;
      enum_value = str_to_enum(value + (use_default ? 0 : 1));
      if (!use_default) value[value_len - 1] = '\"';
      if (UNKNOWN_VALUE == enum_value) {
        error = true;
      }
    } else {
      error = true;
    }
  } else {
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_INVALID_TOKEN;
  }

  if (error) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FORMAT_ERROR, "string", "enumerated");
    enum_value = UNBOUND_VALUE;
    return JSON_ERROR_FATAL;
  }
  return dec_len;
}

void TrailerFieldType_template::copy_template(const TrailerFieldType_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TrailerFieldType_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
}
}

TrailerFieldType_template::TrailerFieldType_template()
{
}

TrailerFieldType_template::TrailerFieldType_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

TrailerFieldType_template::TrailerFieldType_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!TrailerFieldType::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType with unknown numeric value %d.", other_value);
single_value = (TrailerFieldType::enum_type)other_value;
}

TrailerFieldType_template::TrailerFieldType_template(TrailerFieldType::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

TrailerFieldType_template::TrailerFieldType_template(const TrailerFieldType& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == TrailerFieldType::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
single_value = other_value.enum_value;
}

TrailerFieldType_template::TrailerFieldType_template(const OPTIONAL<TrailerFieldType>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (TrailerFieldType::enum_type)(const TrailerFieldType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType from an unbound optional field.");
}
}

TrailerFieldType_template::TrailerFieldType_template(const TrailerFieldType_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

TrailerFieldType_template::~TrailerFieldType_template()
{
clean_up();
}

boolean TrailerFieldType_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean TrailerFieldType_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != TrailerFieldType::UNBOUND_VALUE;
}

void TrailerFieldType_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

TrailerFieldType_template& TrailerFieldType_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TrailerFieldType_template& TrailerFieldType_template::operator=(int other_value)
{
if (!TrailerFieldType::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (TrailerFieldType::enum_type)other_value;
return *this;
}

TrailerFieldType_template& TrailerFieldType_template::operator=(TrailerFieldType::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

TrailerFieldType_template& TrailerFieldType_template::operator=(const TrailerFieldType& other_value)
{
if (other_value.enum_value == TrailerFieldType::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

TrailerFieldType_template& TrailerFieldType_template::operator=(const OPTIONAL<TrailerFieldType>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (TrailerFieldType::enum_type)(const TrailerFieldType&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
}
return *this;
}

TrailerFieldType_template& TrailerFieldType_template::operator=(const TrailerFieldType_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean TrailerFieldType_template::match(TrailerFieldType::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
}
return FALSE;
}

boolean TrailerFieldType_template::match(const TrailerFieldType& other_value, boolean) const
{
if (other_value.enum_value == TrailerFieldType::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType with an unbound value.");
return match(other_value.enum_value);
}

TrailerFieldType::enum_type TrailerFieldType_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
return single_value;
}

void TrailerFieldType_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new TrailerFieldType_template[list_length];
}

TrailerFieldType_template& TrailerFieldType_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
return value_list.list_value[list_index];
}

void TrailerFieldType_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(TrailerFieldType::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void TrailerFieldType_template::log_match(const TrailerFieldType& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void TrailerFieldType_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
}
}

void TrailerFieldType_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (TrailerFieldType::enum_type)text_buf.pull_int().get_val();
if (!TrailerFieldType::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TrailerFieldType_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
}
}

boolean TrailerFieldType_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TrailerFieldType_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void TrailerFieldType_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    char* enum_name = param.get_enumerated();
    TrailerFieldType::enum_type enum_val = (enum_name != NULL) ? TrailerFieldType::str_to_enum(enum_name) : TrailerFieldType::UNKNOWN_VALUE;
    if (TrailerFieldType::is_valid_enum(enum_val)) {
      *this = enum_val;
      is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
      return;
    }
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TrailerFieldType_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Enumerated: {
    TrailerFieldType::enum_type enum_val = TrailerFieldType::str_to_enum(mp->get_enumerated());
    if (!TrailerFieldType::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @LibItsSecurity_TypesAndValues.TrailerFieldType.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@LibItsSecurity_TypesAndValues.TrailerFieldType");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* TrailerFieldType_template::get_param(Module_Param_Name& param_name) const
{
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE:
    mp = new Module_Param_Enumerated(mcopystr(TrailerFieldType::enum_to_str(single_value)));
    break;
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void TrailerFieldType_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.TrailerFieldType");
}

ToBeSignedSecuredMessage::ToBeSignedSecuredMessage()
{
  bound_flag = FALSE;
}

ToBeSignedSecuredMessage::ToBeSignedSecuredMessage(const INTEGER& par_protocol__version,
    const HeaderFields& par_header__fields,
    const SecPayload& par_payload__field,
    const INTEGER& par_trailer__fieldsLength,
    const TrailerFieldType& par_trailerFieldType)
  :   field_protocol__version(par_protocol__version),
  field_header__fields(par_header__fields),
  field_payload__field(par_payload__field),
  field_trailer__fieldsLength(par_trailer__fieldsLength),
  field_trailerFieldType(par_trailerFieldType)
{
  bound_flag = TRUE;
}

ToBeSignedSecuredMessage::ToBeSignedSecuredMessage(const ToBeSignedSecuredMessage& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
bound_flag = TRUE;
if (other_value.protocol__version().is_bound()) field_protocol__version = other_value.protocol__version();
else field_protocol__version.clean_up();
if (other_value.header__fields().is_bound()) field_header__fields = other_value.header__fields();
else field_header__fields.clean_up();
if (other_value.payload__field().is_bound()) field_payload__field = other_value.payload__field();
else field_payload__field.clean_up();
if (other_value.trailer__fieldsLength().is_bound()) field_trailer__fieldsLength = other_value.trailer__fieldsLength();
else field_trailer__fieldsLength.clean_up();
if (other_value.trailerFieldType().is_bound()) field_trailerFieldType = other_value.trailerFieldType();
else field_trailerFieldType.clean_up();
}

void ToBeSignedSecuredMessage::clean_up()
{
field_protocol__version.clean_up();
field_header__fields.clean_up();
field_payload__field.clean_up();
field_trailer__fieldsLength.clean_up();
field_trailerFieldType.clean_up();
bound_flag = FALSE;
}

ToBeSignedSecuredMessage& ToBeSignedSecuredMessage::operator=(const ToBeSignedSecuredMessage& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
  bound_flag = TRUE;
  if (other_value.protocol__version().is_bound()) field_protocol__version = other_value.protocol__version();
  else field_protocol__version.clean_up();
  if (other_value.header__fields().is_bound()) field_header__fields = other_value.header__fields();
  else field_header__fields.clean_up();
  if (other_value.payload__field().is_bound()) field_payload__field = other_value.payload__field();
  else field_payload__field.clean_up();
  if (other_value.trailer__fieldsLength().is_bound()) field_trailer__fieldsLength = other_value.trailer__fieldsLength();
  else field_trailer__fieldsLength.clean_up();
  if (other_value.trailerFieldType().is_bound()) field_trailerFieldType = other_value.trailerFieldType();
  else field_trailerFieldType.clean_up();
}
return *this;
}

boolean ToBeSignedSecuredMessage::operator==(const ToBeSignedSecuredMessage& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_protocol__version==other_value.field_protocol__version
  && field_header__fields==other_value.field_header__fields
  && field_payload__field==other_value.field_payload__field
  && field_trailer__fieldsLength==other_value.field_trailer__fieldsLength
  && field_trailerFieldType==other_value.field_trailerFieldType;
}

boolean ToBeSignedSecuredMessage::is_bound() const
{
if (bound_flag) return TRUE;
if(field_protocol__version.is_bound()) return TRUE;
if(field_header__fields.is_bound()) return TRUE;
if(field_payload__field.is_bound()) return TRUE;
if(field_trailer__fieldsLength.is_bound()) return TRUE;
if(field_trailerFieldType.is_bound()) return TRUE;
return FALSE;
}
boolean ToBeSignedSecuredMessage::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_protocol__version.is_value()) return FALSE;
if(!field_header__fields.is_value()) return FALSE;
if(!field_payload__field.is_value()) return FALSE;
if(!field_trailer__fieldsLength.is_value()) return FALSE;
if(!field_trailerFieldType.is_value()) return FALSE;
return TRUE;
}
int ToBeSignedSecuredMessage::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage");
  return 5;
}

void ToBeSignedSecuredMessage::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ protocol_version := ");
field_protocol__version.log();
TTCN_Logger::log_event_str(", header_fields := ");
field_header__fields.log();
TTCN_Logger::log_event_str(", payload_field := ");
field_payload__field.log();
TTCN_Logger::log_event_str(", trailer_fieldsLength := ");
field_trailer__fieldsLength.log();
TTCN_Logger::log_event_str(", trailerFieldType := ");
field_trailerFieldType.log();
TTCN_Logger::log_event_str(" }");
}

void ToBeSignedSecuredMessage::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage'");
    }
    if (strcmp("protocol_version", param_field) == 0) {
      protocol__version().set_param(param);
      return;
    } else if (strcmp("header_fields", param_field) == 0) {
      header__fields().set_param(param);
      return;
    } else if (strcmp("payload_field", param_field) == 0) {
      payload__field().set_param(param);
      return;
    } else if (strcmp("trailer_fieldsLength", param_field) == 0) {
      trailer__fieldsLength().set_param(param);
      return;
    } else if (strcmp("trailerFieldType", param_field) == 0) {
      trailerFieldType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) protocol__version().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) header__fields().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload__field().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) trailer__fieldsLength().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) trailerFieldType().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protocol_version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protocol__version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header_fields")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header__fields().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload_field")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload__field().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trailer_fieldsLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trailer__fieldsLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trailerFieldType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trailerFieldType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage");
  }
}

Module_Param* ToBeSignedSecuredMessage::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage'");
    }
    if (strcmp("protocol_version", param_field) == 0) {
      return protocol__version().get_param(param_name);
    } else if (strcmp("header_fields", param_field) == 0) {
      return header__fields().get_param(param_name);
    } else if (strcmp("payload_field", param_field) == 0) {
      return payload__field().get_param(param_name);
    } else if (strcmp("trailer_fieldsLength", param_field) == 0) {
      return trailer__fieldsLength().get_param(param_name);
    } else if (strcmp("trailerFieldType", param_field) == 0) {
      return trailerFieldType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_protocol__version = field_protocol__version.get_param(param_name);
  mp_field_protocol__version->set_id(new Module_Param_FieldName(mcopystr("protocol_version")));
  mp->add_elem(mp_field_protocol__version);
  Module_Param* mp_field_header__fields = field_header__fields.get_param(param_name);
  mp_field_header__fields->set_id(new Module_Param_FieldName(mcopystr("header_fields")));
  mp->add_elem(mp_field_header__fields);
  Module_Param* mp_field_payload__field = field_payload__field.get_param(param_name);
  mp_field_payload__field->set_id(new Module_Param_FieldName(mcopystr("payload_field")));
  mp->add_elem(mp_field_payload__field);
  Module_Param* mp_field_trailer__fieldsLength = field_trailer__fieldsLength.get_param(param_name);
  mp_field_trailer__fieldsLength->set_id(new Module_Param_FieldName(mcopystr("trailer_fieldsLength")));
  mp->add_elem(mp_field_trailer__fieldsLength);
  Module_Param* mp_field_trailerFieldType = field_trailerFieldType.get_param(param_name);
  mp_field_trailerFieldType->set_id(new Module_Param_FieldName(mcopystr("trailerFieldType")));
  mp->add_elem(mp_field_trailerFieldType);
  return mp;
  }

void ToBeSignedSecuredMessage::set_implicit_omit()
{
if (protocol__version().is_bound()) protocol__version().set_implicit_omit();
if (header__fields().is_bound()) header__fields().set_implicit_omit();
if (payload__field().is_bound()) payload__field().set_implicit_omit();
if (trailer__fieldsLength().is_bound()) trailer__fieldsLength().set_implicit_omit();
if (trailerFieldType().is_bound()) trailerFieldType().set_implicit_omit();
}

void ToBeSignedSecuredMessage::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
field_protocol__version.encode_text(text_buf);
field_header__fields.encode_text(text_buf);
field_payload__field.encode_text(text_buf);
field_trailer__fieldsLength.encode_text(text_buf);
field_trailerFieldType.encode_text(text_buf);
}

void ToBeSignedSecuredMessage::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_protocol__version.decode_text(text_buf);
field_header__fields.decode_text(text_buf);
field_payload__field.decode_text(text_buf);
field_trailer__fieldsLength.decode_text(text_buf);
field_trailerFieldType.decode_text(text_buf);
}

void ToBeSignedSecuredMessage::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ToBeSignedSecuredMessage::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ToBeSignedSecuredMessage::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_protocol__version.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_header__fields.RAW_decode(HeaderFields_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_payload__field.RAW_decode(SecPayload_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_trailer__fieldsLength.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_trailerFieldType.RAW_decode(TrailerFieldType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ToBeSignedSecuredMessage::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 5;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(5);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, HeaderFields_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, SecPayload_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, TrailerFieldType_descr_.raw);
  encoded_length += field_protocol__version.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_header__fields.RAW_encode(HeaderFields_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_payload__field.RAW_encode(SecPayload_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_trailer__fieldsLength.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_trailerFieldType.RAW_encode(TrailerFieldType_descr_, *myleaf.body.node.nodes[4]);
  return myleaf.length = encoded_length;
}

int ToBeSignedSecuredMessage::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "protocol_version");
    enc_len += field_protocol__version.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "header_fields");
    enc_len += field_header__fields.JSON_encode(HeaderFields_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payload_field");
    enc_len += field_payload__field.JSON_encode(SecPayload_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "trailer_fieldsLength");
    enc_len += field_trailer__fieldsLength.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "trailerFieldType");
    enc_len += field_trailerFieldType.JSON_encode(TrailerFieldType_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ToBeSignedSecuredMessage::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (16 == name_len && 0 == strncmp(fld_name, "protocol_version", name_len)) {
         int ret_val = field_protocol__version.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "protocol_version");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "header_fields", name_len)) {
         int ret_val = field_header__fields.JSON_decode(HeaderFields_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "header_fields");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "payload_field", name_len)) {
         int ret_val = field_payload__field.JSON_decode(SecPayload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "payload_field");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (20 == name_len && 0 == strncmp(fld_name, "trailer_fieldsLength", name_len)) {
         int ret_val = field_trailer__fieldsLength.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "trailer_fieldsLength");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (16 == name_len && 0 == strncmp(fld_name, "trailerFieldType", name_len)) {
         int ret_val = field_trailerFieldType.JSON_decode(TrailerFieldType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "trailerFieldType");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_protocol__version.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "protocol_version");
    return JSON_ERROR_FATAL;
  }
if (!field_header__fields.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "header_fields");
    return JSON_ERROR_FATAL;
  }
if (!field_payload__field.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "payload_field");
    return JSON_ERROR_FATAL;
  }
if (!field_trailer__fieldsLength.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "trailer_fieldsLength");
    return JSON_ERROR_FATAL;
  }
if (!field_trailerFieldType.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "trailerFieldType");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ToBeSignedSecuredMessage_template::single_value_struct {
INTEGER_template field_protocol__version;
HeaderFields_template field_header__fields;
SecPayload_template field_payload__field;
INTEGER_template field_trailer__fieldsLength;
TrailerFieldType_template field_trailerFieldType;
};

void ToBeSignedSecuredMessage_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_protocol__version = ANY_VALUE;
single_value->field_header__fields = ANY_VALUE;
single_value->field_payload__field = ANY_VALUE;
single_value->field_trailer__fieldsLength = ANY_VALUE;
single_value->field_trailerFieldType = ANY_VALUE;
}
}
}

void ToBeSignedSecuredMessage_template::copy_value(const ToBeSignedSecuredMessage& other_value)
{
single_value = new single_value_struct;
if (other_value.protocol__version().is_bound()) {
  single_value->field_protocol__version = other_value.protocol__version();
} else {
  single_value->field_protocol__version.clean_up();
}
if (other_value.header__fields().is_bound()) {
  single_value->field_header__fields = other_value.header__fields();
} else {
  single_value->field_header__fields.clean_up();
}
if (other_value.payload__field().is_bound()) {
  single_value->field_payload__field = other_value.payload__field();
} else {
  single_value->field_payload__field.clean_up();
}
if (other_value.trailer__fieldsLength().is_bound()) {
  single_value->field_trailer__fieldsLength = other_value.trailer__fieldsLength();
} else {
  single_value->field_trailer__fieldsLength.clean_up();
}
if (other_value.trailerFieldType().is_bound()) {
  single_value->field_trailerFieldType = other_value.trailerFieldType();
} else {
  single_value->field_trailerFieldType.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ToBeSignedSecuredMessage_template::copy_template(const ToBeSignedSecuredMessage_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.protocol__version().get_selection()) {
single_value->field_protocol__version = other_value.protocol__version();
} else {
single_value->field_protocol__version.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.header__fields().get_selection()) {
single_value->field_header__fields = other_value.header__fields();
} else {
single_value->field_header__fields.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload__field().get_selection()) {
single_value->field_payload__field = other_value.payload__field();
} else {
single_value->field_payload__field.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trailer__fieldsLength().get_selection()) {
single_value->field_trailer__fieldsLength = other_value.trailer__fieldsLength();
} else {
single_value->field_trailer__fieldsLength.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trailerFieldType().get_selection()) {
single_value->field_trailerFieldType = other_value.trailerFieldType();
} else {
single_value->field_trailerFieldType.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ToBeSignedSecuredMessage_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
break;
}
set_selection(other_value);
}

ToBeSignedSecuredMessage_template::ToBeSignedSecuredMessage_template()
{
}

ToBeSignedSecuredMessage_template::ToBeSignedSecuredMessage_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ToBeSignedSecuredMessage_template::ToBeSignedSecuredMessage_template(const ToBeSignedSecuredMessage& other_value)
{
copy_value(other_value);
}

ToBeSignedSecuredMessage_template::ToBeSignedSecuredMessage_template(const OPTIONAL<ToBeSignedSecuredMessage>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ToBeSignedSecuredMessage&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage from an unbound optional field.");
}
}

ToBeSignedSecuredMessage_template::ToBeSignedSecuredMessage_template(const ToBeSignedSecuredMessage_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ToBeSignedSecuredMessage_template::~ToBeSignedSecuredMessage_template()
{
clean_up();
}

ToBeSignedSecuredMessage_template& ToBeSignedSecuredMessage_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ToBeSignedSecuredMessage_template& ToBeSignedSecuredMessage_template::operator=(const ToBeSignedSecuredMessage& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ToBeSignedSecuredMessage_template& ToBeSignedSecuredMessage_template::operator=(const OPTIONAL<ToBeSignedSecuredMessage>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ToBeSignedSecuredMessage&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
}
return *this;
}

ToBeSignedSecuredMessage_template& ToBeSignedSecuredMessage_template::operator=(const ToBeSignedSecuredMessage_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ToBeSignedSecuredMessage_template::match(const ToBeSignedSecuredMessage& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.protocol__version().is_bound()) return FALSE;
if(!single_value->field_protocol__version.match(other_value.protocol__version(), legacy))return FALSE;
if(!other_value.header__fields().is_bound()) return FALSE;
if(!single_value->field_header__fields.match(other_value.header__fields(), legacy))return FALSE;
if(!other_value.payload__field().is_bound()) return FALSE;
if(!single_value->field_payload__field.match(other_value.payload__field(), legacy))return FALSE;
if(!other_value.trailer__fieldsLength().is_bound()) return FALSE;
if(!single_value->field_trailer__fieldsLength.match(other_value.trailer__fieldsLength(), legacy))return FALSE;
if(!other_value.trailerFieldType().is_bound()) return FALSE;
if(!single_value->field_trailerFieldType.match(other_value.trailerFieldType(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
}
return FALSE;
}

boolean ToBeSignedSecuredMessage_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_protocol__version.is_bound()) return TRUE;
if (single_value->field_header__fields.is_bound()) return TRUE;
if (single_value->field_payload__field.is_bound()) return TRUE;
if (single_value->field_trailer__fieldsLength.is_bound()) return TRUE;
if (single_value->field_trailerFieldType.is_bound()) return TRUE;
return FALSE;
}

boolean ToBeSignedSecuredMessage_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_protocol__version.is_value()) return FALSE;
if (!single_value->field_header__fields.is_value()) return FALSE;
if (!single_value->field_payload__field.is_value()) return FALSE;
if (!single_value->field_trailer__fieldsLength.is_value()) return FALSE;
if (!single_value->field_trailerFieldType.is_value()) return FALSE;
return TRUE;
}

void ToBeSignedSecuredMessage_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ToBeSignedSecuredMessage ToBeSignedSecuredMessage_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
ToBeSignedSecuredMessage ret_val;
if (single_value->field_protocol__version.is_bound()) {
ret_val.protocol__version() = single_value->field_protocol__version.valueof();
}
if (single_value->field_header__fields.is_bound()) {
ret_val.header__fields() = single_value->field_header__fields.valueof();
}
if (single_value->field_payload__field.is_bound()) {
ret_val.payload__field() = single_value->field_payload__field.valueof();
}
if (single_value->field_trailer__fieldsLength.is_bound()) {
ret_val.trailer__fieldsLength() = single_value->field_trailer__fieldsLength.valueof();
}
if (single_value->field_trailerFieldType.is_bound()) {
ret_val.trailerFieldType() = single_value->field_trailerFieldType.valueof();
}
return ret_val;
}

void ToBeSignedSecuredMessage_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ToBeSignedSecuredMessage_template[list_length];
}

ToBeSignedSecuredMessage_template& ToBeSignedSecuredMessage_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
return value_list.list_value[list_index];
}

INTEGER_template& ToBeSignedSecuredMessage_template::protocol__version()
{
set_specific();
return single_value->field_protocol__version;
}

const INTEGER_template& ToBeSignedSecuredMessage_template::protocol__version() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field protocol_version of a non-specific template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
return single_value->field_protocol__version;
}

HeaderFields_template& ToBeSignedSecuredMessage_template::header__fields()
{
set_specific();
return single_value->field_header__fields;
}

const HeaderFields_template& ToBeSignedSecuredMessage_template::header__fields() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header_fields of a non-specific template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
return single_value->field_header__fields;
}

SecPayload_template& ToBeSignedSecuredMessage_template::payload__field()
{
set_specific();
return single_value->field_payload__field;
}

const SecPayload_template& ToBeSignedSecuredMessage_template::payload__field() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload_field of a non-specific template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
return single_value->field_payload__field;
}

INTEGER_template& ToBeSignedSecuredMessage_template::trailer__fieldsLength()
{
set_specific();
return single_value->field_trailer__fieldsLength;
}

const INTEGER_template& ToBeSignedSecuredMessage_template::trailer__fieldsLength() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trailer_fieldsLength of a non-specific template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
return single_value->field_trailer__fieldsLength;
}

TrailerFieldType_template& ToBeSignedSecuredMessage_template::trailerFieldType()
{
set_specific();
return single_value->field_trailerFieldType;
}

const TrailerFieldType_template& ToBeSignedSecuredMessage_template::trailerFieldType() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trailerFieldType of a non-specific template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
return single_value->field_trailerFieldType;
}

int ToBeSignedSecuredMessage_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 5;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
  }
  return 0;
}

void ToBeSignedSecuredMessage_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ protocol_version := ");
single_value->field_protocol__version.log();
TTCN_Logger::log_event_str(", header_fields := ");
single_value->field_header__fields.log();
TTCN_Logger::log_event_str(", payload_field := ");
single_value->field_payload__field.log();
TTCN_Logger::log_event_str(", trailer_fieldsLength := ");
single_value->field_trailer__fieldsLength.log();
TTCN_Logger::log_event_str(", trailerFieldType := ");
single_value->field_trailerFieldType.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ToBeSignedSecuredMessage_template::log_match(const ToBeSignedSecuredMessage& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_protocol__version.match(match_value.protocol__version(), legacy)){
TTCN_Logger::log_logmatch_info(".protocol_version");
single_value->field_protocol__version.log_match(match_value.protocol__version(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_header__fields.match(match_value.header__fields(), legacy)){
TTCN_Logger::log_logmatch_info(".header_fields");
single_value->field_header__fields.log_match(match_value.header__fields(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_payload__field.match(match_value.payload__field(), legacy)){
TTCN_Logger::log_logmatch_info(".payload_field");
single_value->field_payload__field.log_match(match_value.payload__field(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_trailer__fieldsLength.match(match_value.trailer__fieldsLength(), legacy)){
TTCN_Logger::log_logmatch_info(".trailer_fieldsLength");
single_value->field_trailer__fieldsLength.log_match(match_value.trailer__fieldsLength(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_trailerFieldType.match(match_value.trailerFieldType(), legacy)){
TTCN_Logger::log_logmatch_info(".trailerFieldType");
single_value->field_trailerFieldType.log_match(match_value.trailerFieldType(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ protocol_version := ");
single_value->field_protocol__version.log_match(match_value.protocol__version(), legacy);
TTCN_Logger::log_event_str(", header_fields := ");
single_value->field_header__fields.log_match(match_value.header__fields(), legacy);
TTCN_Logger::log_event_str(", payload_field := ");
single_value->field_payload__field.log_match(match_value.payload__field(), legacy);
TTCN_Logger::log_event_str(", trailer_fieldsLength := ");
single_value->field_trailer__fieldsLength.log_match(match_value.trailer__fieldsLength(), legacy);
TTCN_Logger::log_event_str(", trailerFieldType := ");
single_value->field_trailerFieldType.log_match(match_value.trailerFieldType(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ToBeSignedSecuredMessage_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_protocol__version.encode_text(text_buf);
single_value->field_header__fields.encode_text(text_buf);
single_value->field_payload__field.encode_text(text_buf);
single_value->field_trailer__fieldsLength.encode_text(text_buf);
single_value->field_trailerFieldType.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
}
}

void ToBeSignedSecuredMessage_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_protocol__version.decode_text(text_buf);
single_value->field_header__fields.decode_text(text_buf);
single_value->field_payload__field.decode_text(text_buf);
single_value->field_trailer__fieldsLength.decode_text(text_buf);
single_value->field_trailerFieldType.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ToBeSignedSecuredMessage_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage.");
}
}

void ToBeSignedSecuredMessage_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage'");
    }
    if (strcmp("protocol_version", param_field) == 0) {
      protocol__version().set_param(param);
      return;
    } else if (strcmp("header_fields", param_field) == 0) {
      header__fields().set_param(param);
      return;
    } else if (strcmp("payload_field", param_field) == 0) {
      payload__field().set_param(param);
      return;
    } else if (strcmp("trailer_fieldsLength", param_field) == 0) {
      trailer__fieldsLength().set_param(param);
      return;
    } else if (strcmp("trailerFieldType", param_field) == 0) {
      trailerFieldType().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ToBeSignedSecuredMessage_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) protocol__version().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) header__fields().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload__field().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) trailer__fieldsLength().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) trailerFieldType().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protocol_version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protocol__version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header_fields")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header__fields().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload_field")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload__field().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trailer_fieldsLength")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trailer__fieldsLength().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trailerFieldType")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trailerFieldType().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ToBeSignedSecuredMessage_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage'");
    }
    if (strcmp("protocol_version", param_field) == 0) {
      return protocol__version().get_param(param_name);
    } else if (strcmp("header_fields", param_field) == 0) {
      return header__fields().get_param(param_name);
    } else if (strcmp("payload_field", param_field) == 0) {
      return payload__field().get_param(param_name);
    } else if (strcmp("trailer_fieldsLength", param_field) == 0) {
      return trailer__fieldsLength().get_param(param_name);
    } else if (strcmp("trailerFieldType", param_field) == 0) {
      return trailerFieldType().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_protocol__version = single_value->field_protocol__version.get_param(param_name);
    mp_field_protocol__version->set_id(new Module_Param_FieldName(mcopystr("protocol_version")));
    mp->add_elem(mp_field_protocol__version);
    Module_Param* mp_field_header__fields = single_value->field_header__fields.get_param(param_name);
    mp_field_header__fields->set_id(new Module_Param_FieldName(mcopystr("header_fields")));
    mp->add_elem(mp_field_header__fields);
    Module_Param* mp_field_payload__field = single_value->field_payload__field.get_param(param_name);
    mp_field_payload__field->set_id(new Module_Param_FieldName(mcopystr("payload_field")));
    mp->add_elem(mp_field_payload__field);
    Module_Param* mp_field_trailer__fieldsLength = single_value->field_trailer__fieldsLength.get_param(param_name);
    mp_field_trailer__fieldsLength->set_id(new Module_Param_FieldName(mcopystr("trailer_fieldsLength")));
    mp->add_elem(mp_field_trailer__fieldsLength);
    Module_Param* mp_field_trailerFieldType = single_value->field_trailerFieldType.get_param(param_name);
    mp_field_trailerFieldType->set_id(new Module_Param_FieldName(mcopystr("trailerFieldType")));
    mp->add_elem(mp_field_trailerFieldType);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ToBeSignedSecuredMessage_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_protocol__version.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage");
single_value->field_header__fields.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage");
single_value->field_payload__field.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage");
single_value->field_trailer__fieldsLength.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage");
single_value->field_trailerFieldType.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.ToBeSignedSecuredMessage");
}

boolean ToBeSignedSecuredMessage_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ToBeSignedSecuredMessage_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const TrailerField TrailerFields::UNBOUND_ELEM;
boolean TrailerFields::compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index)
{
if (((const TrailerFields*)left_ptr)->val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
if (((const TrailerFields*)right_ptr)->val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
if (((const TrailerFields*)left_ptr)->val_ptr->value_elements[left_index] != NULL){
if (((const TrailerFields*)right_ptr)->val_ptr->value_elements[right_index] != NULL){
return *((const TrailerFields*)left_ptr)->val_ptr->value_elements[left_index] == *((const TrailerFields*)right_ptr)->val_ptr->value_elements[right_index];
} else return FALSE;
} else {
return ((const TrailerFields*)right_ptr)->val_ptr->value_elements[right_index] == NULL;
}
}

TrailerFields::TrailerFields()
{
val_ptr = NULL;
}

TrailerFields::TrailerFields(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

TrailerFields::TrailerFields(const TrailerFields& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

TrailerFields::~TrailerFields()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void TrailerFields::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

TrailerFields& TrailerFields::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

TrailerFields& TrailerFields::operator=(const TrailerFields& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean TrailerFields::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
return val_ptr->n_elements == 0 ;
}

boolean TrailerFields::operator==(const TrailerFields& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
if (val_ptr == other_value.val_ptr) return TRUE;
return compare_set_of(this, val_ptr->n_elements, &other_value, (other_value.val_ptr)->n_elements, compare_function);
}

TrailerField& TrailerFields::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.TrailerFields using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (TrailerField**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new TrailerField(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new TrailerField;
}
return *val_ptr->value_elements[index_value];
}

TrailerField& TrailerFields::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
return (*this)[(int)index_value];
}

const TrailerField& TrailerFields::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.TrailerFields using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsSecurity_TypesAndValues.TrailerFields: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const TrailerField& TrailerFields::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
return (*this)[(int)index_value];
}

TrailerFields TrailerFields::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

TrailerFields TrailerFields::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

TrailerFields TrailerFields::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

TrailerFields TrailerFields::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
TrailerFields ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new TrailerField(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

TrailerFields TrailerFields::operator+(const TrailerFields& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsSecurity_TypesAndValues.TrailerFields concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
TrailerFields ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new TrailerField(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new TrailerField(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

TrailerFields TrailerFields::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsSecurity_TypesAndValues.TrailerFields","element");
TrailerFields ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new TrailerField(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

TrailerFields TrailerFields::replace(int index, int len, const TrailerFields& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsSecurity_TypesAndValues.TrailerFields","element");
TrailerFields ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new TrailerField(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new TrailerField(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new TrailerField(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

TrailerFields TrailerFields::replace(int index, int len, const TrailerFields_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void TrailerFields::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (TrailerField**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new TrailerField(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (TrailerField**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsSecurity_TypesAndValues.TrailerFields: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (TrailerField**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean TrailerFields::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int TrailerFields::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
return val_ptr->n_elements;
}

int TrailerFields::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void TrailerFields::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void TrailerFields::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set of type `@LibItsSecurity_TypesAndValues.TrailerFields'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "set of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.TrailerFields");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.TrailerFields");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* TrailerFields::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of type `@LibItsSecurity_TypesAndValues.TrailerFields'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void TrailerFields::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void TrailerFields::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void TrailerFields::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
val_ptr->value_elements = (TrailerField**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new TrailerField;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void TrailerFields::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void TrailerFields::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int TrailerFields::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int TrailerFields::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

int TrailerFields::JSON_encode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_ARRAY_START, NULL);
  for(int i = 0; i < val_ptr->n_elements; ++i) {
    int ret_val = (*this)[i].JSON_encode(*p_td.oftype_descr, p_tok);
    if (0 > ret_val) break;
    enc_len += ret_val;
  }
  enc_len += p_tok.put_next_token(JSON_TOKEN_ARRAY_END, NULL);
  return enc_len;
}

int TrailerFields::JSON_decode(const TTCN_Typedescriptor_t& p_td, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ERROR == token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_ARRAY_START != token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  set_size(0);
  while (true) {
    size_t buf_pos = p_tok.get_buf_pos();
    TrailerField* val = new TrailerField;
    int ret_val = val->JSON_decode(*p_td.oftype_descr, p_tok, p_silent);
    if (JSON_ERROR_INVALID_TOKEN == ret_val) {
      p_tok.set_buf_pos(buf_pos);
      delete val;
      break;
    }
    else if (JSON_ERROR_FATAL == ret_val) {
      delete val;
      if (p_silent) {
        clean_up();
      }
      return JSON_ERROR_FATAL;
    }
    val_ptr->value_elements = (TrailerField**)reallocate_pointers(
      (void**)val_ptr->value_elements, val_ptr->n_elements, val_ptr->n_elements + 1);
    val_ptr->value_elements[val_ptr->n_elements] = val;
    val_ptr->n_elements++;
    dec_len += ret_val;
  }

  dec_len += p_tok.get_next_token(&token, NULL, NULL);
  if (JSON_TOKEN_ARRAY_END != token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_REC_OF_END_TOKEN_ERROR, "");
    if (p_silent) {
      clean_up();
    }
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void TrailerFields_template::copy_value(const TrailerFields& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsSecurity_TypesAndValues.TrailerFields with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (TrailerField_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new TrailerField_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new TrailerField_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void TrailerFields_template::copy_template(const TrailerFields_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (TrailerField_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new TrailerField_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new TrailerField_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TrailerFields_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = other_value.value_set.n_items;
value_set.set_items = new TrailerField_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count] = other_value.value_set.set_items[set_count];
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TrailerFields.");
break;
}
set_selection(other_value);
}

boolean TrailerFields_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const TrailerFields_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const TrailerFields*)value_ptr)[value_index], legacy);
else return ((const TrailerFields_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

boolean TrailerFields_template::match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const TrailerFields_template*)template_ptr)->value_set.set_items[template_index].match((*(const TrailerFields*)value_ptr)[value_index], legacy);
else return ((const TrailerFields_template*)template_ptr)->value_set.set_items[template_index].is_any_or_omit();
}

void TrailerFields_template::log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy)
{
if (value_ptr != NULL && template_ptr != NULL)((const TrailerFields_template*)template_ptr)->single_value.value_elements[index_template]->log_match((*(const TrailerFields*)value_ptr)[index_value], legacy);
else if (value_ptr != NULL) (*(const TrailerFields*)value_ptr)[index_value].log();
else if (template_ptr != NULL) ((const TrailerFields_template*)template_ptr)->single_value.value_elements[index_template]->log();
}

TrailerFields_template::TrailerFields_template()
{
}

TrailerFields_template::TrailerFields_template(template_sel other_value)
 : Restricted_Length_Template(other_value)
{
check_single_selection(other_value);
}

TrailerFields_template::TrailerFields_template(null_type)
 : Restricted_Length_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

TrailerFields_template::TrailerFields_template(const TrailerFields& other_value)
{
copy_value(other_value);
}

TrailerFields_template::TrailerFields_template(const OPTIONAL<TrailerFields>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TrailerFields&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.TrailerFields from an unbound optional field.");
}
}

TrailerFields_template::TrailerFields_template(const TrailerFields_template& other_value)
 : Restricted_Length_Template()
{
copy_template(other_value);
}

TrailerFields_template::~TrailerFields_template()
{
clean_up();
}

void TrailerFields_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
delete [] value_set.set_items;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

TrailerFields_template& TrailerFields_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TrailerFields_template& TrailerFields_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

TrailerFields_template& TrailerFields_template::operator=(const TrailerFields& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

TrailerFields_template& TrailerFields_template::operator=(const OPTIONAL<TrailerFields>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TrailerFields&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.TrailerFields.");
}
return *this;
}

TrailerFields_template& TrailerFields_template::operator=(const TrailerFields_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

TrailerField_template& TrailerFields_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.TrailerFields using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.TrailerFields.");
    break;
}
return *single_value.value_elements[index_value];
}

TrailerField_template& TrailerFields_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.TrailerFields.");
return (*this)[(int)index_value];
}

const TrailerField_template& TrailerFields_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.TrailerFields using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.TrailerFields.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsSecurity_TypesAndValues.TrailerFields: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const TrailerField_template& TrailerFields_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.TrailerFields.");
return (*this)[(int)index_value];
}

void TrailerFields_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsSecurity_TypesAndValues.TrailerFields.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (TrailerField_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new TrailerField_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new TrailerField_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (TrailerField_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int TrailerFields_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int TrailerFields_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TrailerFields which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TrailerFields containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case SUPERSET_MATCH:
case SUBSET_MATCH: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = value_set.n_items;
  if (!is_size) { while (elem_count>0 && !value_set.set_items[elem_count-1].is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (value_set.set_items[i].get_selection())
    {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TrailerFields containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
  if (template_selection==SUPERSET_MATCH) {
    has_any_or_none = TRUE;
   } else {
    int max_size = min_size;
    min_size = 0;
    if (!has_any_or_none) { // [0,max_size]
      switch (length_restriction_type) {
      case NO_LENGTH_RESTRICTION:
        if (max_size==0) return 0;
        TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TrailerFields with no exact size.", op_name);
      case SINGLE_LENGTH_RESTRICTION:
        if (length_restriction.single_length<=max_size)
          return length_restriction.single_length;
        TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.TrailerFields. The maximum size (%d) contradicts the length restriction (%d).", op_name, max_size, length_restriction.single_length);
      case RANGE_LENGTH_RESTRICTION:
        if (max_size==length_restriction.range_length.min_length) {
          return max_size;
        } else if (max_size>length_restriction.range_length.min_length){
          TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TrailerFields with no exact size.", op_name);
        } else
          TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.TrailerFields. Maximum size (%d) contradicts the length restriction (%d..%d).", op_name, max_size, length_restriction.range_length.min_length, length_restriction.range_length.max_length);
      default:
        TTCN_error("Internal error: Template has invalid length restriction type.");
      }
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TrailerFields containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TrailerFields containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TrailerFields containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TrailerFields containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TrailerFields.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsSecurity_TypesAndValues.TrailerFields");
}

boolean TrailerFields_template::match(const TrailerFields& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_set_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case SUPERSET_MATCH:
case SUBSET_MATCH:
return match_set_of(&other_value, value_length, this, value_set.n_items, match_function_set, legacy);
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TrailerFields.");
}
return FALSE;
}

boolean TrailerFields_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

TrailerFields TrailerFields_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.TrailerFields.");
TrailerFields ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

TrailerFields TrailerFields_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

TrailerFields TrailerFields_template::replace(int index, int len, const TrailerFields_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

TrailerFields TrailerFields_template::replace(int index, int len, const TrailerFields& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void TrailerFields_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new TrailerFields_template[list_length];
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = list_length;
value_set.set_items = new TrailerField_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsSecurity_TypesAndValues.TrailerFields.");
}
set_selection(template_type);
}

TrailerFields_template& TrailerFields_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.TrailerFields.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.TrailerFields.");
return value_list.list_value[list_index];
}

TrailerField_template& TrailerFields_template::set_item(unsigned int set_index)
{
if (template_selection != SUPERSET_MATCH && template_selection != SUBSET_MATCH) TTCN_error("Internal error: Accessing a set element of a non-set template of type @LibItsSecurity_TypesAndValues.TrailerFields.");
if (set_index >= value_set.n_items) TTCN_error("Internal error: Index overflow in a set template of type @LibItsSecurity_TypesAndValues.TrailerFields.");
return value_set.set_items[set_index];
}

void TrailerFields_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log();
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
TTCN_Logger::log_event("%s(", template_selection == SUPERSET_MATCH ? "superset" : "subset");
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++) {
if (set_count > 0) TTCN_Logger::log_event_str(", ");
value_set.set_items[set_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void TrailerFields_template::log_match(const TrailerFields& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (template_selection == SPECIFIC_VALUE)
  log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
else{
if(previous_size != 0){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::set_logmatch_buffer_len(previous_size);
TTCN_Logger::log_event_str(":=");
}
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
return;
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else {
TTCN_Logger::log_event_str(" unmatched");
if (template_selection == SPECIFIC_VALUE) log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
}
}

void TrailerFields_template::encode_text(Text_Buf& text_buf) const
{
encode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
text_buf.push_int(value_set.n_items);
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TrailerFields.");
}
}

void TrailerFields_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsSecurity_TypesAndValues.TrailerFields.");
single_value.value_elements = (TrailerField_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new TrailerField_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TrailerFields_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = text_buf.pull_int().get_val();
value_set.set_items = new TrailerField_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsSecurity_TypesAndValues.TrailerFields.");
}
}

boolean TrailerFields_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TrailerFields_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void TrailerFields_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set template type `@LibItsSecurity_TypesAndValues.TrailerFields'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "set of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TrailerFields_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    set_size(mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      if (mp->get_elem(p_i)->get_type()!=Module_Param::MP_NotUsed) {
        (*this)[p_i].set_param(*mp->get_elem(p_i));
      }
    }
    break;
  case Module_Param::MP_Superset_Template:
  case Module_Param::MP_Subset_Template:
    set_type(mp->get_type()==Module_Param::MP_Superset_Template ? SUPERSET_MATCH : SUBSET_MATCH, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      set_item(p_i).set_param(*mp->get_elem(p_i));
    }
    break;
  default:
    param.type_error("set of template", "@LibItsSecurity_TypesAndValues.TrailerFields");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* TrailerFields_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of template type `@LibItsSecurity_TypesAndValues.TrailerFields'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void TrailerFields_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TrailerFields");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.TrailerFields");
}

void TrailerFieldContainer::copy_value(const TrailerFieldContainer& other_value)
{
switch (other_value.union_selection) {
case ALT_signature__:
field_signature__ = new Signature(*other_value.field_signature__);
break;
case ALT_security__field:
field_security__field = new OCTETSTRING(*other_value.field_security__field);
break;
default:
TTCN_error("Assignment of an unbound union value of type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
}
union_selection = other_value.union_selection;
}

TrailerFieldContainer::TrailerFieldContainer()
{
union_selection = UNBOUND_VALUE;
}

TrailerFieldContainer::TrailerFieldContainer(const TrailerFieldContainer& other_value)
: Base_Type(){
copy_value(other_value);
}

TrailerFieldContainer::~TrailerFieldContainer()
{
clean_up();
}

TrailerFieldContainer& TrailerFieldContainer::operator=(const TrailerFieldContainer& other_value)
{
if (this != &other_value) {
clean_up();
copy_value(other_value);
}
return *this;
}

boolean TrailerFieldContainer::operator==(const TrailerFieldContainer& other_value) const
{
if (union_selection == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
if (other_value.union_selection == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
if (union_selection != other_value.union_selection) return FALSE;
switch (union_selection) {
case ALT_signature__:
return *field_signature__ == *other_value.field_signature__;
case ALT_security__field:
return *field_security__field == *other_value.field_security__field;
default:
return FALSE;
}
}

Signature& TrailerFieldContainer::signature__()
{
if (union_selection != ALT_signature__) {
clean_up();
field_signature__ = new Signature;
union_selection = ALT_signature__;
}
return *field_signature__;
}

const Signature& TrailerFieldContainer::signature__() const
{
if (union_selection != ALT_signature__) TTCN_error("Using non-selected field signature_ in a value of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
return *field_signature__;
}

OCTETSTRING& TrailerFieldContainer::security__field()
{
if (union_selection != ALT_security__field) {
clean_up();
field_security__field = new OCTETSTRING;
union_selection = ALT_security__field;
}
return *field_security__field;
}

const OCTETSTRING& TrailerFieldContainer::security__field() const
{
if (union_selection != ALT_security__field) TTCN_error("Using non-selected field security_field in a value of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
return *field_security__field;
}

boolean TrailerFieldContainer::ischosen(union_selection_type checked_selection) const
{
if (checked_selection == UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
if (union_selection == UNBOUND_VALUE) TTCN_error("Performing ischosen() operation on an unbound value of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
return union_selection == checked_selection;
}

boolean TrailerFieldContainer::is_bound() const
{
  return union_selection != UNBOUND_VALUE;
}

boolean TrailerFieldContainer::is_value() const
{
switch (union_selection) {
case UNBOUND_VALUE: return FALSE;
case ALT_signature__: return field_signature__->is_value();
case ALT_security__field: return field_security__field->is_value();
default: TTCN_error("Invalid selection in union is_bound");}
}

void TrailerFieldContainer::clean_up()
{
switch (union_selection) {
case ALT_signature__:
  delete field_signature__;
  break;
case ALT_security__field:
  delete field_security__field;
  break;
default:
  break;
}
union_selection = UNBOUND_VALUE;
}

void TrailerFieldContainer::log() const
{
switch (union_selection) {
case ALT_signature__:
TTCN_Logger::log_event_str("{ signature_ := ");
field_signature__->log();
TTCN_Logger::log_event_str(" }");
break;
case ALT_security__field:
TTCN_Logger::log_event_str("{ security_field := ");
field_security__field->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_unbound();
}
}

void TrailerFieldContainer::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union type `@LibItsSecurity_TypesAndValues.TrailerFieldContainer'");
    }
    if (strcmp("signature_", param_field) == 0) {
      signature__().set_param(param);
      return;
    } else if (strcmp("security_field", param_field) == 0) {
      security__field().set_param(param);
      return;
    } else param.error("Field `%s' not found in union type `@LibItsSecurity_TypesAndValues.TrailerFieldContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "union value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) return;
  if (mp->get_type()!=Module_Param::MP_Assignment_List) {
    param.error("union value with field name was expected");
  }
  Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
  if (!strcmp(mp_last->get_id()->get_name(), "signature_")) {
    signature__().set_param(*mp_last);
    return;
  }
  if (!strcmp(mp_last->get_id()->get_name(), "security_field")) {
    security__field().set_param(*mp_last);
    return;
  }
  mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.", mp_last->get_id()->get_name());
}

Module_Param* TrailerFieldContainer::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union type `@LibItsSecurity_TypesAndValues.TrailerFieldContainer'");
    }
    if (strcmp("signature_", param_field) == 0) {
      return signature__().get_param(param_name);
    } else if (strcmp("security_field", param_field) == 0) {
      return security__field().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `TrailerFieldContainer'", param_field);
  }
  Module_Param* mp_field = NULL;
  switch(union_selection) {
  case ALT_signature__:
    mp_field = field_signature__->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("signature_")));
    break;
  case ALT_security__field:
    mp_field = field_security__field->get_param(param_name);
    mp_field->set_id(new Module_Param_FieldName(mcopystr("security_field")));
    break;
  default:
    break;
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  mp->add_elem(mp_field);
  return mp;
}

void TrailerFieldContainer::set_implicit_omit()
{
switch (union_selection) {
case ALT_signature__:
field_signature__->set_implicit_omit(); break;
case ALT_security__field:
field_security__field->set_implicit_omit(); break;
default: break;
}
}

void TrailerFieldContainer::encode_text(Text_Buf& text_buf) const
{
text_buf.push_int(union_selection);
switch (union_selection) {
case ALT_signature__:
field_signature__->encode_text(text_buf);
break;
case ALT_security__field:
field_security__field->encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an unbound value of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
}
}

void TrailerFieldContainer::decode_text(Text_Buf& text_buf)
{
switch ((union_selection_type)text_buf.pull_int().get_val()) {
case ALT_signature__:
signature__().decode_text(text_buf);
break;
case ALT_security__field:
security__field().decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
}
}

void TrailerFieldContainer::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(TRUE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void TrailerFieldContainer::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int TrailerFieldContainer::RAW_decode(
const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, 
raw_order_t top_bit_ord, boolean no_err, int sel_field, boolean)
{
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int starting_pos=p_buf.get_pos_bit();
  if(sel_field!=-1){
    switch(sel_field){
    case 0:
      decoded_length = signature__().RAW_decode(Signature_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    case 1:
      decoded_length = security__field().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, no_err);
      break;
    default: break;
    }
    return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
  } else {
      p_buf.set_pos_bit(starting_pos);
      decoded_length = signature__().RAW_decode(Signature_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
      p_buf.set_pos_bit(starting_pos);
      decoded_length = security__field().RAW_decode(OCTETSTRING_descr_, p_buf, limit, top_bit_ord, TRUE);
      if (decoded_length >= 0) {
         return decoded_length + p_buf.increase_pos_padd(p_td.raw->padding) + prepaddlength;
       }
 }
 clean_up();
 return -1;
}

int TrailerFieldContainer::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const
{
  int encoded_length = 0;
  myleaf.isleaf = FALSE;
  myleaf.body.node.num_of_nodes = 2;  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  memset(myleaf.body.node.nodes, 0, 2 * sizeof(RAW_enc_tree *));
  switch (union_selection) {
  case ALT_signature__:
    myleaf.body.node.nodes[0] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 0, Signature_descr_.raw);
    encoded_length = field_signature__->RAW_encode(Signature_descr_, *myleaf.body.node.nodes[0]);
    myleaf.body.node.nodes[0]->coding_descr = &Signature_descr_;
    break;
  case ALT_security__field:
    myleaf.body.node.nodes[1] = new RAW_enc_tree(TRUE, &myleaf, &myleaf.curr_pos, 1, OCTETSTRING_descr_.raw);
    encoded_length = field_security__field->RAW_encode(OCTETSTRING_descr_, *myleaf.body.node.nodes[1]);
    myleaf.body.node.nodes[1]->coding_descr = &OCTETSTRING_descr_;
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  }
  return encoded_length;
}

int TrailerFieldContainer::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  switch(union_selection) {
  case ALT_signature__:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "signature_");
    enc_len += field_signature__->JSON_encode(Signature_descr_, p_tok);
    break;
  case ALT_security__field:
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "security_field");
    enc_len += field_security__field->JSON_encode(OCTETSTRING_descr_, p_tok);
    break;
  default:
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, 
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
    return -1;
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int TrailerFieldContainer::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }

  char* fld_name = 0;
  size_t name_len = 0;  dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
  if (JSON_TOKEN_NAME != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
    return JSON_ERROR_FATAL;
  } else {
    union_selection = UNBOUND_VALUE;
    if (0 == strncmp(fld_name, "signature_", name_len)) {
      int ret_val = signature__().JSON_decode(Signature_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "signature_");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else if (0 == strncmp(fld_name, "security_field", name_len)) {
      int ret_val = security__field().JSON_decode(OCTETSTRING_descr_, p_tok, p_silent);
      if (0 > ret_val) {
        if (JSON_ERROR_INVALID_TOKEN) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "security_field");
        }
        return JSON_ERROR_FATAL;
      } else {
        dec_len += ret_val;
      }
    } else {
      char* fld_name2 = mcopystrn(fld_name, name_len);
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
      Free(fld_name2);
      return JSON_ERROR_FATAL;
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_STATIC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

void TrailerFieldContainer_template::copy_value(const TrailerFieldContainer& other_value)
{
single_value.union_selection = other_value.get_selection();
switch (single_value.union_selection) {
case TrailerFieldContainer::ALT_signature__:
single_value.field_signature__ = new Signature_template(other_value.signature__());
break;
case TrailerFieldContainer::ALT_security__field:
single_value.field_security__field = new OCTETSTRING_template(other_value.security__field());
break;
default:
TTCN_error("Initializing a template with an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
}
set_selection(SPECIFIC_VALUE);
}

void TrailerFieldContainer_template::copy_template(const TrailerFieldContainer_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.union_selection = other_value.single_value.union_selection;
switch (single_value.union_selection) {
case TrailerFieldContainer::ALT_signature__:
single_value.field_signature__ = new Signature_template(*other_value.single_value.field_signature__);
break;
case TrailerFieldContainer::ALT_security__field:
single_value.field_security__field = new OCTETSTRING_template(*other_value.single_value.field_security__field);
break;
default:
TTCN_error("Internal error: Invalid union selector in a specific value when copying a template of type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TrailerFieldContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
}
set_selection(other_value);
}

TrailerFieldContainer_template::TrailerFieldContainer_template()
{
}

TrailerFieldContainer_template::TrailerFieldContainer_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

TrailerFieldContainer_template::TrailerFieldContainer_template(const TrailerFieldContainer& other_value)
{
copy_value(other_value);
}

TrailerFieldContainer_template::TrailerFieldContainer_template(const OPTIONAL<TrailerFieldContainer>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TrailerFieldContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer from an unbound optional field.");
}
}

TrailerFieldContainer_template::TrailerFieldContainer_template(const TrailerFieldContainer_template& other_value)
: Base_Template(){
copy_template(other_value);
}

TrailerFieldContainer_template::~TrailerFieldContainer_template()
{
clean_up();
}

void TrailerFieldContainer_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case TrailerFieldContainer::ALT_signature__:
delete single_value.field_signature__;
break;
case TrailerFieldContainer::ALT_security__field:
delete single_value.field_security__field;
default:
break;
}
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

TrailerFieldContainer_template& TrailerFieldContainer_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TrailerFieldContainer_template& TrailerFieldContainer_template::operator=(const TrailerFieldContainer& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

TrailerFieldContainer_template& TrailerFieldContainer_template::operator=(const OPTIONAL<TrailerFieldContainer>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TrailerFieldContainer&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
}
return *this;
}

TrailerFieldContainer_template& TrailerFieldContainer_template::operator=(const TrailerFieldContainer_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean TrailerFieldContainer_template::match(const TrailerFieldContainer& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
{
TrailerFieldContainer::union_selection_type value_selection = other_value.get_selection();
if (value_selection == TrailerFieldContainer::UNBOUND_VALUE) return FALSE;
if (value_selection != single_value.union_selection) return FALSE;
switch (value_selection) {
case TrailerFieldContainer::ALT_signature__:
return single_value.field_signature__->match(other_value.signature__(), legacy);
case TrailerFieldContainer::ALT_security__field:
return single_value.field_security__field->match(other_value.security__field(), legacy);
default:
TTCN_error("Internal error: Invalid selector in a specific value when matching a template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
}
}
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error ("Matching an uninitialized template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
}
return FALSE;
}

boolean TrailerFieldContainer_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
switch (single_value.union_selection) {
case TrailerFieldContainer::ALT_signature__:
return single_value.field_signature__->is_value();
case TrailerFieldContainer::ALT_security__field:
return single_value.field_security__field->is_value();
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing is_value operation on a template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
}
}

TrailerFieldContainer TrailerFieldContainer_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
TrailerFieldContainer ret_val;
switch (single_value.union_selection) {
case TrailerFieldContainer::ALT_signature__:
ret_val.signature__() = single_value.field_signature__->valueof();
break;
case TrailerFieldContainer::ALT_security__field:
ret_val.security__field() = single_value.field_security__field->valueof();
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing valueof operation on a template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
}
return ret_val;
}

TrailerFieldContainer_template& TrailerFieldContainer_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
return value_list.list_value[list_index];
}
void TrailerFieldContainer_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error ("Internal error: Setting an invalid list for a template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new TrailerFieldContainer_template[list_length];
}

Signature_template& TrailerFieldContainer_template::signature__()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != TrailerFieldContainer::ALT_signature__) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_signature__ = new Signature_template(ANY_VALUE);
else single_value.field_signature__ = new Signature_template;
single_value.union_selection = TrailerFieldContainer::ALT_signature__;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_signature__;
}

const Signature_template& TrailerFieldContainer_template::signature__() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field signature_ in a non-specific template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
if (single_value.union_selection != TrailerFieldContainer::ALT_signature__) TTCN_error("Accessing non-selected field signature_ in a template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
return *single_value.field_signature__;
}

OCTETSTRING_template& TrailerFieldContainer_template::security__field()
{
if (template_selection != SPECIFIC_VALUE || single_value.union_selection != TrailerFieldContainer::ALT_security__field) {
template_sel old_selection = template_selection;
clean_up();
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) single_value.field_security__field = new OCTETSTRING_template(ANY_VALUE);
else single_value.field_security__field = new OCTETSTRING_template;
single_value.union_selection = TrailerFieldContainer::ALT_security__field;
set_selection(SPECIFIC_VALUE);
}
return *single_value.field_security__field;
}

const OCTETSTRING_template& TrailerFieldContainer_template::security__field() const
{
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing field security_field in a non-specific template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
if (single_value.union_selection != TrailerFieldContainer::ALT_security__field) TTCN_error("Accessing non-selected field security_field in a template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
return *single_value.field_security__field;
}

boolean TrailerFieldContainer_template::ischosen(TrailerFieldContainer::union_selection_type checked_selection) const
{
if (checked_selection == TrailerFieldContainer::UNBOUND_VALUE) TTCN_error("Internal error: Performing ischosen() operation on an invalid field of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.union_selection == TrailerFieldContainer::UNBOUND_VALUE) TTCN_error("Internal error: Invalid selector in a specific value when performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
return single_value.union_selection == checked_selection;
case VALUE_LIST:
{
if (value_list.n_values < 1)
TTCN_error("Internal error: Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer containing an empty list.");
boolean ret_val = value_list.list_value[0].ischosen(checked_selection);
boolean all_same = TRUE;
for (unsigned int list_count = 1; list_count < value_list.n_values; list_count++) {
if (value_list.list_value[list_count].ischosen(checked_selection) != ret_val) {
all_same = FALSE;
break;
}
}
if (all_same) return ret_val;
}
case ANY_VALUE:
case ANY_OR_OMIT:
case OMIT_VALUE:
case COMPLEMENTED_LIST:
TTCN_error("Performing ischosen() operation on a template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer, which does not determine unambiguously the chosen field of the matching values.");
default:
TTCN_error("Performing ischosen() operation on an uninitialized template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer");
}
return FALSE;
}

void TrailerFieldContainer_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
switch (single_value.union_selection) {
case TrailerFieldContainer::ALT_signature__:
TTCN_Logger::log_event_str("{ signature_ := ");
single_value.field_signature__->log();
TTCN_Logger::log_event_str(" }");
break;
case TrailerFieldContainer::ALT_security__field:
TTCN_Logger::log_event_str("{ security_field := ");
single_value.field_security__field->log();
TTCN_Logger::log_event_str(" }");
break;
default:
TTCN_Logger::log_event_str("<invalid selector>");
}
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void TrailerFieldContainer_template::log_match(const TrailerFieldContainer& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity() && match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
return;
}
if (template_selection == SPECIFIC_VALUE && single_value.union_selection == match_value.get_selection()) {
switch (single_value.union_selection) {
case TrailerFieldContainer::ALT_signature__:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".signature_");
single_value.field_signature__->log_match(match_value.signature__(), legacy);
} else {
TTCN_Logger::log_event_str("{ signature_ := ");
single_value.field_signature__->log_match(match_value.signature__(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
case TrailerFieldContainer::ALT_security__field:
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
TTCN_Logger::log_logmatch_info(".security_field");
single_value.field_security__field->log_match(match_value.security__field(), legacy);
} else {
TTCN_Logger::log_event_str("{ security_field := ");
single_value.field_security__field->log_match(match_value.security__field(), legacy);
TTCN_Logger::log_event_str(" }");
}
break;
default:
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str("<invalid selector>");
}
} else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void TrailerFieldContainer_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.union_selection);
switch (single_value.union_selection) {
case TrailerFieldContainer::ALT_signature__:
single_value.field_signature__->encode_text(text_buf);
break;
case TrailerFieldContainer::ALT_security__field:
single_value.field_security__field->encode_text(text_buf);
break;
default:
TTCN_error("Internal error: Invalid selector in a specific value when encoding a template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized template of type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
}
}

void TrailerFieldContainer_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
{
single_value.union_selection = TrailerFieldContainer::UNBOUND_VALUE;
TrailerFieldContainer::union_selection_type new_selection = (TrailerFieldContainer::union_selection_type)text_buf.pull_int().get_val();
switch (new_selection) {
case TrailerFieldContainer::ALT_signature__:
single_value.field_signature__ = new Signature_template;
single_value.field_signature__->decode_text(text_buf);
break;
case TrailerFieldContainer::ALT_security__field:
single_value.field_security__field = new OCTETSTRING_template;
single_value.field_security__field->decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized union selector was received for a template of type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
}
single_value.union_selection = new_selection;
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TrailerFieldContainer_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: Unrecognized selector was received in a template of type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
}
}

boolean TrailerFieldContainer_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TrailerFieldContainer_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int v_idx=0; v_idx<value_list.n_values; v_idx++)
if (value_list.list_value[v_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void TrailerFieldContainer_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for union template type `@LibItsSecurity_TypesAndValues.TrailerFieldContainer'");
    }
    if (strcmp("signature_", param_field) == 0) {
      signature__().set_param(param);
      return;
    } else if (strcmp("security_field", param_field) == 0) {
      security__field().set_param(param);
      return;
    } else param.error("Field `%s' not found in union template type `@LibItsSecurity_TypesAndValues.TrailerFieldContainer'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "union template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TrailerFieldContainer_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (mp->get_size()==0) break;
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.TrailerFieldContainer");
    break;
  case Module_Param::MP_Assignment_List: {
    Module_Param* mp_last = mp->get_elem(mp->get_size()-1);
    if (!strcmp(mp_last->get_id()->get_name(), "signature_")) {
      signature__().set_param(*mp_last);
      break;
    }
    if (!strcmp(mp_last->get_id()->get_name(), "security_field")) {
      security__field().set_param(*mp_last);
      break;
    }
    mp_last->error("Field %s does not exist in type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.", mp_last->get_id()->get_name());
  } break;
  default:
    param.type_error("union template", "@LibItsSecurity_TypesAndValues.TrailerFieldContainer");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* TrailerFieldContainer_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for union template type `@LibItsSecurity_TypesAndValues.TrailerFieldContainer'");
    }
    if (strcmp("signature_", param_field) == 0) {
      return signature__().get_param(param_name);
    } else if (strcmp("security_field", param_field) == 0) {
      return security__field().get_param(param_name);
    } else TTCN_error("Field `%s' not found in union type `TrailerFieldContainer'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Module_Param* mp_field = NULL;
    switch(single_value.union_selection) {
    case TrailerFieldContainer::ALT_signature__:
      mp_field = single_value.field_signature__->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("signature_")));
      break;
    case TrailerFieldContainer::ALT_security__field:
      mp_field = single_value.field_security__field->get_param(param_name);
      mp_field->set_id(new Module_Param_FieldName(mcopystr("security_field")));
      break;
    default:
      break;
    }
    mp = new Module_Param_Assignment_List();
    mp->add_elem(mp_field);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void TrailerFieldContainer_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
switch (single_value.union_selection) {
case TrailerFieldContainer::ALT_signature__:
single_value.field_signature__->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TrailerFieldContainer");
return;
case TrailerFieldContainer::ALT_security__field:
single_value.field_security__field->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TrailerFieldContainer");
return;
default:
TTCN_error("Internal error: Invalid selector in a specific value when performing check_restriction operation on a template of union type @LibItsSecurity_TypesAndValues.TrailerFieldContainer.");
}
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.TrailerFieldContainer");
}

TrailerField::TrailerField()
{
  bound_flag = FALSE;
}

TrailerField::TrailerField(const TrailerFieldType& par_type__,
    const TrailerFieldContainer& par_trailerField)
  :   field_type__(par_type__),
  field_trailerField(par_trailerField)
{
  bound_flag = TRUE;
}

TrailerField::TrailerField(const TrailerField& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.TrailerField.");
bound_flag = TRUE;
if (other_value.type__().is_bound()) field_type__ = other_value.type__();
else field_type__.clean_up();
if (other_value.trailerField().is_bound()) field_trailerField = other_value.trailerField();
else field_trailerField.clean_up();
}

void TrailerField::clean_up()
{
field_type__.clean_up();
field_trailerField.clean_up();
bound_flag = FALSE;
}

TrailerField& TrailerField::operator=(const TrailerField& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.TrailerField.");
  bound_flag = TRUE;
  if (other_value.type__().is_bound()) field_type__ = other_value.type__();
  else field_type__.clean_up();
  if (other_value.trailerField().is_bound()) field_trailerField = other_value.trailerField();
  else field_trailerField.clean_up();
}
return *this;
}

boolean TrailerField::operator==(const TrailerField& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_type__==other_value.field_type__
  && field_trailerField==other_value.field_trailerField;
}

boolean TrailerField::is_bound() const
{
if (bound_flag) return TRUE;
if(field_type__.is_bound()) return TRUE;
if(field_trailerField.is_bound()) return TRUE;
return FALSE;
}
boolean TrailerField::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_type__.is_value()) return FALSE;
if(!field_trailerField.is_value()) return FALSE;
return TRUE;
}
int TrailerField::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.TrailerField");
  return 2;
}

void TrailerField::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ type_ := ");
field_type__.log();
TTCN_Logger::log_event_str(", trailerField := ");
field_trailerField.log();
TTCN_Logger::log_event_str(" }");
}

void TrailerField::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.TrailerField'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("trailerField", param_field) == 0) {
      trailerField().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.TrailerField'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.TrailerField has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) trailerField().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trailerField")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trailerField().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.TrailerField: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.TrailerField");
  }
}

Module_Param* TrailerField::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.TrailerField'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("trailerField", param_field) == 0) {
      return trailerField().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.TrailerField'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_type__ = field_type__.get_param(param_name);
  mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
  mp->add_elem(mp_field_type__);
  Module_Param* mp_field_trailerField = field_trailerField.get_param(param_name);
  mp_field_trailerField->set_id(new Module_Param_FieldName(mcopystr("trailerField")));
  mp->add_elem(mp_field_trailerField);
  return mp;
  }

void TrailerField::set_implicit_omit()
{
if (type__().is_bound()) type__().set_implicit_omit();
if (trailerField().is_bound()) trailerField().set_implicit_omit();
}

void TrailerField::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.TrailerField.");
field_type__.encode_text(text_buf);
field_trailerField.encode_text(text_buf);
}

void TrailerField::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_type__.decode_text(text_buf);
field_trailerField.decode_text(text_buf);
}

void TrailerField::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void TrailerField::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int TrailerField::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_type__.RAW_decode(TrailerFieldType_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_trailerField.RAW_decode(TrailerFieldContainer_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int TrailerField::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 2;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(2);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, TrailerFieldType_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, TrailerFieldContainer_descr_.raw);
  encoded_length += field_type__.RAW_encode(TrailerFieldType_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_trailerField.RAW_encode(TrailerFieldContainer_descr_, *myleaf.body.node.nodes[1]);
  return myleaf.length = encoded_length;
}

int TrailerField::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.TrailerField.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "type_");
    enc_len += field_type__.JSON_encode(TrailerFieldType_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "trailerField");
    enc_len += field_trailerField.JSON_encode(TrailerFieldContainer_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int TrailerField::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (5 == name_len && 0 == strncmp(fld_name, "type_", name_len)) {
         int ret_val = field_type__.JSON_decode(TrailerFieldType_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "type_");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "trailerField", name_len)) {
         int ret_val = field_trailerField.JSON_decode(TrailerFieldContainer_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "trailerField");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_type__.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "type_");
    return JSON_ERROR_FATAL;
  }
if (!field_trailerField.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "trailerField");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct TrailerField_template::single_value_struct {
TrailerFieldType_template field_type__;
TrailerFieldContainer_template field_trailerField;
};

void TrailerField_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_type__ = ANY_VALUE;
single_value->field_trailerField = ANY_VALUE;
}
}
}

void TrailerField_template::copy_value(const TrailerField& other_value)
{
single_value = new single_value_struct;
if (other_value.type__().is_bound()) {
  single_value->field_type__ = other_value.type__();
} else {
  single_value->field_type__.clean_up();
}
if (other_value.trailerField().is_bound()) {
  single_value->field_trailerField = other_value.trailerField();
} else {
  single_value->field_trailerField.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void TrailerField_template::copy_template(const TrailerField_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.type__().get_selection()) {
single_value->field_type__ = other_value.type__();
} else {
single_value->field_type__.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trailerField().get_selection()) {
single_value->field_trailerField = other_value.trailerField();
} else {
single_value->field_trailerField.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TrailerField_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TrailerField.");
break;
}
set_selection(other_value);
}

TrailerField_template::TrailerField_template()
{
}

TrailerField_template::TrailerField_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

TrailerField_template::TrailerField_template(const TrailerField& other_value)
{
copy_value(other_value);
}

TrailerField_template::TrailerField_template(const OPTIONAL<TrailerField>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TrailerField&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.TrailerField from an unbound optional field.");
}
}

TrailerField_template::TrailerField_template(const TrailerField_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

TrailerField_template::~TrailerField_template()
{
clean_up();
}

TrailerField_template& TrailerField_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TrailerField_template& TrailerField_template::operator=(const TrailerField& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

TrailerField_template& TrailerField_template::operator=(const OPTIONAL<TrailerField>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TrailerField&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.TrailerField.");
}
return *this;
}

TrailerField_template& TrailerField_template::operator=(const TrailerField_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean TrailerField_template::match(const TrailerField& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.type__().is_bound()) return FALSE;
if(!single_value->field_type__.match(other_value.type__(), legacy))return FALSE;
if(!other_value.trailerField().is_bound()) return FALSE;
if(!single_value->field_trailerField.match(other_value.trailerField(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TrailerField.");
}
return FALSE;
}

boolean TrailerField_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_type__.is_bound()) return TRUE;
if (single_value->field_trailerField.is_bound()) return TRUE;
return FALSE;
}

boolean TrailerField_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_type__.is_value()) return FALSE;
if (!single_value->field_trailerField.is_value()) return FALSE;
return TRUE;
}

void TrailerField_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

TrailerField TrailerField_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.TrailerField.");
TrailerField ret_val;
if (single_value->field_type__.is_bound()) {
ret_val.type__() = single_value->field_type__.valueof();
}
if (single_value->field_trailerField.is_bound()) {
ret_val.trailerField() = single_value->field_trailerField.valueof();
}
return ret_val;
}

void TrailerField_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.TrailerField.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new TrailerField_template[list_length];
}

TrailerField_template& TrailerField_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.TrailerField.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.TrailerField.");
return value_list.list_value[list_index];
}

TrailerFieldType_template& TrailerField_template::type__()
{
set_specific();
return single_value->field_type__;
}

const TrailerFieldType_template& TrailerField_template::type__() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field type_ of a non-specific template of type @LibItsSecurity_TypesAndValues.TrailerField.");
return single_value->field_type__;
}

TrailerFieldContainer_template& TrailerField_template::trailerField()
{
set_specific();
return single_value->field_trailerField;
}

const TrailerFieldContainer_template& TrailerField_template::trailerField() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trailerField of a non-specific template of type @LibItsSecurity_TypesAndValues.TrailerField.");
return single_value->field_trailerField;
}

int TrailerField_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TrailerField which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 2;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TrailerField containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TrailerField containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TrailerField containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TrailerField containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TrailerField containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TrailerField.");
  }
  return 0;
}

void TrailerField_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log();
TTCN_Logger::log_event_str(", trailerField := ");
single_value->field_trailerField.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void TrailerField_template::log_match(const TrailerField& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_type__.match(match_value.type__(), legacy)){
TTCN_Logger::log_logmatch_info(".type_");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_trailerField.match(match_value.trailerField(), legacy)){
TTCN_Logger::log_logmatch_info(".trailerField");
single_value->field_trailerField.log_match(match_value.trailerField(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ type_ := ");
single_value->field_type__.log_match(match_value.type__(), legacy);
TTCN_Logger::log_event_str(", trailerField := ");
single_value->field_trailerField.log_match(match_value.trailerField(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void TrailerField_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_type__.encode_text(text_buf);
single_value->field_trailerField.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TrailerField.");
}
}

void TrailerField_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_type__.decode_text(text_buf);
single_value->field_trailerField.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TrailerField_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.TrailerField.");
}
}

void TrailerField_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.TrailerField'");
    }
    if (strcmp("type_", param_field) == 0) {
      type__().set_param(param);
      return;
    } else if (strcmp("trailerField", param_field) == 0) {
      trailerField().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.TrailerField'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TrailerField_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (2<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.TrailerField has 2 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) type__().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) trailerField().set_param(*mp->get_elem(1));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "type_")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          type__().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trailerField")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trailerField().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.TrailerField: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.TrailerField");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* TrailerField_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.TrailerField'");
    }
    if (strcmp("type_", param_field) == 0) {
      return type__().get_param(param_name);
    } else if (strcmp("trailerField", param_field) == 0) {
      return trailerField().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.TrailerField'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_type__ = single_value->field_type__.get_param(param_name);
    mp_field_type__->set_id(new Module_Param_FieldName(mcopystr("type_")));
    mp->add_elem(mp_field_type__);
    Module_Param* mp_field_trailerField = single_value->field_trailerField.get_param(param_name);
    mp_field_trailerField->set_id(new Module_Param_FieldName(mcopystr("trailerField")));
    mp->add_elem(mp_field_trailerField);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void TrailerField_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_type__.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TrailerField");
single_value->field_trailerField.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TrailerField");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.TrailerField");
}

boolean TrailerField_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TrailerField_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

SecuredMessage::SecuredMessage()
{
  bound_flag = FALSE;
}

SecuredMessage::SecuredMessage(const INTEGER& par_protocol__version,
    const HeaderFields& par_header__fields,
    const SecPayload& par_payload__field,
    const TrailerFields& par_trailer__fields)
  :   field_protocol__version(par_protocol__version),
  field_header__fields(par_header__fields),
  field_payload__field(par_payload__field),
  field_trailer__fields(par_trailer__fields)
{
  bound_flag = TRUE;
}

SecuredMessage::SecuredMessage(const SecuredMessage& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
bound_flag = TRUE;
if (other_value.protocol__version().is_bound()) field_protocol__version = other_value.protocol__version();
else field_protocol__version.clean_up();
if (other_value.header__fields().is_bound()) field_header__fields = other_value.header__fields();
else field_header__fields.clean_up();
if (other_value.payload__field().is_bound()) field_payload__field = other_value.payload__field();
else field_payload__field.clean_up();
if (other_value.trailer__fields().is_bound()) field_trailer__fields = other_value.trailer__fields();
else field_trailer__fields.clean_up();
}

void SecuredMessage::clean_up()
{
field_protocol__version.clean_up();
field_header__fields.clean_up();
field_payload__field.clean_up();
field_trailer__fields.clean_up();
bound_flag = FALSE;
}

SecuredMessage& SecuredMessage::operator=(const SecuredMessage& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
  bound_flag = TRUE;
  if (other_value.protocol__version().is_bound()) field_protocol__version = other_value.protocol__version();
  else field_protocol__version.clean_up();
  if (other_value.header__fields().is_bound()) field_header__fields = other_value.header__fields();
  else field_header__fields.clean_up();
  if (other_value.payload__field().is_bound()) field_payload__field = other_value.payload__field();
  else field_payload__field.clean_up();
  if (other_value.trailer__fields().is_bound()) field_trailer__fields = other_value.trailer__fields();
  else field_trailer__fields.clean_up();
}
return *this;
}

boolean SecuredMessage::operator==(const SecuredMessage& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_protocol__version==other_value.field_protocol__version
  && field_header__fields==other_value.field_header__fields
  && field_payload__field==other_value.field_payload__field
  && field_trailer__fields==other_value.field_trailer__fields;
}

boolean SecuredMessage::is_bound() const
{
if (bound_flag) return TRUE;
if(field_protocol__version.is_bound()) return TRUE;
if(field_header__fields.is_bound()) return TRUE;
if(field_payload__field.is_bound()) return TRUE;
if(field_trailer__fields.is_bound()) return TRUE;
return FALSE;
}
boolean SecuredMessage::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_protocol__version.is_value()) return FALSE;
if(!field_header__fields.is_value()) return FALSE;
if(!field_payload__field.is_value()) return FALSE;
if(!field_trailer__fields.is_value()) return FALSE;
return TRUE;
}
int SecuredMessage::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.SecuredMessage");
  return 4;
}

void SecuredMessage::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ protocol_version := ");
field_protocol__version.log();
TTCN_Logger::log_event_str(", header_fields := ");
field_header__fields.log();
TTCN_Logger::log_event_str(", payload_field := ");
field_payload__field.log();
TTCN_Logger::log_event_str(", trailer_fields := ");
field_trailer__fields.log();
TTCN_Logger::log_event_str(" }");
}

void SecuredMessage::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.SecuredMessage'");
    }
    if (strcmp("protocol_version", param_field) == 0) {
      protocol__version().set_param(param);
      return;
    } else if (strcmp("header_fields", param_field) == 0) {
      header__fields().set_param(param);
      return;
    } else if (strcmp("payload_field", param_field) == 0) {
      payload__field().set_param(param);
      return;
    } else if (strcmp("trailer_fields", param_field) == 0) {
      trailer__fields().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SecuredMessage'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.SecuredMessage has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) protocol__version().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) header__fields().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload__field().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) trailer__fields().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protocol_version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protocol__version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header_fields")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header__fields().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload_field")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload__field().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trailer_fields")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trailer__fields().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.SecuredMessage: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.SecuredMessage");
  }
}

Module_Param* SecuredMessage::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.SecuredMessage'");
    }
    if (strcmp("protocol_version", param_field) == 0) {
      return protocol__version().get_param(param_name);
    } else if (strcmp("header_fields", param_field) == 0) {
      return header__fields().get_param(param_name);
    } else if (strcmp("payload_field", param_field) == 0) {
      return payload__field().get_param(param_name);
    } else if (strcmp("trailer_fields", param_field) == 0) {
      return trailer__fields().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SecuredMessage'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_protocol__version = field_protocol__version.get_param(param_name);
  mp_field_protocol__version->set_id(new Module_Param_FieldName(mcopystr("protocol_version")));
  mp->add_elem(mp_field_protocol__version);
  Module_Param* mp_field_header__fields = field_header__fields.get_param(param_name);
  mp_field_header__fields->set_id(new Module_Param_FieldName(mcopystr("header_fields")));
  mp->add_elem(mp_field_header__fields);
  Module_Param* mp_field_payload__field = field_payload__field.get_param(param_name);
  mp_field_payload__field->set_id(new Module_Param_FieldName(mcopystr("payload_field")));
  mp->add_elem(mp_field_payload__field);
  Module_Param* mp_field_trailer__fields = field_trailer__fields.get_param(param_name);
  mp_field_trailer__fields->set_id(new Module_Param_FieldName(mcopystr("trailer_fields")));
  mp->add_elem(mp_field_trailer__fields);
  return mp;
  }

void SecuredMessage::set_implicit_omit()
{
if (protocol__version().is_bound()) protocol__version().set_implicit_omit();
if (header__fields().is_bound()) header__fields().set_implicit_omit();
if (payload__field().is_bound()) payload__field().set_implicit_omit();
if (trailer__fields().is_bound()) trailer__fields().set_implicit_omit();
}

void SecuredMessage::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
field_protocol__version.encode_text(text_buf);
field_header__fields.encode_text(text_buf);
field_payload__field.encode_text(text_buf);
field_trailer__fields.encode_text(text_buf);
}

void SecuredMessage::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_protocol__version.decode_text(text_buf);
field_header__fields.decode_text(text_buf);
field_payload__field.decode_text(text_buf);
field_trailer__fields.decode_text(text_buf);
}

void SecuredMessage::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void SecuredMessage::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int SecuredMessage::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_protocol__version.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_header__fields.RAW_decode(HeaderFields_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_payload__field.RAW_decode(SecPayload_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_trailer__fields.RAW_decode(TrailerFields_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int SecuredMessage::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 4;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(4);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, HeaderFields_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, SecPayload_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, TrailerFields_descr_.raw);
  encoded_length += field_protocol__version.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_header__fields.RAW_encode(HeaderFields_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_payload__field.RAW_encode(SecPayload_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_trailer__fields.RAW_encode(TrailerFields_descr_, *myleaf.body.node.nodes[3]);
  return myleaf.length = encoded_length;
}

int SecuredMessage::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "protocol_version");
    enc_len += field_protocol__version.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "header_fields");
    enc_len += field_header__fields.JSON_encode(HeaderFields_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "payload_field");
    enc_len += field_payload__field.JSON_encode(SecPayload_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "trailer_fields");
    enc_len += field_trailer__fields.JSON_encode(TrailerFields_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int SecuredMessage::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (16 == name_len && 0 == strncmp(fld_name, "protocol_version", name_len)) {
         int ret_val = field_protocol__version.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "protocol_version");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "header_fields", name_len)) {
         int ret_val = field_header__fields.JSON_decode(HeaderFields_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "header_fields");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "payload_field", name_len)) {
         int ret_val = field_payload__field.JSON_decode(SecPayload_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "payload_field");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (14 == name_len && 0 == strncmp(fld_name, "trailer_fields", name_len)) {
         int ret_val = field_trailer__fields.JSON_decode(TrailerFields_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "trailer_fields");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_protocol__version.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "protocol_version");
    return JSON_ERROR_FATAL;
  }
if (!field_header__fields.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "header_fields");
    return JSON_ERROR_FATAL;
  }
if (!field_payload__field.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "payload_field");
    return JSON_ERROR_FATAL;
  }
if (!field_trailer__fields.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "trailer_fields");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct SecuredMessage_template::single_value_struct {
INTEGER_template field_protocol__version;
HeaderFields_template field_header__fields;
SecPayload_template field_payload__field;
TrailerFields_template field_trailer__fields;
};

void SecuredMessage_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_protocol__version = ANY_VALUE;
single_value->field_header__fields = ANY_VALUE;
single_value->field_payload__field = ANY_VALUE;
single_value->field_trailer__fields = ANY_VALUE;
}
}
}

void SecuredMessage_template::copy_value(const SecuredMessage& other_value)
{
single_value = new single_value_struct;
if (other_value.protocol__version().is_bound()) {
  single_value->field_protocol__version = other_value.protocol__version();
} else {
  single_value->field_protocol__version.clean_up();
}
if (other_value.header__fields().is_bound()) {
  single_value->field_header__fields = other_value.header__fields();
} else {
  single_value->field_header__fields.clean_up();
}
if (other_value.payload__field().is_bound()) {
  single_value->field_payload__field = other_value.payload__field();
} else {
  single_value->field_payload__field.clean_up();
}
if (other_value.trailer__fields().is_bound()) {
  single_value->field_trailer__fields = other_value.trailer__fields();
} else {
  single_value->field_trailer__fields.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void SecuredMessage_template::copy_template(const SecuredMessage_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.protocol__version().get_selection()) {
single_value->field_protocol__version = other_value.protocol__version();
} else {
single_value->field_protocol__version.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.header__fields().get_selection()) {
single_value->field_header__fields = other_value.header__fields();
} else {
single_value->field_header__fields.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.payload__field().get_selection()) {
single_value->field_payload__field = other_value.payload__field();
} else {
single_value->field_payload__field.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.trailer__fields().get_selection()) {
single_value->field_trailer__fields = other_value.trailer__fields();
} else {
single_value->field_trailer__fields.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new SecuredMessage_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
break;
}
set_selection(other_value);
}

SecuredMessage_template::SecuredMessage_template()
{
}

SecuredMessage_template::SecuredMessage_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

SecuredMessage_template::SecuredMessage_template(const SecuredMessage& other_value)
{
copy_value(other_value);
}

SecuredMessage_template::SecuredMessage_template(const OPTIONAL<SecuredMessage>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SecuredMessage&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.SecuredMessage from an unbound optional field.");
}
}

SecuredMessage_template::SecuredMessage_template(const SecuredMessage_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

SecuredMessage_template::~SecuredMessage_template()
{
clean_up();
}

SecuredMessage_template& SecuredMessage_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

SecuredMessage_template& SecuredMessage_template::operator=(const SecuredMessage& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

SecuredMessage_template& SecuredMessage_template::operator=(const OPTIONAL<SecuredMessage>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const SecuredMessage&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
}
return *this;
}

SecuredMessage_template& SecuredMessage_template::operator=(const SecuredMessage_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean SecuredMessage_template::match(const SecuredMessage& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.protocol__version().is_bound()) return FALSE;
if(!single_value->field_protocol__version.match(other_value.protocol__version(), legacy))return FALSE;
if(!other_value.header__fields().is_bound()) return FALSE;
if(!single_value->field_header__fields.match(other_value.header__fields(), legacy))return FALSE;
if(!other_value.payload__field().is_bound()) return FALSE;
if(!single_value->field_payload__field.match(other_value.payload__field(), legacy))return FALSE;
if(!other_value.trailer__fields().is_bound()) return FALSE;
if(!single_value->field_trailer__fields.match(other_value.trailer__fields(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
}
return FALSE;
}

boolean SecuredMessage_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_protocol__version.is_bound()) return TRUE;
if (single_value->field_header__fields.is_bound()) return TRUE;
if (single_value->field_payload__field.is_bound()) return TRUE;
if (single_value->field_trailer__fields.is_bound()) return TRUE;
return FALSE;
}

boolean SecuredMessage_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_protocol__version.is_value()) return FALSE;
if (!single_value->field_header__fields.is_value()) return FALSE;
if (!single_value->field_payload__field.is_value()) return FALSE;
if (!single_value->field_trailer__fields.is_value()) return FALSE;
return TRUE;
}

void SecuredMessage_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

SecuredMessage SecuredMessage_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
SecuredMessage ret_val;
if (single_value->field_protocol__version.is_bound()) {
ret_val.protocol__version() = single_value->field_protocol__version.valueof();
}
if (single_value->field_header__fields.is_bound()) {
ret_val.header__fields() = single_value->field_header__fields.valueof();
}
if (single_value->field_payload__field.is_bound()) {
ret_val.payload__field() = single_value->field_payload__field.valueof();
}
if (single_value->field_trailer__fields.is_bound()) {
ret_val.trailer__fields() = single_value->field_trailer__fields.valueof();
}
return ret_val;
}

void SecuredMessage_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new SecuredMessage_template[list_length];
}

SecuredMessage_template& SecuredMessage_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
return value_list.list_value[list_index];
}

INTEGER_template& SecuredMessage_template::protocol__version()
{
set_specific();
return single_value->field_protocol__version;
}

const INTEGER_template& SecuredMessage_template::protocol__version() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field protocol_version of a non-specific template of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
return single_value->field_protocol__version;
}

HeaderFields_template& SecuredMessage_template::header__fields()
{
set_specific();
return single_value->field_header__fields;
}

const HeaderFields_template& SecuredMessage_template::header__fields() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field header_fields of a non-specific template of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
return single_value->field_header__fields;
}

SecPayload_template& SecuredMessage_template::payload__field()
{
set_specific();
return single_value->field_payload__field;
}

const SecPayload_template& SecuredMessage_template::payload__field() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field payload_field of a non-specific template of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
return single_value->field_payload__field;
}

TrailerFields_template& SecuredMessage_template::trailer__fields()
{
set_specific();
return single_value->field_trailer__fields;
}

const TrailerFields_template& SecuredMessage_template::trailer__fields() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field trailer_fields of a non-specific template of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
return single_value->field_trailer__fields;
}

int SecuredMessage_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SecuredMessage which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 4;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SecuredMessage containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SecuredMessage containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SecuredMessage containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SecuredMessage containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.SecuredMessage containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
  }
  return 0;
}

void SecuredMessage_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ protocol_version := ");
single_value->field_protocol__version.log();
TTCN_Logger::log_event_str(", header_fields := ");
single_value->field_header__fields.log();
TTCN_Logger::log_event_str(", payload_field := ");
single_value->field_payload__field.log();
TTCN_Logger::log_event_str(", trailer_fields := ");
single_value->field_trailer__fields.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void SecuredMessage_template::log_match(const SecuredMessage& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_protocol__version.match(match_value.protocol__version(), legacy)){
TTCN_Logger::log_logmatch_info(".protocol_version");
single_value->field_protocol__version.log_match(match_value.protocol__version(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_header__fields.match(match_value.header__fields(), legacy)){
TTCN_Logger::log_logmatch_info(".header_fields");
single_value->field_header__fields.log_match(match_value.header__fields(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_payload__field.match(match_value.payload__field(), legacy)){
TTCN_Logger::log_logmatch_info(".payload_field");
single_value->field_payload__field.log_match(match_value.payload__field(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_trailer__fields.match(match_value.trailer__fields(), legacy)){
TTCN_Logger::log_logmatch_info(".trailer_fields");
single_value->field_trailer__fields.log_match(match_value.trailer__fields(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ protocol_version := ");
single_value->field_protocol__version.log_match(match_value.protocol__version(), legacy);
TTCN_Logger::log_event_str(", header_fields := ");
single_value->field_header__fields.log_match(match_value.header__fields(), legacy);
TTCN_Logger::log_event_str(", payload_field := ");
single_value->field_payload__field.log_match(match_value.payload__field(), legacy);
TTCN_Logger::log_event_str(", trailer_fields := ");
single_value->field_trailer__fields.log_match(match_value.trailer__fields(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void SecuredMessage_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_protocol__version.encode_text(text_buf);
single_value->field_header__fields.encode_text(text_buf);
single_value->field_payload__field.encode_text(text_buf);
single_value->field_trailer__fields.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
}
}

void SecuredMessage_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_protocol__version.decode_text(text_buf);
single_value->field_header__fields.decode_text(text_buf);
single_value->field_payload__field.decode_text(text_buf);
single_value->field_trailer__fields.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new SecuredMessage_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.SecuredMessage.");
}
}

void SecuredMessage_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.SecuredMessage'");
    }
    if (strcmp("protocol_version", param_field) == 0) {
      protocol__version().set_param(param);
      return;
    } else if (strcmp("header_fields", param_field) == 0) {
      header__fields().set_param(param);
      return;
    } else if (strcmp("payload_field", param_field) == 0) {
      payload__field().set_param(param);
      return;
    } else if (strcmp("trailer_fields", param_field) == 0) {
      trailer__fields().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.SecuredMessage'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    SecuredMessage_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (4<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.SecuredMessage has 4 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) protocol__version().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) header__fields().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) payload__field().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) trailer__fields().set_param(*mp->get_elem(3));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "protocol_version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          protocol__version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "header_fields")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          header__fields().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "payload_field")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          payload__field().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "trailer_fields")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          trailer__fields().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.SecuredMessage: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.SecuredMessage");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* SecuredMessage_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.SecuredMessage'");
    }
    if (strcmp("protocol_version", param_field) == 0) {
      return protocol__version().get_param(param_name);
    } else if (strcmp("header_fields", param_field) == 0) {
      return header__fields().get_param(param_name);
    } else if (strcmp("payload_field", param_field) == 0) {
      return payload__field().get_param(param_name);
    } else if (strcmp("trailer_fields", param_field) == 0) {
      return trailer__fields().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.SecuredMessage'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_protocol__version = single_value->field_protocol__version.get_param(param_name);
    mp_field_protocol__version->set_id(new Module_Param_FieldName(mcopystr("protocol_version")));
    mp->add_elem(mp_field_protocol__version);
    Module_Param* mp_field_header__fields = single_value->field_header__fields.get_param(param_name);
    mp_field_header__fields->set_id(new Module_Param_FieldName(mcopystr("header_fields")));
    mp->add_elem(mp_field_header__fields);
    Module_Param* mp_field_payload__field = single_value->field_payload__field.get_param(param_name);
    mp_field_payload__field->set_id(new Module_Param_FieldName(mcopystr("payload_field")));
    mp->add_elem(mp_field_payload__field);
    Module_Param* mp_field_trailer__fields = single_value->field_trailer__fields.get_param(param_name);
    mp_field_trailer__fields->set_id(new Module_Param_FieldName(mcopystr("trailer_fields")));
    mp->add_elem(mp_field_trailer__fields);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void SecuredMessage_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_protocol__version.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SecuredMessage");
single_value->field_header__fields.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SecuredMessage");
single_value->field_payload__field.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SecuredMessage");
single_value->field_trailer__fields.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.SecuredMessage");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.SecuredMessage");
}

boolean SecuredMessage_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean SecuredMessage_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

ToBeSignedCertificate::ToBeSignedCertificate()
{
  bound_flag = FALSE;
}

ToBeSignedCertificate::ToBeSignedCertificate(const INTEGER& par_version,
    const SignerInfo& par_signer__info,
    const SubjectInfo& par_subject__info,
    const SubjectAttributes& par_subject__attributes,
    const ValidityRestrictions& par_validity__restrictions)
  :   field_version(par_version),
  field_signer__info(par_signer__info),
  field_subject__info(par_subject__info),
  field_subject__attributes(par_subject__attributes),
  field_validity__restrictions(par_validity__restrictions)
{
  bound_flag = TRUE;
}

ToBeSignedCertificate::ToBeSignedCertificate(const ToBeSignedCertificate& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
bound_flag = TRUE;
if (other_value.version().is_bound()) field_version = other_value.version();
else field_version.clean_up();
if (other_value.signer__info().is_bound()) field_signer__info = other_value.signer__info();
else field_signer__info.clean_up();
if (other_value.subject__info().is_bound()) field_subject__info = other_value.subject__info();
else field_subject__info.clean_up();
if (other_value.subject__attributes().is_bound()) field_subject__attributes = other_value.subject__attributes();
else field_subject__attributes.clean_up();
if (other_value.validity__restrictions().is_bound()) field_validity__restrictions = other_value.validity__restrictions();
else field_validity__restrictions.clean_up();
}

void ToBeSignedCertificate::clean_up()
{
field_version.clean_up();
field_signer__info.clean_up();
field_subject__info.clean_up();
field_subject__attributes.clean_up();
field_validity__restrictions.clean_up();
bound_flag = FALSE;
}

ToBeSignedCertificate& ToBeSignedCertificate::operator=(const ToBeSignedCertificate& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
  bound_flag = TRUE;
  if (other_value.version().is_bound()) field_version = other_value.version();
  else field_version.clean_up();
  if (other_value.signer__info().is_bound()) field_signer__info = other_value.signer__info();
  else field_signer__info.clean_up();
  if (other_value.subject__info().is_bound()) field_subject__info = other_value.subject__info();
  else field_subject__info.clean_up();
  if (other_value.subject__attributes().is_bound()) field_subject__attributes = other_value.subject__attributes();
  else field_subject__attributes.clean_up();
  if (other_value.validity__restrictions().is_bound()) field_validity__restrictions = other_value.validity__restrictions();
  else field_validity__restrictions.clean_up();
}
return *this;
}

boolean ToBeSignedCertificate::operator==(const ToBeSignedCertificate& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_version==other_value.field_version
  && field_signer__info==other_value.field_signer__info
  && field_subject__info==other_value.field_subject__info
  && field_subject__attributes==other_value.field_subject__attributes
  && field_validity__restrictions==other_value.field_validity__restrictions;
}

boolean ToBeSignedCertificate::is_bound() const
{
if (bound_flag) return TRUE;
if(field_version.is_bound()) return TRUE;
if(field_signer__info.is_bound()) return TRUE;
if(field_subject__info.is_bound()) return TRUE;
if(field_subject__attributes.is_bound()) return TRUE;
if(field_validity__restrictions.is_bound()) return TRUE;
return FALSE;
}
boolean ToBeSignedCertificate::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_version.is_value()) return FALSE;
if(!field_signer__info.is_value()) return FALSE;
if(!field_subject__info.is_value()) return FALSE;
if(!field_subject__attributes.is_value()) return FALSE;
if(!field_validity__restrictions.is_value()) return FALSE;
return TRUE;
}
int ToBeSignedCertificate::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate");
  return 5;
}

void ToBeSignedCertificate::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ version := ");
field_version.log();
TTCN_Logger::log_event_str(", signer_info := ");
field_signer__info.log();
TTCN_Logger::log_event_str(", subject_info := ");
field_subject__info.log();
TTCN_Logger::log_event_str(", subject_attributes := ");
field_subject__attributes.log();
TTCN_Logger::log_event_str(", validity_restrictions := ");
field_validity__restrictions.log();
TTCN_Logger::log_event_str(" }");
}

void ToBeSignedCertificate::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.ToBeSignedCertificate'");
    }
    if (strcmp("version", param_field) == 0) {
      version().set_param(param);
      return;
    } else if (strcmp("signer_info", param_field) == 0) {
      signer__info().set_param(param);
      return;
    } else if (strcmp("subject_info", param_field) == 0) {
      subject__info().set_param(param);
      return;
    } else if (strcmp("subject_attributes", param_field) == 0) {
      subject__attributes().set_param(param);
      return;
    } else if (strcmp("validity_restrictions", param_field) == 0) {
      validity__restrictions().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ToBeSignedCertificate'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) signer__info().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) subject__info().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) subject__attributes().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) validity__restrictions().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signer_info")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signer__info().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "subject_info")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          subject__info().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "subject_attributes")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          subject__attributes().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "validity_restrictions")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          validity__restrictions().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.ToBeSignedCertificate");
  }
}

Module_Param* ToBeSignedCertificate::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.ToBeSignedCertificate'");
    }
    if (strcmp("version", param_field) == 0) {
      return version().get_param(param_name);
    } else if (strcmp("signer_info", param_field) == 0) {
      return signer__info().get_param(param_name);
    } else if (strcmp("subject_info", param_field) == 0) {
      return subject__info().get_param(param_name);
    } else if (strcmp("subject_attributes", param_field) == 0) {
      return subject__attributes().get_param(param_name);
    } else if (strcmp("validity_restrictions", param_field) == 0) {
      return validity__restrictions().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ToBeSignedCertificate'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_version = field_version.get_param(param_name);
  mp_field_version->set_id(new Module_Param_FieldName(mcopystr("version")));
  mp->add_elem(mp_field_version);
  Module_Param* mp_field_signer__info = field_signer__info.get_param(param_name);
  mp_field_signer__info->set_id(new Module_Param_FieldName(mcopystr("signer_info")));
  mp->add_elem(mp_field_signer__info);
  Module_Param* mp_field_subject__info = field_subject__info.get_param(param_name);
  mp_field_subject__info->set_id(new Module_Param_FieldName(mcopystr("subject_info")));
  mp->add_elem(mp_field_subject__info);
  Module_Param* mp_field_subject__attributes = field_subject__attributes.get_param(param_name);
  mp_field_subject__attributes->set_id(new Module_Param_FieldName(mcopystr("subject_attributes")));
  mp->add_elem(mp_field_subject__attributes);
  Module_Param* mp_field_validity__restrictions = field_validity__restrictions.get_param(param_name);
  mp_field_validity__restrictions->set_id(new Module_Param_FieldName(mcopystr("validity_restrictions")));
  mp->add_elem(mp_field_validity__restrictions);
  return mp;
  }

void ToBeSignedCertificate::set_implicit_omit()
{
if (version().is_bound()) version().set_implicit_omit();
if (signer__info().is_bound()) signer__info().set_implicit_omit();
if (subject__info().is_bound()) subject__info().set_implicit_omit();
if (subject__attributes().is_bound()) subject__attributes().set_implicit_omit();
if (validity__restrictions().is_bound()) validity__restrictions().set_implicit_omit();
}

void ToBeSignedCertificate::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
field_version.encode_text(text_buf);
field_signer__info.encode_text(text_buf);
field_subject__info.encode_text(text_buf);
field_subject__attributes.encode_text(text_buf);
field_validity__restrictions.encode_text(text_buf);
}

void ToBeSignedCertificate::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_version.decode_text(text_buf);
field_signer__info.decode_text(text_buf);
field_subject__info.decode_text(text_buf);
field_subject__attributes.decode_text(text_buf);
field_validity__restrictions.decode_text(text_buf);
}

void ToBeSignedCertificate::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void ToBeSignedCertificate::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int ToBeSignedCertificate::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_version.RAW_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_signer__info.RAW_decode(SignerInfo_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_subject__info.RAW_decode(SubjectInfo_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_subject__attributes.RAW_decode(SubjectAttributes_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_validity__restrictions.RAW_decode(ValidityRestrictions_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int ToBeSignedCertificate::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 5;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(5);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__BasicTypesAndValues::UInt8_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, SignerInfo_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, SubjectInfo_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, SubjectAttributes_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, ValidityRestrictions_descr_.raw);
  encoded_length += field_version.RAW_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_signer__info.RAW_encode(SignerInfo_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_subject__info.RAW_encode(SubjectInfo_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_subject__attributes.RAW_encode(SubjectAttributes_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_validity__restrictions.RAW_encode(ValidityRestrictions_descr_, *myleaf.body.node.nodes[4]);
  return myleaf.length = encoded_length;
}

int ToBeSignedCertificate::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "version");
    enc_len += field_version.JSON_encode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "signer_info");
    enc_len += field_signer__info.JSON_encode(SignerInfo_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "subject_info");
    enc_len += field_subject__info.JSON_encode(SubjectInfo_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "subject_attributes");
    enc_len += field_subject__attributes.JSON_encode(SubjectAttributes_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "validity_restrictions");
    enc_len += field_validity__restrictions.JSON_encode(ValidityRestrictions_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int ToBeSignedCertificate::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (7 == name_len && 0 == strncmp(fld_name, "version", name_len)) {
         int ret_val = field_version.JSON_decode(LibCommon__BasicTypesAndValues::UInt8_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "version");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (11 == name_len && 0 == strncmp(fld_name, "signer_info", name_len)) {
         int ret_val = field_signer__info.JSON_decode(SignerInfo_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "signer_info");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (12 == name_len && 0 == strncmp(fld_name, "subject_info", name_len)) {
         int ret_val = field_subject__info.JSON_decode(SubjectInfo_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "subject_info");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (18 == name_len && 0 == strncmp(fld_name, "subject_attributes", name_len)) {
         int ret_val = field_subject__attributes.JSON_decode(SubjectAttributes_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "subject_attributes");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (21 == name_len && 0 == strncmp(fld_name, "validity_restrictions", name_len)) {
         int ret_val = field_validity__restrictions.JSON_decode(ValidityRestrictions_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "validity_restrictions");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_version.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "version");
    return JSON_ERROR_FATAL;
  }
if (!field_signer__info.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "signer_info");
    return JSON_ERROR_FATAL;
  }
if (!field_subject__info.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "subject_info");
    return JSON_ERROR_FATAL;
  }
if (!field_subject__attributes.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "subject_attributes");
    return JSON_ERROR_FATAL;
  }
if (!field_validity__restrictions.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "validity_restrictions");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct ToBeSignedCertificate_template::single_value_struct {
INTEGER_template field_version;
SignerInfo_template field_signer__info;
SubjectInfo_template field_subject__info;
SubjectAttributes_template field_subject__attributes;
ValidityRestrictions_template field_validity__restrictions;
};

void ToBeSignedCertificate_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_version = ANY_VALUE;
single_value->field_signer__info = ANY_VALUE;
single_value->field_subject__info = ANY_VALUE;
single_value->field_subject__attributes = ANY_VALUE;
single_value->field_validity__restrictions = ANY_VALUE;
}
}
}

void ToBeSignedCertificate_template::copy_value(const ToBeSignedCertificate& other_value)
{
single_value = new single_value_struct;
if (other_value.version().is_bound()) {
  single_value->field_version = other_value.version();
} else {
  single_value->field_version.clean_up();
}
if (other_value.signer__info().is_bound()) {
  single_value->field_signer__info = other_value.signer__info();
} else {
  single_value->field_signer__info.clean_up();
}
if (other_value.subject__info().is_bound()) {
  single_value->field_subject__info = other_value.subject__info();
} else {
  single_value->field_subject__info.clean_up();
}
if (other_value.subject__attributes().is_bound()) {
  single_value->field_subject__attributes = other_value.subject__attributes();
} else {
  single_value->field_subject__attributes.clean_up();
}
if (other_value.validity__restrictions().is_bound()) {
  single_value->field_validity__restrictions = other_value.validity__restrictions();
} else {
  single_value->field_validity__restrictions.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void ToBeSignedCertificate_template::copy_template(const ToBeSignedCertificate_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.version().get_selection()) {
single_value->field_version = other_value.version();
} else {
single_value->field_version.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.signer__info().get_selection()) {
single_value->field_signer__info = other_value.signer__info();
} else {
single_value->field_signer__info.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.subject__info().get_selection()) {
single_value->field_subject__info = other_value.subject__info();
} else {
single_value->field_subject__info.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.subject__attributes().get_selection()) {
single_value->field_subject__attributes = other_value.subject__attributes();
} else {
single_value->field_subject__attributes.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.validity__restrictions().get_selection()) {
single_value->field_validity__restrictions = other_value.validity__restrictions();
} else {
single_value->field_validity__restrictions.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new ToBeSignedCertificate_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
break;
}
set_selection(other_value);
}

ToBeSignedCertificate_template::ToBeSignedCertificate_template()
{
}

ToBeSignedCertificate_template::ToBeSignedCertificate_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

ToBeSignedCertificate_template::ToBeSignedCertificate_template(const ToBeSignedCertificate& other_value)
{
copy_value(other_value);
}

ToBeSignedCertificate_template::ToBeSignedCertificate_template(const OPTIONAL<ToBeSignedCertificate>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ToBeSignedCertificate&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate from an unbound optional field.");
}
}

ToBeSignedCertificate_template::ToBeSignedCertificate_template(const ToBeSignedCertificate_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

ToBeSignedCertificate_template::~ToBeSignedCertificate_template()
{
clean_up();
}

ToBeSignedCertificate_template& ToBeSignedCertificate_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

ToBeSignedCertificate_template& ToBeSignedCertificate_template::operator=(const ToBeSignedCertificate& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

ToBeSignedCertificate_template& ToBeSignedCertificate_template::operator=(const OPTIONAL<ToBeSignedCertificate>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const ToBeSignedCertificate&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
}
return *this;
}

ToBeSignedCertificate_template& ToBeSignedCertificate_template::operator=(const ToBeSignedCertificate_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean ToBeSignedCertificate_template::match(const ToBeSignedCertificate& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.version().is_bound()) return FALSE;
if(!single_value->field_version.match(other_value.version(), legacy))return FALSE;
if(!other_value.signer__info().is_bound()) return FALSE;
if(!single_value->field_signer__info.match(other_value.signer__info(), legacy))return FALSE;
if(!other_value.subject__info().is_bound()) return FALSE;
if(!single_value->field_subject__info.match(other_value.subject__info(), legacy))return FALSE;
if(!other_value.subject__attributes().is_bound()) return FALSE;
if(!single_value->field_subject__attributes.match(other_value.subject__attributes(), legacy))return FALSE;
if(!other_value.validity__restrictions().is_bound()) return FALSE;
if(!single_value->field_validity__restrictions.match(other_value.validity__restrictions(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
}
return FALSE;
}

boolean ToBeSignedCertificate_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_version.is_bound()) return TRUE;
if (single_value->field_signer__info.is_bound()) return TRUE;
if (single_value->field_subject__info.is_bound()) return TRUE;
if (single_value->field_subject__attributes.is_bound()) return TRUE;
if (single_value->field_validity__restrictions.is_bound()) return TRUE;
return FALSE;
}

boolean ToBeSignedCertificate_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_version.is_value()) return FALSE;
if (!single_value->field_signer__info.is_value()) return FALSE;
if (!single_value->field_subject__info.is_value()) return FALSE;
if (!single_value->field_subject__attributes.is_value()) return FALSE;
if (!single_value->field_validity__restrictions.is_value()) return FALSE;
return TRUE;
}

void ToBeSignedCertificate_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

ToBeSignedCertificate ToBeSignedCertificate_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
ToBeSignedCertificate ret_val;
if (single_value->field_version.is_bound()) {
ret_val.version() = single_value->field_version.valueof();
}
if (single_value->field_signer__info.is_bound()) {
ret_val.signer__info() = single_value->field_signer__info.valueof();
}
if (single_value->field_subject__info.is_bound()) {
ret_val.subject__info() = single_value->field_subject__info.valueof();
}
if (single_value->field_subject__attributes.is_bound()) {
ret_val.subject__attributes() = single_value->field_subject__attributes.valueof();
}
if (single_value->field_validity__restrictions.is_bound()) {
ret_val.validity__restrictions() = single_value->field_validity__restrictions.valueof();
}
return ret_val;
}

void ToBeSignedCertificate_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new ToBeSignedCertificate_template[list_length];
}

ToBeSignedCertificate_template& ToBeSignedCertificate_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
return value_list.list_value[list_index];
}

INTEGER_template& ToBeSignedCertificate_template::version()
{
set_specific();
return single_value->field_version;
}

const INTEGER_template& ToBeSignedCertificate_template::version() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field version of a non-specific template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
return single_value->field_version;
}

SignerInfo_template& ToBeSignedCertificate_template::signer__info()
{
set_specific();
return single_value->field_signer__info;
}

const SignerInfo_template& ToBeSignedCertificate_template::signer__info() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field signer_info of a non-specific template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
return single_value->field_signer__info;
}

SubjectInfo_template& ToBeSignedCertificate_template::subject__info()
{
set_specific();
return single_value->field_subject__info;
}

const SubjectInfo_template& ToBeSignedCertificate_template::subject__info() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field subject_info of a non-specific template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
return single_value->field_subject__info;
}

SubjectAttributes_template& ToBeSignedCertificate_template::subject__attributes()
{
set_specific();
return single_value->field_subject__attributes;
}

const SubjectAttributes_template& ToBeSignedCertificate_template::subject__attributes() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field subject_attributes of a non-specific template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
return single_value->field_subject__attributes;
}

ValidityRestrictions_template& ToBeSignedCertificate_template::validity__restrictions()
{
set_specific();
return single_value->field_validity__restrictions;
}

const ValidityRestrictions_template& ToBeSignedCertificate_template::validity__restrictions() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field validity_restrictions of a non-specific template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
return single_value->field_validity__restrictions;
}

int ToBeSignedCertificate_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 5;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
  }
  return 0;
}

void ToBeSignedCertificate_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log();
TTCN_Logger::log_event_str(", signer_info := ");
single_value->field_signer__info.log();
TTCN_Logger::log_event_str(", subject_info := ");
single_value->field_subject__info.log();
TTCN_Logger::log_event_str(", subject_attributes := ");
single_value->field_subject__attributes.log();
TTCN_Logger::log_event_str(", validity_restrictions := ");
single_value->field_validity__restrictions.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void ToBeSignedCertificate_template::log_match(const ToBeSignedCertificate& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_version.match(match_value.version(), legacy)){
TTCN_Logger::log_logmatch_info(".version");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_signer__info.match(match_value.signer__info(), legacy)){
TTCN_Logger::log_logmatch_info(".signer_info");
single_value->field_signer__info.log_match(match_value.signer__info(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_subject__info.match(match_value.subject__info(), legacy)){
TTCN_Logger::log_logmatch_info(".subject_info");
single_value->field_subject__info.log_match(match_value.subject__info(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_subject__attributes.match(match_value.subject__attributes(), legacy)){
TTCN_Logger::log_logmatch_info(".subject_attributes");
single_value->field_subject__attributes.log_match(match_value.subject__attributes(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_validity__restrictions.match(match_value.validity__restrictions(), legacy)){
TTCN_Logger::log_logmatch_info(".validity_restrictions");
single_value->field_validity__restrictions.log_match(match_value.validity__restrictions(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ version := ");
single_value->field_version.log_match(match_value.version(), legacy);
TTCN_Logger::log_event_str(", signer_info := ");
single_value->field_signer__info.log_match(match_value.signer__info(), legacy);
TTCN_Logger::log_event_str(", subject_info := ");
single_value->field_subject__info.log_match(match_value.subject__info(), legacy);
TTCN_Logger::log_event_str(", subject_attributes := ");
single_value->field_subject__attributes.log_match(match_value.subject__attributes(), legacy);
TTCN_Logger::log_event_str(", validity_restrictions := ");
single_value->field_validity__restrictions.log_match(match_value.validity__restrictions(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void ToBeSignedCertificate_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_version.encode_text(text_buf);
single_value->field_signer__info.encode_text(text_buf);
single_value->field_subject__info.encode_text(text_buf);
single_value->field_subject__attributes.encode_text(text_buf);
single_value->field_validity__restrictions.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
}
}

void ToBeSignedCertificate_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_version.decode_text(text_buf);
single_value->field_signer__info.decode_text(text_buf);
single_value->field_subject__info.decode_text(text_buf);
single_value->field_subject__attributes.decode_text(text_buf);
single_value->field_validity__restrictions.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new ToBeSignedCertificate_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate.");
}
}

void ToBeSignedCertificate_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.ToBeSignedCertificate'");
    }
    if (strcmp("version", param_field) == 0) {
      version().set_param(param);
      return;
    } else if (strcmp("signer_info", param_field) == 0) {
      signer__info().set_param(param);
      return;
    } else if (strcmp("subject_info", param_field) == 0) {
      subject__info().set_param(param);
      return;
    } else if (strcmp("subject_attributes", param_field) == 0) {
      subject__attributes().set_param(param);
      return;
    } else if (strcmp("validity_restrictions", param_field) == 0) {
      validity__restrictions().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.ToBeSignedCertificate'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    ToBeSignedCertificate_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (5<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate has 5 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) version().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) signer__info().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) subject__info().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) subject__attributes().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) validity__restrictions().set_param(*mp->get_elem(4));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "version")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          version().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signer_info")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signer__info().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "subject_info")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          subject__info().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "subject_attributes")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          subject__attributes().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "validity_restrictions")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          validity__restrictions().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.ToBeSignedCertificate: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.ToBeSignedCertificate");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* ToBeSignedCertificate_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.ToBeSignedCertificate'");
    }
    if (strcmp("version", param_field) == 0) {
      return version().get_param(param_name);
    } else if (strcmp("signer_info", param_field) == 0) {
      return signer__info().get_param(param_name);
    } else if (strcmp("subject_info", param_field) == 0) {
      return subject__info().get_param(param_name);
    } else if (strcmp("subject_attributes", param_field) == 0) {
      return subject__attributes().get_param(param_name);
    } else if (strcmp("validity_restrictions", param_field) == 0) {
      return validity__restrictions().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.ToBeSignedCertificate'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_version = single_value->field_version.get_param(param_name);
    mp_field_version->set_id(new Module_Param_FieldName(mcopystr("version")));
    mp->add_elem(mp_field_version);
    Module_Param* mp_field_signer__info = single_value->field_signer__info.get_param(param_name);
    mp_field_signer__info->set_id(new Module_Param_FieldName(mcopystr("signer_info")));
    mp->add_elem(mp_field_signer__info);
    Module_Param* mp_field_subject__info = single_value->field_subject__info.get_param(param_name);
    mp_field_subject__info->set_id(new Module_Param_FieldName(mcopystr("subject_info")));
    mp->add_elem(mp_field_subject__info);
    Module_Param* mp_field_subject__attributes = single_value->field_subject__attributes.get_param(param_name);
    mp_field_subject__attributes->set_id(new Module_Param_FieldName(mcopystr("subject_attributes")));
    mp->add_elem(mp_field_subject__attributes);
    Module_Param* mp_field_validity__restrictions = single_value->field_validity__restrictions.get_param(param_name);
    mp_field_validity__restrictions->set_id(new Module_Param_FieldName(mcopystr("validity_restrictions")));
    mp->add_elem(mp_field_validity__restrictions);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void ToBeSignedCertificate_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_version.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ToBeSignedCertificate");
single_value->field_signer__info.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ToBeSignedCertificate");
single_value->field_subject__info.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ToBeSignedCertificate");
single_value->field_subject__attributes.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ToBeSignedCertificate");
single_value->field_validity__restrictions.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.ToBeSignedCertificate");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.ToBeSignedCertificate");
}

boolean ToBeSignedCertificate_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean ToBeSignedCertificate_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

TaConfig::TaConfig()
{
  bound_flag = FALSE;
}

TaConfig::TaConfig(const OCTETSTRING& par_signingPrivateKey,
    const OCTETSTRING& par_encryptPrivateKey,
    const Certificate& par_caCertificate,
    const Certificate& par_aaCertificate,
    const Certificate& par_atCertificate,
    const ThreeDLocation& par_location)
  :   field_signingPrivateKey(par_signingPrivateKey),
  field_encryptPrivateKey(par_encryptPrivateKey),
  field_caCertificate(par_caCertificate),
  field_aaCertificate(par_aaCertificate),
  field_atCertificate(par_atCertificate),
  field_location(par_location)
{
  bound_flag = TRUE;
}

TaConfig::TaConfig(const TaConfig& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.TaConfig.");
bound_flag = TRUE;
if (other_value.signingPrivateKey().is_bound()) field_signingPrivateKey = other_value.signingPrivateKey();
else field_signingPrivateKey.clean_up();
if (other_value.encryptPrivateKey().is_bound()) field_encryptPrivateKey = other_value.encryptPrivateKey();
else field_encryptPrivateKey.clean_up();
if (other_value.caCertificate().is_bound()) field_caCertificate = other_value.caCertificate();
else field_caCertificate.clean_up();
if (other_value.aaCertificate().is_bound()) field_aaCertificate = other_value.aaCertificate();
else field_aaCertificate.clean_up();
if (other_value.atCertificate().is_bound()) field_atCertificate = other_value.atCertificate();
else field_atCertificate.clean_up();
if (other_value.location().is_bound()) field_location = other_value.location();
else field_location.clean_up();
}

void TaConfig::clean_up()
{
field_signingPrivateKey.clean_up();
field_encryptPrivateKey.clean_up();
field_caCertificate.clean_up();
field_aaCertificate.clean_up();
field_atCertificate.clean_up();
field_location.clean_up();
bound_flag = FALSE;
}

TaConfig& TaConfig::operator=(const TaConfig& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.TaConfig.");
  bound_flag = TRUE;
  if (other_value.signingPrivateKey().is_bound()) field_signingPrivateKey = other_value.signingPrivateKey();
  else field_signingPrivateKey.clean_up();
  if (other_value.encryptPrivateKey().is_bound()) field_encryptPrivateKey = other_value.encryptPrivateKey();
  else field_encryptPrivateKey.clean_up();
  if (other_value.caCertificate().is_bound()) field_caCertificate = other_value.caCertificate();
  else field_caCertificate.clean_up();
  if (other_value.aaCertificate().is_bound()) field_aaCertificate = other_value.aaCertificate();
  else field_aaCertificate.clean_up();
  if (other_value.atCertificate().is_bound()) field_atCertificate = other_value.atCertificate();
  else field_atCertificate.clean_up();
  if (other_value.location().is_bound()) field_location = other_value.location();
  else field_location.clean_up();
}
return *this;
}

boolean TaConfig::operator==(const TaConfig& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_signingPrivateKey==other_value.field_signingPrivateKey
  && field_encryptPrivateKey==other_value.field_encryptPrivateKey
  && field_caCertificate==other_value.field_caCertificate
  && field_aaCertificate==other_value.field_aaCertificate
  && field_atCertificate==other_value.field_atCertificate
  && field_location==other_value.field_location;
}

boolean TaConfig::is_bound() const
{
if (bound_flag) return TRUE;
if(field_signingPrivateKey.is_bound()) return TRUE;
if(field_encryptPrivateKey.is_bound()) return TRUE;
if(field_caCertificate.is_bound()) return TRUE;
if(field_aaCertificate.is_bound()) return TRUE;
if(field_atCertificate.is_bound()) return TRUE;
if(field_location.is_bound()) return TRUE;
return FALSE;
}
boolean TaConfig::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_signingPrivateKey.is_value()) return FALSE;
if(!field_encryptPrivateKey.is_value()) return FALSE;
if(!field_caCertificate.is_value()) return FALSE;
if(!field_aaCertificate.is_value()) return FALSE;
if(!field_atCertificate.is_value()) return FALSE;
if(!field_location.is_value()) return FALSE;
return TRUE;
}
int TaConfig::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.TaConfig");
  return 6;
}

void TaConfig::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ signingPrivateKey := ");
field_signingPrivateKey.log();
TTCN_Logger::log_event_str(", encryptPrivateKey := ");
field_encryptPrivateKey.log();
TTCN_Logger::log_event_str(", caCertificate := ");
field_caCertificate.log();
TTCN_Logger::log_event_str(", aaCertificate := ");
field_aaCertificate.log();
TTCN_Logger::log_event_str(", atCertificate := ");
field_atCertificate.log();
TTCN_Logger::log_event_str(", location := ");
field_location.log();
TTCN_Logger::log_event_str(" }");
}

void TaConfig::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.TaConfig'");
    }
    if (strcmp("signingPrivateKey", param_field) == 0) {
      signingPrivateKey().set_param(param);
      return;
    } else if (strcmp("encryptPrivateKey", param_field) == 0) {
      encryptPrivateKey().set_param(param);
      return;
    } else if (strcmp("caCertificate", param_field) == 0) {
      caCertificate().set_param(param);
      return;
    } else if (strcmp("aaCertificate", param_field) == 0) {
      aaCertificate().set_param(param);
      return;
    } else if (strcmp("atCertificate", param_field) == 0) {
      atCertificate().set_param(param);
      return;
    } else if (strcmp("location", param_field) == 0) {
      location().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.TaConfig'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.TaConfig has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) signingPrivateKey().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) encryptPrivateKey().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) caCertificate().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) aaCertificate().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) atCertificate().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) location().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signingPrivateKey")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signingPrivateKey().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "encryptPrivateKey")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          encryptPrivateKey().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "caCertificate")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          caCertificate().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "aaCertificate")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          aaCertificate().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "atCertificate")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          atCertificate().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "location")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          location().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.TaConfig: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.TaConfig");
  }
}

Module_Param* TaConfig::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.TaConfig'");
    }
    if (strcmp("signingPrivateKey", param_field) == 0) {
      return signingPrivateKey().get_param(param_name);
    } else if (strcmp("encryptPrivateKey", param_field) == 0) {
      return encryptPrivateKey().get_param(param_name);
    } else if (strcmp("caCertificate", param_field) == 0) {
      return caCertificate().get_param(param_name);
    } else if (strcmp("aaCertificate", param_field) == 0) {
      return aaCertificate().get_param(param_name);
    } else if (strcmp("atCertificate", param_field) == 0) {
      return atCertificate().get_param(param_name);
    } else if (strcmp("location", param_field) == 0) {
      return location().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.TaConfig'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_signingPrivateKey = field_signingPrivateKey.get_param(param_name);
  mp_field_signingPrivateKey->set_id(new Module_Param_FieldName(mcopystr("signingPrivateKey")));
  mp->add_elem(mp_field_signingPrivateKey);
  Module_Param* mp_field_encryptPrivateKey = field_encryptPrivateKey.get_param(param_name);
  mp_field_encryptPrivateKey->set_id(new Module_Param_FieldName(mcopystr("encryptPrivateKey")));
  mp->add_elem(mp_field_encryptPrivateKey);
  Module_Param* mp_field_caCertificate = field_caCertificate.get_param(param_name);
  mp_field_caCertificate->set_id(new Module_Param_FieldName(mcopystr("caCertificate")));
  mp->add_elem(mp_field_caCertificate);
  Module_Param* mp_field_aaCertificate = field_aaCertificate.get_param(param_name);
  mp_field_aaCertificate->set_id(new Module_Param_FieldName(mcopystr("aaCertificate")));
  mp->add_elem(mp_field_aaCertificate);
  Module_Param* mp_field_atCertificate = field_atCertificate.get_param(param_name);
  mp_field_atCertificate->set_id(new Module_Param_FieldName(mcopystr("atCertificate")));
  mp->add_elem(mp_field_atCertificate);
  Module_Param* mp_field_location = field_location.get_param(param_name);
  mp_field_location->set_id(new Module_Param_FieldName(mcopystr("location")));
  mp->add_elem(mp_field_location);
  return mp;
  }

void TaConfig::set_implicit_omit()
{
if (signingPrivateKey().is_bound()) signingPrivateKey().set_implicit_omit();
if (encryptPrivateKey().is_bound()) encryptPrivateKey().set_implicit_omit();
if (caCertificate().is_bound()) caCertificate().set_implicit_omit();
if (aaCertificate().is_bound()) aaCertificate().set_implicit_omit();
if (atCertificate().is_bound()) atCertificate().set_implicit_omit();
if (location().is_bound()) location().set_implicit_omit();
}

void TaConfig::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.TaConfig.");
field_signingPrivateKey.encode_text(text_buf);
field_encryptPrivateKey.encode_text(text_buf);
field_caCertificate.encode_text(text_buf);
field_aaCertificate.encode_text(text_buf);
field_atCertificate.encode_text(text_buf);
field_location.encode_text(text_buf);
}

void TaConfig::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_signingPrivateKey.decode_text(text_buf);
field_encryptPrivateKey.decode_text(text_buf);
field_caCertificate.decode_text(text_buf);
field_aaCertificate.decode_text(text_buf);
field_atCertificate.decode_text(text_buf);
field_location.decode_text(text_buf);
}

void TaConfig::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void TaConfig::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int TaConfig::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_signingPrivateKey.RAW_decode(LibCommon__DataStrings::Oct32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_encryptPrivateKey.RAW_decode(LibCommon__DataStrings::Oct32_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_caCertificate.RAW_decode(Certificate_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_aaCertificate.RAW_decode(Certificate_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_atCertificate.RAW_decode(Certificate_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  decoded_field_length = field_location.RAW_decode(ThreeDLocation_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int TaConfig::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 6;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(6);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, LibCommon__DataStrings::Oct32_descr_.raw);
  myleaf.body.node.nodes[1] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 1, LibCommon__DataStrings::Oct32_descr_.raw);
  myleaf.body.node.nodes[2] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 2, Certificate_descr_.raw);
  myleaf.body.node.nodes[3] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 3, Certificate_descr_.raw);
  myleaf.body.node.nodes[4] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 4, Certificate_descr_.raw);
  myleaf.body.node.nodes[5] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 5, ThreeDLocation_descr_.raw);
  encoded_length += field_signingPrivateKey.RAW_encode(LibCommon__DataStrings::Oct32_descr_, *myleaf.body.node.nodes[0]);
  encoded_length += field_encryptPrivateKey.RAW_encode(LibCommon__DataStrings::Oct32_descr_, *myleaf.body.node.nodes[1]);
  encoded_length += field_caCertificate.RAW_encode(Certificate_descr_, *myleaf.body.node.nodes[2]);
  encoded_length += field_aaCertificate.RAW_encode(Certificate_descr_, *myleaf.body.node.nodes[3]);
  encoded_length += field_atCertificate.RAW_encode(Certificate_descr_, *myleaf.body.node.nodes[4]);
  encoded_length += field_location.RAW_encode(ThreeDLocation_descr_, *myleaf.body.node.nodes[5]);
  return myleaf.length = encoded_length;
}

int TaConfig::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.TaConfig.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "signingPrivateKey");
    enc_len += field_signingPrivateKey.JSON_encode(LibCommon__DataStrings::Oct32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "encryptPrivateKey");
    enc_len += field_encryptPrivateKey.JSON_encode(LibCommon__DataStrings::Oct32_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "caCertificate");
    enc_len += field_caCertificate.JSON_encode(Certificate_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "aaCertificate");
    enc_len += field_aaCertificate.JSON_encode(Certificate_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "atCertificate");
    enc_len += field_atCertificate.JSON_encode(Certificate_descr_, p_tok);
  }

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "location");
    enc_len += field_location.JSON_encode(ThreeDLocation_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int TaConfig::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (17 == name_len && 0 == strncmp(fld_name, "signingPrivateKey", name_len)) {
         int ret_val = field_signingPrivateKey.JSON_decode(LibCommon__DataStrings::Oct32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "signingPrivateKey");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (17 == name_len && 0 == strncmp(fld_name, "encryptPrivateKey", name_len)) {
         int ret_val = field_encryptPrivateKey.JSON_decode(LibCommon__DataStrings::Oct32_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "encryptPrivateKey");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "caCertificate", name_len)) {
         int ret_val = field_caCertificate.JSON_decode(Certificate_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "caCertificate");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "aaCertificate", name_len)) {
         int ret_val = field_aaCertificate.JSON_decode(Certificate_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "aaCertificate");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (13 == name_len && 0 == strncmp(fld_name, "atCertificate", name_len)) {
         int ret_val = field_atCertificate.JSON_decode(Certificate_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "atCertificate");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else if (8 == name_len && 0 == strncmp(fld_name, "location", name_len)) {
         int ret_val = field_location.JSON_decode(ThreeDLocation_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "location");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_signingPrivateKey.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "signingPrivateKey");
    return JSON_ERROR_FATAL;
  }
if (!field_encryptPrivateKey.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "encryptPrivateKey");
    return JSON_ERROR_FATAL;
  }
if (!field_caCertificate.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "caCertificate");
    return JSON_ERROR_FATAL;
  }
if (!field_aaCertificate.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "aaCertificate");
    return JSON_ERROR_FATAL;
  }
if (!field_atCertificate.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "atCertificate");
    return JSON_ERROR_FATAL;
  }
if (!field_location.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "location");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct TaConfig_template::single_value_struct {
OCTETSTRING_template field_signingPrivateKey;
OCTETSTRING_template field_encryptPrivateKey;
Certificate_template field_caCertificate;
Certificate_template field_aaCertificate;
Certificate_template field_atCertificate;
ThreeDLocation_template field_location;
};

void TaConfig_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_signingPrivateKey = ANY_VALUE;
single_value->field_encryptPrivateKey = ANY_VALUE;
single_value->field_caCertificate = ANY_VALUE;
single_value->field_aaCertificate = ANY_VALUE;
single_value->field_atCertificate = ANY_VALUE;
single_value->field_location = ANY_VALUE;
}
}
}

void TaConfig_template::copy_value(const TaConfig& other_value)
{
single_value = new single_value_struct;
if (other_value.signingPrivateKey().is_bound()) {
  single_value->field_signingPrivateKey = other_value.signingPrivateKey();
} else {
  single_value->field_signingPrivateKey.clean_up();
}
if (other_value.encryptPrivateKey().is_bound()) {
  single_value->field_encryptPrivateKey = other_value.encryptPrivateKey();
} else {
  single_value->field_encryptPrivateKey.clean_up();
}
if (other_value.caCertificate().is_bound()) {
  single_value->field_caCertificate = other_value.caCertificate();
} else {
  single_value->field_caCertificate.clean_up();
}
if (other_value.aaCertificate().is_bound()) {
  single_value->field_aaCertificate = other_value.aaCertificate();
} else {
  single_value->field_aaCertificate.clean_up();
}
if (other_value.atCertificate().is_bound()) {
  single_value->field_atCertificate = other_value.atCertificate();
} else {
  single_value->field_atCertificate.clean_up();
}
if (other_value.location().is_bound()) {
  single_value->field_location = other_value.location();
} else {
  single_value->field_location.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void TaConfig_template::copy_template(const TaConfig_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.signingPrivateKey().get_selection()) {
single_value->field_signingPrivateKey = other_value.signingPrivateKey();
} else {
single_value->field_signingPrivateKey.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.encryptPrivateKey().get_selection()) {
single_value->field_encryptPrivateKey = other_value.encryptPrivateKey();
} else {
single_value->field_encryptPrivateKey.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.caCertificate().get_selection()) {
single_value->field_caCertificate = other_value.caCertificate();
} else {
single_value->field_caCertificate.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.aaCertificate().get_selection()) {
single_value->field_aaCertificate = other_value.aaCertificate();
} else {
single_value->field_aaCertificate.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.atCertificate().get_selection()) {
single_value->field_atCertificate = other_value.atCertificate();
} else {
single_value->field_atCertificate.clean_up();
}
if (UNINITIALIZED_TEMPLATE != other_value.location().get_selection()) {
single_value->field_location = other_value.location();
} else {
single_value->field_location.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TaConfig_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TaConfig.");
break;
}
set_selection(other_value);
}

TaConfig_template::TaConfig_template()
{
}

TaConfig_template::TaConfig_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

TaConfig_template::TaConfig_template(const TaConfig& other_value)
{
copy_value(other_value);
}

TaConfig_template::TaConfig_template(const OPTIONAL<TaConfig>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TaConfig&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.TaConfig from an unbound optional field.");
}
}

TaConfig_template::TaConfig_template(const TaConfig_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

TaConfig_template::~TaConfig_template()
{
clean_up();
}

TaConfig_template& TaConfig_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TaConfig_template& TaConfig_template::operator=(const TaConfig& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

TaConfig_template& TaConfig_template::operator=(const OPTIONAL<TaConfig>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TaConfig&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.TaConfig.");
}
return *this;
}

TaConfig_template& TaConfig_template::operator=(const TaConfig_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean TaConfig_template::match(const TaConfig& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.signingPrivateKey().is_bound()) return FALSE;
if(!single_value->field_signingPrivateKey.match(other_value.signingPrivateKey(), legacy))return FALSE;
if(!other_value.encryptPrivateKey().is_bound()) return FALSE;
if(!single_value->field_encryptPrivateKey.match(other_value.encryptPrivateKey(), legacy))return FALSE;
if(!other_value.caCertificate().is_bound()) return FALSE;
if(!single_value->field_caCertificate.match(other_value.caCertificate(), legacy))return FALSE;
if(!other_value.aaCertificate().is_bound()) return FALSE;
if(!single_value->field_aaCertificate.match(other_value.aaCertificate(), legacy))return FALSE;
if(!other_value.atCertificate().is_bound()) return FALSE;
if(!single_value->field_atCertificate.match(other_value.atCertificate(), legacy))return FALSE;
if(!other_value.location().is_bound()) return FALSE;
if(!single_value->field_location.match(other_value.location(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TaConfig.");
}
return FALSE;
}

boolean TaConfig_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_signingPrivateKey.is_bound()) return TRUE;
if (single_value->field_encryptPrivateKey.is_bound()) return TRUE;
if (single_value->field_caCertificate.is_bound()) return TRUE;
if (single_value->field_aaCertificate.is_bound()) return TRUE;
if (single_value->field_atCertificate.is_bound()) return TRUE;
if (single_value->field_location.is_bound()) return TRUE;
return FALSE;
}

boolean TaConfig_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_signingPrivateKey.is_value()) return FALSE;
if (!single_value->field_encryptPrivateKey.is_value()) return FALSE;
if (!single_value->field_caCertificate.is_value()) return FALSE;
if (!single_value->field_aaCertificate.is_value()) return FALSE;
if (!single_value->field_atCertificate.is_value()) return FALSE;
if (!single_value->field_location.is_value()) return FALSE;
return TRUE;
}

void TaConfig_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

TaConfig TaConfig_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.TaConfig.");
TaConfig ret_val;
if (single_value->field_signingPrivateKey.is_bound()) {
ret_val.signingPrivateKey() = single_value->field_signingPrivateKey.valueof();
}
if (single_value->field_encryptPrivateKey.is_bound()) {
ret_val.encryptPrivateKey() = single_value->field_encryptPrivateKey.valueof();
}
if (single_value->field_caCertificate.is_bound()) {
ret_val.caCertificate() = single_value->field_caCertificate.valueof();
}
if (single_value->field_aaCertificate.is_bound()) {
ret_val.aaCertificate() = single_value->field_aaCertificate.valueof();
}
if (single_value->field_atCertificate.is_bound()) {
ret_val.atCertificate() = single_value->field_atCertificate.valueof();
}
if (single_value->field_location.is_bound()) {
ret_val.location() = single_value->field_location.valueof();
}
return ret_val;
}

void TaConfig_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.TaConfig.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new TaConfig_template[list_length];
}

TaConfig_template& TaConfig_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.TaConfig.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.TaConfig.");
return value_list.list_value[list_index];
}

OCTETSTRING_template& TaConfig_template::signingPrivateKey()
{
set_specific();
return single_value->field_signingPrivateKey;
}

const OCTETSTRING_template& TaConfig_template::signingPrivateKey() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field signingPrivateKey of a non-specific template of type @LibItsSecurity_TypesAndValues.TaConfig.");
return single_value->field_signingPrivateKey;
}

OCTETSTRING_template& TaConfig_template::encryptPrivateKey()
{
set_specific();
return single_value->field_encryptPrivateKey;
}

const OCTETSTRING_template& TaConfig_template::encryptPrivateKey() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field encryptPrivateKey of a non-specific template of type @LibItsSecurity_TypesAndValues.TaConfig.");
return single_value->field_encryptPrivateKey;
}

Certificate_template& TaConfig_template::caCertificate()
{
set_specific();
return single_value->field_caCertificate;
}

const Certificate_template& TaConfig_template::caCertificate() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field caCertificate of a non-specific template of type @LibItsSecurity_TypesAndValues.TaConfig.");
return single_value->field_caCertificate;
}

Certificate_template& TaConfig_template::aaCertificate()
{
set_specific();
return single_value->field_aaCertificate;
}

const Certificate_template& TaConfig_template::aaCertificate() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field aaCertificate of a non-specific template of type @LibItsSecurity_TypesAndValues.TaConfig.");
return single_value->field_aaCertificate;
}

Certificate_template& TaConfig_template::atCertificate()
{
set_specific();
return single_value->field_atCertificate;
}

const Certificate_template& TaConfig_template::atCertificate() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field atCertificate of a non-specific template of type @LibItsSecurity_TypesAndValues.TaConfig.");
return single_value->field_atCertificate;
}

ThreeDLocation_template& TaConfig_template::location()
{
set_specific();
return single_value->field_location;
}

const ThreeDLocation_template& TaConfig_template::location() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field location of a non-specific template of type @LibItsSecurity_TypesAndValues.TaConfig.");
return single_value->field_location;
}

int TaConfig_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TaConfig which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 6;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TaConfig containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TaConfig containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TaConfig containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TaConfig containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.TaConfig containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TaConfig.");
  }
  return 0;
}

void TaConfig_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ signingPrivateKey := ");
single_value->field_signingPrivateKey.log();
TTCN_Logger::log_event_str(", encryptPrivateKey := ");
single_value->field_encryptPrivateKey.log();
TTCN_Logger::log_event_str(", caCertificate := ");
single_value->field_caCertificate.log();
TTCN_Logger::log_event_str(", aaCertificate := ");
single_value->field_aaCertificate.log();
TTCN_Logger::log_event_str(", atCertificate := ");
single_value->field_atCertificate.log();
TTCN_Logger::log_event_str(", location := ");
single_value->field_location.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void TaConfig_template::log_match(const TaConfig& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_signingPrivateKey.match(match_value.signingPrivateKey(), legacy)){
TTCN_Logger::log_logmatch_info(".signingPrivateKey");
single_value->field_signingPrivateKey.log_match(match_value.signingPrivateKey(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_encryptPrivateKey.match(match_value.encryptPrivateKey(), legacy)){
TTCN_Logger::log_logmatch_info(".encryptPrivateKey");
single_value->field_encryptPrivateKey.log_match(match_value.encryptPrivateKey(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_caCertificate.match(match_value.caCertificate(), legacy)){
TTCN_Logger::log_logmatch_info(".caCertificate");
single_value->field_caCertificate.log_match(match_value.caCertificate(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_aaCertificate.match(match_value.aaCertificate(), legacy)){
TTCN_Logger::log_logmatch_info(".aaCertificate");
single_value->field_aaCertificate.log_match(match_value.aaCertificate(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_atCertificate.match(match_value.atCertificate(), legacy)){
TTCN_Logger::log_logmatch_info(".atCertificate");
single_value->field_atCertificate.log_match(match_value.atCertificate(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
if(!single_value->field_location.match(match_value.location(), legacy)){
TTCN_Logger::log_logmatch_info(".location");
single_value->field_location.log_match(match_value.location(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ signingPrivateKey := ");
single_value->field_signingPrivateKey.log_match(match_value.signingPrivateKey(), legacy);
TTCN_Logger::log_event_str(", encryptPrivateKey := ");
single_value->field_encryptPrivateKey.log_match(match_value.encryptPrivateKey(), legacy);
TTCN_Logger::log_event_str(", caCertificate := ");
single_value->field_caCertificate.log_match(match_value.caCertificate(), legacy);
TTCN_Logger::log_event_str(", aaCertificate := ");
single_value->field_aaCertificate.log_match(match_value.aaCertificate(), legacy);
TTCN_Logger::log_event_str(", atCertificate := ");
single_value->field_atCertificate.log_match(match_value.atCertificate(), legacy);
TTCN_Logger::log_event_str(", location := ");
single_value->field_location.log_match(match_value.location(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void TaConfig_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_signingPrivateKey.encode_text(text_buf);
single_value->field_encryptPrivateKey.encode_text(text_buf);
single_value->field_caCertificate.encode_text(text_buf);
single_value->field_aaCertificate.encode_text(text_buf);
single_value->field_atCertificate.encode_text(text_buf);
single_value->field_location.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TaConfig.");
}
}

void TaConfig_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_signingPrivateKey.decode_text(text_buf);
single_value->field_encryptPrivateKey.decode_text(text_buf);
single_value->field_caCertificate.decode_text(text_buf);
single_value->field_aaCertificate.decode_text(text_buf);
single_value->field_atCertificate.decode_text(text_buf);
single_value->field_location.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TaConfig_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.TaConfig.");
}
}

void TaConfig_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.TaConfig'");
    }
    if (strcmp("signingPrivateKey", param_field) == 0) {
      signingPrivateKey().set_param(param);
      return;
    } else if (strcmp("encryptPrivateKey", param_field) == 0) {
      encryptPrivateKey().set_param(param);
      return;
    } else if (strcmp("caCertificate", param_field) == 0) {
      caCertificate().set_param(param);
      return;
    } else if (strcmp("aaCertificate", param_field) == 0) {
      aaCertificate().set_param(param);
      return;
    } else if (strcmp("atCertificate", param_field) == 0) {
      atCertificate().set_param(param);
      return;
    } else if (strcmp("location", param_field) == 0) {
      location().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.TaConfig'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TaConfig_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (6<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.TaConfig has 6 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) signingPrivateKey().set_param(*mp->get_elem(0));
    if (mp->get_size()>1 && mp->get_elem(1)->get_type()!=Module_Param::MP_NotUsed) encryptPrivateKey().set_param(*mp->get_elem(1));
    if (mp->get_size()>2 && mp->get_elem(2)->get_type()!=Module_Param::MP_NotUsed) caCertificate().set_param(*mp->get_elem(2));
    if (mp->get_size()>3 && mp->get_elem(3)->get_type()!=Module_Param::MP_NotUsed) aaCertificate().set_param(*mp->get_elem(3));
    if (mp->get_size()>4 && mp->get_elem(4)->get_type()!=Module_Param::MP_NotUsed) atCertificate().set_param(*mp->get_elem(4));
    if (mp->get_size()>5 && mp->get_elem(5)->get_type()!=Module_Param::MP_NotUsed) location().set_param(*mp->get_elem(5));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "signingPrivateKey")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          signingPrivateKey().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "encryptPrivateKey")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          encryptPrivateKey().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "caCertificate")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          caCertificate().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "aaCertificate")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          aaCertificate().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "atCertificate")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          atCertificate().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "location")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          location().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.TaConfig: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.TaConfig");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* TaConfig_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.TaConfig'");
    }
    if (strcmp("signingPrivateKey", param_field) == 0) {
      return signingPrivateKey().get_param(param_name);
    } else if (strcmp("encryptPrivateKey", param_field) == 0) {
      return encryptPrivateKey().get_param(param_name);
    } else if (strcmp("caCertificate", param_field) == 0) {
      return caCertificate().get_param(param_name);
    } else if (strcmp("aaCertificate", param_field) == 0) {
      return aaCertificate().get_param(param_name);
    } else if (strcmp("atCertificate", param_field) == 0) {
      return atCertificate().get_param(param_name);
    } else if (strcmp("location", param_field) == 0) {
      return location().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.TaConfig'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_signingPrivateKey = single_value->field_signingPrivateKey.get_param(param_name);
    mp_field_signingPrivateKey->set_id(new Module_Param_FieldName(mcopystr("signingPrivateKey")));
    mp->add_elem(mp_field_signingPrivateKey);
    Module_Param* mp_field_encryptPrivateKey = single_value->field_encryptPrivateKey.get_param(param_name);
    mp_field_encryptPrivateKey->set_id(new Module_Param_FieldName(mcopystr("encryptPrivateKey")));
    mp->add_elem(mp_field_encryptPrivateKey);
    Module_Param* mp_field_caCertificate = single_value->field_caCertificate.get_param(param_name);
    mp_field_caCertificate->set_id(new Module_Param_FieldName(mcopystr("caCertificate")));
    mp->add_elem(mp_field_caCertificate);
    Module_Param* mp_field_aaCertificate = single_value->field_aaCertificate.get_param(param_name);
    mp_field_aaCertificate->set_id(new Module_Param_FieldName(mcopystr("aaCertificate")));
    mp->add_elem(mp_field_aaCertificate);
    Module_Param* mp_field_atCertificate = single_value->field_atCertificate.get_param(param_name);
    mp_field_atCertificate->set_id(new Module_Param_FieldName(mcopystr("atCertificate")));
    mp->add_elem(mp_field_atCertificate);
    Module_Param* mp_field_location = single_value->field_location.get_param(param_name);
    mp_field_location->set_id(new Module_Param_FieldName(mcopystr("location")));
    mp->add_elem(mp_field_location);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void TaConfig_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_signingPrivateKey.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TaConfig");
single_value->field_encryptPrivateKey.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TaConfig");
single_value->field_caCertificate.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TaConfig");
single_value->field_aaCertificate.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TaConfig");
single_value->field_atCertificate.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TaConfig");
single_value->field_location.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TaConfig");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.TaConfig");
}

boolean TaConfig_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TaConfig_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


const TaConfig TaConfigs::UNBOUND_ELEM;
boolean TaConfigs::compare_function(const Base_Type *left_ptr, int left_index, const Base_Type *right_ptr, int right_index)
{
if (((const TaConfigs*)left_ptr)->val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
if (((const TaConfigs*)right_ptr)->val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
if (((const TaConfigs*)left_ptr)->val_ptr->value_elements[left_index] != NULL){
if (((const TaConfigs*)right_ptr)->val_ptr->value_elements[right_index] != NULL){
return *((const TaConfigs*)left_ptr)->val_ptr->value_elements[left_index] == *((const TaConfigs*)right_ptr)->val_ptr->value_elements[right_index];
} else return FALSE;
} else {
return ((const TaConfigs*)right_ptr)->val_ptr->value_elements[right_index] == NULL;
}
}

TaConfigs::TaConfigs()
{
val_ptr = NULL;
}

TaConfigs::TaConfigs(null_type)
{
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
}

TaConfigs::TaConfigs(const TaConfigs& other_value)
{
if (!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}

TaConfigs::~TaConfigs()
{
clean_up();
if (val_ptr != NULL) val_ptr = NULL;
}

void TaConfigs::clean_up()
{
if (val_ptr != NULL) {
if (val_ptr->ref_count > 1) {
val_ptr->ref_count--;
val_ptr = NULL;
}
else if (val_ptr->ref_count == 1) {
for (int elem_count = 0; elem_count < val_ptr->n_elements;
elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)
delete val_ptr->value_elements[elem_count];
free_pointers((void**)val_ptr->value_elements);
delete val_ptr;
val_ptr = NULL;
}
else
TTCN_error("Internal error: Invalid reference counter in a record of/set of value.");
}
}

TaConfigs& TaConfigs::operator=(null_type)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
return *this;
}

TaConfigs& TaConfigs::operator=(const TaConfigs& other_value)
{
if (other_value.val_ptr == NULL) TTCN_error("Assigning an unbound value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
if (this != &other_value) {
clean_up();
val_ptr = other_value.val_ptr;
val_ptr->ref_count++;
}
return *this;
}

boolean TaConfigs::operator==(null_type) const
{
if (val_ptr == NULL)
TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
return val_ptr->n_elements == 0 ;
}

boolean TaConfigs::operator==(const TaConfigs& other_value) const
{
if (val_ptr == NULL) TTCN_error("The left operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
if (other_value.val_ptr == NULL) TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
if (val_ptr == other_value.val_ptr) return TRUE;
return compare_set_of(this, val_ptr->n_elements, &other_value, (other_value.val_ptr)->n_elements, compare_function);
}

TaConfig& TaConfigs::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.TaConfigs using a negative index: %d.", index_value);
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (index_value >= val_ptr->n_elements) ? index_value + 1 : val_ptr->n_elements;
new_val_ptr->value_elements = (TaConfig**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++){
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new TaConfig(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (index_value >= val_ptr->n_elements) set_size(index_value + 1);
if (val_ptr->value_elements[index_value] == NULL) {
val_ptr->value_elements[index_value] = new TaConfig;
}
return *val_ptr->value_elements[index_value];
}

TaConfig& TaConfigs::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
return (*this)[(int)index_value];
}

const TaConfig& TaConfigs::operator[](int index_value) const
{
if (val_ptr == NULL)
TTCN_error("Accessing an element in an unbound value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
if (index_value < 0) TTCN_error("Accessing an element of type @LibItsSecurity_TypesAndValues.TaConfigs using a negative index: %d.", index_value);
if (index_value >= val_ptr->n_elements) TTCN_error("Index overflow in a value of type @LibItsSecurity_TypesAndValues.TaConfigs: The index is %d, but the value has only %d elements.", index_value, val_ptr->n_elements);
return (val_ptr->value_elements[index_value] != NULL) ?
*val_ptr->value_elements[index_value] : UNBOUND_ELEM;
}

const TaConfig& TaConfigs::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
return (*this)[(int)index_value];
}

TaConfigs TaConfigs::operator<<=(int rotate_count) const
{
return *this >>= (-rotate_count);
}

TaConfigs TaConfigs::operator<<=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate left operator.");
return *this >>= (int)(-rotate_count);
}

TaConfigs TaConfigs::operator>>=(const INTEGER& rotate_count) const
{
rotate_count.must_bound("Unbound integer operand of rotate right operator.");
return *this >>= (int)rotate_count;
}

TaConfigs TaConfigs::operator>>=(int rotate_count) const
{
if (val_ptr == NULL) TTCN_error("Performing rotation operation on an unbound value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
if (val_ptr->n_elements == 0) return *this;
int rc;
if (rotate_count>=0) rc = rotate_count % val_ptr->n_elements;
else rc = val_ptr->n_elements - ((-rotate_count) % val_ptr->n_elements);
if (rc == 0) return *this;
TaConfigs ret_val;
ret_val.set_size(val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[(i+rc)%val_ptr->n_elements] =new TaConfig(*val_ptr->value_elements[i]);
}
}
return ret_val;
}

TaConfigs TaConfigs::operator+(const TaConfigs& other_value) const
{
if (val_ptr == NULL || other_value.val_ptr == NULL) TTCN_error("Unbound operand of @LibItsSecurity_TypesAndValues.TaConfigs concatenation.");
if (val_ptr->n_elements == 0) return other_value;
if (other_value.val_ptr->n_elements == 0) return *this;
TaConfigs ret_val;
ret_val.set_size(val_ptr->n_elements+other_value.val_ptr->n_elements);
for (int i=0; i<val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new TaConfig(*val_ptr->value_elements[i]);
}
}
for (int i=0; i<other_value.val_ptr->n_elements; i++) {
if (other_value.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+val_ptr->n_elements] = new TaConfig(*other_value.val_ptr->value_elements[i]);
}
}
return ret_val;
}

TaConfigs TaConfigs::substr(int index, int returncount) const
{
if (val_ptr == NULL) TTCN_error("The first argument of substr() is an unbound value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
check_substr_arguments(val_ptr->n_elements, index, returncount, "@LibItsSecurity_TypesAndValues.TaConfigs","element");
TaConfigs ret_val;
ret_val.set_size(returncount);
for (int i=0; i<returncount; i++) {
if (val_ptr->value_elements[i+index] != NULL) {
ret_val.val_ptr->value_elements[i] = new TaConfig(*val_ptr->value_elements[i+index]);
}
}
return ret_val;
}

TaConfigs TaConfigs::replace(int index, int len, const TaConfigs& repl) const
{
if (val_ptr == NULL) TTCN_error("The first argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
if (repl.val_ptr == NULL) TTCN_error("The fourth argument of replace() is an unbound value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
check_replace_arguments(val_ptr->n_elements, index, len, "@LibItsSecurity_TypesAndValues.TaConfigs","element");
TaConfigs ret_val;
ret_val.set_size(val_ptr->n_elements + repl.val_ptr->n_elements - len);
for (int i = 0; i < index; i++) {
if (val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i] = new TaConfig(*val_ptr->value_elements[i]);
}
}
for (int i = 0; i < repl.val_ptr->n_elements; i++) {
if (repl.val_ptr->value_elements[i] != NULL) {
ret_val.val_ptr->value_elements[i+index] = new TaConfig(*repl.val_ptr->value_elements[i]);
}
}
for (int i = 0; i < val_ptr->n_elements - index - len; i++) {
if (val_ptr->value_elements[index+i+len] != NULL) {
ret_val.val_ptr->value_elements[index+i+repl.val_ptr->n_elements] = new TaConfig(*val_ptr->value_elements[index+i+len]);
}
}
return ret_val;
}

TaConfigs TaConfigs::replace(int index, int len, const TaConfigs_template& repl) const
{
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return replace(index, len, repl.valueof());
}

void TaConfigs::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
if (val_ptr == NULL) {
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = 0;
val_ptr->value_elements = NULL;
} else if (val_ptr->ref_count > 1) {
struct recordof_setof_struct *new_val_ptr = new recordof_setof_struct;
new_val_ptr->ref_count = 1;
new_val_ptr->n_elements = (new_size < val_ptr->n_elements) ? new_size : val_ptr->n_elements;
new_val_ptr->value_elements = (TaConfig**)allocate_pointers(new_val_ptr->n_elements);
for (int elem_count = 0; elem_count < new_val_ptr->n_elements; elem_count++) {
if (val_ptr->value_elements[elem_count] != NULL){
new_val_ptr->value_elements[elem_count] = new TaConfig(*(val_ptr->value_elements[elem_count]));
}
}
clean_up();
val_ptr = new_val_ptr;
}
if (new_size > val_ptr->n_elements) {
val_ptr->value_elements = (TaConfig**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
#ifdef TITAN_MEMORY_DEBUG_SET_RECORD_OF
if((val_ptr->n_elements/1000)!=(new_size/1000)) TTCN_warning("New size of type @LibItsSecurity_TypesAndValues.TaConfigs: %d",new_size);
#endif
val_ptr->n_elements = new_size;
} else if (new_size < val_ptr->n_elements) {
for (int elem_count = new_size; elem_count < val_ptr->n_elements; elem_count++)
if (val_ptr->value_elements[elem_count] != NULL)delete val_ptr->value_elements[elem_count];
val_ptr->value_elements = (TaConfig**)reallocate_pointers((void**)val_ptr->value_elements, val_ptr->n_elements, new_size);
val_ptr->n_elements = new_size;
}
}

boolean TaConfigs::is_value() const
{
if (val_ptr == NULL) return false;
for(int i = 0; i < val_ptr->n_elements; ++i) {
if (val_ptr->value_elements[i] == NULL || !val_ptr->value_elements[i]->is_value()) return FALSE;
}
return TRUE;
}

int TaConfigs::size_of() const
{
if (val_ptr == NULL) TTCN_error("Performing sizeof operation on an unbound value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
return val_ptr->n_elements;
}

int TaConfigs::lengthof() const
{
if (val_ptr == NULL) TTCN_error("Performing lengthof operation on an unbound value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
for (int my_length=val_ptr->n_elements; my_length>0; my_length--) if (val_ptr->value_elements[my_length-1] != NULL) return my_length;
return 0;
}

void TaConfigs::log() const
{
if (val_ptr == NULL) {;
TTCN_Logger::log_event_unbound();
return;
}
switch (val_ptr->n_elements) {
case 0:
TTCN_Logger::log_event_str("{ }");
break;
default:
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
(*this)[elem_count].log();
}
TTCN_Logger::log_event_str(" }");
}
}

void TaConfigs::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set of type `@LibItsSecurity_TypesAndValues.TaConfigs'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_VALUE|Module_Param::BC_LIST, "set of value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (param.get_operation_type()) {
  case Module_Param::OT_ASSIGN:
    if (mp->get_type()==Module_Param::MP_Value_List && mp->get_size()==0) {
      *this = NULL_VALUE;
      return;
    }
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List:
      set_size(mp->get_size());
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if (curr->get_type()!=Module_Param::MP_NotUsed) {
          (*this)[i].set_param(*curr);
        }
      }
      break;
    case Module_Param::MP_Indexed_List:
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        (*this)[curr->get_id()->get_index()].set_param(*curr);
      }
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.TaConfigs");
    }
    break;
  case Module_Param::OT_CONCAT:
    switch (mp->get_type()) {
    case Module_Param::MP_Value_List: {
      if (!is_bound()) *this = NULL_VALUE;
      int start_idx = lengthof();
      for (size_t i=0; i<mp->get_size(); ++i) {
        Module_Param* const curr = mp->get_elem(i);
        if ((curr->get_type()!=Module_Param::MP_NotUsed)) {
          (*this)[start_idx+(int)i].set_param(*curr);
        }
      }
    } break;
    case Module_Param::MP_Indexed_List:
      param.error("Cannot concatenate an indexed value list");
      break;
    default:
      param.type_error("set of value", "@LibItsSecurity_TypesAndValues.TaConfigs");
    }
    break;
  default:
    TTCN_error("Internal error: Unknown operation type.");
  }
}

Module_Param* TaConfigs::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of type `@LibItsSecurity_TypesAndValues.TaConfigs'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Vector<Module_Param*> values;
  for (int i = 0; i < val_ptr->n_elements; ++i) {
    values.push_back((*this)[i].get_param(param_name));
  }
  Module_Param_Value_List* mp = new Module_Param_Value_List();
  mp->add_list_with_implicit_ids(&values);
  values.clear();
  return mp;
}

void TaConfigs::set_implicit_omit()
{
if (val_ptr == NULL) return;
for (int i = 0; i < val_ptr->n_elements; i++) {
if (val_ptr->value_elements[i] != NULL) val_ptr->value_elements[i]->set_implicit_omit();
}
}

void TaConfigs::encode_text(Text_Buf& text_buf) const
{
if (val_ptr == NULL) TTCN_error("Text encoder: Encoding an unbound value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
text_buf.push_int(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++)
(*this)[elem_count].encode_text(text_buf);
}

void TaConfigs::decode_text(Text_Buf& text_buf)
{
clean_up();
val_ptr = new recordof_setof_struct;
val_ptr->ref_count = 1;
val_ptr->n_elements = text_buf.pull_int().get_val();
if (val_ptr->n_elements < 0) TTCN_error("Text decoder: Negative size was received for a value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
val_ptr->value_elements = (TaConfig**)allocate_pointers(val_ptr->n_elements);
for (int elem_count = 0; elem_count < val_ptr->n_elements; elem_count++) {
val_ptr->value_elements[elem_count] = new TaConfig;
val_ptr->value_elements[elem_count]->decode_text(text_buf);
}
}

void TaConfigs::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void TaConfigs::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int TaConfigs::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean /*no_err*/, int sel_field, boolean first_call){
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  int decoded_length=0;
  int decoded_field_length=0;
  size_t start_of_field=0;
  if(first_call) {
    clean_up();
    val_ptr=new recordof_setof_struct;
    val_ptr->ref_count=1;
    val_ptr->n_elements=0;
    val_ptr->value_elements=NULL;
  }
  int start_field=val_ptr->n_elements;
  if(p_td.raw->fieldlength || sel_field!=-1){
    int a=0;
    if(sel_field==-1) sel_field=p_td.raw->fieldlength;
    for(a=0;a<sel_field;a++){
      decoded_field_length=(*this)[a+start_field].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0) return decoded_field_length;
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
    }
    if(a==0) val_ptr->n_elements=0;
  } else {
    int a=start_field;
    if(limit==0){
      if(!first_call) return -1;
      val_ptr->n_elements=0;
      return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
    }
    while(limit>0){
      start_of_field=p_buf.get_pos_bit();
      decoded_field_length=(*this)[a].RAW_decode(*p_td.oftype_descr,p_buf,limit,top_bit_ord,TRUE);
      if(decoded_field_length < 0){
        delete &(*this)[a];
        val_ptr->n_elements--;
        p_buf.set_pos_bit(start_of_field);
        if(a>start_field){
        return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
        } else return -1;
      }
      decoded_length+=decoded_field_length;
      limit-=decoded_field_length;
      a++;
    }
  }
 return decoded_length+p_buf.increase_pos_padd(p_td.raw->padding)+prepaddlength;
}

int TaConfigs::RAW_encode(const TTCN_Typedescriptor_t& p_td,RAW_enc_tree& myleaf) const{
  int encoded_length=0;
  int encoded_num_of_records=p_td.raw->fieldlength?smaller(val_ptr->n_elements, p_td.raw->fieldlength):val_ptr->n_elements;
  myleaf.isleaf=FALSE;
  myleaf.rec_of=TRUE;
  myleaf.body.node.num_of_nodes=encoded_num_of_records;
  myleaf.body.node.nodes=init_nodes_of_enc_tree(encoded_num_of_records);
  for(int a=0;a<encoded_num_of_records;a++){
    myleaf.body.node.nodes[a]=new RAW_enc_tree(TRUE,&myleaf,&(myleaf.curr_pos),a,p_td.oftype_descr->raw);
    encoded_length+=(*this)[a].RAW_encode(*p_td.oftype_descr,*myleaf.body.node.nodes[a]);
  }
 return myleaf.length=encoded_length;
}

void TaConfigs_template::copy_value(const TaConfigs& other_value)
{
if (!other_value.is_bound()) TTCN_error("Initialization of a template of type @LibItsSecurity_TypesAndValues.TaConfigs with an unbound value.");
single_value.n_elements = other_value.size_of();
single_value.value_elements = (TaConfig_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (other_value[elem_count].is_bound()) {
single_value.value_elements[elem_count] = new TaConfig_template(other_value[elem_count]);
} else {
single_value.value_elements[elem_count] = new TaConfig_template;
}
}
set_selection(SPECIFIC_VALUE);
}

void TaConfigs_template::copy_template(const TaConfigs_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = other_value.single_value.n_elements;
single_value.value_elements = (TaConfig_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (UNINITIALIZED_TEMPLATE != other_value.single_value.value_elements[elem_count]->get_selection()) {
single_value.value_elements[elem_count] = new TaConfig_template(*other_value.single_value.value_elements[elem_count]);
} else {
single_value.value_elements[elem_count] = new TaConfig_template;
}
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new TaConfigs_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = other_value.value_set.n_items;
value_set.set_items = new TaConfig_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count] = other_value.value_set.set_items[set_count];
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TaConfigs.");
break;
}
set_selection(other_value);
}

boolean TaConfigs_template::match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const TaConfigs_template*)template_ptr)->single_value.value_elements[template_index]->match((*(const TaConfigs*)value_ptr)[value_index], legacy);
else return ((const TaConfigs_template*)template_ptr)->single_value.value_elements[template_index]->is_any_or_omit();
}

boolean TaConfigs_template::match_function_set(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy)
{
if (value_index >= 0) return ((const TaConfigs_template*)template_ptr)->value_set.set_items[template_index].match((*(const TaConfigs*)value_ptr)[value_index], legacy);
else return ((const TaConfigs_template*)template_ptr)->value_set.set_items[template_index].is_any_or_omit();
}

void TaConfigs_template::log_function(const Base_Type *value_ptr, const Restricted_Length_Template *template_ptr, int index_value, int index_template, boolean legacy)
{
if (value_ptr != NULL && template_ptr != NULL)((const TaConfigs_template*)template_ptr)->single_value.value_elements[index_template]->log_match((*(const TaConfigs*)value_ptr)[index_value], legacy);
else if (value_ptr != NULL) (*(const TaConfigs*)value_ptr)[index_value].log();
else if (template_ptr != NULL) ((const TaConfigs_template*)template_ptr)->single_value.value_elements[index_template]->log();
}

TaConfigs_template::TaConfigs_template()
{
}

TaConfigs_template::TaConfigs_template(template_sel other_value)
 : Restricted_Length_Template(other_value)
{
check_single_selection(other_value);
}

TaConfigs_template::TaConfigs_template(null_type)
 : Restricted_Length_Template(SPECIFIC_VALUE)
{
single_value.n_elements = 0;
single_value.value_elements = NULL;
}

TaConfigs_template::TaConfigs_template(const TaConfigs& other_value)
{
copy_value(other_value);
}

TaConfigs_template::TaConfigs_template(const OPTIONAL<TaConfigs>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TaConfigs&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.TaConfigs from an unbound optional field.");
}
}

TaConfigs_template::TaConfigs_template(const TaConfigs_template& other_value)
 : Restricted_Length_Template()
{
copy_template(other_value);
}

TaConfigs_template::~TaConfigs_template()
{
clean_up();
}

void TaConfigs_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
free_pointers((void**)single_value.value_elements);
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
delete [] value_set.set_items;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

TaConfigs_template& TaConfigs_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

TaConfigs_template& TaConfigs_template::operator=(null_type)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
return *this;
}

TaConfigs_template& TaConfigs_template::operator=(const TaConfigs& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

TaConfigs_template& TaConfigs_template::operator=(const OPTIONAL<TaConfigs>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const TaConfigs&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.TaConfigs.");
}
return *this;
}

TaConfigs_template& TaConfigs_template::operator=(const TaConfigs_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

TaConfig_template& TaConfigs_template::operator[](int index_value)
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.TaConfigs using a negative index: %d.", index_value);
switch (template_selection)
{
  case SPECIFIC_VALUE:
    if(index_value < single_value.n_elements) break;
    // no break
  case OMIT_VALUE:
  case ANY_VALUE:
  case ANY_OR_OMIT:
  case UNINITIALIZED_TEMPLATE:
    set_size(index_value + 1);
    break;
  default:
    TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.TaConfigs.");
    break;
}
return *single_value.value_elements[index_value];
}

TaConfig_template& TaConfigs_template::operator[](const INTEGER& index_value)
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.TaConfigs.");
return (*this)[(int)index_value];
}

const TaConfig_template& TaConfigs_template::operator[](int index_value) const
{
if (index_value < 0) TTCN_error("Accessing an element of a template for type @LibItsSecurity_TypesAndValues.TaConfigs using a negative index: %d.", index_value);
if (template_selection != SPECIFIC_VALUE) TTCN_error("Accessing an element of a non-specific template for type @LibItsSecurity_TypesAndValues.TaConfigs.");
if (index_value >= single_value.n_elements) TTCN_error("Index overflow in a template of type @LibItsSecurity_TypesAndValues.TaConfigs: The index is %d, but the template has only %d elements.", index_value, single_value.n_elements);
return *single_value.value_elements[index_value];
}

const TaConfig_template& TaConfigs_template::operator[](const INTEGER& index_value) const
{
index_value.must_bound("Using an unbound integer value for indexing a template of type @LibItsSecurity_TypesAndValues.TaConfigs.");
return (*this)[(int)index_value];
}

void TaConfigs_template::set_size(int new_size)
{
if (new_size < 0) TTCN_error("Internal error: Setting a negative size for a template of type @LibItsSecurity_TypesAndValues.TaConfigs.");
template_sel old_selection = template_selection;
if (old_selection != SPECIFIC_VALUE) {
clean_up();
set_selection(SPECIFIC_VALUE);
single_value.n_elements = 0;
single_value.value_elements = NULL;
}
if (new_size > single_value.n_elements) {
single_value.value_elements = (TaConfig_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new TaConfig_template(ANY_VALUE);
} else {
for (int elem_count = single_value.n_elements; elem_count < new_size; elem_count++)
single_value.value_elements[elem_count] = new TaConfig_template;
}
single_value.n_elements = new_size;
} else if (new_size < single_value.n_elements) {
for (int elem_count = new_size; elem_count < single_value.n_elements; elem_count++)
delete single_value.value_elements[elem_count];
single_value.value_elements = (TaConfig_template**)reallocate_pointers((void**)single_value.value_elements, single_value.n_elements, new_size);
single_value.n_elements = new_size;
}
}

int TaConfigs_template::n_elem() const
{
  switch (template_selection) {
  case SPECIFIC_VALUE:
    return single_value.n_elements;
    break;
  case VALUE_LIST:
    return value_list.n_values;
    break;
  default:
    TTCN_error("Performing n_elem");
  }
}

int TaConfigs_template::size_of(boolean is_size) const
{
const char* op_name = is_size ? "size" : "length";
int min_size;
boolean has_any_or_none;
if (is_ifpresent) TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TaConfigs which has an ifpresent attribute.", op_name);
switch (template_selection)
{
case SPECIFIC_VALUE: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = single_value.n_elements;
  if (!is_size) { while (elem_count>0 && !single_value.value_elements[elem_count-1]->is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (single_value.value_elements[i]->get_selection()) {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TaConfigs containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
} break;
case SUPERSET_MATCH:
case SUBSET_MATCH: {
  min_size = 0;
  has_any_or_none = FALSE;
  int elem_count = value_set.n_items;
  if (!is_size) { while (elem_count>0 && !value_set.set_items[elem_count-1].is_bound()) elem_count--; }
  for (int i=0; i<elem_count; i++) {
    switch (value_set.set_items[i].get_selection())
    {
    case OMIT_VALUE:
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TaConfigs containing omit element.", op_name);
    case ANY_OR_OMIT:
      has_any_or_none = TRUE;
      break;
    default:
      min_size++;
      break;
    }
  }
  if (template_selection==SUPERSET_MATCH) {
    has_any_or_none = TRUE;
   } else {
    int max_size = min_size;
    min_size = 0;
    if (!has_any_or_none) { // [0,max_size]
      switch (length_restriction_type) {
      case NO_LENGTH_RESTRICTION:
        if (max_size==0) return 0;
        TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TaConfigs with no exact size.", op_name);
      case SINGLE_LENGTH_RESTRICTION:
        if (length_restriction.single_length<=max_size)
          return length_restriction.single_length;
        TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.TaConfigs. The maximum size (%d) contradicts the length restriction (%d).", op_name, max_size, length_restriction.single_length);
      case RANGE_LENGTH_RESTRICTION:
        if (max_size==length_restriction.range_length.min_length) {
          return max_size;
        } else if (max_size>length_restriction.range_length.min_length){
          TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TaConfigs with no exact size.", op_name);
        } else
          TTCN_error("Performing %sof() operation on an invalid template of type @LibItsSecurity_TypesAndValues.TaConfigs. Maximum size (%d) contradicts the length restriction (%d..%d).", op_name, max_size, length_restriction.range_length.min_length, length_restriction.range_length.max_length);
      default:
        TTCN_error("Internal error: Template has invalid length restriction type.");
      }
    }
  }
} break;
case OMIT_VALUE:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TaConfigs containing omit value.", op_name);
case ANY_VALUE:
case ANY_OR_OMIT:
  min_size = 0;
  has_any_or_none = TRUE;
  break;
case VALUE_LIST:
{
  if (value_list.n_values<1)
    TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TaConfigs containing an empty list.", op_name);
  int item_size = value_list.list_value[0].size_of(is_size);
  for (unsigned int i = 1; i < value_list.n_values; i++) {
    if (value_list.list_value[i].size_of(is_size)!=item_size)
      TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TaConfigs containing a value list with different sizes.", op_name);
  }
  min_size = item_size;
  has_any_or_none = FALSE;
  break;
}
case COMPLEMENTED_LIST:
  TTCN_error("Performing %sof() operation on a template of type @LibItsSecurity_TypesAndValues.TaConfigs containing complemented list.", op_name);
default:
  TTCN_error("Performing %sof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TaConfigs.", op_name);
}
return check_section_is_single(min_size, has_any_or_none, op_name, "a", "template of type @LibItsSecurity_TypesAndValues.TaConfigs");
}

boolean TaConfigs_template::match(const TaConfigs& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
int value_length = other_value.size_of();
if (!match_length(value_length)) return FALSE;
switch (template_selection) {
case SPECIFIC_VALUE:
return match_set_of(&other_value, value_length, this, single_value.n_elements, match_function_specific, legacy);
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
case SUPERSET_MATCH:
case SUBSET_MATCH:
return match_set_of(&other_value, value_length, this, value_set.n_items, match_function_set, legacy);
default:
TTCN_error("Matching with an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TaConfigs.");
}
return FALSE;
}

boolean TaConfigs_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return false;
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (!single_value.value_elements[elem_count]->is_value()) return false;
return true;
}

TaConfigs TaConfigs_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.TaConfigs.");
TaConfigs ret_val;
ret_val.set_size(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
if (single_value.value_elements[elem_count]->is_bound()) {
ret_val[elem_count] = single_value.value_elements[elem_count]->valueof();
}
return ret_val;
}

TaConfigs TaConfigs_template::substr(int index, int returncount) const
{
if (!is_value()) TTCN_error("The first argument of function substr() is a template with non-specific value.");
return valueof().substr(index, returncount);
}

TaConfigs TaConfigs_template::replace(int index, int len, const TaConfigs_template& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
if (!repl.is_value()) TTCN_error("The fourth argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl.valueof());
}

TaConfigs TaConfigs_template::replace(int index, int len, const TaConfigs& repl) const
{
if (!is_value()) TTCN_error("The first argument of function replace() is a template with non-specific value.");
return valueof().replace(index, len, repl);
}

void TaConfigs_template::set_type(template_sel template_type, unsigned int list_length)
{
clean_up();
switch (template_type) {
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = list_length;
value_list.list_value = new TaConfigs_template[list_length];
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = list_length;
value_set.set_items = new TaConfig_template[list_length];
break;
default:
TTCN_error("Internal error: Setting an invalid type for a template of type @LibItsSecurity_TypesAndValues.TaConfigs.");
}
set_selection(template_type);
}

TaConfigs_template& TaConfigs_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Internal error: Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.TaConfigs.");
if (list_index >= value_list.n_values) TTCN_error("Internal error: Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.TaConfigs.");
return value_list.list_value[list_index];
}

TaConfig_template& TaConfigs_template::set_item(unsigned int set_index)
{
if (template_selection != SUPERSET_MATCH && template_selection != SUBSET_MATCH) TTCN_error("Internal error: Accessing a set element of a non-set template of type @LibItsSecurity_TypesAndValues.TaConfigs.");
if (set_index >= value_set.n_items) TTCN_error("Internal error: Index overflow in a set template of type @LibItsSecurity_TypesAndValues.TaConfigs.");
return value_set.set_items[set_index];
}

void TaConfigs_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
if (single_value.n_elements > 0) {
TTCN_Logger::log_event_str("{ ");
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
single_value.value_elements[elem_count]->log();
}
TTCN_Logger::log_event_str(" }");
} else TTCN_Logger::log_event_str("{ }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
TTCN_Logger::log_event("%s(", template_selection == SUPERSET_MATCH ? "superset" : "subset");
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++) {
if (set_count > 0) TTCN_Logger::log_event_str(", ");
value_set.set_items[set_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_restricted();
log_ifpresent();
}

void TaConfigs_template::log_match(const TaConfigs& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
}else{
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if (template_selection == SPECIFIC_VALUE)
  log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
else{
if(previous_size != 0){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::set_logmatch_buffer_len(previous_size);
TTCN_Logger::log_event_str(":=");
}
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
return;
}
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else {
TTCN_Logger::log_event_str(" unmatched");
if (template_selection == SPECIFIC_VALUE) log_match_heuristics(&match_value, match_value.size_of(), this, single_value.n_elements, match_function_specific, log_function, legacy);
}
}

void TaConfigs_template::encode_text(Text_Buf& text_buf) const
{
encode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++)
single_value.value_elements[elem_count]->encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
text_buf.push_int(value_set.n_items);
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.TaConfigs.");
}
}

void TaConfigs_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_restricted(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value.n_elements = text_buf.pull_int().get_val();
if (single_value.n_elements < 0) TTCN_error("Text decoder: Negative size was received for a template of type @LibItsSecurity_TypesAndValues.TaConfigs.");
single_value.value_elements = (TaConfig_template**)allocate_pointers(single_value.n_elements);
for (int elem_count = 0; elem_count < single_value.n_elements; elem_count++) {
single_value.value_elements[elem_count] = new TaConfig_template;
single_value.value_elements[elem_count]->decode_text(text_buf);
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new TaConfigs_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
case SUPERSET_MATCH:
case SUBSET_MATCH:
value_set.n_items = text_buf.pull_int().get_val();
value_set.set_items = new TaConfig_template[value_set.n_items];
for (unsigned int set_count = 0; set_count < value_set.n_items; set_count++)
value_set.set_items[set_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of type @LibItsSecurity_TypesAndValues.TaConfigs.");
}
}

boolean TaConfigs_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean TaConfigs_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void TaConfigs_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      param.error("Unexpected record field name in module parameter, expected a valid"
        " index for set template type `@LibItsSecurity_TypesAndValues.TaConfigs'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    (*this)[param_index].set_param(param);
    return;
  }
  param.basic_check(Module_Param::BC_TEMPLATE|Module_Param::BC_LIST, "set of template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    TaConfigs_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Indexed_List:
    if (template_selection!=SPECIFIC_VALUE) set_size(0);
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      (*this)[(int)(mp->get_elem(p_i)->get_id()->get_index())].set_param(*mp->get_elem(p_i));
    }
    break;
  case Module_Param::MP_Value_List:
    set_size(mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); ++p_i) {
      if (mp->get_elem(p_i)->get_type()!=Module_Param::MP_NotUsed) {
        (*this)[p_i].set_param(*mp->get_elem(p_i));
      }
    }
    break;
  case Module_Param::MP_Superset_Template:
  case Module_Param::MP_Subset_Template:
    set_type(mp->get_type()==Module_Param::MP_Superset_Template ? SUPERSET_MATCH : SUBSET_MATCH, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      set_item(p_i).set_param(*mp->get_elem(p_i));
    }
    break;
  default:
    param.type_error("set of template", "@LibItsSecurity_TypesAndValues.TaConfigs");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
  if (param.get_length_restriction() != NULL) {
    set_length_range(param);
  }
  else {
    set_length_range(*mp);
  };
}

Module_Param* TaConfigs_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] < '0' || param_field[0] > '9') {
      TTCN_error("Unexpected record field name in module parameter reference, "
        "expected a valid index for set of template type `@LibItsSecurity_TypesAndValues.TaConfigs'");
    }
    int param_index = -1;
    sscanf(param_field, "%d", &param_index);
    return (*this)[param_index].get_param(param_name);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    Vector<Module_Param*> values;
    for (int i = 0; i < single_value.n_elements; ++i) {
      values.push_back((*this)[i].get_param(param_name));
    }
    mp = new Module_Param_Value_List();
    mp->add_list_with_implicit_ids(&values);
    values.clear();
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  mp->set_length_restriction(get_length_range());
  return mp;
}

void TaConfigs_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
for (int i=0; i<single_value.n_elements; i++) single_value.value_elements[i]->check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.TaConfigs");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.TaConfigs");
}

AcEnableSecurity::AcEnableSecurity()
{
  bound_flag = FALSE;
}

AcEnableSecurity::AcEnableSecurity(const CHARSTRING& par_certificateId)
  :   field_certificateId(par_certificateId)
{
  bound_flag = TRUE;
}

AcEnableSecurity::AcEnableSecurity(const AcEnableSecurity& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.AcEnableSecurity.");
bound_flag = TRUE;
if (other_value.certificateId().is_bound()) field_certificateId = other_value.certificateId();
else field_certificateId.clean_up();
}

void AcEnableSecurity::clean_up()
{
field_certificateId.clean_up();
bound_flag = FALSE;
}

AcEnableSecurity& AcEnableSecurity::operator=(const AcEnableSecurity& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.AcEnableSecurity.");
  bound_flag = TRUE;
  if (other_value.certificateId().is_bound()) field_certificateId = other_value.certificateId();
  else field_certificateId.clean_up();
}
return *this;
}

boolean AcEnableSecurity::operator==(const AcEnableSecurity& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_certificateId==other_value.field_certificateId;
}

boolean AcEnableSecurity::is_bound() const
{
if (bound_flag) return TRUE;
if(field_certificateId.is_bound()) return TRUE;
return FALSE;
}
boolean AcEnableSecurity::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_certificateId.is_value()) return FALSE;
return TRUE;
}
int AcEnableSecurity::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.AcEnableSecurity");
  return 1;
}

void AcEnableSecurity::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ certificateId := ");
field_certificateId.log();
TTCN_Logger::log_event_str(" }");
}

void AcEnableSecurity::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.AcEnableSecurity'");
    }
    if (strcmp("certificateId", param_field) == 0) {
      certificateId().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.AcEnableSecurity'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.AcEnableSecurity has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) certificateId().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "certificateId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          certificateId().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.AcEnableSecurity: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.AcEnableSecurity");
  }
}

Module_Param* AcEnableSecurity::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.AcEnableSecurity'");
    }
    if (strcmp("certificateId", param_field) == 0) {
      return certificateId().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.AcEnableSecurity'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_certificateId = field_certificateId.get_param(param_name);
  mp_field_certificateId->set_id(new Module_Param_FieldName(mcopystr("certificateId")));
  mp->add_elem(mp_field_certificateId);
  return mp;
  }

void AcEnableSecurity::set_implicit_omit()
{
if (certificateId().is_bound()) certificateId().set_implicit_omit();
}

void AcEnableSecurity::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.AcEnableSecurity.");
field_certificateId.encode_text(text_buf);
}

void AcEnableSecurity::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_certificateId.decode_text(text_buf);
}

void AcEnableSecurity::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AcEnableSecurity::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AcEnableSecurity::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_certificateId.RAW_decode(CHARSTRING_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int AcEnableSecurity::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, CHARSTRING_descr_.raw);
  encoded_length += field_certificateId.RAW_encode(CHARSTRING_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int AcEnableSecurity::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.AcEnableSecurity.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "certificateId");
    enc_len += field_certificateId.JSON_encode(CHARSTRING_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AcEnableSecurity::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (13 == name_len && 0 == strncmp(fld_name, "certificateId", name_len)) {
         int ret_val = field_certificateId.JSON_decode(CHARSTRING_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "certificateId");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_certificateId.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "certificateId");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct AcEnableSecurity_template::single_value_struct {
CHARSTRING_template field_certificateId;
};

void AcEnableSecurity_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_certificateId = ANY_VALUE;
}
}
}

void AcEnableSecurity_template::copy_value(const AcEnableSecurity& other_value)
{
single_value = new single_value_struct;
if (other_value.certificateId().is_bound()) {
  single_value->field_certificateId = other_value.certificateId();
} else {
  single_value->field_certificateId.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void AcEnableSecurity_template::copy_template(const AcEnableSecurity_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.certificateId().get_selection()) {
single_value->field_certificateId = other_value.certificateId();
} else {
single_value->field_certificateId.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AcEnableSecurity_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity.");
break;
}
set_selection(other_value);
}

AcEnableSecurity_template::AcEnableSecurity_template()
{
}

AcEnableSecurity_template::AcEnableSecurity_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AcEnableSecurity_template::AcEnableSecurity_template(const AcEnableSecurity& other_value)
{
copy_value(other_value);
}

AcEnableSecurity_template::AcEnableSecurity_template(const OPTIONAL<AcEnableSecurity>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcEnableSecurity&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity from an unbound optional field.");
}
}

AcEnableSecurity_template::AcEnableSecurity_template(const AcEnableSecurity_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

AcEnableSecurity_template::~AcEnableSecurity_template()
{
clean_up();
}

AcEnableSecurity_template& AcEnableSecurity_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AcEnableSecurity_template& AcEnableSecurity_template::operator=(const AcEnableSecurity& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AcEnableSecurity_template& AcEnableSecurity_template::operator=(const OPTIONAL<AcEnableSecurity>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcEnableSecurity&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity.");
}
return *this;
}

AcEnableSecurity_template& AcEnableSecurity_template::operator=(const AcEnableSecurity_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AcEnableSecurity_template::match(const AcEnableSecurity& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.certificateId().is_bound()) return FALSE;
if(!single_value->field_certificateId.match(other_value.certificateId(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity.");
}
return FALSE;
}

boolean AcEnableSecurity_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_certificateId.is_bound()) return TRUE;
return FALSE;
}

boolean AcEnableSecurity_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_certificateId.is_value()) return FALSE;
return TRUE;
}

void AcEnableSecurity_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AcEnableSecurity AcEnableSecurity_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity.");
AcEnableSecurity ret_val;
if (single_value->field_certificateId.is_bound()) {
ret_val.certificateId() = single_value->field_certificateId.valueof();
}
return ret_val;
}

void AcEnableSecurity_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AcEnableSecurity_template[list_length];
}

AcEnableSecurity_template& AcEnableSecurity_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity.");
return value_list.list_value[list_index];
}

CHARSTRING_template& AcEnableSecurity_template::certificateId()
{
set_specific();
return single_value->field_certificateId;
}

const CHARSTRING_template& AcEnableSecurity_template::certificateId() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field certificateId of a non-specific template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity.");
return single_value->field_certificateId;
}

int AcEnableSecurity_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity.");
  }
  return 0;
}

void AcEnableSecurity_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ certificateId := ");
single_value->field_certificateId.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AcEnableSecurity_template::log_match(const AcEnableSecurity& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_certificateId.match(match_value.certificateId(), legacy)){
TTCN_Logger::log_logmatch_info(".certificateId");
single_value->field_certificateId.log_match(match_value.certificateId(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ certificateId := ");
single_value->field_certificateId.log_match(match_value.certificateId(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AcEnableSecurity_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_certificateId.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity.");
}
}

void AcEnableSecurity_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_certificateId.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AcEnableSecurity_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity.");
}
}

void AcEnableSecurity_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.AcEnableSecurity'");
    }
    if (strcmp("certificateId", param_field) == 0) {
      certificateId().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.AcEnableSecurity'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AcEnableSecurity_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.AcEnableSecurity has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) certificateId().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "certificateId")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          certificateId().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.AcEnableSecurity: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.AcEnableSecurity");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AcEnableSecurity_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.AcEnableSecurity'");
    }
    if (strcmp("certificateId", param_field) == 0) {
      return certificateId().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.AcEnableSecurity'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_certificateId = single_value->field_certificateId.get_param(param_name);
    mp_field_certificateId->set_id(new Module_Param_FieldName(mcopystr("certificateId")));
    mp->add_elem(mp_field_certificateId);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AcEnableSecurity_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_certificateId.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.AcEnableSecurity");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.AcEnableSecurity");
}

boolean AcEnableSecurity_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AcEnableSecurity_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

AcDisableSecurity::AcDisableSecurity()
{
  bound_flag = FALSE;
}

AcDisableSecurity::AcDisableSecurity(const BOOLEAN& par_disable)
  :   field_disable(par_disable)
{
  bound_flag = TRUE;
}

AcDisableSecurity::AcDisableSecurity(const AcDisableSecurity& other_value)
{
if(!other_value.is_bound()) TTCN_error("Copying an unbound value of type @LibItsSecurity_TypesAndValues.AcDisableSecurity.");
bound_flag = TRUE;
if (other_value.disable().is_bound()) field_disable = other_value.disable();
else field_disable.clean_up();
}

void AcDisableSecurity::clean_up()
{
field_disable.clean_up();
bound_flag = FALSE;
}

AcDisableSecurity& AcDisableSecurity::operator=(const AcDisableSecurity& other_value)
{
if (this != &other_value) {
  if(!other_value.is_bound()) TTCN_error("Assignment of an unbound value of type @LibItsSecurity_TypesAndValues.AcDisableSecurity.");
  bound_flag = TRUE;
  if (other_value.disable().is_bound()) field_disable = other_value.disable();
  else field_disable.clean_up();
}
return *this;
}

boolean AcDisableSecurity::operator==(const AcDisableSecurity& other_value) const
{
if (!is_bound() && !other_value.is_bound()) return TRUE;
return field_disable==other_value.field_disable;
}

boolean AcDisableSecurity::is_bound() const
{
if (bound_flag) return TRUE;
if(field_disable.is_bound()) return TRUE;
return FALSE;
}
boolean AcDisableSecurity::is_value() const
{
if (!is_bound()) return FALSE;
if(!field_disable.is_value()) return FALSE;
return TRUE;
}
int AcDisableSecurity::size_of() const
{
  if (!is_bound()) TTCN_error("Calculating the size of an unbound record/set value of type @LibItsSecurity_TypesAndValues.AcDisableSecurity");
  return 1;
}

void AcDisableSecurity::log() const
{
if (!is_bound()) {
TTCN_Logger::log_event_unbound();
return;
}
TTCN_Logger::log_event_str("{ disable := ");
field_disable.log();
TTCN_Logger::log_event_str(" }");
}

void AcDisableSecurity::set_param(Module_Param& param)
{
  bound_flag = TRUE;
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record type `@LibItsSecurity_TypesAndValues.AcDisableSecurity'");
    }
    if (strcmp("disable", param_field) == 0) {
      disable().set_param(param);
      return;
    } else param.error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.AcDisableSecurity'", param_field);
  }
  param.basic_check(Module_Param::BC_VALUE, "record value");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record value of type @LibItsSecurity_TypesAndValues.AcDisableSecurity has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) disable().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "disable")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          disable().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.AcDisableSecurity: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record value", "@LibItsSecurity_TypesAndValues.AcDisableSecurity");
  }
}

Module_Param* AcDisableSecurity::get_param(Module_Param_Name& param_name) const
{
  if (!is_bound()) {
    return new Module_Param_Unbound();
  }
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record type `@LibItsSecurity_TypesAndValues.AcDisableSecurity'");
    }
    if (strcmp("disable", param_field) == 0) {
      return disable().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.AcDisableSecurity'", param_field);
  }
  Module_Param_Assignment_List* mp = new Module_Param_Assignment_List();
  Module_Param* mp_field_disable = field_disable.get_param(param_name);
  mp_field_disable->set_id(new Module_Param_FieldName(mcopystr("disable")));
  mp->add_elem(mp_field_disable);
  return mp;
  }

void AcDisableSecurity::set_implicit_omit()
{
if (disable().is_bound()) disable().set_implicit_omit();
}

void AcDisableSecurity::encode_text(Text_Buf& text_buf) const
{
if (!is_bound()) TTCN_error("Text encoder: Encoding an unbound record/set value of type @LibItsSecurity_TypesAndValues.AcDisableSecurity.");
field_disable.encode_text(text_buf);
}

void AcDisableSecurity::decode_text(Text_Buf& text_buf)
{
bound_flag = TRUE;
field_disable.decode_text(text_buf);
}

void AcDisableSecurity::encode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...) const
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-encoding type '%s': ", p_td.name);
    unsigned BER_coding=va_arg(pvar, unsigned);
    BER_encode_chk_coding(BER_coding);
    ASN_BER_TLV_t *tlv=BER_encode_TLV(p_td, BER_coding);
    tlv->put_in_buffer(p_buf);
    ASN_BER_TLV_t::destruct(tlv);
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-encoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    RAW_enc_tr_pos rp;
    rp.level=0;
    rp.pos=NULL;
    RAW_enc_tree root(FALSE, NULL, &rp, 1, p_td.raw);
    RAW_encode(p_td, root);
    root.put_to_buf(p_buf);
    break;}
  case TTCN_EncDec::CT_TEXT: {
    TTCN_EncDec_ErrorContext ec("While TEXT-encoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
      ("No TEXT descriptor available for type '%s'.", p_td.name);
    TEXT_encode(p_td,p_buf);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-encoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XER_encode(*(p_td.xer),p_buf, XER_coding, 0, 0);
    p_buf.put_c('\n');
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-encoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok(va_arg(pvar, int) != 0);
    JSON_encode(p_td, tok);
    p_buf.put_s(tok.get_buffer_length(), (const unsigned char*)tok.get_buffer());
    break;}
  default:
    TTCN_error("Unknown coding method requested to encode type '%s'", p_td.name);
  }
  va_end(pvar);
}

void AcDisableSecurity::decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, TTCN_EncDec::coding_t p_coding, ...)
{
  va_list pvar;
  va_start(pvar, p_coding);
  switch(p_coding) {
  case TTCN_EncDec::CT_BER: {
    TTCN_EncDec_ErrorContext ec("While BER-decoding type '%s': ", p_td.name);
    unsigned L_form=va_arg(pvar, unsigned);
    ASN_BER_TLV_t tlv;
    BER_decode_str2TLV(p_buf, tlv, L_form);
    BER_decode_TLV(p_td, tlv, L_form);
    if(tlv.isComplete) p_buf.increase_pos(tlv.get_len());
    break;}
  case TTCN_EncDec::CT_RAW: {
    TTCN_EncDec_ErrorContext ec("While RAW-decoding type '%s': ", p_td.name);
    if(!p_td.raw)
      TTCN_EncDec_ErrorContext::error_internal
        ("No RAW descriptor available for type '%s'.", p_td.name);
    raw_order_t r_order;
    switch(p_td.raw->top_bit_order) {
    case TOP_BIT_LEFT:
      r_order=ORDER_LSB;
      break;
    case TOP_BIT_RIGHT:
    default:
      r_order=ORDER_MSB;
    }
    int rawr = RAW_decode(p_td, p_buf, p_buf.get_len()*8, r_order);
    if(rawr<0) switch (-rawr) {
    case TTCN_EncDec::ET_INCOMPL_MSG:
    case TTCN_EncDec::ET_LEN_ERR:
      ec.error((TTCN_EncDec::error_type_t)-rawr, "Can not decode type '%s', because incomplete message was received", p_td.name);
      break;
    case 1:
    default:
      ec.error(TTCN_EncDec::ET_INVAL_MSG, "Can not decode type '%s', because invalid message was received", p_td.name);
      break;
    }
    break;}
  case TTCN_EncDec::CT_TEXT: {
    Limit_Token_List limit;
    TTCN_EncDec_ErrorContext ec("While TEXT-decoding type '%s': ", p_td.name);
    if(!p_td.text)
      TTCN_EncDec_ErrorContext::error_internal
        ("No TEXT descriptor available for type '%s'.", p_td.name);
    const unsigned char *b_data=p_buf.get_data();
    if(b_data[p_buf.get_len()-1]!='\0'){
      p_buf.set_pos(p_buf.get_len());
      p_buf.put_zero(8,ORDER_LSB);
      p_buf.rewind();
    }
    if(TEXT_decode(p_td,p_buf,limit)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    break;}
  case TTCN_EncDec::CT_XER: {
    TTCN_EncDec_ErrorContext ec("While XER-decoding type '%s': ", p_td.name);
    unsigned XER_coding=va_arg(pvar, unsigned);
    XER_encode_chk_coding(XER_coding, p_td);
    XmlReaderWrap reader(p_buf);
    for (int rd_ok=reader.Read(); rd_ok==1; rd_ok=reader.Read()) {
      if (reader.NodeType() == XML_READER_TYPE_ELEMENT) break;
    }
    XER_decode(*(p_td.xer), reader, XER_coding | XER_TOPLEVEL, 0);
    size_t bytes = reader.ByteConsumed();
    p_buf.set_pos(bytes);
    break;}
  case TTCN_EncDec::CT_JSON: {
    TTCN_EncDec_ErrorContext ec("While JSON-decoding type '%s': ", p_td.name);
    if(!p_td.json)
      TTCN_EncDec_ErrorContext::error_internal
        ("No JSON descriptor available for type '%s'.", p_td.name);
    JSON_Tokenizer tok((const char*)p_buf.get_data(), p_buf.get_len());
    if(JSON_decode(p_td, tok, false)<0)
      ec.error(TTCN_EncDec::ET_INCOMPL_MSG,"Can not decode type '%s', because invalid or incomplete message was received", p_td.name);
    p_buf.set_pos(tok.get_buf_pos());
    break;}
  default:
    TTCN_error("Unknown coding method requested to decode type '%s'", p_td.name);
  }
  va_end(pvar);
}

int AcDisableSecurity::RAW_decode(const TTCN_Typedescriptor_t& p_td, TTCN_Buffer& p_buf, int limit, raw_order_t top_bit_ord, boolean no_err, int, boolean)
{ (void)no_err;
  bound_flag = TRUE;
  int prepaddlength=p_buf.increase_pos_padd(p_td.raw->prepadding);
  limit-=prepaddlength;
  size_t last_decoded_pos = p_buf.get_pos_bit();
  int decoded_length = 0;
  int decoded_field_length = 0;
  raw_order_t local_top_order;
  if(p_td.raw->top_bit_order==TOP_BIT_INHERITED)local_top_order=top_bit_ord;
  else if(p_td.raw->top_bit_order==TOP_BIT_RIGHT)local_top_order=ORDER_MSB;
  else local_top_order=ORDER_LSB;
  decoded_field_length = field_disable.RAW_decode(BOOLEAN_descr_, p_buf, limit, local_top_order, no_err);
  if (decoded_field_length < 0) return decoded_field_length;
  decoded_length+=decoded_field_length;
  limit-=decoded_field_length;
  last_decoded_pos=bigger(last_decoded_pos, p_buf.get_pos_bit());
  p_buf.set_pos_bit(last_decoded_pos);
  return decoded_length+prepaddlength+p_buf.increase_pos_padd(p_td.raw->padding);
}

int AcDisableSecurity::RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree& myleaf) const {
  if (!is_bound()) TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND, "Encoding an unbound value.");
  int encoded_length = 0;
  myleaf.isleaf = false;
  myleaf.body.node.num_of_nodes = 1;
  myleaf.body.node.nodes = init_nodes_of_enc_tree(1);
  myleaf.body.node.nodes[0] = new RAW_enc_tree(true, &myleaf, &(myleaf.curr_pos), 0, BOOLEAN_descr_.raw);
  encoded_length += field_disable.RAW_encode(BOOLEAN_descr_, *myleaf.body.node.nodes[0]);
  return myleaf.length = encoded_length;
}

int AcDisableSecurity::JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok) const
{
  if (!is_bound()) {
    TTCN_EncDec_ErrorContext::error(TTCN_EncDec::ET_UNBOUND,
      "Encoding an unbound value of type @LibItsSecurity_TypesAndValues.AcDisableSecurity.");
    return -1;
  }

  int enc_len = p_tok.put_next_token(JSON_TOKEN_OBJECT_START, NULL);

  {
    enc_len += p_tok.put_next_token(JSON_TOKEN_NAME, "disable");
    enc_len += field_disable.JSON_encode(BOOLEAN_descr_, p_tok);
  }

  enc_len += p_tok.put_next_token(JSON_TOKEN_OBJECT_END, NULL);
  return enc_len;
}

int AcDisableSecurity::JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer& p_tok, boolean p_silent)
{
  json_token_t j_token = JSON_TOKEN_NONE;
  int dec_len = p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_ERROR == j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_BAD_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }
  else if (JSON_TOKEN_OBJECT_START != j_token) {
    return JSON_ERROR_INVALID_TOKEN;
  }
  bound_flag = TRUE;


  while (true) {
    char* fld_name = 0;
    size_t name_len = 0;
    size_t buf_pos = p_tok.get_buf_pos();
    dec_len += p_tok.get_next_token(&j_token, &fld_name, &name_len);
    if (JSON_TOKEN_ERROR == j_token) {
      JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_NAME_TOKEN_ERROR);
      return JSON_ERROR_FATAL;
    }
    else if (JSON_TOKEN_NAME != j_token) {
      p_tok.set_buf_pos(buf_pos);
      break;
    }
    else {
      if (7 == name_len && 0 == strncmp(fld_name, "disable", name_len)) {
         int ret_val = field_disable.JSON_decode(BOOLEAN_descr_, p_tok, p_silent);
         if (0 > ret_val) {
           if (JSON_ERROR_INVALID_TOKEN == ret_val) {
             JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, "disable");
           }
           return JSON_ERROR_FATAL;
         }
         dec_len += ret_val;
      }
      else {
        char* fld_name2 = mcopystrn(fld_name, name_len);
        JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_INVALID_NAME_ERROR, fld_name2);
        dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
        if (JSON_TOKEN_NUMBER != j_token && JSON_TOKEN_STRING != j_token &&
            JSON_TOKEN_LITERAL_TRUE != j_token && JSON_TOKEN_LITERAL_FALSE != j_token &&
            JSON_TOKEN_LITERAL_NULL != j_token) {
          JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_FIELD_TOKEN_ERROR, fld_name2);
          Free(fld_name2);
          return JSON_ERROR_FATAL;
        }
        Free(fld_name2);
      }
    }
  }

  dec_len += p_tok.get_next_token(&j_token, NULL, NULL);
  if (JSON_TOKEN_OBJECT_END != j_token) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_OBJECT_END_TOKEN_ERROR, "");
    return JSON_ERROR_FATAL;
  }

  if (!field_disable.is_bound()) {
    JSON_ERROR(TTCN_EncDec::ET_INVAL_MSG, JSON_DEC_MISSING_FIELD_ERROR, "disable");
    return JSON_ERROR_FATAL;
  }

  return dec_len;
}

struct AcDisableSecurity_template::single_value_struct {
BOOLEAN_template field_disable;
};

void AcDisableSecurity_template::set_specific()
{
if (template_selection != SPECIFIC_VALUE) {
template_sel old_selection = template_selection;
clean_up();
single_value = new single_value_struct;
set_selection(SPECIFIC_VALUE);
if (old_selection == ANY_VALUE || old_selection == ANY_OR_OMIT) {
single_value->field_disable = ANY_VALUE;
}
}
}

void AcDisableSecurity_template::copy_value(const AcDisableSecurity& other_value)
{
single_value = new single_value_struct;
if (other_value.disable().is_bound()) {
  single_value->field_disable = other_value.disable();
} else {
  single_value->field_disable.clean_up();
}
set_selection(SPECIFIC_VALUE);
}

void AcDisableSecurity_template::copy_template(const AcDisableSecurity_template& other_value)
{
switch (other_value.template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
if (UNINITIALIZED_TEMPLATE != other_value.disable().get_selection()) {
single_value->field_disable = other_value.disable();
} else {
single_value->field_disable.clean_up();
}
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new AcDisableSecurity_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity.");
break;
}
set_selection(other_value);
}

AcDisableSecurity_template::AcDisableSecurity_template()
{
}

AcDisableSecurity_template::AcDisableSecurity_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

AcDisableSecurity_template::AcDisableSecurity_template(const AcDisableSecurity& other_value)
{
copy_value(other_value);
}

AcDisableSecurity_template::AcDisableSecurity_template(const OPTIONAL<AcDisableSecurity>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcDisableSecurity&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity from an unbound optional field.");
}
}

AcDisableSecurity_template::AcDisableSecurity_template(const AcDisableSecurity_template& other_value)
: Base_Template()
{
copy_template(other_value);
}

AcDisableSecurity_template::~AcDisableSecurity_template()
{
clean_up();
}

AcDisableSecurity_template& AcDisableSecurity_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

AcDisableSecurity_template& AcDisableSecurity_template::operator=(const AcDisableSecurity& other_value)
{
clean_up();
copy_value(other_value);
return *this;
}

AcDisableSecurity_template& AcDisableSecurity_template::operator=(const OPTIONAL<AcDisableSecurity>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
copy_value((const AcDisableSecurity&)other_value);
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity.");
}
return *this;
}

AcDisableSecurity_template& AcDisableSecurity_template::operator=(const AcDisableSecurity_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean AcDisableSecurity_template::match(const AcDisableSecurity& other_value, boolean legacy) const
{
if (!other_value.is_bound()) return FALSE;
switch (template_selection) {
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case OMIT_VALUE:
return FALSE;
case SPECIFIC_VALUE:
if(!other_value.disable().is_bound()) return FALSE;
if(!single_value->field_disable.match(other_value.disable(), legacy))return FALSE;
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value, legacy)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity.");
}
return FALSE;
}

boolean AcDisableSecurity_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
if (template_selection != SPECIFIC_VALUE) return TRUE;
if (single_value->field_disable.is_bound()) return TRUE;
return FALSE;
}

boolean AcDisableSecurity_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
if (!single_value->field_disable.is_value()) return FALSE;
return TRUE;
}

void AcDisableSecurity_template::clean_up()
{
switch (template_selection) {
case SPECIFIC_VALUE:
delete single_value;
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
delete [] value_list.list_value;
default:
break;
}
template_selection = UNINITIALIZED_TEMPLATE;
}

AcDisableSecurity AcDisableSecurity_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent)
TTCN_error("Performing valueof or send operation on a non-specific template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity.");
AcDisableSecurity ret_val;
if (single_value->field_disable.is_bound()) {
ret_val.disable() = single_value->field_disable.valueof();
}
return ret_val;
}

void AcDisableSecurity_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST)
TTCN_error("Setting an invalid list for a template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new AcDisableSecurity_template[list_length];
}

AcDisableSecurity_template& AcDisableSecurity_template::list_item(unsigned int list_index) const
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST)
TTCN_error("Accessing a list element of a non-list template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity.");
if (list_index >= value_list.n_values)
TTCN_error("Index overflow in a value list template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity.");
return value_list.list_value[list_index];
}

BOOLEAN_template& AcDisableSecurity_template::disable()
{
set_specific();
return single_value->field_disable;
}

const BOOLEAN_template& AcDisableSecurity_template::disable() const
{
if (template_selection != SPECIFIC_VALUE)
TTCN_error("Accessing field disable of a non-specific template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity.");
return single_value->field_disable;
}

int AcDisableSecurity_template::size_of() const
{
  if (is_ifpresent) TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity which has an ifpresent attribute.");
  switch (template_selection)
  {
  case SPECIFIC_VALUE:
    return 1;
  case VALUE_LIST:
   {
     if (value_list.n_values<1)
       TTCN_error("Internal error: Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity containing an empty list.");
      int item_size = value_list.list_value[0].size_of();
      for (unsigned int l_idx = 1; l_idx < value_list.n_values; l_idx++)
      {
        if (value_list.list_value[l_idx].size_of()!=item_size)
          TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity containing a value list with different sizes.");
      }
      return item_size;
    }
  case OMIT_VALUE:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity containing omit value.");
  case ANY_VALUE:
  case ANY_OR_OMIT:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity containing */? value.");
  case COMPLEMENTED_LIST:
    TTCN_error("Performing sizeof() operation on a template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity containing complemented list.");
  default:
    TTCN_error("Performing sizeof() operation on an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity.");
  }
  return 0;
}

void AcDisableSecurity_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_str("{ disable := ");
single_value->field_disable.log();
TTCN_Logger::log_event_str(" }");
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++) {
if (list_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[list_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void AcDisableSecurity_template::log_match(const AcDisableSecurity& match_value, boolean legacy) const
{
if(TTCN_Logger::VERBOSITY_COMPACT == TTCN_Logger::get_matching_verbosity()){
if(match(match_value, legacy)){
TTCN_Logger::print_logmatch_buffer();
TTCN_Logger::log_event_str(" matched");
} else{
if (template_selection == SPECIFIC_VALUE) {
size_t previous_size = TTCN_Logger::get_logmatch_buffer_len();
if(!single_value->field_disable.match(match_value.disable(), legacy)){
TTCN_Logger::log_logmatch_info(".disable");
single_value->field_disable.log_match(match_value.disable(), legacy);
TTCN_Logger::set_logmatch_buffer_len(previous_size);
}
}else {
TTCN_Logger::print_logmatch_buffer();
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
TTCN_Logger::log_event_str(" unmatched");
}
}
return;
}
if (template_selection == SPECIFIC_VALUE) {
TTCN_Logger::log_event_str("{ disable := ");
single_value->field_disable.log_match(match_value.disable(), legacy);
TTCN_Logger::log_event_str(" }");
} else {
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value, legacy)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}
}

void AcDisableSecurity_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value->field_disable.encode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity.");
}
}

void AcDisableSecurity_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = new single_value_struct;
single_value->field_disable.decode_text(text_buf);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new AcDisableSecurity_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received in a template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity.");
}
}

void AcDisableSecurity_template::set_param(Module_Param& param)
{
  if (dynamic_cast<Module_Param_Name*>(param.get_id()) != NULL &&
      param.get_id()->next_name()) {
    char* param_field = param.get_id()->get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      param.error("Unexpected array index in module parameter, expected a valid field"
        " name for record template type `@LibItsSecurity_TypesAndValues.AcDisableSecurity'");
    }
    if (strcmp("disable", param_field) == 0) {
      disable().set_param(param);
      return;
    } else param.error("Field `%s' not found in record template type `@LibItsSecurity_TypesAndValues.AcDisableSecurity'", param_field);
  }
  param.basic_check(Module_Param::BC_TEMPLATE, "record template");
  Module_Param_Ptr mp = &param;
  if (param.get_type() == Module_Param::MP_Reference) {
    mp = param.get_referenced_param();
  }
  switch (mp->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    AcDisableSecurity_template temp;
    temp.set_type(mp->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, mp->get_size());
    for (size_t p_i=0; p_i<mp->get_size(); p_i++) {
      temp.list_item(p_i).set_param(*mp->get_elem(p_i));
    }
    *this = temp;
    break; }
  case Module_Param::MP_Value_List:
    if (1<mp->get_size()) {
      param.error("record template of type @LibItsSecurity_TypesAndValues.AcDisableSecurity has 1 fields but list value has %d fields", (int)mp->get_size());
    }
    if (mp->get_size()>0 && mp->get_elem(0)->get_type()!=Module_Param::MP_NotUsed) disable().set_param(*mp->get_elem(0));
    break;
  case Module_Param::MP_Assignment_List: {
    Vector<bool> value_used(mp->get_size());
    value_used.resize(mp->get_size(), false);
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) {
      Module_Param* const curr_param = mp->get_elem(val_idx);
      if (!strcmp(curr_param->get_id()->get_name(), "disable")) {
        if (curr_param->get_type()!=Module_Param::MP_NotUsed) {
          disable().set_param(*curr_param);
        }
        value_used[val_idx]=true;
      }
    }
    for (size_t val_idx=0; val_idx<mp->get_size(); val_idx++) if (!value_used[val_idx]) {
      mp->get_elem(val_idx)->error("Non existent field name in type @LibItsSecurity_TypesAndValues.AcDisableSecurity: %s", mp->get_elem(val_idx)->get_id()->get_name());
      break;
    }
  } break;
  default:
    param.type_error("record template", "@LibItsSecurity_TypesAndValues.AcDisableSecurity");
  }
  is_ifpresent = param.get_ifpresent() || mp->get_ifpresent();
}

Module_Param* AcDisableSecurity_template::get_param(Module_Param_Name& param_name) const
{
  if (param_name.next_name()) {
    char* param_field = param_name.get_current_name();
    if (param_field[0] >= '0' && param_field[0] <= '9') {
      TTCN_error("Unexpected array index in module parameter reference, "
        "expected a valid field name for record template type `@LibItsSecurity_TypesAndValues.AcDisableSecurity'");
    }
    if (strcmp("disable", param_field) == 0) {
      return disable().get_param(param_name);
    } else TTCN_error("Field `%s' not found in record type `@LibItsSecurity_TypesAndValues.AcDisableSecurity'", param_field);
  }
  Module_Param* mp = NULL;
  switch (template_selection) {
  case UNINITIALIZED_TEMPLATE:
    mp = new Module_Param_Unbound();
    break;
  case OMIT_VALUE:
    mp = new Module_Param_Omit();
    break;
  case ANY_VALUE:
    mp = new Module_Param_Any();
    break;
  case ANY_OR_OMIT:
    mp = new Module_Param_AnyOrNone();
    break;
  case SPECIFIC_VALUE: {
    mp = new Module_Param_Assignment_List();
    Module_Param* mp_field_disable = single_value->field_disable.get_param(param_name);
    mp_field_disable->set_id(new Module_Param_FieldName(mcopystr("disable")));
    mp->add_elem(mp_field_disable);
    break; }
  case VALUE_LIST:
  case COMPLEMENTED_LIST: {
    if (template_selection == VALUE_LIST) {
      mp = new Module_Param_List_Template();
    }
    else {
      mp = new Module_Param_ComplementList_Template();
    }
    for (size_t i = 0; i < value_list.n_values; ++i) {
      mp->add_elem(value_list.list_value[i].get_param(param_name));
    }
    break; }
  default:
    break;
  }
  if (is_ifpresent) {
    mp->set_ifpresent();
  }
  return mp;
}

void AcDisableSecurity_template::check_restriction(template_res t_res, const char* t_name, boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_OMIT:
if (template_selection==OMIT_VALUE) return;
case TR_VALUE:
if (template_selection!=SPECIFIC_VALUE || is_ifpresent) break;
single_value->field_disable.check_restriction(t_res, t_name ? t_name : "@LibItsSecurity_TypesAndValues.AcDisableSecurity");
return;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@LibItsSecurity_TypesAndValues.AcDisableSecurity");
}

boolean AcDisableSecurity_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean AcDisableSecurity_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int l_idx=0; l_idx<value_list.n_values; l_idx++)
if (value_list.list_value[l_idx].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}


/* Bodies of functions, altsteps and testcases */

boolean operator==(null_type, const SubjectAttributes& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.SubjectAttributes.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const ItsAidSsps& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ItsAidSsps.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const ValidityRestrictions& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ValidityRestrictions.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const RectangularRegions& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.RectangularRegions.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const PolygonalRegion& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.PolygonalRegion.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const CertificateChain& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.CertificateChain.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const ThreeDLocations& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.ThreeDLocations.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const HeaderFields& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.HeaderFields.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const RecipientInfos& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.RecipientInfos.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const TrailerFields& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.TrailerFields.");
return other_value.val_ptr->n_elements == 0;
}

boolean operator==(null_type, const TaConfigs& other_value)
{
if (other_value.val_ptr == NULL)
TTCN_error("The right operand of comparison is an unbound value of type @LibItsSecurity_TypesAndValues.TaConfigs.");
return other_value.val_ptr->n_elements == 0;
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("LibItsSecurity_TypesAndValues.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "LibItsSecurity_TypesAndValues");
LibCommon__BasicTypesAndValues::module_object.pre_init_module();
LibCommon__DataStrings::module_object.pre_init_module();
}

static void post_init_module()
{
TTCN_Location current_location("LibItsSecurity_TypesAndValues.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "LibItsSecurity_TypesAndValues");
LibCommon__BasicTypesAndValues::module_object.post_init_module();
LibCommon__DataStrings::module_object.post_init_module();
}


} /* end of namespace */
