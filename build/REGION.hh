// This C++ header file was generated by the ASN.1 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef REGION_HH
#define REGION_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 50400
#error Version mismatch detected.\
 Please check the version of the ASN.1 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef REGION_HH
#endif

namespace REGION {

/* Forward declarations of classes */

class Reg__AdvisorySpeed;
class Reg__AdvisorySpeed_template;
class Reg__ComputedLane;
class Reg__ComputedLane_template;
class Reg__GenericLane;
class Reg__GenericLane_template;
class Reg__Intersection;
class Reg__Intersection_template;
class Reg__LaneAttributes;
class Reg__LaneAttributes_template;
class Reg__LaneDataAttribute;
class Reg__LaneDataAttribute_template;
class Reg__MovementEvent;
class Reg__MovementEvent_template;
class Reg__MovementState;
class Reg__MovementState_template;
class Reg__NodeAttribute;
class Reg__NodeAttribute_template;
class Reg__NodeOffsetPoint;
class Reg__NodeOffsetPoint_template;
class Reg__RoadSegment;
class Reg__RoadSegment_template;
class Reg__SignalControlZone;
class Reg__SignalControlZone_template;
class Reg__SPAT;
class Reg__SPAT_template;

} /* end of namespace */

#ifndef REGION_HH
#define REGION_HH

namespace REGION {

/* Class definitions */

class Reg__AdvisorySpeed : public Base_Type {
boolean bound_flag;
public:
Reg__AdvisorySpeed();
Reg__AdvisorySpeed(null_type other_value);
Reg__AdvisorySpeed(const Reg__AdvisorySpeed& other_value);
Reg__AdvisorySpeed& operator=(null_type other_value);
Reg__AdvisorySpeed& operator=(const Reg__AdvisorySpeed& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const Reg__AdvisorySpeed& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Reg__AdvisorySpeed& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__AdvisorySpeed_template : public Base_Template {
struct {
unsigned int n_values;
Reg__AdvisorySpeed_template *list_value;
} value_list;
void copy_template(const Reg__AdvisorySpeed_template& other_value);

public:
Reg__AdvisorySpeed_template();
Reg__AdvisorySpeed_template(template_sel other_value);
Reg__AdvisorySpeed_template(null_type other_value);
Reg__AdvisorySpeed_template(const Reg__AdvisorySpeed& other_value);
Reg__AdvisorySpeed_template(const OPTIONAL<Reg__AdvisorySpeed>& other_value);
Reg__AdvisorySpeed_template(const Reg__AdvisorySpeed_template& other_value);
~Reg__AdvisorySpeed_template();
void clean_up();
Reg__AdvisorySpeed_template& operator=(template_sel other_value);
Reg__AdvisorySpeed_template& operator=(null_type other_value);
Reg__AdvisorySpeed_template& operator=(const Reg__AdvisorySpeed& other_value);
Reg__AdvisorySpeed_template& operator=(const OPTIONAL<Reg__AdvisorySpeed>& other_value);
Reg__AdvisorySpeed_template& operator=(const Reg__AdvisorySpeed_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const Reg__AdvisorySpeed& other_value, boolean legacy = FALSE) const;
Reg__AdvisorySpeed valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__AdvisorySpeed_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const Reg__AdvisorySpeed& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Reg__ComputedLane : public Base_Type {
boolean bound_flag;
public:
Reg__ComputedLane();
Reg__ComputedLane(null_type other_value);
Reg__ComputedLane(const Reg__ComputedLane& other_value);
Reg__ComputedLane& operator=(null_type other_value);
Reg__ComputedLane& operator=(const Reg__ComputedLane& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const Reg__ComputedLane& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Reg__ComputedLane& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__ComputedLane_template : public Base_Template {
struct {
unsigned int n_values;
Reg__ComputedLane_template *list_value;
} value_list;
void copy_template(const Reg__ComputedLane_template& other_value);

public:
Reg__ComputedLane_template();
Reg__ComputedLane_template(template_sel other_value);
Reg__ComputedLane_template(null_type other_value);
Reg__ComputedLane_template(const Reg__ComputedLane& other_value);
Reg__ComputedLane_template(const OPTIONAL<Reg__ComputedLane>& other_value);
Reg__ComputedLane_template(const Reg__ComputedLane_template& other_value);
~Reg__ComputedLane_template();
void clean_up();
Reg__ComputedLane_template& operator=(template_sel other_value);
Reg__ComputedLane_template& operator=(null_type other_value);
Reg__ComputedLane_template& operator=(const Reg__ComputedLane& other_value);
Reg__ComputedLane_template& operator=(const OPTIONAL<Reg__ComputedLane>& other_value);
Reg__ComputedLane_template& operator=(const Reg__ComputedLane_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const Reg__ComputedLane& other_value, boolean legacy = FALSE) const;
Reg__ComputedLane valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__ComputedLane_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const Reg__ComputedLane& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Reg__GenericLane : public Base_Type {
boolean bound_flag;
public:
Reg__GenericLane();
Reg__GenericLane(null_type other_value);
Reg__GenericLane(const Reg__GenericLane& other_value);
Reg__GenericLane& operator=(null_type other_value);
Reg__GenericLane& operator=(const Reg__GenericLane& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const Reg__GenericLane& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Reg__GenericLane& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__GenericLane_template : public Base_Template {
struct {
unsigned int n_values;
Reg__GenericLane_template *list_value;
} value_list;
void copy_template(const Reg__GenericLane_template& other_value);

public:
Reg__GenericLane_template();
Reg__GenericLane_template(template_sel other_value);
Reg__GenericLane_template(null_type other_value);
Reg__GenericLane_template(const Reg__GenericLane& other_value);
Reg__GenericLane_template(const OPTIONAL<Reg__GenericLane>& other_value);
Reg__GenericLane_template(const Reg__GenericLane_template& other_value);
~Reg__GenericLane_template();
void clean_up();
Reg__GenericLane_template& operator=(template_sel other_value);
Reg__GenericLane_template& operator=(null_type other_value);
Reg__GenericLane_template& operator=(const Reg__GenericLane& other_value);
Reg__GenericLane_template& operator=(const OPTIONAL<Reg__GenericLane>& other_value);
Reg__GenericLane_template& operator=(const Reg__GenericLane_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const Reg__GenericLane& other_value, boolean legacy = FALSE) const;
Reg__GenericLane valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__GenericLane_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const Reg__GenericLane& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Reg__Intersection : public Base_Type {
boolean bound_flag;
public:
Reg__Intersection();
Reg__Intersection(null_type other_value);
Reg__Intersection(const Reg__Intersection& other_value);
Reg__Intersection& operator=(null_type other_value);
Reg__Intersection& operator=(const Reg__Intersection& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const Reg__Intersection& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Reg__Intersection& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__Intersection_template : public Base_Template {
struct {
unsigned int n_values;
Reg__Intersection_template *list_value;
} value_list;
void copy_template(const Reg__Intersection_template& other_value);

public:
Reg__Intersection_template();
Reg__Intersection_template(template_sel other_value);
Reg__Intersection_template(null_type other_value);
Reg__Intersection_template(const Reg__Intersection& other_value);
Reg__Intersection_template(const OPTIONAL<Reg__Intersection>& other_value);
Reg__Intersection_template(const Reg__Intersection_template& other_value);
~Reg__Intersection_template();
void clean_up();
Reg__Intersection_template& operator=(template_sel other_value);
Reg__Intersection_template& operator=(null_type other_value);
Reg__Intersection_template& operator=(const Reg__Intersection& other_value);
Reg__Intersection_template& operator=(const OPTIONAL<Reg__Intersection>& other_value);
Reg__Intersection_template& operator=(const Reg__Intersection_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const Reg__Intersection& other_value, boolean legacy = FALSE) const;
Reg__Intersection valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__Intersection_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const Reg__Intersection& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Reg__LaneAttributes : public Base_Type {
boolean bound_flag;
public:
Reg__LaneAttributes();
Reg__LaneAttributes(null_type other_value);
Reg__LaneAttributes(const Reg__LaneAttributes& other_value);
Reg__LaneAttributes& operator=(null_type other_value);
Reg__LaneAttributes& operator=(const Reg__LaneAttributes& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const Reg__LaneAttributes& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Reg__LaneAttributes& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__LaneAttributes_template : public Base_Template {
struct {
unsigned int n_values;
Reg__LaneAttributes_template *list_value;
} value_list;
void copy_template(const Reg__LaneAttributes_template& other_value);

public:
Reg__LaneAttributes_template();
Reg__LaneAttributes_template(template_sel other_value);
Reg__LaneAttributes_template(null_type other_value);
Reg__LaneAttributes_template(const Reg__LaneAttributes& other_value);
Reg__LaneAttributes_template(const OPTIONAL<Reg__LaneAttributes>& other_value);
Reg__LaneAttributes_template(const Reg__LaneAttributes_template& other_value);
~Reg__LaneAttributes_template();
void clean_up();
Reg__LaneAttributes_template& operator=(template_sel other_value);
Reg__LaneAttributes_template& operator=(null_type other_value);
Reg__LaneAttributes_template& operator=(const Reg__LaneAttributes& other_value);
Reg__LaneAttributes_template& operator=(const OPTIONAL<Reg__LaneAttributes>& other_value);
Reg__LaneAttributes_template& operator=(const Reg__LaneAttributes_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const Reg__LaneAttributes& other_value, boolean legacy = FALSE) const;
Reg__LaneAttributes valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__LaneAttributes_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const Reg__LaneAttributes& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Reg__LaneDataAttribute : public Base_Type {
boolean bound_flag;
public:
Reg__LaneDataAttribute();
Reg__LaneDataAttribute(null_type other_value);
Reg__LaneDataAttribute(const Reg__LaneDataAttribute& other_value);
Reg__LaneDataAttribute& operator=(null_type other_value);
Reg__LaneDataAttribute& operator=(const Reg__LaneDataAttribute& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const Reg__LaneDataAttribute& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Reg__LaneDataAttribute& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__LaneDataAttribute_template : public Base_Template {
struct {
unsigned int n_values;
Reg__LaneDataAttribute_template *list_value;
} value_list;
void copy_template(const Reg__LaneDataAttribute_template& other_value);

public:
Reg__LaneDataAttribute_template();
Reg__LaneDataAttribute_template(template_sel other_value);
Reg__LaneDataAttribute_template(null_type other_value);
Reg__LaneDataAttribute_template(const Reg__LaneDataAttribute& other_value);
Reg__LaneDataAttribute_template(const OPTIONAL<Reg__LaneDataAttribute>& other_value);
Reg__LaneDataAttribute_template(const Reg__LaneDataAttribute_template& other_value);
~Reg__LaneDataAttribute_template();
void clean_up();
Reg__LaneDataAttribute_template& operator=(template_sel other_value);
Reg__LaneDataAttribute_template& operator=(null_type other_value);
Reg__LaneDataAttribute_template& operator=(const Reg__LaneDataAttribute& other_value);
Reg__LaneDataAttribute_template& operator=(const OPTIONAL<Reg__LaneDataAttribute>& other_value);
Reg__LaneDataAttribute_template& operator=(const Reg__LaneDataAttribute_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const Reg__LaneDataAttribute& other_value, boolean legacy = FALSE) const;
Reg__LaneDataAttribute valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__LaneDataAttribute_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const Reg__LaneDataAttribute& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Reg__MovementEvent : public Base_Type {
boolean bound_flag;
public:
Reg__MovementEvent();
Reg__MovementEvent(null_type other_value);
Reg__MovementEvent(const Reg__MovementEvent& other_value);
Reg__MovementEvent& operator=(null_type other_value);
Reg__MovementEvent& operator=(const Reg__MovementEvent& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const Reg__MovementEvent& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Reg__MovementEvent& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__MovementEvent_template : public Base_Template {
struct {
unsigned int n_values;
Reg__MovementEvent_template *list_value;
} value_list;
void copy_template(const Reg__MovementEvent_template& other_value);

public:
Reg__MovementEvent_template();
Reg__MovementEvent_template(template_sel other_value);
Reg__MovementEvent_template(null_type other_value);
Reg__MovementEvent_template(const Reg__MovementEvent& other_value);
Reg__MovementEvent_template(const OPTIONAL<Reg__MovementEvent>& other_value);
Reg__MovementEvent_template(const Reg__MovementEvent_template& other_value);
~Reg__MovementEvent_template();
void clean_up();
Reg__MovementEvent_template& operator=(template_sel other_value);
Reg__MovementEvent_template& operator=(null_type other_value);
Reg__MovementEvent_template& operator=(const Reg__MovementEvent& other_value);
Reg__MovementEvent_template& operator=(const OPTIONAL<Reg__MovementEvent>& other_value);
Reg__MovementEvent_template& operator=(const Reg__MovementEvent_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const Reg__MovementEvent& other_value, boolean legacy = FALSE) const;
Reg__MovementEvent valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__MovementEvent_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const Reg__MovementEvent& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Reg__MovementState : public Base_Type {
boolean bound_flag;
public:
Reg__MovementState();
Reg__MovementState(null_type other_value);
Reg__MovementState(const Reg__MovementState& other_value);
Reg__MovementState& operator=(null_type other_value);
Reg__MovementState& operator=(const Reg__MovementState& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const Reg__MovementState& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Reg__MovementState& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__MovementState_template : public Base_Template {
struct {
unsigned int n_values;
Reg__MovementState_template *list_value;
} value_list;
void copy_template(const Reg__MovementState_template& other_value);

public:
Reg__MovementState_template();
Reg__MovementState_template(template_sel other_value);
Reg__MovementState_template(null_type other_value);
Reg__MovementState_template(const Reg__MovementState& other_value);
Reg__MovementState_template(const OPTIONAL<Reg__MovementState>& other_value);
Reg__MovementState_template(const Reg__MovementState_template& other_value);
~Reg__MovementState_template();
void clean_up();
Reg__MovementState_template& operator=(template_sel other_value);
Reg__MovementState_template& operator=(null_type other_value);
Reg__MovementState_template& operator=(const Reg__MovementState& other_value);
Reg__MovementState_template& operator=(const OPTIONAL<Reg__MovementState>& other_value);
Reg__MovementState_template& operator=(const Reg__MovementState_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const Reg__MovementState& other_value, boolean legacy = FALSE) const;
Reg__MovementState valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__MovementState_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const Reg__MovementState& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Reg__NodeAttribute : public Base_Type {
boolean bound_flag;
public:
Reg__NodeAttribute();
Reg__NodeAttribute(null_type other_value);
Reg__NodeAttribute(const Reg__NodeAttribute& other_value);
Reg__NodeAttribute& operator=(null_type other_value);
Reg__NodeAttribute& operator=(const Reg__NodeAttribute& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const Reg__NodeAttribute& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Reg__NodeAttribute& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__NodeAttribute_template : public Base_Template {
struct {
unsigned int n_values;
Reg__NodeAttribute_template *list_value;
} value_list;
void copy_template(const Reg__NodeAttribute_template& other_value);

public:
Reg__NodeAttribute_template();
Reg__NodeAttribute_template(template_sel other_value);
Reg__NodeAttribute_template(null_type other_value);
Reg__NodeAttribute_template(const Reg__NodeAttribute& other_value);
Reg__NodeAttribute_template(const OPTIONAL<Reg__NodeAttribute>& other_value);
Reg__NodeAttribute_template(const Reg__NodeAttribute_template& other_value);
~Reg__NodeAttribute_template();
void clean_up();
Reg__NodeAttribute_template& operator=(template_sel other_value);
Reg__NodeAttribute_template& operator=(null_type other_value);
Reg__NodeAttribute_template& operator=(const Reg__NodeAttribute& other_value);
Reg__NodeAttribute_template& operator=(const OPTIONAL<Reg__NodeAttribute>& other_value);
Reg__NodeAttribute_template& operator=(const Reg__NodeAttribute_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const Reg__NodeAttribute& other_value, boolean legacy = FALSE) const;
Reg__NodeAttribute valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__NodeAttribute_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const Reg__NodeAttribute& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Reg__NodeOffsetPoint : public Base_Type {
boolean bound_flag;
public:
Reg__NodeOffsetPoint();
Reg__NodeOffsetPoint(null_type other_value);
Reg__NodeOffsetPoint(const Reg__NodeOffsetPoint& other_value);
Reg__NodeOffsetPoint& operator=(null_type other_value);
Reg__NodeOffsetPoint& operator=(const Reg__NodeOffsetPoint& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const Reg__NodeOffsetPoint& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Reg__NodeOffsetPoint& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__NodeOffsetPoint_template : public Base_Template {
struct {
unsigned int n_values;
Reg__NodeOffsetPoint_template *list_value;
} value_list;
void copy_template(const Reg__NodeOffsetPoint_template& other_value);

public:
Reg__NodeOffsetPoint_template();
Reg__NodeOffsetPoint_template(template_sel other_value);
Reg__NodeOffsetPoint_template(null_type other_value);
Reg__NodeOffsetPoint_template(const Reg__NodeOffsetPoint& other_value);
Reg__NodeOffsetPoint_template(const OPTIONAL<Reg__NodeOffsetPoint>& other_value);
Reg__NodeOffsetPoint_template(const Reg__NodeOffsetPoint_template& other_value);
~Reg__NodeOffsetPoint_template();
void clean_up();
Reg__NodeOffsetPoint_template& operator=(template_sel other_value);
Reg__NodeOffsetPoint_template& operator=(null_type other_value);
Reg__NodeOffsetPoint_template& operator=(const Reg__NodeOffsetPoint& other_value);
Reg__NodeOffsetPoint_template& operator=(const OPTIONAL<Reg__NodeOffsetPoint>& other_value);
Reg__NodeOffsetPoint_template& operator=(const Reg__NodeOffsetPoint_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const Reg__NodeOffsetPoint& other_value, boolean legacy = FALSE) const;
Reg__NodeOffsetPoint valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__NodeOffsetPoint_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const Reg__NodeOffsetPoint& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Reg__RoadSegment : public Base_Type {
boolean bound_flag;
public:
Reg__RoadSegment();
Reg__RoadSegment(null_type other_value);
Reg__RoadSegment(const Reg__RoadSegment& other_value);
Reg__RoadSegment& operator=(null_type other_value);
Reg__RoadSegment& operator=(const Reg__RoadSegment& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const Reg__RoadSegment& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Reg__RoadSegment& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__RoadSegment_template : public Base_Template {
struct {
unsigned int n_values;
Reg__RoadSegment_template *list_value;
} value_list;
void copy_template(const Reg__RoadSegment_template& other_value);

public:
Reg__RoadSegment_template();
Reg__RoadSegment_template(template_sel other_value);
Reg__RoadSegment_template(null_type other_value);
Reg__RoadSegment_template(const Reg__RoadSegment& other_value);
Reg__RoadSegment_template(const OPTIONAL<Reg__RoadSegment>& other_value);
Reg__RoadSegment_template(const Reg__RoadSegment_template& other_value);
~Reg__RoadSegment_template();
void clean_up();
Reg__RoadSegment_template& operator=(template_sel other_value);
Reg__RoadSegment_template& operator=(null_type other_value);
Reg__RoadSegment_template& operator=(const Reg__RoadSegment& other_value);
Reg__RoadSegment_template& operator=(const OPTIONAL<Reg__RoadSegment>& other_value);
Reg__RoadSegment_template& operator=(const Reg__RoadSegment_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const Reg__RoadSegment& other_value, boolean legacy = FALSE) const;
Reg__RoadSegment valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__RoadSegment_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const Reg__RoadSegment& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Reg__SignalControlZone : public Base_Type {
boolean bound_flag;
public:
Reg__SignalControlZone();
Reg__SignalControlZone(null_type other_value);
Reg__SignalControlZone(const Reg__SignalControlZone& other_value);
Reg__SignalControlZone& operator=(null_type other_value);
Reg__SignalControlZone& operator=(const Reg__SignalControlZone& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const Reg__SignalControlZone& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Reg__SignalControlZone& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__SignalControlZone_template : public Base_Template {
struct {
unsigned int n_values;
Reg__SignalControlZone_template *list_value;
} value_list;
void copy_template(const Reg__SignalControlZone_template& other_value);

public:
Reg__SignalControlZone_template();
Reg__SignalControlZone_template(template_sel other_value);
Reg__SignalControlZone_template(null_type other_value);
Reg__SignalControlZone_template(const Reg__SignalControlZone& other_value);
Reg__SignalControlZone_template(const OPTIONAL<Reg__SignalControlZone>& other_value);
Reg__SignalControlZone_template(const Reg__SignalControlZone_template& other_value);
~Reg__SignalControlZone_template();
void clean_up();
Reg__SignalControlZone_template& operator=(template_sel other_value);
Reg__SignalControlZone_template& operator=(null_type other_value);
Reg__SignalControlZone_template& operator=(const Reg__SignalControlZone& other_value);
Reg__SignalControlZone_template& operator=(const OPTIONAL<Reg__SignalControlZone>& other_value);
Reg__SignalControlZone_template& operator=(const Reg__SignalControlZone_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const Reg__SignalControlZone& other_value, boolean legacy = FALSE) const;
Reg__SignalControlZone valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__SignalControlZone_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const Reg__SignalControlZone& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Reg__SPAT : public Base_Type {
boolean bound_flag;
public:
Reg__SPAT();
Reg__SPAT(null_type other_value);
Reg__SPAT(const Reg__SPAT& other_value);
Reg__SPAT& operator=(null_type other_value);
Reg__SPAT& operator=(const Reg__SPAT& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const Reg__SPAT& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const Reg__SPAT& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
ASN_BER_TLV_t* BER_encode_TLV(const TTCN_Typedescriptor_t& p_td, unsigned p_coding) const;
boolean BER_decode_TLV(const TTCN_Typedescriptor_t& p_td, const ASN_BER_TLV_t& p_tlv, unsigned L_form);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class Reg__SPAT_template : public Base_Template {
struct {
unsigned int n_values;
Reg__SPAT_template *list_value;
} value_list;
void copy_template(const Reg__SPAT_template& other_value);

public:
Reg__SPAT_template();
Reg__SPAT_template(template_sel other_value);
Reg__SPAT_template(null_type other_value);
Reg__SPAT_template(const Reg__SPAT& other_value);
Reg__SPAT_template(const OPTIONAL<Reg__SPAT>& other_value);
Reg__SPAT_template(const Reg__SPAT_template& other_value);
~Reg__SPAT_template();
void clean_up();
Reg__SPAT_template& operator=(template_sel other_value);
Reg__SPAT_template& operator=(null_type other_value);
Reg__SPAT_template& operator=(const Reg__SPAT& other_value);
Reg__SPAT_template& operator=(const OPTIONAL<Reg__SPAT>& other_value);
Reg__SPAT_template& operator=(const Reg__SPAT_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const Reg__SPAT& other_value, boolean legacy = FALSE) const;
Reg__SPAT valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Reg__SPAT_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const Reg__SPAT& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const Reg__AdvisorySpeed& other_value);
inline boolean operator!=(null_type null_value, const Reg__AdvisorySpeed& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Reg__ComputedLane& other_value);
inline boolean operator!=(null_type null_value, const Reg__ComputedLane& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Reg__GenericLane& other_value);
inline boolean operator!=(null_type null_value, const Reg__GenericLane& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Reg__Intersection& other_value);
inline boolean operator!=(null_type null_value, const Reg__Intersection& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Reg__LaneAttributes& other_value);
inline boolean operator!=(null_type null_value, const Reg__LaneAttributes& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Reg__LaneDataAttribute& other_value);
inline boolean operator!=(null_type null_value, const Reg__LaneDataAttribute& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Reg__MovementEvent& other_value);
inline boolean operator!=(null_type null_value, const Reg__MovementEvent& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Reg__MovementState& other_value);
inline boolean operator!=(null_type null_value, const Reg__MovementState& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Reg__NodeAttribute& other_value);
inline boolean operator!=(null_type null_value, const Reg__NodeAttribute& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Reg__NodeOffsetPoint& other_value);
inline boolean operator!=(null_type null_value, const Reg__NodeOffsetPoint& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Reg__RoadSegment& other_value);
inline boolean operator!=(null_type null_value, const Reg__RoadSegment& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Reg__SignalControlZone& other_value);
inline boolean operator!=(null_type null_value, const Reg__SignalControlZone& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const Reg__SPAT& other_value);
inline boolean operator!=(null_type null_value, const Reg__SPAT& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const TTCN_JSONdescriptor_t Reg__AdvisorySpeed_json_;
extern const TTCN_Typedescriptor_t Reg__AdvisorySpeed_descr_;
extern const TTCN_JSONdescriptor_t Reg__ComputedLane_json_;
extern const TTCN_Typedescriptor_t Reg__ComputedLane_descr_;
extern const TTCN_JSONdescriptor_t Reg__GenericLane_json_;
extern const TTCN_Typedescriptor_t Reg__GenericLane_descr_;
extern const TTCN_JSONdescriptor_t Reg__Intersection_json_;
extern const TTCN_Typedescriptor_t Reg__Intersection_descr_;
extern const TTCN_JSONdescriptor_t Reg__LaneAttributes_json_;
extern const TTCN_Typedescriptor_t Reg__LaneAttributes_descr_;
extern const TTCN_JSONdescriptor_t Reg__LaneDataAttribute_json_;
extern const TTCN_Typedescriptor_t Reg__LaneDataAttribute_descr_;
extern const TTCN_JSONdescriptor_t Reg__MovementEvent_json_;
extern const TTCN_Typedescriptor_t Reg__MovementEvent_descr_;
extern const TTCN_JSONdescriptor_t Reg__MovementState_json_;
extern const TTCN_Typedescriptor_t Reg__MovementState_descr_;
extern const TTCN_JSONdescriptor_t Reg__NodeAttribute_json_;
extern const TTCN_Typedescriptor_t Reg__NodeAttribute_descr_;
extern const TTCN_JSONdescriptor_t Reg__NodeOffsetPoint_json_;
extern const TTCN_Typedescriptor_t Reg__NodeOffsetPoint_descr_;
extern const TTCN_JSONdescriptor_t Reg__RoadSegment_json_;
extern const TTCN_Typedescriptor_t Reg__RoadSegment_descr_;
extern const TTCN_JSONdescriptor_t Reg__SignalControlZone_json_;
extern const TTCN_Typedescriptor_t Reg__SignalControlZone_descr_;
extern const TTCN_JSONdescriptor_t Reg__SPAT_json_;
extern const TTCN_Typedescriptor_t Reg__SPAT_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
