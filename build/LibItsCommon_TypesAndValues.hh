// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/5 R4A
// for Aitor (aitorkun@aitorkun-HP-EliteBook-2530p) on Tue Feb 16 10:46:43 2016

// Copyright (c) 2000-2015 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef LibItsCommon__TypesAndValues_HH
#define LibItsCommon__TypesAndValues_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include "LibCommon_DataStrings.hh"
#include "ITS_Container.hh"

#if TTCN3_VERSION != 50400
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef LibItsCommon__TypesAndValues_HH
#endif

namespace LibItsCommon__TypesAndValues {

/* Forward declarations of classes */

class UtInitialize;
class UtInitialize_template;
class UtInitializeResult;
class UtInitializeResult_template;
class UtChangePosition;
class UtChangePosition_template;
class UtChangePositionResult;
class UtChangePositionResult_template;
class UtChangePseudonym;
class UtChangePseudonym_template;
class UtChangePseudonymResult;
class UtChangePseudonymResult_template;

} /* end of namespace */

#ifndef LibItsCommon__TypesAndValues_HH
#define LibItsCommon__TypesAndValues_HH

namespace LibItsCommon__TypesAndValues {

/* Class definitions */

class UtInitialize : public Base_Type {
  OCTETSTRING field_hashedId8;
  boolean bound_flag;
public:
  UtInitialize();
  UtInitialize(const OCTETSTRING& par_hashedId8);
  UtInitialize(const UtInitialize& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtInitialize& operator=(const UtInitialize& other_value);
  boolean operator==(const UtInitialize& other_value) const;
  inline boolean operator!=(const UtInitialize& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OCTETSTRING& hashedId8()
    {return field_hashedId8;}
  inline const OCTETSTRING& hashedId8() const
    {return field_hashedId8;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtInitialize_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtInitialize_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtInitialize& other_value);
void copy_template(const UtInitialize_template& other_value);

public:
UtInitialize_template();
UtInitialize_template(template_sel other_value);
UtInitialize_template(const UtInitialize& other_value);
UtInitialize_template(const OPTIONAL<UtInitialize>& other_value);
UtInitialize_template(const UtInitialize_template& other_value);
~UtInitialize_template();
UtInitialize_template& operator=(template_sel other_value);
UtInitialize_template& operator=(const UtInitialize& other_value);
UtInitialize_template& operator=(const OPTIONAL<UtInitialize>& other_value);
UtInitialize_template& operator=(const UtInitialize_template& other_value);
boolean match(const UtInitialize& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtInitialize valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtInitialize_template& list_item(unsigned int list_index) const;
OCTETSTRING_template& hashedId8();
const OCTETSTRING_template& hashedId8() const;
int size_of() const;
void log() const;
void log_match(const UtInitialize& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtInitializeResult : public Base_Type {
  BOOLEAN field_utInitializeResult;
  boolean bound_flag;
public:
  UtInitializeResult();
  UtInitializeResult(const BOOLEAN& par_utInitializeResult);
  UtInitializeResult(const UtInitializeResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtInitializeResult& operator=(const UtInitializeResult& other_value);
  boolean operator==(const UtInitializeResult& other_value) const;
  inline boolean operator!=(const UtInitializeResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BOOLEAN& utInitializeResult()
    {return field_utInitializeResult;}
  inline const BOOLEAN& utInitializeResult() const
    {return field_utInitializeResult;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtInitializeResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtInitializeResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtInitializeResult& other_value);
void copy_template(const UtInitializeResult_template& other_value);

public:
UtInitializeResult_template();
UtInitializeResult_template(template_sel other_value);
UtInitializeResult_template(const UtInitializeResult& other_value);
UtInitializeResult_template(const OPTIONAL<UtInitializeResult>& other_value);
UtInitializeResult_template(const UtInitializeResult_template& other_value);
~UtInitializeResult_template();
UtInitializeResult_template& operator=(template_sel other_value);
UtInitializeResult_template& operator=(const UtInitializeResult& other_value);
UtInitializeResult_template& operator=(const OPTIONAL<UtInitializeResult>& other_value);
UtInitializeResult_template& operator=(const UtInitializeResult_template& other_value);
boolean match(const UtInitializeResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtInitializeResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtInitializeResult_template& list_item(unsigned int list_index) const;
BOOLEAN_template& utInitializeResult();
const BOOLEAN_template& utInitializeResult() const;
int size_of() const;
void log() const;
void log_match(const UtInitializeResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtChangePosition : public Base_Type {
  INTEGER field_latitude;
  INTEGER field_longitude;
  INTEGER field_elevation;
  boolean bound_flag;
public:
  UtChangePosition();
  UtChangePosition(const INTEGER& par_latitude,
    const INTEGER& par_longitude,
    const INTEGER& par_elevation);
  UtChangePosition(const UtChangePosition& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtChangePosition& operator=(const UtChangePosition& other_value);
  boolean operator==(const UtChangePosition& other_value) const;
  inline boolean operator!=(const UtChangePosition& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& latitude()
    {return field_latitude;}
  inline const INTEGER& latitude() const
    {return field_latitude;}
  inline INTEGER& longitude()
    {return field_longitude;}
  inline const INTEGER& longitude() const
    {return field_longitude;}
  inline INTEGER& elevation()
    {return field_elevation;}
  inline const INTEGER& elevation() const
    {return field_elevation;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtChangePosition_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtChangePosition_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtChangePosition& other_value);
void copy_template(const UtChangePosition_template& other_value);

public:
UtChangePosition_template();
UtChangePosition_template(template_sel other_value);
UtChangePosition_template(const UtChangePosition& other_value);
UtChangePosition_template(const OPTIONAL<UtChangePosition>& other_value);
UtChangePosition_template(const UtChangePosition_template& other_value);
~UtChangePosition_template();
UtChangePosition_template& operator=(template_sel other_value);
UtChangePosition_template& operator=(const UtChangePosition& other_value);
UtChangePosition_template& operator=(const OPTIONAL<UtChangePosition>& other_value);
UtChangePosition_template& operator=(const UtChangePosition_template& other_value);
boolean match(const UtChangePosition& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtChangePosition valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtChangePosition_template& list_item(unsigned int list_index) const;
INTEGER_template& latitude();
const INTEGER_template& latitude() const;
INTEGER_template& longitude();
const INTEGER_template& longitude() const;
INTEGER_template& elevation();
const INTEGER_template& elevation() const;
int size_of() const;
void log() const;
void log_match(const UtChangePosition& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtChangePositionResult : public Base_Type {
  BOOLEAN field_utChangePositionResult;
  boolean bound_flag;
public:
  UtChangePositionResult();
  UtChangePositionResult(const BOOLEAN& par_utChangePositionResult);
  UtChangePositionResult(const UtChangePositionResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtChangePositionResult& operator=(const UtChangePositionResult& other_value);
  boolean operator==(const UtChangePositionResult& other_value) const;
  inline boolean operator!=(const UtChangePositionResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BOOLEAN& utChangePositionResult()
    {return field_utChangePositionResult;}
  inline const BOOLEAN& utChangePositionResult() const
    {return field_utChangePositionResult;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtChangePositionResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtChangePositionResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtChangePositionResult& other_value);
void copy_template(const UtChangePositionResult_template& other_value);

public:
UtChangePositionResult_template();
UtChangePositionResult_template(template_sel other_value);
UtChangePositionResult_template(const UtChangePositionResult& other_value);
UtChangePositionResult_template(const OPTIONAL<UtChangePositionResult>& other_value);
UtChangePositionResult_template(const UtChangePositionResult_template& other_value);
~UtChangePositionResult_template();
UtChangePositionResult_template& operator=(template_sel other_value);
UtChangePositionResult_template& operator=(const UtChangePositionResult& other_value);
UtChangePositionResult_template& operator=(const OPTIONAL<UtChangePositionResult>& other_value);
UtChangePositionResult_template& operator=(const UtChangePositionResult_template& other_value);
boolean match(const UtChangePositionResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtChangePositionResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtChangePositionResult_template& list_item(unsigned int list_index) const;
BOOLEAN_template& utChangePositionResult();
const BOOLEAN_template& utChangePositionResult() const;
int size_of() const;
void log() const;
void log_match(const UtChangePositionResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtChangePseudonym : public Base_Type {
boolean bound_flag;
public:
UtChangePseudonym();
UtChangePseudonym(null_type other_value);
UtChangePseudonym(const UtChangePseudonym& other_value);
UtChangePseudonym& operator=(null_type other_value);
UtChangePseudonym& operator=(const UtChangePseudonym& other_value);
boolean operator==(null_type other_value) const;
boolean operator==(const UtChangePseudonym& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const UtChangePseudonym& other_value) const { return !(*this == other_value); }
inline boolean is_bound() const { return bound_flag; }
inline boolean is_present() const { return is_bound(); }
inline boolean is_value() const { return bound_flag; }
inline void clean_up() { bound_flag = FALSE; }
inline void must_bound(const char *err_msg) const { if (!bound_flag) TTCN_error("%s", err_msg); }
void log() const;
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtChangePseudonym_template : public Base_Template {
struct {
unsigned int n_values;
UtChangePseudonym_template *list_value;
} value_list;
void copy_template(const UtChangePseudonym_template& other_value);

public:
UtChangePseudonym_template();
UtChangePseudonym_template(template_sel other_value);
UtChangePseudonym_template(null_type other_value);
UtChangePseudonym_template(const UtChangePseudonym& other_value);
UtChangePseudonym_template(const OPTIONAL<UtChangePseudonym>& other_value);
UtChangePseudonym_template(const UtChangePseudonym_template& other_value);
~UtChangePseudonym_template();
void clean_up();
UtChangePseudonym_template& operator=(template_sel other_value);
UtChangePseudonym_template& operator=(null_type other_value);
UtChangePseudonym_template& operator=(const UtChangePseudonym& other_value);
UtChangePseudonym_template& operator=(const OPTIONAL<UtChangePseudonym>& other_value);
UtChangePseudonym_template& operator=(const UtChangePseudonym_template& other_value);
boolean match(null_type other_value, boolean legacy = FALSE) const;
boolean match(const UtChangePseudonym& other_value, boolean legacy = FALSE) const;
UtChangePseudonym valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtChangePseudonym_template& list_item(unsigned int list_index) const;
void log() const;
void log_match(const UtChangePseudonym& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UtChangePseudonymResult : public Base_Type {
  BOOLEAN field_utChangePseudonymResult;
  boolean bound_flag;
public:
  UtChangePseudonymResult();
  UtChangePseudonymResult(const BOOLEAN& par_utChangePseudonymResult);
  UtChangePseudonymResult(const UtChangePseudonymResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UtChangePseudonymResult& operator=(const UtChangePseudonymResult& other_value);
  boolean operator==(const UtChangePseudonymResult& other_value) const;
  inline boolean operator!=(const UtChangePseudonymResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline BOOLEAN& utChangePseudonymResult()
    {return field_utChangePseudonymResult;}
  inline const BOOLEAN& utChangePseudonymResult() const
    {return field_utChangePseudonymResult;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
int JSON_encode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&) const;
int JSON_decode(const TTCN_Typedescriptor_t&, JSON_Tokenizer&, boolean);
};

class UtChangePseudonymResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UtChangePseudonymResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UtChangePseudonymResult& other_value);
void copy_template(const UtChangePseudonymResult_template& other_value);

public:
UtChangePseudonymResult_template();
UtChangePseudonymResult_template(template_sel other_value);
UtChangePseudonymResult_template(const UtChangePseudonymResult& other_value);
UtChangePseudonymResult_template(const OPTIONAL<UtChangePseudonymResult>& other_value);
UtChangePseudonymResult_template(const UtChangePseudonymResult_template& other_value);
~UtChangePseudonymResult_template();
UtChangePseudonymResult_template& operator=(template_sel other_value);
UtChangePseudonymResult_template& operator=(const UtChangePseudonymResult& other_value);
UtChangePseudonymResult_template& operator=(const OPTIONAL<UtChangePseudonymResult>& other_value);
UtChangePseudonymResult_template& operator=(const UtChangePseudonymResult_template& other_value);
boolean match(const UtChangePseudonymResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UtChangePseudonymResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UtChangePseudonymResult_template& list_item(unsigned int list_index) const;
BOOLEAN_template& utChangePseudonymResult();
const BOOLEAN_template& utChangePseudonymResult() const;
int size_of() const;
void log() const;
void log_match(const UtChangePseudonymResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
Module_Param* get_param(Module_Param_Name& param_name) const;
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern boolean operator==(null_type null_value, const UtChangePseudonym& other_value);
inline boolean operator!=(null_type null_value, const UtChangePseudonym& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const XERdescriptor_t UtInitialize_hashedId8_xer_;
extern const TTCN_Typedescriptor_t UtInitialize_hashedId8_descr_;
extern const TTCN_RAWdescriptor_t UtInitialize_raw_;
extern const TTCN_JSONdescriptor_t UtInitialize_json_;
extern const TTCN_Typedescriptor_t UtInitialize_descr_;
extern const TTCN_RAWdescriptor_t UtInitializeResult_utInitializeResult_raw_;
extern const XERdescriptor_t UtInitializeResult_utInitializeResult_xer_;
extern const TTCN_Typedescriptor_t UtInitializeResult_utInitializeResult_descr_;
extern const TTCN_RAWdescriptor_t UtInitializeResult_raw_;
extern const TTCN_JSONdescriptor_t UtInitializeResult_json_;
extern const TTCN_Typedescriptor_t UtInitializeResult_descr_;
extern const TTCN_RAWdescriptor_t UtChangePosition_latitude_raw_;
extern const XERdescriptor_t UtChangePosition_latitude_xer_;
extern const TTCN_Typedescriptor_t UtChangePosition_latitude_descr_;
extern const TTCN_RAWdescriptor_t UtChangePosition_longitude_raw_;
extern const XERdescriptor_t UtChangePosition_longitude_xer_;
extern const TTCN_Typedescriptor_t UtChangePosition_longitude_descr_;
extern const TTCN_RAWdescriptor_t UtChangePosition_elevation_raw_;
extern const XERdescriptor_t UtChangePosition_elevation_xer_;
extern const TTCN_Typedescriptor_t UtChangePosition_elevation_descr_;
extern const TTCN_RAWdescriptor_t UtChangePosition_raw_;
extern const TTCN_JSONdescriptor_t UtChangePosition_json_;
extern const TTCN_Typedescriptor_t UtChangePosition_descr_;
extern const TTCN_RAWdescriptor_t UtChangePositionResult_utChangePositionResult_raw_;
extern const XERdescriptor_t UtChangePositionResult_utChangePositionResult_xer_;
extern const TTCN_Typedescriptor_t UtChangePositionResult_utChangePositionResult_descr_;
extern const TTCN_RAWdescriptor_t UtChangePositionResult_raw_;
extern const TTCN_JSONdescriptor_t UtChangePositionResult_json_;
extern const TTCN_Typedescriptor_t UtChangePositionResult_descr_;
extern const TTCN_RAWdescriptor_t UtChangePseudonym_raw_;
extern const TTCN_JSONdescriptor_t UtChangePseudonym_json_;
extern const TTCN_Typedescriptor_t UtChangePseudonym_descr_;
extern const TTCN_RAWdescriptor_t UtChangePseudonymResult_utChangePseudonymResult_raw_;
extern const XERdescriptor_t UtChangePseudonymResult_utChangePseudonymResult_xer_;
extern const TTCN_Typedescriptor_t UtChangePseudonymResult_utChangePseudonymResult_descr_;
extern const TTCN_RAWdescriptor_t UtChangePseudonymResult_raw_;
extern const TTCN_JSONdescriptor_t UtChangePseudonymResult_json_;
extern const TTCN_Typedescriptor_t UtChangePseudonymResult_descr_;
extern const INTEGER& c__semiAxisLengthOneCentimeter;
extern const INTEGER& c__semiAxisLengthUnavailable;
extern const INTEGER& c__headingConfidence__withinZeroPointOneDegree;
extern const INTEGER& c__headingValue__wgs84North;
extern const INTEGER& c__altitudeValue__seaLevel;
extern const INTEGER& c__stationType__passengerCar;
extern const INTEGER& c__longitudinalAccelerationValue__unavailable;
extern const INTEGER& c__accelerationConfidence__unavailable;
extern const INTEGER& c__curvatureValue__straight;
extern const INTEGER& c__yawRateValue__straight;
extern const INTEGER& c__causeReserved;
extern const INTEGER& c__causeTrafficCondition;
extern const INTEGER& c__causeAccident;
extern const INTEGER& c__causeRoadworks;
extern const INTEGER& c__causeAdverseWeatherCondition__Adhesion;
extern const INTEGER& c__causeHazardousLocation__SurfaceCondition;
extern const INTEGER& c__causeHazardousLocation__ObstacleOnTheRoad;
extern const INTEGER& c__causeHazardousLocation__AnimalOnTheRoad;
extern const INTEGER& c__causeHumanPresenceOnTheRoad;
extern const INTEGER& c__causeWrongWayDriving;
extern const INTEGER& c__causeRescueAndRecoveryWorkInProgress;
extern const INTEGER& c__causeAdverseWeatherCondition__ExtremeWeatherCondition;
extern const INTEGER& c__causeAdverseWeatherCondition__Visibility;
extern const INTEGER& c__causeAdverseWeatherCondition__Precipitation;
extern const INTEGER& c__causeSlowVehicle;
extern const INTEGER& c__causeDangerousEndOfQueue;
extern const INTEGER& c__causeVehicleBreakdown;
extern const INTEGER& c__causePostCrash;
extern const INTEGER& c__causeHumanProblem;
extern const INTEGER& c__causeStationaryVehicle;
extern const INTEGER& c__causeEmergencyVehicleApproaching;
extern const INTEGER& c__causeHazardousLocation__DangerousCurve;
extern const INTEGER& c__causeCollisionRisk;
extern const INTEGER& c__causeSignalViolation;
extern const INTEGER& c__causeDangerousSituation;
extern const INTEGER& c__subCauseCode__Unavailable;
extern const INTEGER& c__vehicleBreakDownSubCauseCode__engineProblem;
extern const INTEGER& c__slowVehicleSubCauseCode__convoy;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
